{"version":3,"file":"dom-alter.cjs","names":["MC","_interopRequireWildcard","require","MH","_cssAlter","_domOptimize","_domQuery","_text","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","wrapElementNow","element","options","wrapper","createWrapperFor","ignoreMove","from","parentOf","to","replaceWith","append","exports","wrapElement","waitForMutateTime","then","wrapChildrenNow","moveChildrenNow","moveElementNow","wrapChildren","replaceElementNow","newElement","replaceElement","swapElementsNow","elementA","elementB","temp","createElement","swapElements","oldParent","newParent","child","childrenOf","moveChildren","parentEl","position","remove","moveElement","hideAndRemoveElement","delay","hideElement","getOrAssignID","prefix","domID","id","randId","wrapScrollingContent","firstChild","lengthOf","isHTMLElement","hasClass","PREFIX_CONTENT_WRAPPER","addClassesNow","cloneElement","clone","cloneNode","setBoolData","prefixName","insertGhostCloneNow","insertBefore","PREFIX_GHOST","PREFIX_TRANSITION_DISABLE","PREFIX_ANIMATE_DISABLE","PREFIX_WRAPPER","_wrapper","_clone","insertGhostClone","target","recordsToSkipOnce","getIgnoreMove","clearIgnoreMove","setTimer","deleteKey","insertArrow","direction","tag","arrow","S_ARROW","setDataNow","newMap","isElement","isInlineTag","tagName"],"sources":["../../../src/ts/utils/dom-alter.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Altering\n * These functions alter the DOM tree, but could lead to forced layout if not\n * scheduled using {@link waitForMutateTime}.\n *\n * @categoryDescription DOM: Altering (optimized)\n * These functions alter the DOM tree in an optimized way using\n * {@link waitForMutateTime} and so are asynchronous.\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  hideElement,\n  hasClass,\n  addClassesNow,\n  setDataNow,\n  setBoolData,\n} from \"@lisn/utils/css-alter\";\nimport { waitForMutateTime } from \"@lisn/utils/dom-optimize\";\nimport { isInlineTag } from \"@lisn/utils/dom-query\";\nimport { randId } from \"@lisn/utils/text\";\n\n/**\n * Wraps the element in the given wrapper, or a newly created element if not given.\n *\n * @param {} [options.wrapper]\n *              If it's an element, it is used as the wrapper. If it's a string\n *              tag name, then a new element with this tag is created as the\n *              wrapper. If not given, then `div` is used if the element to be\n *              wrapped has an block-display tag, or otherwise `span` (if the\n *              element to be wrapped has an inline tag name).\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              replacing the element (so as to not trigger relevant callbacks).\n * @returns {} The wrapper element that was either passed in options or created.\n *\n * @category DOM: Altering\n */\nexport const wrapElementNow = (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => {\n  const wrapper = createWrapperFor(element, options?.wrapper);\n\n  if (options?.ignoreMove === true) {\n    ignoreMove(element, {\n      from: MH.parentOf(element),\n      to: wrapper,\n    });\n\n    ignoreMove(wrapper, {\n      to: MH.parentOf(element),\n    });\n  }\n\n  element.replaceWith(wrapper);\n  wrapper.append(element);\n\n  return wrapper;\n};\n\n/**\n * Like {@link wrapElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const wrapElement = async (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => wrapElementNow(element, options));\n\n/**\n * Wraps the element's children in the given wrapper, or a newly created element\n * if not given.\n *\n * @see {@link wrapElementNow}.\n *\n * @category DOM: Altering\n */\nexport const wrapChildrenNow = (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => {\n  const wrapper = createWrapperFor(element, options?.wrapper);\n\n  moveChildrenNow(element, wrapper, { ignoreMove: true });\n  moveElementNow(wrapper, {\n    to: element,\n    ignoreMove: true,\n  });\n\n  return wrapper;\n};\n\n/**\n * Like {@link wrapChildrenNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const wrapChildren = async (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => wrapChildrenNow(element, options));\n\n/**\n * Replace an element with another one.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const replaceElementNow = (\n  element: Element,\n  newElement: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  if (options?.ignoreMove === true) {\n    ignoreMove(\n      // remove element\n      element,\n      { from: MH.parentOf(element) },\n    );\n\n    ignoreMove(\n      // move newElement to element's current parent\n      newElement,\n      { from: MH.parentOf(newElement), to: MH.parentOf(element) },\n    );\n  }\n\n  element.replaceWith(newElement);\n};\n\n/**\n * Like {@link replaceElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const replaceElement = async (\n  element: Element,\n  newElement: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() =>\n    replaceElementNow(element, newElement, options),\n  );\n\n/**\n * Replace an element with another one.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const swapElementsNow = (\n  elementA: Element,\n  elementB: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  const temp = MH.createElement(\"div\");\n  replaceElementNow(elementA, temp, options);\n  replaceElementNow(elementB, elementA, options);\n  replaceElementNow(temp, elementB, options);\n};\n\n/**\n * Like {@link swapElementsNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const swapElements = async (\n  elementA: Element,\n  elementB: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() => swapElementsNow(elementA, elementB, options));\n\n/**\n * Move an element's children to a new element\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the children (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const moveChildrenNow = (\n  oldParent: Element,\n  newParent: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  if (options?.ignoreMove === true) {\n    for (const child of MH.childrenOf(oldParent)) {\n      ignoreMove(child, {\n        from: oldParent,\n        to: newParent,\n      });\n    }\n  }\n\n  newParent.append(...MH.childrenOf(oldParent));\n};\n\n/**\n * Like {@link moveChildrenNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const moveChildren = async (\n  oldParent: Element,\n  newParent: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() =>\n    moveChildrenNow(oldParent, newParent, options),\n  );\n\n/**\n * Moves an element to a new position.\n *\n * @param {} [options.to]         The new parent or sibling (depending on\n *                                `options.position`). If not given, the\n *                                element is removed from the DOM.\n * @param {} [options.position]   - append (default): append to `options.to`\n *                                - prepend: prepend to `options.to`\n *                                - before: insert before `options.to`\n *                                - after: insert after `options.to`\n * @param {} [options.ignoreMove] If true, the DOM watcher instances will\n *                                ignore the operation of moving the element\n *                                (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const moveElementNow = (\n  element: Element,\n  options?: {\n    to?: Element;\n    position?: \"append\" | \"prepend\" | \"before\" | \"after\";\n    ignoreMove?: boolean;\n  },\n) => {\n  let parentEl = options?.to || null;\n  const position = options?.position || \"append\";\n  if (position === \"before\" || position === \"after\") {\n    parentEl = MH.parentOf(options?.to);\n  }\n\n  if (options?.ignoreMove === true) {\n    ignoreMove(element, {\n      from: MH.parentOf(element),\n      to: parentEl,\n    });\n  }\n\n  if (options?.to) {\n    options.to[position](element);\n  } else {\n    MH.remove(element);\n  }\n};\n\n/**\n * Like {@link moveElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const moveElement = async (\n  element: Element,\n  options?: {\n    to?: Element;\n    position?: \"append\" | \"prepend\" | \"before\" | \"after\";\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => moveElementNow(element, options));\n\n/**\n * It will {@link hideElement} and then remove it from the DOM.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              replacing the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering (optimized)\n */\nexport const hideAndRemoveElement = async (\n  element: Element,\n  delay = 0,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  await hideElement(element, delay);\n  moveElementNow(element, options);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getOrAssignID = (element: Element, prefix = \"\") => {\n  let domID = element.id;\n  if (!domID) {\n    domID = `${prefix}-${randId()}`;\n    element.id = domID;\n  }\n\n  return domID;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const wrapScrollingContent = async (element: Element) => {\n  await waitForMutateTime();\n\n  let wrapper: HTMLElement;\n  const firstChild = MH.childrenOf(element)[0];\n  if (\n    MH.lengthOf(MH.childrenOf(element)) === 1 &&\n    MH.isHTMLElement(firstChild) &&\n    hasClass(firstChild, PREFIX_CONTENT_WRAPPER)\n  ) {\n    // Another concurrent call has just wrapped it\n    wrapper = firstChild;\n  } else {\n    wrapper = wrapChildrenNow(element, { ignoreMove: true });\n    addClassesNow(wrapper, PREFIX_CONTENT_WRAPPER);\n  }\n\n  return wrapper;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const cloneElement = <E extends Element>(element: E) => {\n  const clone = element.cloneNode(true) as E;\n  setBoolData(clone, MH.prefixName(\"clone\"));\n  return clone;\n};\n\n/**\n * Creates a dummy hidden clone that's got animation and transitions disabled\n * and absolute position, wrapped in a wrapper (of size 0) and inserts it just\n * before the `insertBefore` element (or if not given, the original element),\n * so that the hidden clone overlaps the actual element's regular\n * (pre-transformed) position.\n *\n * It clears the ID of the clone.\n *\n * Returns the clone.\n *\n * @ignore\n * @internal\n */\nexport const insertGhostCloneNow = <E extends Element>(\n  element: E,\n  insertBefore: Element | null = null,\n) => {\n  const clone = cloneElement(element);\n  clone.id = \"\";\n\n  addClassesNow(\n    clone,\n    MC.PREFIX_GHOST,\n    MC.PREFIX_TRANSITION_DISABLE,\n    MC.PREFIX_ANIMATE_DISABLE,\n  );\n\n  const wrapper = wrapElementNow(clone);\n  addClassesNow(wrapper, MC.PREFIX_WRAPPER);\n\n  moveElementNow(wrapper, {\n    to: insertBefore || element,\n    position: \"before\",\n    ignoreMove: true,\n  });\n\n  return { _wrapper: wrapper, _clone: clone };\n};\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via DOMWatcher\n */\nexport const insertGhostClone = <E extends Element>(\n  element: E,\n  insertBefore: Element | null = null,\n) => waitForMutateTime().then(() => insertGhostCloneNow(element, insertBefore));\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via DOMWatcher\n */\nexport const ignoreMove = (\n  target: Element,\n  options: { from?: Element | null; to?: Element | null },\n) =>\n  recordsToSkipOnce.set(target, {\n    from: options.from || null,\n    to: options.to || null,\n  });\n\n/**\n * @ignore\n * @internal\n */\nexport const getIgnoreMove = (\n  target: Element,\n): { from: Element | null; to: Element | null } | null =>\n  recordsToSkipOnce.get(target) || null;\n\n/**\n * @ignore\n * @internal\n */\nexport const clearIgnoreMove = (target: Element) => {\n  // We should not clear the entry the first time the operation is observed\n  // (when we return true here), because there may be multiple DOMWatcher\n  // instances that will observe it and need to query it. Instead do it shortly.\n  MH.setTimer(() => {\n    MH.deleteKey(recordsToSkipOnce, target);\n  }, 100);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const insertArrow = (\n  target: Element,\n  direction: \"up\" | \"down\" | \"left\" | \"right\",\n  position: \"prepend\" | \"append\" | \"before\" | \"after\" = \"append\",\n  tag = \"span\",\n) => {\n  const arrow = MH.createElement(tag);\n  addClassesNow(arrow, MH.prefixName(MC.S_ARROW));\n  setDataNow(arrow, MH.prefixName(\"direction\"), direction);\n  moveElement(arrow, { to: target, position, ignoreMove: true });\n  return arrow;\n};\n\n// ----------------------------------------\n\nconst PREFIX_CONTENT_WRAPPER = MH.prefixName(\"content-wrapper\");\n\nconst recordsToSkipOnce = MH.newMap<\n  /* target being moved */ Element,\n  { from: Element | null; to: Element | null }\n>();\n\nconst createWrapperFor = (\n  element: Element,\n  wrapper: HTMLElement | keyof HTMLElementTagNameMap | undefined,\n) => {\n  if (MH.isElement(wrapper)) {\n    return wrapper;\n  }\n\n  let tag = wrapper;\n  if (!tag) {\n    if (isInlineTag(MH.tagName(element))) {\n      tag = \"span\";\n    } else {\n      tag = \"div\";\n    }\n  }\n\n  return MH.createElement(tag);\n};\n"],"mappings":"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","ignoreList":[]}