{"version":3,"file":"views.js","names":["MC","MH","isValidStrList","validateStrList","newBitSpaces","createBitSpace","isValidScrollOffset","offset","match","OFFSET_REGEX","isValidView","view","includes","VIEWS","isValidViewList","views","getOppositeViews","usageError","bitmask","getViewsBitmask","oppositeBitmask","VIEWS_SPACE","bit","at","above","below","left","right","getViewsFromBitmask","viewsStr","viewsBitmask","_iterator","_createForOfIteratorHelper","_step","s","n","done","v","value","concat","err","e","f","parseScrollOffset","input","_match$groups","_match$groups2","reference","groups","ref","bugError","S_AT","S_ABOVE","S_BELOW","S_LEFT","S_RIGHT","apply","RegExp","start","end","name","nameOf","push"],"sources":["../../../src/ts/utils/views.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { ScrollOffset, View, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\nimport { newBitSpaces, createBitSpace } from \"@lisn/modules/bit-spaces\";\n\n/**\n * Returns true if the given string is a valid {@link ScrollOffset}.\n *\n * @category Validation\n */\nexport const isValidScrollOffset = (offset: string): offset is ScrollOffset =>\n  offset.match(OFFSET_REGEX) !== null;\n\n/**\n * Returns true if the given string is a valid \"view\".\n *\n * @category Validation\n */\nexport const isValidView = (view: string): view is View =>\n  MH.includes(VIEWS, view);\n\n/**\n * Returns true if the given string or array is a list of valid views.\n *\n * @category Validation\n */\nexport const isValidViewList = (views: string | string[]) =>\n  isValidStrList(views, isValidView, false);\n\n/**\n * Returns the views that are opposite to the given set of views.\n *\n * Above and below are opposites, and so are left and right.\n *\n * \"at\" is a special case. It is considered opposite to any view in the sense\n * that if it is not present in `views` it will always be included in the\n * returned array. However it is not \"strongly\" opposite in the sense that it\n * will not cause other views to be included in the result unless it is the\n * only view in `views`. That is, there are two sets of strongly opposite pairs\n * (\"above\"/\"below\" and \"left\"/\"right\") and at least one of the two opposing\n * views of a pair must be present for the other one to be included, _except in\n * the special case of `views` being \"at\"_. See examples below for\n * clarification.\n *\n * **Note** that the order of the returned array is not defined.\n *\n * @example\n * Returns [\"above\", \"below\", \"left\", \"right\"] (not definite order), since\n * \"at\" is the only view present and is opposite to all:\n *\n * ```javascript\n * getOppositeViews(\"at\"); // -> [\"above\", \"below\", \"left\", \"right\"] (not necessarily in this order)\n * ```\n *\n * @example\n * Returns [\"below\"]. \"left\" and \"right\" are NOT included even though \"at\" is\n * given, because at least one of the two opposing views of a pair must be\n * present for the other one to be included (except in the special case of\n * `views` being \"at\").\n *\n * ```javascript\n * getOppositeViews(\"at,above\"); // -> [\"below\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above\"); // -> [\"at\", \"below\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,below\"); // -> [\"at\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,below\"); // -> []\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,right\"); // -> [\"at\", \"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,right\"); // -> [\"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid, including if it's empty \"\".\n *\n * @category Views\n */\nexport const getOppositeViews = (\n  views: CommaSeparatedStr<View> | View[],\n): View[] => {\n  if (!views) {\n    throw MH.usageError(\"'views' cannot be empty\");\n  }\n\n  const bitmask = getViewsBitmask(views);\n  let oppositeBitmask = VIEWS_SPACE.bitmask & ~bitmask; // initial, all not present in bitmask\n\n  // If the given view is \"at\", then include all the other ones.\n  // Otherwise include only the opposite views of those directional\n  // (above/below/left/right) that are present. I.e. if neither left not right\n  // is given, then don't include them\n  if (bitmask !== VIEWS_SPACE.bit.at) {\n    // remove the opposite ones to those not present\n    if (!(bitmask & VIEWS_SPACE.bit.above)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.below;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.below)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.above;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.left)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.right;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.right)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.left;\n    }\n  }\n\n  return getViewsFromBitmask(oppositeBitmask);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getViewsBitmask = (\n  viewsStr: View[] | string | undefined,\n): number => {\n  let viewsBitmask = 0;\n  const views = validateStrList(\"views\", viewsStr, isValidView);\n\n  if (views) {\n    for (const v of views) {\n      if (!isValidView(v)) {\n        throw MH.usageError(`Unknown view '${v}'`);\n      }\n\n      viewsBitmask |= VIEWS_SPACE.bit[v];\n    }\n  } else {\n    viewsBitmask = VIEWS_SPACE.bitmask; // default: all\n  }\n\n  return viewsBitmask;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const parseScrollOffset = (input: string) => {\n  const match = input.match(OFFSET_REGEX);\n  if (!match) {\n    throw MH.usageError(`Invalid offset: '${input}'`);\n  }\n\n  const reference = match.groups?.ref;\n  const value = match.groups?.value;\n  /* istanbul ignore next */ // shouldn't happen\n  if (!reference || !value) {\n    throw MH.bugError(\"Offset regex: blank named groups\");\n  }\n\n  return { reference, value };\n};\n\nconst VIEWS: View[] = [\n  MC.S_AT,\n  MC.S_ABOVE,\n  MC.S_BELOW,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const VIEWS_SPACE = createBitSpace<View>(newBitSpaces(), ...VIEWS);\n\n// --------------------\n\nconst OFFSET_REGEX = RegExp(\"(?<ref>top|bottom|left|right): *(?<value>[^ ].+)\");\n\nconst getViewsFromBitmask = (bitmask: number): View[] => {\n  const views: View[] = [];\n  for (let bit = VIEWS_SPACE.start; bit <= VIEWS_SPACE.end; bit++) {\n    const value = 1 << bit;\n    if (bitmask & value) {\n      const name = VIEWS_SPACE.nameOf(value);\n      if (name) {\n        views.push(name);\n      }\n    }\n  }\n\n  return views;\n};\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAId,SAASC,cAAc,EAAEC,eAAe;AAExC,SAASC,YAAY,EAAEC,cAAc;;AAErC;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAIC,MAAc;EAAA,OAChDA,MAAM,CAACC,KAAK,CAACC,YAAY,CAAC,KAAK,IAAI;AAAA;;AAErC;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAY;EAAA,OACtCV,EAAE,CAACW,QAAQ,CAACC,KAAK,EAAEF,IAAI,CAAC;AAAA;;AAE1B;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMG,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,KAAwB;EAAA,OACtDb,cAAc,CAACa,KAAK,EAAEL,WAAW,EAAE,KAAK,CAAC;AAAA;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMM,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAC3BD,KAAuC,EAC5B;EACX,IAAI,CAACA,KAAK,EAAE;IACV,MAAMd,EAAE,CAACgB,UAAU,CAAC,yBAAyB,CAAC;EAChD;EAEA,IAAMC,OAAO,GAAGC,eAAe,CAACJ,KAAK,CAAC;EACtC,IAAIK,eAAe,GAAGC,WAAW,CAACH,OAAO,GAAG,CAACA,OAAO,CAAC,CAAC;;EAEtD;EACA;EACA;EACA;EACA,IAAIA,OAAO,KAAKG,WAAW,CAACC,GAAG,CAACC,EAAE,EAAE;IAClC;IACA,IAAI,EAAEL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","ignoreList":[]}