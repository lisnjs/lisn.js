{"version":3,"file":"bit-spaces.js","names":["MH","getBitmask","BitSpaces","_createClass","_classCallCheck","_defineProperty","counter","newCounter","create","_len","arguments","length","propNames","Array","_key","newBitSpace","defineProperty","get","_nBits","_bitmask","newBitSpaces","createBitSpace","spaces","_len2","_key2","apply","start","end","lengthOf","usageError","bitmask","space","bit","has","p","isString","isNumber","bitmaskFor","pStart","pEnd","isEmpty","thisStart","log2","thisEnd","nameOf","val","_propNames","_iterator","_createForOfIteratorHelper","_step","s","n","done","name","value","enumerable","err","e","f"],"sources":["../../../src/ts/modules/bit-spaces.ts"],"sourcesContent":["/**\n * @module Modules/BitSpaces\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getBitmask } from \"@lisn/utils/math\";\n\nexport type BitPropName = string;\n\n/**\n * A union of all property names in the space.\n */\nexport type BitSpaceKey<S> = S extends BitSpace<infer T> ? T : never;\n\n/**\n * {@link BitSpace} represents a single set of mutually exclusive (or\n * orthogonal) properties.\n *\n * Each property has a numeric value equal to 1 bit-shifted by a certain number\n * of bits.\n *\n * Created using {@link BitSpaces.create}\n *\n * @interface\n */\nexport type BitSpace<T extends BitPropName> = {\n  /**\n   * The starting bit of the space. It's 0 for the first space created in a\n   * given set of {@link BitSpaces}.\n   */\n  start: number;\n\n  /**\n   * The ending bit of the space. It's always equal to\n   * start + (# of properties in space) - 1\n   */\n  end: number;\n\n  /**\n   * A bitmask of all values in the space.\n   */\n  bitmask: number;\n\n  /**\n   * Returns true if the given name is one of the properties in the space.\n   * It is case-sensitive.\n   */\n  has: (p: string) => p is T;\n\n  /**\n   * Takes the names of two properties within the space and returns a bitmask\n   * that covers all values between them _including the starting and ending\n   * one_.*\n   *\n   * If pStart > pEnd, they are reversed.\n   *\n   * * The numeric values of the properties are guaranteed to be in the same\n   *   order, increasing in value, as the keys passed to the `BitSpaces.create`,\n   *   function.\n   *\n   * @param {} pStart  The name of the property that holds the start value.\n   *                   If null the bitmask will cover from the lowest property.\n   * @param {} pEnd    The name of the property that holds the end cut-off\n   *                   value for the bitmask. The bitmask with _not_ include\n   *                   pEnd's value.\n   *                   If null the bitmask will cover to the highest property,\n   *                   _including_.\n   *\n   * @returns {} Returns a non-0 bitmask containing all values in the space\n   *             between the given ones.\n   *             Returns 0 if one or both of the given properties do not exist\n   *             in the space.\n   */\n  bitmaskFor: (pStart?: T | null, pEnd?: T | null) => number;\n\n  /**\n   * Returns the name of the property with the given value, or null if the\n   * value does not correspond to one of the space properties.\n   */\n  nameOf: (val: number) => T | null;\n\n  /**\n   * Holds properties whose numeric values are non-overlapping binary values,\n   * suitable for bitmasking.\n   *\n   * The given properties are set under the \"bit\" key in the object and hold\n   * the numeric value.\n   *\n   * @example\n   * ```javascript\n   * const space = new BitSpaces().create(\"up\", \"down\", \"left\", \"right\");\n   *\n   * // {\n   * //     bit: {\n   * //         up:    1, // at bit 0, i.e. 1 << 0\n   * //         down:  2, // at bit 1, i.e. 1 << 1\n   * //         left:  4, // at bit 2, i.e. 1 << 2\n   * //         right: 8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      0,\n   * //     end:        3,\n   * //     bitmask:    15, // 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"up\" || p === \"down\" || p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : v === 4 ...\n   * // }\n   *\n   * space.bitmaskFor(); // => space.bitmask (15)\n   * space.bitmaskFor(\"left\"); // => space.bit.left | space.bit.right (12)\n   * space.bitmaskFor(null, \"down\"); // => space.bit.up | space.bit.down (3)\n   * ```\n   */\n  bit: {\n    [key in T]: number;\n  };\n};\n\n/**\n * {@link BitSpaces} represents one or more related {@link BitSpace}s whose bit\n * values will not overlap.\n */\nexport class BitSpaces {\n  /**\n   * Creates and returns a new BitSpace that is bit shifted to the left as\n   * many bits as the ending bit of the previous space created by this\n   * instances, so that each new space created is non-overlapping with previous\n   * ones.\n   *\n   * The numeric values of the properties are guaranteed to be in the same\n   * order, increasing in value, as the keys passed to the function.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the number of bits in the space will exceed 32.\n   *\n   * @example\n   * ```javascript\n   * const spaces = new BitSpaces();\n   * const spaceA = spaces.create(\"up\", \"down\");\n   *\n   * // spaces.nBits   => 2\n   * // spaces.bitmask => 3\n   * //\n   * // spaceA:\n   * // {\n   * //     bit: {\n   * //         up:     1, // at bit 0, i.e. 1 << 0\n   * //         down:   2, // at bit 1, i.e. 1 << 1\n   * //     },\n   * //     start:      0,\n   * //     end:        1,\n   * //     bitmask:    3, // 1 << 0 | 1 << 1\n   * //     has:        (p) => p === \"up\" || p === \"down\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : null\n   * // }\n   *\n   * const spaceB = spaces.create(\"left\", \"right\");\n   *\n   * // spaces.nBits   => 4\n   * // spaces.bitmask => 15\n   * //\n   * // spaceB:\n   * // {\n   * //     bit: {\n   * //         left:   4, // at bit 2, i.e. 1 << 2\n   * //         right:  8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      2,\n   * //     end:        3,\n   * //     bitmask:    12, // 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 4 ? \"left\" : v === 8 ? \"right\" : null\n   * // }\n   *\n   * ```\n   */\n  readonly create: <T extends BitPropName>(\n    ...propNames: readonly T[]\n  ) => BitSpace<T>;\n\n  /**\n   * Returns the number of bits all created spaces span, i.e. the end bit of\n   * the one + 1.\n   */\n  readonly nBits!: number;\n\n  /**\n   * Returns a bitmask containing all values in all created spaces.\n   */\n  readonly bitmask!: number;\n\n  constructor() {\n    const counter = newCounter();\n\n    this.create = (...propNames) => newBitSpace(counter, propNames);\n    MH.defineProperty(this, \"nBits\", { get: () => counter._nBits });\n    MH.defineProperty(this, \"bitmask\", { get: () => counter._bitmask });\n  }\n}\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newBitSpaces = () => new BitSpaces();\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const createBitSpace = <T extends BitPropName>(\n  spaces: BitSpaces,\n  ...propNames: readonly T[]\n): BitSpace<T> => spaces.create(...propNames);\n\n// ----------------------------------------\n\ntype BitCounter = {\n  _nBits: number;\n  _bitmask: number;\n};\n\nconst newCounter = (): BitCounter => ({\n  _nBits: 0,\n  _bitmask: 0,\n});\n\nconst newBitSpace = <T extends BitPropName>(\n  counter: BitCounter,\n  propNames: readonly T[],\n): BitSpace<T> => {\n  const start = counter._nBits;\n  const end = start + MH.lengthOf(propNames) - 1;\n  if (end >= 31) {\n    throw MH.usageError(\"BitSpaces overflow\");\n  }\n\n  const bitmask = getBitmask(start, end);\n  const space: BitSpace<T> = {\n    bit: {},\n    start,\n    end,\n    bitmask,\n\n    has: (p) =>\n      MH.isString(p) &&\n      p in space.bit &&\n      MH.isNumber((space.bit as Record<string, unknown>)[p]),\n\n    bitmaskFor: (pStart, pEnd) => {\n      if (\n        (!MH.isEmpty(pStart) && !space.has(pStart)) ||\n        (!MH.isEmpty(pEnd) && !space.has(pEnd))\n      ) {\n        return 0;\n      }\n\n      const thisStart = !MH.isEmpty(pStart)\n        ? MH.log2(space.bit[pStart])\n        : start;\n      const thisEnd = !MH.isEmpty(pEnd) ? MH.log2(space.bit[pEnd]) : end;\n\n      return getBitmask(thisStart, thisEnd);\n    },\n\n    nameOf: (val) => propNames[MH.log2(val) - start] ?? null,\n  } as BitSpace<T>;\n\n  for (const name of propNames) {\n    MH.defineProperty(space.bit, name, {\n      value: 1 << counter._nBits++,\n      enumerable: true,\n    });\n  }\n\n  counter._bitmask |= bitmask;\n\n  return space;\n};\n"],"mappings":"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","ignoreList":[]}