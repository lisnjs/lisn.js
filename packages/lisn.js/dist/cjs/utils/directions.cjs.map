{"version":3,"file":"directions.cjs","names":["MC","_interopRequireWildcard","require","MH","_math","_validation","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","getMaxDeltaDirection","deltaX","deltaY","abs","S_NONE","S_AMBIGUOUS","S_LEFT","S_RIGHT","S_UP","S_DOWN","exports","getVectorDirection","vector","angleDiffThreshold","min","maxAbs","areParallel","getOppositeDirection","direction","OPPOSITE_DIRECTIONS","usageError","getOppositeXYDirections","directions","directionList","validateStrList","isValidXYDirection","opposites","opposite","includes","push","lengthOf","XY_DIRECTIONS","isValidZDirection","Z_DIRECTIONS","isValidDirection","DIRECTIONS","isValidDirectionList","isValidStrList","S_IN","S_OUT","SCROLL_DIRECTIONS"],"sources":["../../../src/ts/utils/directions.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  XYDirection,\n  ZDirection,\n  NoDirection,\n  AmbiguousDirection,\n  CommaSeparatedStr,\n  Vector,\n} from \"@lisn/globals/types\";\n\nimport { maxAbs, areParallel } from \"@lisn/utils/math\";\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\n/**\n * Returns the cardinal direction in the XY plane for the larger of the two\n * deltas (horizontal vs vertical).\n *\n * If both deltas are 0, returns \"none\".\n *\n * If both deltas are equal and non-0, returns \"ambiguous\".\n *\n * @category Directions\n */\nexport const getMaxDeltaDirection = (\n  deltaX: number,\n  deltaY: number,\n): XYDirection | NoDirection | AmbiguousDirection => {\n  if (!MH.abs(deltaX) && !MH.abs(deltaY)) {\n    return MC.S_NONE;\n  }\n\n  if (MH.abs(deltaX) === MH.abs(deltaY)) {\n    return MC.S_AMBIGUOUS;\n  }\n\n  if (MH.abs(deltaX) > MH.abs(deltaY)) {\n    return deltaX < 0 ? MC.S_LEFT : MC.S_RIGHT;\n  }\n  return deltaY < 0 ? MC.S_UP : MC.S_DOWN;\n};\n\n/**\n * Returns the approximate direction of the given 2D vector as one of the\n * cardinal (XY plane) ones: \"up\", \"down\", \"left\" or \"right\"; or \"ambiguous\".\n *\n * @param {} angleDiffThreshold  See {@link areParallel} or\n *                               {@link Utils.areAntiParallel | areAntiParallel}.\n *                               This determines whether the inferred direction\n *                               is ambiguous. For it to _not_ be ambiguous it\n *                               must align with one of the four cardinal\n *                               directions to within `angleDiffThreshold`.\n *                               It doesn't make sense for this value to be < 0\n *                               or >= 45 degrees. If it is, it's forced to be\n *                               positive (absolute) and <= 44.99.\n *\n * @category Directions\n */\nexport const getVectorDirection = (\n  vector: Vector,\n  angleDiffThreshold = 0,\n): XYDirection | AmbiguousDirection | NoDirection => {\n  angleDiffThreshold = MH.min(44.99, MH.abs(angleDiffThreshold));\n\n  if (!maxAbs(...vector)) {\n    return MC.S_NONE;\n  } else if (areParallel(vector, [1, 0], angleDiffThreshold)) {\n    return MC.S_RIGHT;\n  } else if (areParallel(vector, [0, 1], angleDiffThreshold)) {\n    return MC.S_DOWN;\n  } else if (areParallel(vector, [-1, 0], angleDiffThreshold)) {\n    return MC.S_LEFT;\n  } else if (areParallel(vector, [0, -1], angleDiffThreshold)) {\n    return MC.S_UP;\n  }\n\n  return MC.S_AMBIGUOUS;\n};\n\n/**\n * Returns the opposite direction to the given direction or null if the given\n * direction has no opposite.\n *\n * @example\n * ```javascript\n * getOppositeDirection(\"up\"); // -> \"down\"\n * getOppositeDirection(\"down\"); // -> \"up\"\n * getOppositeDirection(\"left\"); // -> \"right\"\n * getOppositeDirection(\"right\"); // -> \"left\"\n * getOppositeDirection(\"none\"); // -> null\n * getOppositeDirection(\"ambiguous\"); // -> null\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeDirection = (\n  direction: Direction,\n): Direction | null => {\n  if (!(direction in OPPOSITE_DIRECTIONS)) {\n    throw MH.usageError(\"Invalid 'direction'\");\n  }\n\n  return OPPOSITE_DIRECTIONS[direction];\n};\n\n/**\n * Returns the set of directions which are opposite to the given set of directions.\n *\n * There are two sets of opposite pairs (\"up\"/\"down\" and \"left\"/\"right\") and at\n * least one of the two opposing directions of a pair must be present for the\n * other one to be included. If both directions that constitute a pair of\n * opposites is given, then the other pair is returned instead (minus any that\n * are present in the input). See examples below for clarification.\n *\n * @example\n * ```javascript\n * getOppositeXYDirections(\"up\"); // -> [\"down\"]\n * getOppositeXYDirections(\"left\"); // -> [\"right\"]\n * getOppositeXYDirections(\"up,down\"); // -> [\"left\",\"right\"]\n * getOppositeXYDirections(\"up,left\"); // -> [\"down\",\"right\"]\n * getOppositeXYDirections(\"up,left,right\"); // -> [\"down\"]\n * getOppositeXYDirections(\"none\"); // -> throws\n * getOppositeXYDirections(\"ambiguous\"); // -> throws\n * getOppositeXYDirections(\"in\"); // -> throws\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeXYDirections = (\n  directions: CommaSeparatedStr<XYDirection> | XYDirection[],\n): XYDirection[] => {\n  const directionList = validateStrList(\n    \"directions\",\n    directions,\n    isValidXYDirection,\n  );\n\n  if (!directionList) {\n    throw MH.usageError(\"'directions' is required\");\n  }\n\n  const opposites: XYDirection[] = [];\n  for (const direction of directionList) {\n    const opposite = getOppositeDirection(direction);\n    if (\n      opposite &&\n      isValidXYDirection(opposite) &&\n      !MH.includes(directionList, opposite)\n    ) {\n      opposites.push(opposite);\n    }\n  }\n\n  if (!MH.lengthOf(opposites)) {\n    for (const direction of XY_DIRECTIONS) {\n      if (!MH.includes(directionList, direction)) {\n        opposites.push(direction);\n      }\n    }\n  }\n\n  return opposites;\n};\n\n/**\n * Returns true if the given direction is one of the known XY ones.\n *\n * @category Validation\n */\nexport const isValidXYDirection = (\n  direction: string,\n): direction is XYDirection => MH.includes(XY_DIRECTIONS, direction);\n\n/**\n * Returns true if the given direction is one of the known Z ones.\n *\n * @category Validation\n */\nexport const isValidZDirection = (direction: string): direction is ZDirection =>\n  MH.includes(Z_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string is a valid direction.\n *\n * @category Validation\n */\nexport const isValidDirection = (direction: string): direction is Direction =>\n  MH.includes(DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid directions.\n *\n * @category Validation\n */\nexport const isValidDirectionList = (\n  directions: string | string[],\n): directions is CommaSeparatedStr<Direction> | Direction[] =>\n  isValidStrList(directions, isValidDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const XY_DIRECTIONS = [\n  MC.S_UP,\n  MC.S_DOWN,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const Z_DIRECTIONS = [MC.S_IN, MC.S_OUT] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const SCROLL_DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  ...Z_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n// --------------------\n\nconst OPPOSITE_DIRECTIONS = {\n  [MC.S_UP]: MC.S_DOWN,\n  [MC.S_DOWN]: MC.S_UP,\n  [MC.S_LEFT]: MC.S_RIGHT,\n  [MC.S_RIGHT]: MC.S_LEFT,\n  [MC.S_IN]: MC.S_OUT,\n  [MC.S_OUT]: MC.S_IN,\n  [MC.S_NONE]: null,\n  [MC.S_AMBIGUOUS]: null,\n} as const;\n"],"mappings":";;;;;;AAIA,IAAAA,EAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,EAAA,GAAAF,uBAAA,CAAAC,OAAA;AAYA,IAAAE,KAAA,GAAAF,OAAA;AACA,IAAAG,WAAA,GAAAH,OAAA;AAAyE,SAAAD,wBAAAK,CAAA,EAAAC,CAAA,6BAAAC,OAAA,MAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAP,uBAAA,YAAAA,CAAAK,CAAA,EAAAC,CAAA,SAAAA,CAAA,IAAAD,CAAA,IAAAA,CAAA,CAAAK,UAAA,SAAAL,CAAA,MAAAM,CAAA,EAAAC,CAAA,EAAAC,CAAA,KAAAC,SAAA,QAAAC,OAAA,EAAAV,CAAA,iBAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,SAAAQ,CAAA,MAAAF,CAAA,GAAAL,CAAA,GAAAG,CAAA,GAAAD,CAAA,QAAAG,CAAA,CAAAK,GAAA,CAAAX,CAAA,UAAAM,CAAA,CAAAM,GAAA,CAAAZ,CAAA,GAAAM,CAAA,CAAAO,GAAA,CAAAb,CAAA,EAAAQ,CAAA,gBAAAP,CAAA,IAAAD,CAAA,gBAAAC,CAAA,OAAAa,cAAA,CAAAC,IAAA,CAAAf,CAAA,EAAAC,CAAA,OAAAM,CAAA,IAAAD,CAAA,GAAAU,MAAA,CAAAC,cAAA,KAAAD,MAAA,CAAAE,wBAAA,CAAAlB,CAAA,EAAAC,CAAA,OAAAM,CAAA,CAAAK,GAAA,IAAAL,CAAA,CAAAM,GAAA,IAAAP,CAAA,CAAAE,CAAA,EAAAP,CAAA,EAAAM,CAAA,IAAAC,CAAA,CAAAP,CAAA,IAAAD,CAAA,CAAAC,CAAA,WAAAO,CAAA,KAAAR,CAAA,EAAAC,CAAA;AAlBzE;AACA;AACA;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMkB,oBAAoB,GAAGA,CAClCC,MAAc,EACdC,MAAc,KACqC;EACnD,IAAI,CAACxB,EAAE,CAACyB,GAAG,CAACF,MAAM,CAAC,IAAI,CAACvB,EAAE,CAACyB,GAAG,CAACD,MAAM,CAAC,EAAE;IACtC,OAAO3B,EAAE,CAAC6B,MAAM;EAClB;EAEA,IAAI1B,EAAE,CAACyB,GAAG,CAACF,MAAM,CAAC,KAAKvB,EAAE,CAACyB,GAAG,CAACD,MAAM,CAAC,EAAE;IACrC,OAAO3B,EAAE,CAAC8B,WAAW;EACvB;EAEA,IAAI3B,EAAE,CAACyB,GAAG,CAACF,MAAM,CAAC,GAAGvB,EAAE,CAACyB,GAAG,CAACD,MAAM,CAAC,EAAE;IACnC,OAAOD,MAAM,GAAG,CAAC,GAAG1B,EAAE,CAAC+B,MAAM,GAAG/B,EAAE,CAACgC,OAAO;EAC5C;EACA,OAAOL,MAAM,GAAG,CAAC,GAAG3B,EAAE,CAACiC,IAAI,GAAGjC,EAAE,CAACkC,MAAM;AACzC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfAC,OAAA,CAAAV,oBAAA,GAAAA,oBAAA;AAgBO,MAAMW,kBAAkB,GAAGA,CAChCC,MAAc,EACdC,kBAAkB,GAAG,CAAC,KAC6B;EACnDA,kBAAkB,GAAGnC,EAAE,CAACoC,GAAG,CAAC,KAAK,EAAEpC,EAAE,CAACyB,GAAG,CAACU,kBAAkB,CAAC,CAAC;EAE9D,IAAI,CAAC,IAAAE,YAAM,EAAC,GAAGH,MAAM,CAAC,EAAE;IACtB,OAAOrC,EAAE,CAAC6B,MAAM;EAClB,CAAC,MAAM,IAAI,IAAAY,iBAAW,EAACJ,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEC,kBAAkB,CAAC,EAAE;IAC1D,OAAOtC,EAAE,CAACgC,OAAO;EACnB,CAAC,MAAM,IAAI,IAAAS,iBAAW,EAACJ,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEC,kBAAkB,CAAC,EAAE;IAC1D,OAAOtC,EAAE,CAACkC,MAAM;EAClB,CAAC,MAAM,IAAI,IAAAO,iBAAW,EAACJ,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEC,kBAAkB,CAAC,EAAE;IAC3D,OAAOtC,EAAE,CAAC+B,MAAM;EAClB,CAAC,MAAM,IAAI,IAAAU,iBAAW,EAACJ,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEC,kBAAkB,CAAC,EAAE;IAC3D,OAAOtC,EAAE,CAACiC,IAAI;EAChB;EAEA,OAAOjC,EAAE,CAAC8B,WAAW;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBAK,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAmBO,MAAMM,oBAAoB,GAC/BC,SAAoB,IACC;EACrB,IAAI,EAAEA,SAAS,IAAIC,mBAAmB,CAAC,EAAE;IACvC,MAAMzC,EAAE,CAAC0C,UAAU,CAAC,qBAAqB,CAAC;EAC5C;EAEA,OAAOD,mBAAmB,CAACD,SAAS,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBAR,OAAA,CAAAO,oBAAA,GAAAA,oBAAA;AA0BO,MAAMI,uBAAuB,GAClCC,UAA0D,IACxC;EAClB,MAAMC,aAAa,GAAG,IAAAC,2BAAe,EACnC,YAAY,EACZF,UAAU,EACVG,kBACF,CAAC;EAED,IAAI,CAACF,aAAa,EAAE;IAClB,MAAM7C,EAAE,CAAC0C,UAAU,CAAC,0BAA0B,CAAC;EACjD;EAEA,MAAMM,SAAwB,GAAG,EAAE;EACnC,KAAK,MAAMR,SAAS,IAAIK,aAAa,EAAE;IACrC,MAAMI,QAAQ,GAAGV,oBAAoB,CAACC,SAAS,CAAC;IAChD,IACES,QAAQ,IACRF,kBAAkB,CAACE,QAAQ,CAAC,IAC5B,CAACjD,EAAE,CAACkD,QAAQ,CAACL,aAAa,EAAEI,QAAQ,CAAC,EACrC;MACAD,SAAS,CAACG,IAAI,CAACF,QAAQ,CAAC;IAC1B;EACF;EAEA,IAAI,CAACjD,EAAE,CAACoD,QAAQ,CAACJ,SAAS,CAAC,EAAE;IAC3B,KAAK,MAAMR,SAAS,IAAIa,aAAa,EAAE;MACrC,IAAI,CAACrD,EAAE,CAACkD,QAAQ,CAACL,aAAa,EAAEL,SAAS,CAAC,EAAE;QAC1CQ,SAAS,CAACG,IAAI,CAACX,SAAS,CAAC;MAC3B;IACF;EACF;EAEA,OAAOQ,SAAS;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AAJAhB,OAAA,CAAAW,uBAAA,GAAAA,uBAAA;AAKO,MAAMI,kBAAkB,GAC7BP,SAAiB,IACYxC,EAAE,CAACkD,QAAQ,CAACG,aAAa,EAAEb,SAAS,CAAC;;AAEpE;AACA;AACA;AACA;AACA;AAJAR,OAAA,CAAAe,kBAAA,GAAAA,kBAAA;AAKO,MAAMO,iBAAiB,GAAId,SAAiB,IACjDxC,EAAE,CAACkD,QAAQ,CAACK,YAAY,EAAEf,SAAS,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AAJAR,OAAA,CAAAsB,iBAAA,GAAAA,iBAAA;AAKO,MAAME,gBAAgB,GAAIhB,SAAiB,IAChDxC,EAAE,CAACkD,QAAQ,CAACO,UAAU,EAAEjB,SAAS,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AAJAR,OAAA,CAAAwB,gBAAA,GAAAA,gBAAA;AAKO,MAAME,oBAAoB,GAC/Bd,UAA6B,IAE7B,IAAAe,0BAAc,EAACf,UAAU,EAAEY,gBAAgB,EAAE,KAAK,CAAC;;AAErD;AACA;AACA;AACA;AAHAxB,OAAA,CAAA0B,oBAAA,GAAAA,oBAAA;AAIO,MAAML,aAAa,GAAArB,OAAA,CAAAqB,aAAA,GAAG,CAC3BxD,EAAE,CAACiC,IAAI,EACPjC,EAAE,CAACkC,MAAM,EACTlC,EAAE,CAAC+B,MAAM,EACT/B,EAAE,CAACgC,OAAO,CACF;;AAEV;AACA;AACA;AACA;AACO,MAAM0B,YAAY,GAAAvB,OAAA,CAAAuB,YAAA,GAAG,CAAC1D,EAAE,CAAC+D,IAAI,EAAE/D,EAAE,CAACgE,KAAK,CAAU;;AAExD;AACA;AACA;AACA;AACO,MAAMC,iBAAiB,GAAA9B,OAAA,CAAA8B,iBAAA,GAAG,CAC/B,GAAGT,aAAa,EAChBxD,EAAE,CAAC6B,MAAM,EACT7B,EAAE,CAAC8B,WAAW,CACN;;AAEV;AACA;AACA;AACA;AACO,MAAM8B,UAAU,GAAAzB,OAAA,CAAAyB,UAAA,GAAG,CACxB,GAAGJ,aAAa,EAChB,GAAGE,YAAY,EACf1D,EAAE,CAAC6B,MAAM,EACT7B,EAAE,CAAC8B,WAAW,CACN;;AAEV;;AAEA,MAAMc,mBAAmB,GAAG;EAC1B,CAAC5C,EAAE,CAACiC,IAAI,GAAGjC,EAAE,CAACkC,MAAM;EACpB,CAAClC,EAAE,CAACkC,MAAM,GAAGlC,EAAE,CAACiC,IAAI;EACpB,CAACjC,EAAE,CAAC+B,MAAM,GAAG/B,EAAE,CAACgC,OAAO;EACvB,CAAChC,EAAE,CAACgC,OAAO,GAAGhC,EAAE,CAAC+B,MAAM;EACvB,CAAC/B,EAAE,CAAC+D,IAAI,GAAG/D,EAAE,CAACgE,KAAK;EACnB,CAAChE,EAAE,CAACgE,KAAK,GAAGhE,EAAE,CAAC+D,IAAI;EACnB,CAAC/D,EAAE,CAAC6B,MAAM,GAAG,IAAI;EACjB,CAAC7B,EAAE,CAAC8B,WAAW,GAAG;AACpB,CAAU","ignoreList":[]}