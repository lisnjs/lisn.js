{"version":3,"file":"size-watcher.js","names":["MC","MH","setNumericStyleJsVars","logError","toNonNegNum","isValidBox","isValidDimension","getEntryBorderBox","getEntryContentBox","tryGetViewportOverlay","fetchViewportOverlay","objToStrKey","wrapCallback","newXWeakMap","XResizeObserver","debug","SizeWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","instance","instances","get","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","allSizeData","newWeakMap","allCallbacks","newMap","resizeHandler","entries","entry","processEntry","xObserver","fetchCurrentSize","target","element","fetchElement","sizeData","copyObject","newPromise","resolve","observer","newResizeObserver","getSizeData","disconnect","observe","border","S_WIDTH","S_HEIGHT","content","fetchOptions","options","_options$box","_options$dimension","_options$MC$S_DEBOUNC","box","usageError","dimension","_element","targetOf","_box","_dimension","_threshold","threshold","_resizeThreshold","_debounceWindow","S_DEBOUNCE_WINDOW","createCallback","handler","_allCallbacks$get","remove","_callback","debug5","callback","onRemove","deleteHandler","_options","sGet","setupOnResize","userOptions","isRemoved","_data","observeLater","skipInitial","invokeCallback","removeOnResize","_allCallbacks$get2","currEntry","setSizeCssProps","deleteKey","prune","has","debug4","unobserve","latestData","debug9","_allCallbacks$get3","values","thresholdsExceeded","hasExceededThreshold","trackSize","noTrackSize","onResize","offResize","SYMBOL","resizeThreshold","lastThresholdData","dim","diff","abs","borderBox","contentBox","prefix","getDocElement","props","borderWidth","borderHeight","contentWidth","contentHeight","_prefix","isElement","getWindow","getDoc","invoke","catch"],"sources":["../../../src/ts/watchers/size-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/SizeWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Box, Dimension, Size, SizeTarget } from \"@lisn/globals/types\";\n\nimport { setNumericStyleJsVars } from \"@lisn/utils/css-alter\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum } from \"@lisn/utils/math\";\nimport {\n  isValidBox,\n  isValidDimension,\n  getEntryBorderBox,\n  getEntryContentBox,\n  tryGetViewportOverlay,\n  fetchViewportOverlay,\n} from \"@lisn/utils/size\";\nimport { objToStrKey } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\nimport { XResizeObserver } from \"@lisn/modules/x-resize-observer\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link SizeWatcher} monitors the size of a given target. It's built on top\n * of {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver | ResizeObserver}.\n *\n * It manages registered callbacks globally and reuses ResizeObservers.\n *\n * Each instance of SizeWatcher manages up to two ResizeObservers: one\n * for content-box size changes and one for border-box size changes.\n */\nexport class SizeWatcher {\n  /**\n   * Call the given handler whenever the target's size changes.\n   *\n   * Unless {@link OnResizeOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest size data.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link onResize} or {@link trackSize},\n   * then it will be removed and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or options are invalid.\n   */\n  readonly onResize: (\n    handler: OnResizeHandler,\n    options?: OnResizeOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly offResize: (handler: OnResizeHandler, target?: SizeTarget) => void;\n\n  /**\n   * This is the same as {@link onResize} except that if `handler` is not given,\n   * then it defaults to an  handler that updates a set of CSS variables on the\n   * target's style:\n   *\n   * - If {@link OnResizeOptions.target | options.target} is not given, or is\n   *   `window`, the following CSS variables are set on the root (`html`)\n   *   element and represent the viewport size:\n   *   - `--lisn-js--window-border-width`\n   *   - `--lisn-js--window-border-height`\n   *   - `--lisn-js--window-content-width`\n   *   - `--lisn-js--window-content-height`\n   *\n   * - Otherwise, the following variables are set on the target itself and\n   *   represent its visible size:\n   *   - `--lisn-js--border-width`\n   *   - `--lisn-js--border-height`\n   *   - `--lisn-js--content-width`\n   *   - `--lisn-js--content-height`\n   *\n   * If `target` is `document`, then it will use `document.documentElement`.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link onResize} or {@link trackSize},\n   * then it will be removed and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or options are invalid.\n   */\n  readonly trackSize: (\n    handler?: OnResizeHandler | null,\n    options?: OnResizeOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackSize}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly noTrackSize: (\n    handler?: OnResizeHandler | null,\n    target?: SizeTarget,\n  ) => void;\n\n  /**\n   * Get the size of the given target. It will get the size from a\n   * ResizeObserverEntry and so it's always delayed by one frame at least.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly fetchCurrentSize: (target?: SizeTarget) => Promise<SizeData>;\n\n  /**\n   * Creates a new instance of SizeWatcher with the given\n   * {@link SizeWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: SizeWatcherConfig = {}) {\n    return new SizeWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of SizeWatcher with the given\n   * {@link SizeWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: SizeWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new SizeWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: SizeWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"SizeWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"SizeWatcher\", logAtCreation: config })\n      : null;\n\n    const allSizeData = MH.newWeakMap<Element, SizeData>();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnResizeHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const resizeHandler = (entries: ResizeObserverEntry[]) => {\n      for (const entry of entries) {\n        processEntry(entry);\n      }\n    };\n\n    // Don't debounce the observer, only callbacks.\n    const xObserver = new XResizeObserver(resizeHandler);\n\n    // ----------\n\n    const fetchCurrentSize = async (\n      target: SizeTarget | undefined,\n    ): Promise<SizeData> => {\n      const element = await fetchElement(target);\n      const sizeData = allSizeData.get(element);\n      if (sizeData) {\n        return MH.copyObject(sizeData);\n      }\n\n      return MH.newPromise((resolve) => {\n        // Use a temp ResizeObserver\n        const observer = MH.newResizeObserver((entries) => {\n          const sizeData = getSizeData(entries[0]);\n          observer?.disconnect();\n          resolve(sizeData); // no need to copy or save it\n        });\n\n        if (observer) {\n          observer.observe(element);\n        } else {\n          // Warning would have already been logged by XResizeObserver\n          resolve({\n            border: { [MC.S_WIDTH]: 0, [MC.S_HEIGHT]: 0 },\n            content: { [MC.S_WIDTH]: 0, [MC.S_HEIGHT]: 0 },\n          });\n        }\n      });\n    };\n\n    // ----------\n\n    const fetchOptions = async (\n      options: OnResizeOptions,\n    ): Promise<OnResizeOptionsInternal> => {\n      const box = options.box ?? null;\n      if (box && !isValidBox(box)) {\n        throw MH.usageError(`Unknown box type: '${box}'`);\n      }\n\n      const dimension = options.dimension ?? null;\n      if (dimension && !isValidDimension(dimension)) {\n        throw MH.usageError(`Unknown dimension: '${dimension}'`);\n      }\n\n      return {\n        _element: await fetchElement(MH.targetOf(options)),\n        _box: box,\n        _dimension: dimension,\n        // If threshold is 0, internally treat as 1 (pixel)\n        _threshold:\n          toNonNegNum(options.threshold, config._resizeThreshold) || 1,\n        _debounceWindow:\n          options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n      };\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnResizeHandler,\n      options: OnResizeOptionsInternal,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = { _callback: callback, _options: options };\n      allCallbacks.sGet(element).set(handler, entry);\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnResize = async (\n      handler: OnResizeHandler,\n      userOptions: OnResizeOptions | undefined,\n    ) => {\n      const options = await fetchOptions(userOptions || {});\n      const element = options._element;\n\n      // Don't await for the size data before creating the callback so that\n      // setupOnResize and removeOnResize have the same \"timing\" and therefore\n      // calling onResize and offResize immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options);\n      const callback = entry._callback;\n      const sizeData = await fetchCurrentSize(element);\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = sizeData;\n      allSizeData.set(element, sizeData);\n\n      // Always use observeLater. This is because the initial call to callback\n      // shouldn't be debounced, and so we call it manually here, regardless if\n      // it's a new target or not. Therefore we don't want the observer to also\n      // call it in case it _is_ a new target.\n      // It's ok if already observed, won't do anything.\n      xObserver.observeLater(element);\n\n      if (!userOptions?.skipInitial) {\n        debug: logger?.debug5(\"Calling initially with\", element, sizeData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, sizeData);\n      }\n    };\n\n    // ----------\n\n    const removeOnResize = async (\n      handler: OnResizeHandler,\n      target: SizeTarget | undefined,\n    ) => {\n      const options = await fetchOptions({ target });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setSizeCssProps) {\n          // delete the properties\n          setSizeCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnResizeHandler,\n      options: OnResizeOptionsInternal,\n    ) => {\n      const element = options._element;\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for target; unobserving\",\n          element,\n        );\n        xObserver.unobserve(element);\n        MH.deleteKey(allSizeData, element);\n      }\n    };\n\n    // ----------\n\n    const processEntry = (entry: ResizeObserverEntry) => {\n      // In reality, it can't be just a base Element\n      const element = MH.targetOf(entry);\n\n      const latestData = getSizeData(entry);\n      allSizeData.set(element, latestData);\n\n      debug: logger?.debug9(\"New size data\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        const thresholdsExceeded = hasExceededThreshold(\n          entry._options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\"Threshold not exceeded\");\n          continue;\n        }\n\n        entry._data = latestData;\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentSize = fetchCurrentSize;\n\n    // ----------\n\n    this.trackSize = async (handler?, options?) => {\n      if (!handler) {\n        handler = setSizeCssProps;\n      }\n\n      return setupOnResize(handler, options);\n    };\n\n    // ----------\n\n    this.noTrackSize = (handler?, target?) => {\n      if (!handler) {\n        handler = setSizeCssProps;\n      }\n\n      removeOnResize(handler, target); // no need to await\n    };\n\n    // ----------\n\n    this.onResize = setupOnResize;\n\n    // ----------\n\n    this.offResize = (handler, target?) => {\n      removeOnResize(handler, target); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type SizeWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnResizeOptions.debounceWindow | debounceWindow} in calls to\n   * {@link SizeWatcher.onResize}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnResizeOptions.threshold | threshold} in calls to\n   * {@link SizeWatcher.onResize}.\n   *\n   * @defaultValue 50\n   */\n  resizeThreshold?: number;\n};\n\n/**\n * @interface\n */\nexport type OnResizeOptions = {\n  /**\n   * If it is not given, or is `null` or `window`, then it will track the size\n   * of the viewport (akin to `clientHeight` on `documentElement`).\n   *\n   * If it is `document`, then it will use `document.documentElement`.\n   *\n   * Other values of target must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  target?: SizeTarget;\n\n  /**\n   * Specifies whether to listen for changes in content box size or border box\n   * size.\n   *\n   * If not given, then it listens for changes in either.\n   *\n   * @defaultValue undefined\n   */\n  box?: Box;\n\n  /**\n   * Specifies whether to listen for changes in width or height.\n   *\n   * If not given, then it listens for changes in either.\n   *\n   * @defaultValue undefined\n   */\n  dimension?: Dimension;\n\n  /**\n   * If non-0, the handler will only be called when the target's size in the\n   * observed {@link OnResizeOptions.dimension} and {@link OnResizeOptions.box}\n   * type has changed at least `threshold` pixels since the last time the\n   * handler was called.\n   *\n   * Special case when `threshold` is 0 and at least one of\n   * {@link OnResizeOptions.dimension} or {@link OnResizeOptions.box} is given:\n   * if there's a resize event but the size in the observed dimensions/box\n   * types has not changed, the callback is _not_ called.\n   *\n   * @defaultValue {@link SizeWatcherConfig.resizeThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * @defaultValue {@link SizeWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * The handler is invoked with three arguments:\n *\n * - the element that has been resized: if the target you requested was the\n *   viewport, then this will be a fixed positioned overlay that tracks the\n *   size of the viewport\n * - the {@link SizeData} for the element\n */\nexport type OnResizeHandlerArgs = [Element, SizeData];\nexport type OnResizeCallback = Callback<OnResizeHandlerArgs>;\nexport type OnResizeHandler =\n  | CallbackHandler<OnResizeHandlerArgs>\n  | OnResizeCallback;\n\nexport type SizeData = Record<Box, Size>;\n\n// ----------------------------------------\n\ntype SizeWatcherConfigInternal = {\n  _debounceWindow: number;\n  _resizeThreshold: number;\n};\n\ntype OnResizeOptionsInternal = {\n  _element: Element;\n  _box: Box | null;\n  _dimension: Dimension | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnResizeCallback;\n  _options: OnResizeOptionsInternal;\n  _data?: SizeData;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, SizeWatcher>();\n\nconst getConfig = (config: SizeWatcherConfig): SizeWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _resizeThreshold: toNonNegNum(config.resizeThreshold, 50) || 1,\n  };\n};\n\n// --------------------\n\nconst hasExceededThreshold = (\n  options: OnResizeOptionsInternal,\n  latestData: SizeData,\n  lastThresholdData: SizeData | undefined,\n): boolean => {\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  let box: Box, dim: Dimension;\n  for (box in latestData) {\n    if (options._box && options._box !== box) {\n      continue;\n    }\n\n    for (dim in latestData[box]) {\n      if (options._dimension && options._dimension !== dim) {\n        continue;\n      }\n\n      const diff = MH.abs(latestData[box][dim] - lastThresholdData[box][dim]);\n      if (diff >= options._threshold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst getSizeData = (entry: ResizeObserverEntry): SizeData => {\n  const borderBox = getEntryBorderBox(entry, true);\n  const contentBox = getEntryContentBox(entry);\n\n  return {\n    border: borderBox,\n    content: contentBox,\n  };\n};\n\nconst setSizeCssProps = (\n  element: Element,\n  sizeData: SizeData | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetViewportOverlay()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"window-\";\n  }\n\n  const props = {\n    borderWidth: sizeData?.border[MC.S_WIDTH],\n    borderHeight: sizeData?.border[MC.S_HEIGHT],\n    contentWidth: sizeData?.content[MC.S_WIDTH],\n    contentHeight: sizeData?.content[MC.S_HEIGHT],\n  };\n  setNumericStyleJsVars(element, props, { _prefix: prefix }); // don't await here\n};\n\nconst fetchElement = async (\n  target: SizeTarget | undefined,\n): Promise<Element> => {\n  if (MH.isElement(target)) {\n    return target;\n  }\n\n  if (!target || target === MH.getWindow()) {\n    return fetchViewportOverlay();\n  }\n\n  if (target === MH.getDoc()) {\n    return MH.getDocElement();\n  }\n\n  throw MH.usageError(\"Unsupported resize target\");\n};\n\nconst invokeCallback = (\n  callback: OnResizeCallback,\n  element: Element,\n  sizeData: SizeData,\n) => callback.invoke(element, MH.copyObject(sizeData)).catch(logError);\n"],"mappings":"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","ignoreList":[]}