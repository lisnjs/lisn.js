{"version":3,"file":"scroll-watcher.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_cssAlter","_directions","_domAlter","_domOptimize","_event","_log","_math","_scroll","_text","_validation","_callback","_xMap","_domWatcher","_sizeWatcher","_debug","_interopRequireDefault","e","__esModule","default","_getRequireWildcardCache","WeakMap","r","t","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","ScrollWatcher","fetchMainContentElement","fetchMainScrollableElement","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","objToStrKey","instance","instances","constructor","key","illegalConstructorError","logger","debug","Logger","name","logAtCreation","allScrollData","newWeakMap","activeListeners","allCallbacks","newXWeakMap","newMap","fetchCurrentScroll","element","realtime","isScrollEvent","previousEventData","latestData","fetchScrollData","direction","createCallback","handler","options","trackType","_allCallbacks$get","_element","remove","debug5","callback","wrapCallback","_debounceWindow","onRemove","deleteHandler","entry","_trackType","_options","sGet","setupOnScroll","userOptions","fetchOnScrollOptions","eventTarget","_eventTarget","scrollData","isRemoved","_data","TRACK_FULL","setupSizeTrack","listenerOptions","debug4","_nRealtime","addEventListenerTo","S_SCROLL","scrollHandler","directions","skipInitial","directionMatches","invokeCallback","removeOnScroll","scrollable","_allCallbacks$get2","currEntry","setScrollCssProps","deleteKey","prune","removeEventListenerFrom","scrollCallback","debug8","doc","getDoc","docScrollingElement","getDocScrollingElement","resizeCallback","thresholdsExceeded","hasExceededThreshold","debug9","sizeWatcher","SizeWatcher","setupOnResize","target","onResize","S_DEBOUNCE_WINDOW","threshold","_threshold","observedElements","newSet","allowedToWrap","settings","contentWrappingAllowed","getData","PREFIX_NO_WRAP","wrapper","wrapScrollingContent","add","child","childrenOf","domWatcher","DOMWatcher","root","subtree","onAddedCallback","operation","currentTargetOf","moveElement","to","ignoreMove","onMutation","categories","S_ADDED","event","_activeListeners$get","targetOf","isElement","isDoc","fetchScrollableElement","_allCallbacks$get3","values","then","scroll","_options$amount","isValidScrollDirection","usageError","isVertical","S_UP","S_DOWN","sign","S_LEFT","targetCoordinate","amount","asFractionOf","el","S_SCROLL_TOP","getClientHeightNow","S_SCROLL_LEFT","getClientWidthNow","S_SCROLL_HEIGHT","S_SCROLL_WIDTH","undefined","top","left","scrollTo","merge","duration","_scrollDuration","fetchCurrentScrollAction","getCurrentScrollAction","stopUserScrolling","stopScroll","elScrollTo","immediate","waitForMeasureTime","trackScroll","noTrackScroll","onScroll","TRACK_REGULAR","offScroll","exports","SYMBOL","toNonNegNum","_scrollThreshold","scrollThreshold","scrollDuration","_options$MC$S_DEBOUNC","validateStrList","getEventTarget","userDirections","latestDirection","includes","lastThresholdData","topDiff","maxAbs","S_CLIENT_HEIGHT","leftDiff","S_CLIENT_WIDTH","checkTop","checkLeft","S_NONE","S_AMBIGUOUS","S_RIGHT","scrollTop","ceil","scrollLeft","scrollWidth","scrollHeight","clientWidth","clientHeight","scrollTopFraction","round","INFINITY","scrollLeftFraction","prevScrollTop","prevScrollLeft","getMaxDeltaDirection","S_SCROLL_TOP_FRACTION","S_SCROLL_LEFT_FRACTION","prefix","tryGetMainScrollableElement","getDocElement","props","setNumericStyleProps","_prefix","invoke","copyObject","catch","logError"],"sources":["../../../src/ts/watchers/scroll-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/ScrollWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { XYDirection, ScrollDirection, SizeTarget } from \"@lisn/globals/types\";\n\nimport {\n  ScrollTarget,\n  TargetCoordinate,\n  TargetCoordinates,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { getData, setNumericStyleProps } from \"@lisn/utils/css-alter\";\nimport { getMaxDeltaDirection } from \"@lisn/utils/directions\";\nimport { moveElement, wrapScrollingContent } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum, maxAbs } from \"@lisn/utils/math\";\nimport {\n  scrollTo,\n  getCurrentScrollAction,\n  getClientWidthNow,\n  getClientHeightNow,\n  tryGetMainScrollableElement,\n  fetchMainContentElement,\n  fetchMainScrollableElement,\n  fetchScrollableElement,\n  isValidScrollDirection,\n  ScrollAction,\n  ScrollToOptions,\n} from \"@lisn/utils/scroll\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { MutationOperation, DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n// re-export for convenience\nexport type { ScrollAction, ScrollToOptions } from \"@lisn/utils/scroll\";\n\n/**\n * {@link ScrollWatcher} listens for scroll events in any direction.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class ScrollWatcher {\n  /**\n   * Call the given handler whenever the given scrollable is scrolled.\n   *\n   * Unless {@link OnScrollOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest scroll data. If a scroll has\n   * not yet been observed on the scrollable and its `scrollTop` and\n   * `scrollLeft` are 0, then the direction is {@link Types.NoDirection} and\n   * the handler is only called if {@link Types.NoDirection} is part of the\n   * supplied {@link OnScrollOptions.directions | options.directions} (or\n   * {@link OnScrollOptions.directions | options.directions} is not given).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking content size changes using\n   * {@link trackScroll}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onScroll: (\n    handler: OnScrollHandler,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly offScroll: (\n    handler: OnScrollHandler,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * This everything that {@link onScroll} does plus more:\n   *\n   * In addition to a scroll event, the handler is also called when either the\n   * offset size or scroll (content) size of the scrollable changes as that\n   * would affect its `scrollTopFraction` and `scrollLeftFraction` and possibly\n   * the `scrollTop` and `scrollLeft` as well.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates a set of CSS variables on the scrollable element's style:\n   *\n   * - If {@link OnScrollOptions.scrollable | options.scrollable} is not given,\n   *   or is `null`, `window` or `document`, the following CSS variables are\n   *   set on the root (`html`) element and represent the scroll of the\n   *   {@link fetchMainScrollableElement}:\n   *   - `--lisn-js--page-scroll-top`\n   *   - `--lisn-js--page-scroll-top-fraction`\n   *   - `--lisn-js--page-scroll-left`\n   *   - `--lisn-js--page-scroll-left-fraction`\n   *   - `--lisn-js--page-scroll-width`\n   *   - `--lisn-js--page-scroll-height`\n   *\n   * - Otherwise, the following variables are set on the scrollable itself,\n   *   and represent its scroll offset:\n   *   - `--lisn-js--scroll-top`\n   *   - `--lisn-js--scroll-top-fraction`\n   *   - `--lisn-js--scroll-left`\n   *   - `--lisn-js--scroll-left-fraction`\n   *   - `--lisn-js--scroll-width`\n   *   - `--lisn-js--scroll-height`\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackScroll: (\n    handler?: OnScrollHandler | null,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackScroll}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly noTrackScroll: (\n    handler?: OnScrollHandler | null,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * Get the scroll offset of the given scrollable. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param {} realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                    this only when doing realtime scroll-based animations\n   *                    as it may cause a forced layout.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScroll: (\n    scrollable?: ScrollTarget,\n    realtime?: boolean,\n  ) => Promise<ScrollData>;\n\n  /**\n   * Scrolls the given scrollable element to in the given direction.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the direction or options are invalid.\n   */\n  readonly scroll: (\n    direction: XYDirection,\n    options?: ScrollOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Scrolls the given scrollable element to the given `to` scrollable.\n   *\n   * Returns `null` if there's an ongoing scroll that is not cancellable.\n   *\n   * Note that if `to` is an element or a selector, then it _must_ be a\n   * descendant of the scrollable element.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the \"to\" coordinates or options are invalid.\n   *\n   * @param {} to  If this is an element, then its top-left position is used as\n   *               the target coordinates. If it is a string, then it is treated\n   *               as a selector for an element using `querySelector`.\n   * @param {} [options.scrollable]\n   *               If not given, it defaults to {@link fetchMainScrollableElement}\n   *\n   * @return {} `null` if there's an ongoing scroll that is not cancellable,\n   * otherwise a {@link ScrollAction}.\n   */\n  readonly scrollTo: (\n    to: TargetCoordinates | Element | string,\n    options?: ScrollToOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Returns the current {@link ScrollAction} if any.\n   *\n   * @param {} scrollable\n   *               If not given, it defaults to {@link fetchMainScrollableElement}\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScrollAction: (\n    scrollable?: Element,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Cancels the ongoing scroll that's resulting from smooth scrolling\n   * triggered in the past. Does not interrupt or prevent further scrolling.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   *\n   * @param {} [options.immediate]  If true, then it will not use\n   *                                {@link waitForMeasureTime} or\n   *                                {@link Utils.waitForMutateTime | waitForMutateTime}.\n   *                                Warning: this will likely result in forced layout.\n   */\n  readonly stopUserScrolling: (options?: {\n    scrollable?: ScrollTarget;\n    immediate?: boolean;\n  }) => Promise<void>;\n\n  /**\n   * Returns the element that holds the main page content. By default it's\n   * `document.body` but is overridden by\n   * {@link settings.mainScrollableElementSelector}.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainContentElement(): Promise<HTMLElement> {\n    return fetchMainContentElement();\n  }\n\n  /**\n   * Returns the scrollable element that holds the wrapper around the main page\n   * content. By default it's `document.scrollable` (unless `document.body` is\n   * actually scrollable, in which case it will be used) but it will be\n   * different if {@link settings.mainScrollableElementSelector} is set.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainScrollableElement(): Promise<HTMLElement> {\n    return fetchMainScrollableElement();\n  }\n\n  /**\n   * Creates a new instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ScrollWatcherConfig = {}) {\n    return new ScrollWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ScrollWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new ScrollWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ScrollWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ScrollWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ScrollWatcher\", logAtCreation: config })\n      : null;\n\n    const allScrollData = MH.newWeakMap<Element, ScrollData>();\n\n    const activeListeners = MH.newWeakMap<\n      ScrollTarget,\n      { _nRealtime: number }\n    >();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnScrollHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const fetchCurrentScroll = async (\n      element: Element,\n      realtime = false,\n      isScrollEvent = false,\n    ): Promise<ScrollData> => {\n      // The scroll data can change event without a scroll event, e.g. by the\n      // element changing size, so always get the latest here.\n      const previousEventData = allScrollData.get(element);\n      const latestData = await fetchScrollData(\n        element,\n        previousEventData,\n        realtime,\n      );\n\n      // If there hasn't been a scroll event, use the old scroll direction\n      if (!isScrollEvent && previousEventData) {\n        latestData.direction = previousEventData.direction;\n      }\n      return latestData;\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n      trackType: TrackType,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      };\n      allCallbacks.sGet(element).set(handler, entry);\n\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnScroll = async (\n      handler: OnScrollHandler,\n      userOptions: OnScrollOptions | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, userOptions || {});\n      const element = options._element;\n\n      // Don't await for the scroll data before creating the callback so that\n      // setupOnScroll and removeOnScroll have the same \"timing\" and therefore\n      // calling onScroll and offScroll immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options, trackType);\n      const callback = entry._callback;\n\n      const eventTarget = options._eventTarget;\n      const scrollData = await fetchCurrentScroll(\n        element,\n        options._debounceWindow === 0,\n      );\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = scrollData;\n      allScrollData.set(element, scrollData);\n\n      if (trackType === TRACK_FULL) {\n        await setupSizeTrack(entry);\n      }\n\n      let listenerOptions = activeListeners.get(eventTarget);\n      if (!listenerOptions) {\n        debug: logger?.debug4(\"Adding scroll listener\", eventTarget);\n        listenerOptions = { _nRealtime: 0 };\n        activeListeners.set(eventTarget, listenerOptions);\n        // Don't debounce the scroll handler, only the callbacks.\n        addEventListenerTo(eventTarget, MC.S_SCROLL, scrollHandler);\n      }\n\n      if (options._debounceWindow === 0) {\n        listenerOptions._nRealtime++;\n      }\n\n      const directions = options._directions;\n      if (\n        !callback.isRemoved() &&\n        !userOptions?.skipInitial &&\n        directionMatches(directions, scrollData.direction)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", element, scrollData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, scrollData);\n      }\n    };\n\n    // ----------\n\n    const removeOnScroll = async (\n      handler: OnScrollHandler,\n      scrollable: ScrollTarget | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, { scrollable });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setScrollCssProps) {\n          // delete the properties\n          setScrollCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n    ) => {\n      const element = options._element;\n      const eventTarget = options._eventTarget;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      const listenerOptions = activeListeners.get(eventTarget);\n      if (listenerOptions && options._debounceWindow === 0) {\n        listenerOptions._nRealtime--;\n      }\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for scrollable; removing listener\",\n          element,\n        );\n\n        MH.deleteKey(allScrollData, element);\n        removeEventListenerFrom(eventTarget, MC.S_SCROLL, scrollHandler);\n        MH.deleteKey(activeListeners, eventTarget);\n      }\n    };\n\n    // ----------\n\n    const setupSizeTrack = async (entry: CallbackEntry) => {\n      const options = entry._options;\n      const element = options._element;\n      const scrollCallback = entry._callback;\n      debug: logger?.debug8(\"Setting up size tracking\", element);\n\n      const doc = MH.getDoc();\n      const docScrollingElement = MH.getDocScrollingElement();\n\n      const resizeCallback = wrapCallback(async () => {\n        // Get the latest scroll data for the scrollable\n        // Currently, the resize callback is already delayed by a frame due to\n        // the SizeWatcher, so we don't need to treat this as realtime.\n        const latestData = await fetchCurrentScroll(element);\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n        } else if (!scrollCallback.isRemoved()) {\n          await invokeCallback(scrollCallback, element, latestData);\n        }\n      });\n\n      scrollCallback.onRemove(resizeCallback.remove);\n\n      // Don't use default instance as it has a high threshold.\n      const sizeWatcher = SizeWatcher.reuse();\n      const setupOnResize = (target?: SizeTarget) =>\n        sizeWatcher.onResize(resizeCallback, {\n          target,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          // TODO maybe accepts resizeThreshold option\n          threshold: options._threshold,\n        });\n\n      if (element === docScrollingElement) {\n        // In case we're tracking the main document scroll, then we only need to\n        // observe the viewport size and the size of the documentElement (which is\n        // the content size).\n\n        setupOnResize(); // viewport size\n        setupOnResize(doc); // content size\n\n        return;\n      }\n\n      // ResizeObserver only detects changes in offset width/height which is\n      // the visible size of the scrolling element, and that is not affected by the\n      // size of its content.\n      // But we also need to detect changes in the scroll width/height which is\n      // the size of the content.\n      // We also need to keep track of elements being added to the scrollable element.\n\n      const observedElements = MH.newSet<Element>([element]);\n\n      // Observe the scrolling element\n      setupOnResize(element);\n\n      // And also its children (if possible, single wrapper around children\n      const allowedToWrap =\n        settings.contentWrappingAllowed === true &&\n        element !== docScrollingElement &&\n        getData(element, MC.PREFIX_NO_WRAP) === null;\n\n      let wrapper: Element;\n      if (allowedToWrap) {\n        // Wrap the content and observe the wrapper\n        wrapper = await wrapScrollingContent(element);\n        setupOnResize(wrapper);\n        observedElements.add(wrapper);\n\n        //\n      } else {\n        for (const child of MH.childrenOf(element)) {\n          setupOnResize(child);\n          observedElements.add(child);\n        }\n      }\n\n      // Watch for newly added elements\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      const onAddedCallback = wrapCallback((operation: MutationOperation) => {\n        const child = MH.currentTargetOf(operation);\n        // If we've just added the wrapper, it will be in DOMWatcher's queue,\n        // so check.\n        if (child !== wrapper) {\n          if (allowedToWrap) {\n            // Move this child into the wrapper. If this results in change of size\n            // for wrapper, SizeWatcher will call us.\n            moveElement(child, { to: wrapper, ignoreMove: true });\n          } else {\n            // Track the size of this child.\n            // Don't skip initial, call the callback now\n            setupOnResize(child);\n            observedElements.add(child);\n          }\n        }\n      });\n\n      domWatcher.onMutation(onAddedCallback, { categories: [MC.S_ADDED] });\n      resizeCallback.onRemove(onAddedCallback.remove);\n    };\n\n    // ----------\n\n    const scrollHandler = async (event: Event) => {\n      // We cannot use event.currentTarget because scrollHandler is called inside\n      // a setTimeout so by that time, currentTarget is null or something else.\n      //\n      // However, target and currentTarget only differ when the event is in the\n      // bubbling or capturing phase. Because\n      //\n      // - the scroll event only bubbles when fired on document, and (it only\n      //   bubbles up to window)\n      // - and we never attach the listener to the capturing phase\n      // - and we always use document instead of window to listen for scroll on\n      //   document\n      //\n      // then event.target suffices.\n      const scrollable = MH.targetOf(event);\n      /* istanbul ignore next */\n      if (!scrollable || !(MH.isElement(scrollable) || MH.isDoc(scrollable))) {\n        return;\n      }\n\n      const element = await fetchScrollableElement(scrollable);\n      const realtime = (activeListeners.get(scrollable)?._nRealtime || 0) > 0;\n      const latestData = await fetchCurrentScroll(element, realtime, true);\n      allScrollData.set(element, latestData);\n\n      debug: logger?.debug9(\"Scroll event\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        // Consider the direction since the last scroll event and not the\n        // direction based on the largest delta the last time the callback\n        // was called.\n        const options = entry._options;\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n          continue;\n        }\n\n        // If threshold has been exceeded, always update the latest data for\n        // this callback.\n        entry._data = latestData;\n\n        if (!directionMatches(options._directions, latestData.direction)) {\n          debug: logger?.debug9(\n            \"Direction does not match\",\n            options,\n            latestData,\n          );\n          continue;\n        }\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentScroll = (scrollable?, realtime?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        fetchCurrentScroll(element, realtime),\n      );\n\n    // ----------\n\n    this.scroll = (direction, options = {}) => {\n      if (!isValidScrollDirection(direction)) {\n        throw MH.usageError(`Unknown scroll direction: '${direction}'`);\n      }\n\n      const isVertical = direction === MC.S_UP || direction === MC.S_DOWN;\n      const sign = direction === MC.S_UP || direction === MC.S_LEFT ? -1 : 1;\n      let targetCoordinate: TargetCoordinate;\n\n      const amount = options.amount ?? 100;\n      const asFractionOf = options.asFractionOf;\n\n      if (asFractionOf === \"visible\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * getClientHeightNow(el)) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * getClientWidthNow(el)) / 100;\n\n        //\n      } else if (asFractionOf === \"content\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * el[MC.S_SCROLL_HEIGHT]) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * el[MC.S_SCROLL_WIDTH]) / 100;\n\n        //\n      } else if (asFractionOf !== undefined && asFractionOf !== \"pixel\") {\n        throw MH.usageError(\n          `Unknown 'asFractionOf' keyword: '${asFractionOf}'`,\n        );\n\n        //\n      } else {\n        targetCoordinate = isVertical\n          ? (el) => el[MC.S_SCROLL_TOP] + sign * amount\n          : (el) => el[MC.S_SCROLL_LEFT] + sign * amount;\n      }\n\n      const target = isVertical\n        ? { top: targetCoordinate }\n        : { left: targetCoordinate };\n\n      return this.scrollTo(target, options);\n    };\n\n    // ----------\n\n    this.scrollTo = async (to, options = {}) =>\n      scrollTo(\n        to,\n        MH.merge(\n          { duration: config._scrollDuration }, // default\n          options,\n          {\n            scrollable: await fetchScrollableElement(options.scrollable),\n          }, // override\n        ),\n      );\n\n    // ----------\n\n    this.fetchCurrentScrollAction = (scrollable?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        getCurrentScrollAction(element),\n      );\n\n    // ----------\n\n    this.stopUserScrolling = async (options = {}) => {\n      const element = await fetchScrollableElement(options.scrollable);\n      const stopScroll = () =>\n        MH.elScrollTo(element, {\n          top: element[MC.S_SCROLL_TOP],\n          left: element[MC.S_SCROLL_LEFT],\n        });\n\n      if (options.immediate) {\n        stopScroll();\n      } else {\n        waitForMeasureTime().then(stopScroll);\n      }\n    };\n\n    // ----------\n\n    this.trackScroll = (handler?, options?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      return setupOnScroll(handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackScroll = (handler?, scrollable?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      removeOnScroll(handler, scrollable, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onScroll = (handler, options?) =>\n      setupOnScroll(handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offScroll = (handler, scrollable?) => {\n      removeOnScroll(handler, scrollable, TRACK_REGULAR); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type ScrollWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnScrollOptions.debounceWindow | debounceWindow} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnScrollOptions.threshold | threshold} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 50\n   */\n  scrollThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link ScrollOptions.duration | duration} in calls to\n   * {@link ScrollWatcher.scroll} and {@link ScrollWatcher.scrollTo}.\n   *\n   * @defaultValue 1000\n   */\n  scrollDuration?: number;\n};\n\n/**\n * @interface\n */\nexport type OnScrollOptions = {\n  /**\n   * If it is not given, or is `null`, `window` or `document`, then it will\n   * track the scroll of the {@link ScrollWatcher.fetchMainScrollableElement}.\n   *\n   * Other values must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  scrollable?: ScrollTarget;\n\n  /**\n   * If non-0, the scroll handler will only be called when the scrollable's\n   * scroll offset in the observed direction has changed at least\n   * `scrollThreshold` pixels since the last time the handler was called.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.scrollThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Specifies a list of {@link ScrollDirection}s to listen for.\n   *\n   * It can be a comma-separated list of direction names or an array of such\n   * names.\n   *\n   * If not given, then it listens for scrolls in any direction, including\n   * {@link Types.NoDirection} and {@link Types.AmbiguousDirection}.\n   *\n   * The {@link Types.NoDirection} occurs when the callback is called initially\n   * (if `skipInitial` is not `true`) and there hasn't yet been a scroll\n   * observed on the scrollable _and_ it's `scrollTop`/`scrollLeft` are 0.\n   *\n   * The {@link Types.AmbiguousDirection} occurs when the user scrolls\n   * diagonally with close to equal deltas in both horizontal and vertical\n   * direction.\n   *\n   * **IMPORTANT:**\n   *\n   * The direction of a scroll event is always based on comparing `deltaX` and\n   * `deltaY` relative to the _last scroll event_ (within the `debounceWindow`,\n   * and not to the scroll data for the last time the callback was called (in\n   * case it was skipped because `threshold` was not exceeded or in case it was\n   * debounced by a larger window than the watcher).\n   *\n   * I.e. if you have both `threshold` and `directions` restricted, or if the\n   * callback has a larger debounce window than the watcher, it is possible for\n   * there to be a change in the relevant `scrollTop`/`scrollLeft` offset that\n   * exceeds the threshold, and for the callback to _not_ be called.\n   *\n   * For a callback to be called, both of these must be true:\n   * - the change in `scrollTop`/`scrollLeft`, _compared to the last time the\n   *   callback was called_ must exceed the {@link threshold}\n   * - the effective scroll direction, _compared to the last scroll event_\n   *   prior to the _watcher's_ debounce window must be one of the given\n   *   {@link directions}.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<ScrollDirection> | ScrollDirection[];\n\n  /**\n   * Do not call the handler until there's a future scroll of the element.\n   *\n   * By default we call the handler (almost) immediately if there's been a\n   * scroll in one of the given directions, or if there has not been a scroll\n   * but directions includes {@link Types.NoDirection}, but you can disable\n   * this initial call here.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts, but you probably need this when doing\n   * scroll-based animations.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * @interface\n */\nexport type ScrollOptions = ScrollToOptions & {\n  /**\n   * How much to scroll in the given direction.\n   *\n   * @defaultValue 100\n   */\n  amount?: number;\n\n  /**\n   * If set to \"pixel\" (default), `amount` is taken as absolute pixels.\n   *\n   * If set to \"visible\", `amount` is taken as percent of the element's visible\n   * size in the scrolling direction (100 means full client width for\n   * horizontal or height for vertical scroll).\n   *\n   * If set to \"content\", `amount` is taken as percent of the element's full\n   * content size in the scrolling direction (100 means full scroll width for\n   * horizontal or height for vertical scroll).\n   *\n   * @defaultValue \"pixel\"\n   */\n  asFractionOf?: \"pixel\" | \"visible\" | \"content\";\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the element that has been resized\n * - the {@link ScrollData} for the element\n */\nexport type OnScrollHandlerArgs = [Element, ScrollData];\nexport type OnScrollCallback = Callback<OnScrollHandlerArgs>;\nexport type OnScrollHandler =\n  | CallbackHandler<OnScrollHandlerArgs>\n  | OnScrollCallback;\n\nexport type ScrollData = {\n  clientWidth: number;\n  clientHeight: number;\n\n  scrollTop: number;\n\n  /**\n   * This is the `scrollTop` relative to the full `scrollHeight` minus the\n   * `clientHeight`, ranging from 0 to 1.\n   */\n  scrollTopFraction: number;\n\n  scrollLeft: number;\n\n  /**\n   * This is the `scrollLeft` relative to the full `scrollWidth` minus the\n   * `clientWidth`, ranging from 0 to 1.\n   */\n  scrollLeftFraction: number;\n\n  scrollWidth: number;\n  scrollHeight: number;\n\n  /**\n   * This is the direction of the last scroll action, i.e. _compared to the\n   * last scroll event_, not necessarily based on the deltas compared to the\n   * last time this callback was called.\n   */\n  direction: ScrollDirection;\n};\n\n// ----------------------------------------\n\ntype ScrollWatcherConfigInternal = {\n  _debounceWindow: number;\n  _scrollThreshold: number;\n  _scrollDuration: number;\n};\n\ntype OnScrollOptionsInternal = {\n  _element: Element;\n  _eventTarget: ScrollTarget;\n  _directions: ScrollDirection[] | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnScrollCallback;\n  _trackType: TrackType;\n  _options: OnScrollOptionsInternal;\n  _data?: ScrollData;\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, ScrollWatcher>();\n\nconst getConfig = (\n  config: ScrollWatcherConfig,\n): ScrollWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _scrollThreshold: toNonNegNum(config.scrollThreshold, 50) || 1,\n    _scrollDuration: toNonNegNum(config.scrollDuration, 1000),\n  };\n};\n\nconst TRACK_REGULAR = 1; // only scroll events\nconst TRACK_FULL = 2; // scroll + resizing of content and/or wrapper\n\n// --------------------\n\nconst fetchOnScrollOptions = async (\n  config: ScrollWatcherConfigInternal,\n  options: OnScrollOptions,\n): Promise<OnScrollOptionsInternal> => {\n  const directions =\n    validateStrList(\"directions\", options.directions, isValidScrollDirection) ||\n    null;\n\n  const element = await fetchScrollableElement(options.scrollable);\n\n  return {\n    _element: element,\n    _eventTarget: getEventTarget(element),\n    _directions: directions,\n    // If threshold is 0, internally treat as 1 (pixel)\n    _threshold: toNonNegNum(options.threshold, config._scrollThreshold) || 1,\n    _debounceWindow: options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n  };\n};\n\nconst directionMatches = (\n  userDirections: ScrollDirection[] | null,\n  latestDirection: ScrollDirection,\n) => !userDirections || MH.includes(userDirections, latestDirection);\n\nconst hasExceededThreshold = (\n  options: OnScrollOptionsInternal,\n  latestData: ScrollData,\n  lastThresholdData: ScrollData | undefined,\n): boolean => {\n  const directions = options._directions;\n  const threshold = options._threshold;\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  const topDiff = maxAbs(\n    latestData[MC.S_SCROLL_TOP] - lastThresholdData[MC.S_SCROLL_TOP],\n    latestData[MC.S_SCROLL_HEIGHT] - lastThresholdData[MC.S_SCROLL_HEIGHT],\n    latestData[MC.S_CLIENT_HEIGHT] - lastThresholdData[MC.S_CLIENT_HEIGHT],\n  );\n\n  const leftDiff = maxAbs(\n    latestData[MC.S_SCROLL_LEFT] - lastThresholdData[MC.S_SCROLL_LEFT],\n    latestData[MC.S_SCROLL_WIDTH] - lastThresholdData[MC.S_SCROLL_WIDTH],\n    latestData[MC.S_CLIENT_WIDTH] - lastThresholdData[MC.S_CLIENT_WIDTH],\n  );\n\n  // If the callback is only interested in up/down, then only check the\n  // scrollTop delta, and similarly for left/right.\n  let checkTop = false,\n    checkLeft = false;\n  if (\n    !directions ||\n    MH.includes(directions, MC.S_NONE) ||\n    MH.includes(directions, MC.S_AMBIGUOUS)\n  ) {\n    checkTop = checkLeft = true;\n  } else {\n    if (\n      MH.includes(directions, MC.S_UP) ||\n      MH.includes(directions, MC.S_DOWN)\n    ) {\n      checkTop = true;\n    }\n    if (\n      MH.includes(directions, MC.S_LEFT) ||\n      MH.includes(directions, MC.S_RIGHT)\n    ) {\n      checkLeft = true;\n    }\n  }\n\n  return (\n    (checkTop && topDiff >= threshold) || (checkLeft && leftDiff >= threshold)\n  );\n};\n\nconst fetchScrollData = async (\n  element: Element,\n  previousEventData: ScrollData | undefined,\n  realtime: boolean,\n): Promise<ScrollData> => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollTop = MH.ceil(element[MC.S_SCROLL_TOP]);\n  const scrollLeft = MH.ceil(element[MC.S_SCROLL_LEFT]);\n  const scrollWidth = element[MC.S_SCROLL_WIDTH];\n  const scrollHeight = element[MC.S_SCROLL_HEIGHT];\n  const clientWidth = getClientWidthNow(element);\n  const clientHeight = getClientHeightNow(element);\n\n  const scrollTopFraction =\n    MH.round(scrollTop) / (scrollHeight - clientHeight || MC.INFINITY);\n  const scrollLeftFraction =\n    MH.round(scrollLeft) / (scrollWidth - clientWidth || MC.INFINITY);\n\n  const prevScrollTop = previousEventData?.scrollTop || 0;\n  const prevScrollLeft = previousEventData?.scrollLeft || 0;\n\n  const direction = getMaxDeltaDirection(\n    scrollLeft - prevScrollLeft,\n    scrollTop - prevScrollTop,\n  );\n\n  return {\n    direction,\n    [MC.S_SCROLL_TOP]: scrollTop,\n    [MC.S_SCROLL_TOP_FRACTION]: scrollTopFraction,\n    [MC.S_SCROLL_LEFT]: scrollLeft,\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollLeftFraction,\n    [MC.S_SCROLL_WIDTH]: scrollWidth,\n    [MC.S_SCROLL_HEIGHT]: scrollHeight,\n    [MC.S_CLIENT_WIDTH]: clientWidth,\n    [MC.S_CLIENT_HEIGHT]: clientHeight,\n  };\n};\n\nconst setScrollCssProps = (\n  element: Element,\n  scrollData: Partial<ScrollData> | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetMainScrollableElement()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"page-\";\n  }\n\n  scrollData = scrollData || {};\n  const props = {\n    [MC.S_SCROLL_TOP]: scrollData[MC.S_SCROLL_TOP],\n    [MC.S_SCROLL_TOP_FRACTION]: scrollData[MC.S_SCROLL_TOP_FRACTION],\n    [MC.S_SCROLL_LEFT]: scrollData[MC.S_SCROLL_LEFT],\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollData[MC.S_SCROLL_LEFT_FRACTION],\n    [MC.S_SCROLL_WIDTH]: scrollData[MC.S_SCROLL_WIDTH],\n    [MC.S_SCROLL_HEIGHT]: scrollData[MC.S_SCROLL_HEIGHT],\n  };\n  setNumericStyleProps(element, props, { _prefix: prefix });\n};\n\nconst getEventTarget = (element: Element): ScrollTarget => {\n  if (element === MH.getDocScrollingElement()) {\n    return MH.getDoc();\n  }\n\n  return element;\n};\n\nconst invokeCallback = (\n  callback: OnScrollCallback,\n  element: Element,\n  scrollData: ScrollData,\n) => callback.invoke(element, MH.copyObject(scrollData)).catch(logError);\n"],"mappings":"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rC;;EAEA;AACF;AACA;AACA;EACE,OAAOC,MAAMA,CAACC,MAA2B,GAAG,CAAC,CAAC,EAAE;IAC9C,OAAO,IAAIJ,aAAa,CAACK,SAAS,CAACD,MAAM,CAAC,EAAEE,eAAe,CAAC;EAC9D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAKA,CAACH,MAA2B,GAAG,CAAC,CAAC,EAAE;IAC7C,MAAMI,QAAQ,GAAGH,SAAS,CAACD,MAAM,CAAC;IAClC,MAAMK,YAAY,GAAG,IAAAC,iBAAW,EAACF,QAAQ,CAAC;IAE1C,IAAIG,QAAQ,GAAGC,SAAS,CAACpC,GAAG,CAACiC,YAAY,CAAC;IAC1C,IAAI,CAACE,QAAQ,EAAE;MACbA,QAAQ,GAAG,IAAIX,aAAa,CAACQ,QAAQ,EAAEF,eAAe,CAAC;MACvDM,SAAS,CAACzB,GAAG,CAACsB,YAAY,EAAEE,QAAQ,CAAC;IACvC;IAEA,OAAOA,QAAQ;EACjB;EAEQE,WAAWA,CACjBT,MAAmC,EACnCU,GAA2B,EAC3B;IAvOF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApBE1B,eAAA;IA0BA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAzCEA,eAAA;IA+CA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAVEA,eAAA;IAgBA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]}