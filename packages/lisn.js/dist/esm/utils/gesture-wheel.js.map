{"version":3,"file":"gesture-wheel.js","names":["MC","MH","getVectorDirection","havingMaxAbs","normalizeWheel","addDeltaZ","getWheelGestureFragment","events","options","isIterableObject","direction","S_NONE","intent","deltaX","deltaY","deltaZ","_iterator","_createForOfIteratorHelper","_step","s","n","done","event","value","isWheelEvent","type","S_WHEEL","data","thisIntent","S_SCROLL","thisDeltaX","pixelX","thisDeltaY","pixelY","thisDeltaZ","maxDelta","ctrlKey","percentage","abs","S_ZOOM","shiftKey","S_UNKNOWN","err","e","f","S_AMBIGUOUS","S_IN","S_OUT","angleDiffThreshold","device"],"sources":["../../../src/ts/utils/gesture-wheel.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureIntent } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport { havingMaxAbs } from \"@lisn/utils/math\";\nimport { normalizeWheel } from \"@lisn/utils/normalize-wheel\";\n\nimport { GestureFragment, addDeltaZ } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"wheel\" events\n * will be considered.\n *\n * If there are no \"wheel\" events in the given list of events, returns `false`.\n *\n * The deltas of all events are summed together before determining final delta\n * and direction.\n *\n * If the events are of conflicting types, i.e. some scroll, some zoom, then\n * the intent will be \"unknown\" and the direction will be \"ambiguous\".\n *\n * If the deltas sum up to 0, the direction will be \"none\".\n *\n * **IMPORTANT NOTES ON THE DELTA VALUES**\n *\n * For wheel gestures the deltas are _highly_ unreliable, especially when\n * zooming (Control + wheel or pinching trackpad). You should not assume they\n * correspond to the would-be scroll or zoom amount that the browser would do.\n * But they can be used to determine relative amounts for animating, etc.\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"line\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaLineHeight | settings.deltaLineHeight}).\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"page\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaPageWidth | settings.deltaPageWidth} and\n * ({@link Settings.settings.deltaPageHeight | settings.deltaPageHeight}).\n *\n * For zoom intents `deltaZ` is based on what the browser reports as the\n * `deltaY`, which in most browsers roughly corresponds to a percentage zoom\n * factor.\n *\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}.\n *                                        Default is 5.\n *\n * @return {} `false` if there are no \"wheel\" events in the list, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getWheelGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent | null = null;\n  let deltaX = 0,\n    deltaY = 0,\n    deltaZ = 1;\n\n  for (const event of events) {\n    if (!MH.isWheelEvent(event) || event.type !== MC.S_WHEEL) {\n      continue;\n    }\n\n    const data = normalizeWheel(event);\n    let thisIntent: GestureIntent = MC.S_SCROLL;\n    let thisDeltaX = data.pixelX;\n    let thisDeltaY = data.pixelY;\n    let thisDeltaZ = 1;\n    const maxDelta = havingMaxAbs(thisDeltaX, thisDeltaY);\n\n    if (event.ctrlKey && !thisDeltaX) {\n      // Browsers report negative deltaY for zoom in, so swap sign\n      let percentage = -maxDelta;\n      // If it's more than 50, assume it's a mouse wheel => delta is roughly\n      // multiple of 10%. Otherwise a trackpad => delta is roughly multiple of 1%\n      if (MH.abs(percentage) >= 50) {\n        percentage /= 10;\n      }\n\n      thisDeltaZ = 1 + percentage / 100;\n\n      thisDeltaX = thisDeltaY = 0;\n      thisIntent = MC.S_ZOOM;\n    } else if (event.shiftKey && !thisDeltaX) {\n      // Holding Shift while turning wheel or swiping trackpad in vertically\n      // results in sideways scroll.\n      thisDeltaX = thisDeltaY;\n      thisDeltaY = 0;\n    }\n\n    deltaX += thisDeltaX;\n    deltaY += thisDeltaY;\n    deltaZ = addDeltaZ(deltaZ, thisDeltaZ);\n\n    if (!thisIntent) {\n      // not a relevant key\n    } else if (!intent) {\n      intent = thisIntent;\n    } else if (intent !== thisIntent) {\n      // mixture of zoom and scroll\n      intent = MC.S_UNKNOWN;\n    }\n  }\n\n  if (!intent) {\n    return false; // no relevant events\n  } else if (intent === MC.S_UNKNOWN) {\n    direction = MC.S_AMBIGUOUS;\n  } else if (intent === MC.S_ZOOM) {\n    direction = deltaZ > 1 ? MC.S_IN : deltaZ < 1 ? MC.S_OUT : MC.S_NONE;\n  } else {\n    direction = getVectorDirection(\n      [deltaX, deltaY],\n      options?.angleDiffThreshold,\n    );\n  }\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_WHEEL,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n      };\n};\n"],"mappings":"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","ignoreList":[]}