{"version":3,"file":"layout-watcher.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_cssAlter","_layout","_log","_misc","_overlays","_text","_callback","_xMap","_sizeWatcher","_debug","_interopRequireDefault","e","__esModule","default","_getRequireWildcardCache","WeakMap","r","t","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","LayoutWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","_instances$get","myConfig","configStrKey","objToStrKey","omitKeys","_root","instance","instances","sGet","constructor","key","illegalConstructorError","logger","debug","Logger","name","logAtCreation","nonIntersectingBitmask","currentLayoutData","device","aspectRatio","allCallbacks","newMap","fetchCurrentLayout","readyPromise","copyObject","setupOverlays","root","overlays","createOverlays","_deviceBreakpoints","_aspectRatioBreakpoints","newPromise","resolve","isReady","intersectionHandler","entries","numEntries","lengthOf","debug9","NUM_LAYOUTS","logWarn","bugError","entry","getNonIntersecting","processLayoutChange","observeOptions","rootMargin","observer","newIntersectionObserver","triggerOverlay","observe","createCallback","handler","layoutBitmask","_allCallbacks$get","remove","debug5","callback","wrapCallback","onRemove","deleteHandler","_layoutBitmask","setupOnLayout","options","getLayoutBitmask","skipInitial","layoutData","isRemoved","changeMatches","invokeCallback","deleteKey","skipCallbacks","deviceBit","floor","log2","ORDERED_DEVICES","bitmask","aspectRatioBit","ORDERED_ASPECTR","INFINITY","nameOf","debug8","values","onLayout","offLayout","_allCallbacks$get2","exports","SYMBOL","newXMap","VAR_BORDER_HEIGHT","prefixCssJsVar","PREFIX_DEVICE","prefixName","PREFIX_ASPECTR","deviceBreakpoints","settings","copyExistingKeys","aspectRatioBreakpoints","overlayPromises","overlayParent","createOverlay","style","position","S_WIDTH","push","parent","data","parentHeightCss","SizeWatcher","trackSize","target","promiseAll","getOverlayLayout","overlay","layout","getData","logError","thisLayoutData","prevLayoutData","bit","targetOf","isHTMLElement","typeOrClassOf","isIntersecting","invoke","catch"],"sources":["../../../src/ts/watchers/layout-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/LayoutWatcher\n */\n\n// NOTES FOR DEVELOPERS\n//\n// For each layout (device or aspect ratio), we create an overlay that has a\n// a width that corresponds to the layout:\n//  - for device layouts, it's a fixed width in pixels, equal to the minimum\n//    width of the device\n//  - for aspect ratio layouts, the overlay has a width that's relative to\n//    the root's height, equal to the minimum width of the aspect ratio\n//\n// Then we observe each overlay with an IntersectionObserver whose root\n// is this Watcher's root and whose root margin is -100% from the left (i.e.\n// right-most edge of the root).\n//\n// If the root is null, i.e. the viewport, the overlays will have a \"fixed\"\n// position and be inserted in document.body. Otherwise, they'll be inserted\n// in the root element with an \"absolute\" position. The root element, if not\n// body must be positioned. It gets a default position of \"relative\" through\n// the class `.lisn-overlay-container`, which Overlays ensures it gets.\n//\n// If using custom root we track its size through SizeWatcher as the\n// aspectRatio overlays are relative to the height, and we can't rely on CSS\n// alone as the root may not have a fixed height through CSS.\n//\n// Whenever any overlay intersects the root, this means that the viewport\n// width is now equal to or narrower than the overlay.\n//\n// ~~~~ The current device or aspect ratio corresponds to the _widest_\n// ~~~~ overlay that does not intersect.\n//\n// For example:\n//\n// | mobile\n// ========| mobile-wide\n// ======================| tablet\n// =========================================| desktop\n//\n// _________________________________| viewport width\n//\n// Here, mobile, mobile-wide and tablet overlays are _not_ intersecting, only\n// desktop intersects. The device layout is therefore tablet.\n//\n// Therefore:\n// - have the layout bit spaces ordered from narrowest layout at lowest bit\n//   to widest layout at hightest bit\n// - keep a running bitmask of which overlays are not intersecting and update\n//   it each time there is an IntersectionObserverEntry.\n// - get the highest device or aspect ratio bit in that bitmask to find out\n//   the widest non-intersecting overlay\n//\n// For simplicity we create overlays also for layouts that have a 0-width.\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  Layout,\n  DeviceSpec,\n  Device,\n  AspectRatioSpec,\n  AspectRatio,\n} from \"@lisn/globals/types\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport {\n  getLayoutBitmask,\n  NUM_LAYOUTS,\n  ORDERED_DEVICES,\n  ORDERED_ASPECTR,\n} from \"@lisn/utils/layout\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { omitKeys, copyExistingKeys } from \"@lisn/utils/misc\";\nimport { createOverlay } from \"@lisn/utils/overlays\";\nimport { objToStrKey } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap } from \"@lisn/modules/x-map\";\n\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link LayoutWatcher} listens for changes in either the width or aspect\n * ratio of the viewport or the given {@link LayoutWatcherConfig.root | root}.\n *\n * It does not track resize events; rather it's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}.\n *\n * It manages registered callbacks globally and reuses IntersectionObservers\n * for more efficient performance.\n */\nexport class LayoutWatcher {\n  /**\n   * Call the given handler whenever the layout changes.\n   *\n   * Unless {@link OnLayoutOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the current layout.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times, even if\n   * the options differ. If the handler has already been added, it is removed\n   * and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onLayout: (\n    handler: OnLayoutHandler,\n    options?: OnLayoutOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offLayout: (handler: OnLayoutHandler) => void;\n\n  /**\n   * Get the current screen layout.\n   */\n  readonly fetchCurrentLayout: () => Promise<LayoutData>;\n\n  /**\n   * Creates a new instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: LayoutWatcherConfig = {}) {\n    return new LayoutWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: LayoutWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    let instance = instances.get(myConfig._root)?.get(configStrKey);\n    if (!instance) {\n      instance = new LayoutWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(myConfig._root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: LayoutWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"LayoutWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"LayoutWatcher\", logAtCreation: config })\n      : null;\n    let nonIntersectingBitmask = 0;\n    let currentLayoutData: LayoutData = {\n      device: null,\n      aspectRatio: null,\n    };\n\n    const allCallbacks = MH.newMap<\n      OnLayoutHandler,\n      {\n        _callback: OnLayoutCallback;\n        _layoutBitmask: number;\n      }\n    >();\n\n    // ----------\n\n    const fetchCurrentLayout = async (): Promise<LayoutData> => {\n      await readyPromise;\n\n      return MH.copyObject(currentLayoutData);\n    };\n\n    // ----------\n\n    const setupOverlays = async () => {\n      const { root, overlays } = await createOverlays(\n        config._root,\n        config._deviceBreakpoints,\n        config._aspectRatioBreakpoints,\n      );\n\n      return MH.newPromise<void>((resolve) => {\n        let isReady = false;\n\n        const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n          const numEntries = MH.lengthOf(entries);\n          debug: logger?.debug9(`Got ${numEntries} new entries`, entries);\n\n          if (!isReady) {\n            /* istanbul ignore next */ // shouldn't happen\n            if (numEntries < NUM_LAYOUTS) {\n              logWarn(\n                MH.bugError(\n                  `Got IntersectionObserver ${numEntries}, ` +\n                    `expected >= ${NUM_LAYOUTS}`,\n                ),\n              );\n            }\n          }\n\n          for (const entry of entries) {\n            nonIntersectingBitmask = getNonIntersecting(\n              nonIntersectingBitmask,\n              entry,\n            );\n          }\n\n          // If this is the initial call from IntersectionObserver, skip callbacks.\n          // Those that have skipInitial: false would be called elsewhere, by\n          // setupOnLayout\n          processLayoutChange(!isReady);\n          isReady = true;\n          resolve(); // ready after IntersectionObserver has called us the 1st time\n        };\n\n        // ----------\n\n        const observeOptions = {\n          root,\n          rootMargin: \"5px 0% 5px -100%\",\n        };\n\n        const observer = MH.newIntersectionObserver(\n          intersectionHandler,\n          observeOptions,\n        );\n\n        for (const triggerOverlay of overlays) {\n          observer.observe(triggerOverlay);\n        }\n      });\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnLayoutHandler,\n      layoutBitmask: number,\n    ): OnLayoutCallback => {\n      MH.remove(allCallbacks.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", layoutBitmask);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        deleteHandler(handler);\n      });\n\n      allCallbacks.set(handler, {\n        _callback: callback,\n        _layoutBitmask: layoutBitmask,\n      });\n      return callback;\n    };\n\n    const setupOnLayout = async (\n      handler: OnLayoutHandler,\n      options: OnLayoutOptions | undefined,\n    ) => {\n      const layoutBitmask = getLayoutBitmask(options);\n      const callback = createCallback(handler, layoutBitmask);\n\n      if (options?.skipInitial) {\n        return;\n      }\n\n      const layoutData = await fetchCurrentLayout();\n\n      if (\n        !callback.isRemoved() &&\n        changeMatches(layoutBitmask, layoutData, null)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", layoutData);\n        await invokeCallback(callback, layoutData);\n      }\n    };\n\n    const deleteHandler = (handler: OnLayoutHandler) => {\n      MH.deleteKey(allCallbacks, handler);\n      // no need to unobserve the overlays\n    };\n\n    const processLayoutChange = (skipCallbacks: boolean) => {\n      const deviceBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_DEVICES.bitmask),\n      );\n\n      const aspectRatioBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_ASPECTR.bitmask),\n      );\n\n      const layoutData: LayoutData = { device: null, aspectRatio: null };\n\n      // -Infinity means all of the overlays are intersecting, which would only\n      // happen if the narrowest overlay is not actually 0-width (which is not the\n      // case by default and against the recommended settings).\n      if (deviceBit !== -MC.INFINITY) {\n        layoutData.device = ORDERED_DEVICES.nameOf(1 << deviceBit);\n      }\n      if (aspectRatioBit !== -MC.INFINITY) {\n        layoutData.aspectRatio = ORDERED_ASPECTR.nameOf(1 << aspectRatioBit);\n      }\n\n      debug: logger?.debug8(\"New layout\", layoutData);\n\n      if (!skipCallbacks) {\n        for (const entry of allCallbacks.values()) {\n          const layoutBitmask = entry._layoutBitmask;\n          if (!changeMatches(layoutBitmask, layoutData, currentLayoutData)) {\n            debug: logger?.debug9(\n              `Layout change does not match bitmask ${layoutBitmask}`,\n            );\n            continue;\n          }\n\n          invokeCallback(entry._callback, layoutData);\n        }\n      }\n\n      currentLayoutData = layoutData;\n    };\n\n    const readyPromise = setupOverlays(); // no need to await\n\n    // ----------\n\n    this.fetchCurrentLayout = fetchCurrentLayout;\n\n    // ----------\n\n    this.onLayout = setupOnLayout;\n\n    // ----------\n\n    this.offLayout = (handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type LayoutWatcherConfig = {\n  /**\n   * The root element whose layout to watch. If not given or `null`, then the\n   * viewport layout is watched.\n   *\n   * @defaultValue null\n   */\n  root?: HTMLElement | null;\n\n  /**\n   * Use custom device breakpoints. Only known device names ({@link Device})\n   * are supported. If any are missing from the given dictionary, the value\n   * from {@link settings.deviceBreakpoints} is used.\n   *\n   * @defaultValue {@link settings.deviceBreakpoints}\n   */\n  deviceBreakpoints?: typeof settings.deviceBreakpoints;\n\n  /**\n   * Use custom aspect ratio breakpoints. Only known aspect ratio names\n   * ({@link AspectRatio}) are supported. If any are missing from the given\n   * dictionary, the value from {@link settings.aspectRatioBreakpoints} is\n   * used.\n   *\n   * @defaultValue {@link settings.aspectRatioBreakpoints}\n   */\n  aspectRatioBreakpoints?: typeof settings.aspectRatioBreakpoints;\n};\n\n/**\n * @interface\n */\nexport type OnLayoutOptions = {\n  /**\n   * Specifies a list of {@link Device}s to target for.\n   *\n   * The handler will only be called if there is a change of device to a device\n   * matching the specification.\n   *\n   * It can be:\n   * - \"min <Device>\": devices at least as wide as `<Device>`\n   * - \"max <Device>\": devices at most as wide as `<Device>`\n   * - \"<DeviceMin> to <DeviceMax>\": devices at least as wide as `<DeviceMin>`\n   *                                 and at most as wide as `<DeviceMax>`\n   * - a comma-separated list of device names\n   * - an array of device names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * Also note that an empty array is treated the same as not given, or `null`.\n   *\n   * @defaultValue undefined\n   */\n  devices?: DeviceSpec | Device[];\n\n  /**\n   * Specifies a list of {@link AspectRatio}s to target for.\n   *\n   * The handler will only be called if there is a change of aspect ratio to\n   * an aspect ratios matching the specification.\n   *\n   * It can be:\n   * - \"min <AspectRatio>\": aspect ratios at least as wide as `<AspectRatio>`\n   * - \"max <AspectRatio>\": aspect ratios at most as wide as `<AspectRatio>`\n   * - \"<AspectRatioMin> to <AspectRatioMax>\": aspect ratios at least as wide\n   *                        as `<AspectRatioMin>` and at most as wide as\n   *                        `<AspectRatioMax>`\n   * - a comma-separated list of aspect ratio names\n   * - an array of aspect ratio names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * @defaultValue undefined\n   */\n  aspectRatios?: AspectRatioSpec | AspectRatio[];\n\n  /**\n   * Do not call the handler until there's a future change of layout.\n   *\n   * By default, we call the handler (almost) immediately with the current\n   * layout data if it matches the given {@link devices} and {@link aspectRatios}.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * The handler is invoked with one argument:\n *\n * - the current {@link LayoutData}\n */\nexport type OnLayoutHandlerArgs = [LayoutData];\nexport type OnLayoutCallback = Callback<OnLayoutHandlerArgs>;\nexport type OnLayoutHandler =\n  | CallbackHandler<OnLayoutHandlerArgs>\n  | OnLayoutCallback;\n\n/**\n * Note that {@link device} or {@link aspectRatio} would only be null if the\n * viewport is narrower than the narrowest device/aspect ratio. This would only\n * happen if the narrowest device/aspect ratio is _not_ 0-width (which is not\n * the case with the default breakpoints and is against the recommendation for\n * setting breakpoints.\n */\nexport type LayoutData = {\n  device: Device | null;\n  aspectRatio: AspectRatio | null;\n};\n\n// ----------------------------------------\n\ntype LayoutWatcherConfigInternal = {\n  _root: HTMLElement | null;\n  _deviceBreakpoints: typeof settings.deviceBreakpoints;\n  _aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<HTMLElement | null, Map<string, LayoutWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst VAR_BORDER_HEIGHT = MH.prefixCssJsVar(\"border-height\");\nconst PREFIX_DEVICE = MH.prefixName(\"device\");\nconst PREFIX_ASPECTR = MH.prefixName(\"aspect-ratio\");\n\nconst getConfig = (\n  config: LayoutWatcherConfig | undefined,\n): LayoutWatcherConfigInternal => {\n  const deviceBreakpoints = MH.copyObject(settings.deviceBreakpoints);\n  if (config?.deviceBreakpoints) {\n    copyExistingKeys(config.deviceBreakpoints, deviceBreakpoints);\n  }\n\n  const aspectRatioBreakpoints = MH.copyObject(settings.aspectRatioBreakpoints);\n\n  if (config?.aspectRatioBreakpoints) {\n    copyExistingKeys(config.aspectRatioBreakpoints, aspectRatioBreakpoints);\n  }\n\n  return {\n    _root: config?.root || null,\n    _deviceBreakpoints: deviceBreakpoints,\n    _aspectRatioBreakpoints: aspectRatioBreakpoints,\n  };\n};\n\n// ----------------------------------------\n\nconst createOverlays = async (\n  root: HTMLElement | null,\n  deviceBreakpoints: typeof settings.deviceBreakpoints,\n  aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints,\n) => {\n  const overlayPromises = [];\n\n  let overlayParent: HTMLElement;\n  if (root) {\n    overlayParent = root;\n  } else {\n    // Since modals remove the scrollbar on the body when active, the width of\n    // the body changes upon open/close of a modal, which would create\n    // glitching if it happens near a device breakpoint. So if the root is the\n    // viewport, we create a fixed positioned container to hold the overlays\n    // and set its width to be 100vw and use that as the root of\n    overlayParent = await createOverlay({\n      style: {\n        position: \"fixed\",\n        [MC.S_WIDTH]: \"100vw\",\n      },\n    });\n  }\n\n  let device: Device;\n  for (device in deviceBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]: deviceBreakpoints[device] + \"px\",\n        },\n        data: {\n          [PREFIX_DEVICE]: device,\n        },\n      }),\n    );\n  }\n\n  const parentHeightCss = root ? `var(${VAR_BORDER_HEIGHT}, 0) * 1px` : \"100vh\";\n  if (root) {\n    SizeWatcher.reuse().trackSize(null, { target: root });\n  }\n\n  let aspectRatio: AspectRatio;\n  for (aspectRatio in aspectRatioBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]:\n            `calc(${aspectRatioBreakpoints[aspectRatio]} ` +\n            `* ${parentHeightCss})`,\n        },\n        data: {\n          [PREFIX_ASPECTR]: aspectRatio,\n        },\n      }),\n    );\n  }\n\n  const overlays = await MH.promiseAll(overlayPromises);\n  return { root: overlayParent, overlays };\n};\n\nconst getOverlayLayout = (overlay: HTMLElement): Layout | null => {\n  const layout =\n    getData(overlay, PREFIX_DEVICE) || getData(overlay, PREFIX_ASPECTR);\n  /* istanbul ignore else */\n  if (layout && (ORDERED_DEVICES.has(layout) || ORDERED_ASPECTR.has(layout))) {\n    return layout;\n  } else {\n    // shouldn't happen\n    logError(MH.bugError(\"No device or aspectRatio data attribute\"));\n    return null;\n  }\n};\n\nconst changeMatches = (\n  layoutBitmask: number,\n  thisLayoutData: LayoutData,\n  prevLayoutData: LayoutData | undefined | null,\n): boolean => {\n  // True if the callback is interested in a change of device and there's a\n  // change of device and the new device is one of the ones it's interested in\n  // (or it's null, i.e. device is undefined).\n  // And the same for aspect ratios.\n\n  if (\n    prevLayoutData?.device !== thisLayoutData.device &&\n    (!thisLayoutData.device ||\n      ORDERED_DEVICES.bit[thisLayoutData.device] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  if (\n    prevLayoutData?.aspectRatio !== thisLayoutData.aspectRatio &&\n    (!thisLayoutData.aspectRatio ||\n      ORDERED_ASPECTR.bit[thisLayoutData.aspectRatio] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getNonIntersecting = (\n  nonIntersectingBitmask: number, // current\n  entry: IntersectionObserverEntry,\n): number => {\n  const target = MH.targetOf(entry);\n  /* istanbul ignore next */ // shouldn't happen\n  if (!MH.isHTMLElement(target)) {\n    logError(\n      MH.bugError(\n        `IntersectionObserver called us with '${MH.typeOrClassOf(target)}'`,\n      ),\n    );\n    return nonIntersectingBitmask;\n  }\n\n  const layout = getOverlayLayout(target);\n  let bit = 0;\n  if (!layout) {\n    // error already logged by getOverlayLayout\n  } else if (ORDERED_DEVICES.has(layout)) {\n    bit = ORDERED_DEVICES.bit[layout];\n  } else if (ORDERED_ASPECTR.has(layout)) {\n    bit = ORDERED_ASPECTR.bit[layout];\n  } else {\n    /* istanbul ignore next */ // shouldn't happen\n    logError(\n      MH.bugError(`Unknown device or aspectRatio data attribute: ${layout}`),\n    );\n  }\n\n  if (entry.isIntersecting) {\n    nonIntersectingBitmask &= ~bit;\n  } else {\n    nonIntersectingBitmask |= bit;\n  }\n\n  return nonIntersectingBitmask;\n};\n\nconst invokeCallback = (callback: OnLayoutCallback, layoutData: LayoutData) =>\n  callback.invoke(MH.copyObject(layoutData)).catch(logError);\n"],"mappings":"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","ignoreList":[]}