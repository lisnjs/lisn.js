{"version":3,"file":"gesture-watcher.js","names":["MC","MH","addClasses","removeClasses","setNumericStyleProps","isValidDirection","addEventListenerTo","removeEventListenerFrom","preventSelect","undoPreventSelect","getDebouncedHandler","addDeltaZ","isValidInputDevice","isValidIntent","DEVICES","INTENTS","getKeyGestureFragment","getPointerGestureFragment","getTouchGestureFragment","getWheelGestureFragment","logError","maxAbs","toNonNegNum","toPosNum","toNumWithBounds","randId","objToStrKey","validateStrList","wrapCallback","newXWeakMap","debug","GestureWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","instance","instances","get","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","allCallbacks","newMap","allListeners","createCallback","target","handler","options","_allCallbacks$get","remove","_callback","debug5","_wrapper","getCallbackAndWrapper","onRemove","deleteHandler","sGet","_options","setupOnGesture","userOptions","getOptions","device","_devices","_allListeners$get","listeners","debug4","setupListeners","_nCallbacks","_preventDefault","_nPreventDefault","deleteKey","prune","_allListeners$get2","_remove","invokeCallbacks","event","_allListeners$get3","preventDefault","isTerminated","_allCallbacks$get2","values","intents","_intents","hasAddedTabIndex","hasPreventedSelect","S_KEY","isElement","getTabIndex","setTabIndex","S_TOUCH","PREFIX_NO_TOUCH_ACTION","includes","S_DRAG","addOrRemoveListeners","action","listener","eventTypes","method","eventType","debug8","passive","capture","addInitialListener","initialListener","initiatingEvents","removeInitialListener","addOngoingListener","processEvent","ongoingEvents","removeOngoingListener","unsetTabIndex","trackGesture","element","setGestureCssProps","intent","totalDeltaX","totalDeltaY","totalDeltaZ","noTrackGesture","offGesture","onGesture","_allCallbacks$get3","SYMBOL","_config$preventDefaul","_config$naturalTouchS","_config$touchDragHold","_config$touchDragNumF","_debounceWindow","S_DEBOUNCE_WINDOW","_deltaThreshold","deltaThreshold","_angleDiffThreshold","angleDiffThreshold","_naturalTouchScroll","naturalTouchScroll","_touchDragHoldTime","touchDragHoldTime","_touchDragNumFingers","touchDragNumFingers","S_KEYDOWN","pointer","S_POINTERDOWN","S_CLICK","touch","S_TOUCHSTART","wheel","S_WHEEL","S_POINTERUP","S_POINTERMOVE","S_POINTERCANCEL","S_TOUCHEND","S_TOUCHMOVE","S_TOUCHCANCEL","fragmentGetters","S_POINTER","_options$minTotalDelt","_options$maxTotalDelt","_options$minTotalDelt2","_options$maxTotalDelt2","_options$minTotalDelt3","_options$maxTotalDelt3","_options$preventDefau","_options$naturalTouch","_options$touchDragHol","_options$touchDragNum","debounceWindow","devices","_directions","directions","_minTotalDeltaX","minTotalDeltaX","_maxTotalDeltaX","maxTotalDeltaX","_minTotalDeltaY","minTotalDeltaY","_maxTotalDeltaY","maxTotalDeltaY","_minTotalDeltaZ","minTotalDeltaZ","_maxTotalDeltaZ","maxTotalDeltaZ","preventNextClick","reverseScroll","dragHoldTime","dragNumFingers","eventQueue","id","callback","debouncedWrapper","fragment","eventQueueCopy","_eventQueueCopy","_eventQueueCopy$","isRemoved","deltaX","deltaY","deltaZ","round","debug7","debug9","clearEventQueue","newTotalDeltaX","min","max","newTotalDeltaY","newTotalDeltaZ","direction","time","lengthOf","timeStamp","data","S_NONE","invoke","catch","wrapper","push","type","map","e","preventDefaultActionFor","setTimer","queue","keepLastEvent","splice","isActualGesture","currentTarget","isPointerDown","S_MOUSEDOWN","buttons","isHTMLElement","focus","preventScroll","S_UNKNOWN","prefix","S_ZOOM","_prefix","_numDecimal"],"sources":["../../../src/ts/watchers/gesture-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/GestureWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  GestureIntent,\n  GestureDevice,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport {\n  addClasses,\n  removeClasses,\n  setNumericStyleProps,\n} from \"@lisn/utils/css-alter\";\nimport { isValidDirection } from \"@lisn/utils/directions\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport { addDeltaZ } from \"@lisn/utils/gesture\";\n\nimport {\n  isValidInputDevice,\n  isValidIntent,\n  GestureFragment,\n  DEVICES,\n  INTENTS,\n} from \"@lisn/utils/gesture\";\nimport { getKeyGestureFragment } from \"@lisn/utils/gesture-key\";\nimport { getPointerGestureFragment } from \"@lisn/utils/gesture-pointer\";\nimport { getTouchGestureFragment } from \"@lisn/utils/gesture-touch\";\nimport { getWheelGestureFragment } from \"@lisn/utils/gesture-wheel\";\nimport { logError } from \"@lisn/utils/log\";\nimport {\n  maxAbs,\n  toNonNegNum,\n  toPosNum,\n  toNumWithBounds,\n} from \"@lisn/utils/math\";\nimport { randId, objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { LoggerInterface } from \"@lisn/debug/types\";\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link GestureWatcher} listens for user gestures resulting from wheel,\n * pointer, touch or key input events.\n *\n * It supports scroll, zoom or drag type gestures.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class GestureWatcher {\n  /**\n   * Call the given handler whenever the user performs a gesture on the target\n   * matching the given options.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, either using {@link onGesture} or\n   * {@link trackGesture}, then it will be removed and re-added with the\n   * current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onGesture: (\n    target: EventTarget,\n    handler: OnGestureHandler,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offGesture: (target: EventTarget, handler: OnGestureHandler) => void;\n\n  /**\n   * This is the same as {@link onGesture} except that if `handler` is not\n   * given, then it defaults to an internal handler that updates a set of CSS\n   * variables on the target's style:\n   *\n   *   - `--lisn-js--<Intent>-delta-x`\n   *   - `--lisn-js--<Intent>-delta-y`\n   *   - `--lisn-js--<Intent>-delta-z`\n   *\n   * where and `<Intent>` is one of {@link GestureIntent} and the delta X, Y\n   * and Z are the _total summed up_ `deltaX`, `deltaY` and `deltaZ` since the\n   * callback was added, summed over all devices used (key, touch, etc).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackGesture} or using\n   * {@link onGesture}, then it will be removed and re-added with the current\n   * options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackGesture}.\n   */\n  readonly noTrackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n  ) => void;\n\n  /**\n   * Creates a new instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: GestureWatcherConfig = {}) {\n    return new GestureWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: GestureWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new GestureWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: GestureWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"GestureWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"GestureWatcher\", logAtCreation: config })\n      : null;\n\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<\n        OnGestureHandler,\n        {\n          _callback: OnGestureCallback;\n          _wrapper: OnGestureHandlerWrapper;\n          _options: OnGestureOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    // For each target and event type, add only 1 global listener that will then\n    // manage the event queues and callbacks.\n    const allListeners = newXWeakMap<\n      EventTarget,\n      Map<GestureDevice, DeviceListeners>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ): OnGestureCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler for\", options);\n      const { _callback, _wrapper } = getCallbackAndWrapper(\n        handler,\n        options,\n        logger,\n      );\n\n      _callback.onRemove(() => deleteHandler(target, handler, options));\n\n      allCallbacks.sGet(target).set(handler, {\n        _callback,\n        _wrapper,\n        _options: options,\n      });\n\n      return _callback;\n    };\n\n    // ----------\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnGesture = async (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      userOptions: OnGestureOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions || {});\n      createCallback(target, handler, options);\n\n      for (const device of options._devices || DEVICES) {\n        let listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          debug: logger?.debug4(\n            `Listeners already added for ${device}`,\n            target,\n            options,\n          );\n        } else {\n          debug: logger?.debug4(\n            `Adding listeners for ${device}`,\n            target,\n            options,\n          );\n\n          listeners = setupListeners(target, device, options);\n          allListeners.sGet(target).set(device, listeners);\n        }\n\n        listeners._nCallbacks++;\n        if (options._preventDefault) {\n          listeners._nPreventDefault++;\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ) => {\n      MH.deleteKey(allCallbacks.get(target), handler);\n      allCallbacks.prune(target);\n\n      for (const device of options._devices || DEVICES) {\n        const listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          listeners._nCallbacks--;\n          if (options._preventDefault) {\n            listeners._nPreventDefault--;\n          }\n\n          if (!listeners._nCallbacks) {\n            debug: logger?.debug4(\n              `No more callbacks for target and device ${device}; removing listeners`,\n              target,\n            );\n\n            MH.deleteKey(allListeners.get(target), device);\n            listeners._remove();\n          }\n        }\n      }\n    };\n\n    // ----------\n\n    const invokeCallbacks = (\n      target: EventTarget,\n      device: GestureDevice,\n      event: Event,\n    ): boolean /* true if terminated */ => {\n      const preventDefault =\n        (allListeners.get(target)?.get(device)?._nPreventDefault || 0) > 0;\n\n      let isTerminated = false;\n      for (const { _wrapper } of allCallbacks.get(target)?.values() || []) {\n        isTerminated =\n          _wrapper(target, device, event, preventDefault) || isTerminated;\n      }\n\n      return isTerminated;\n    };\n\n    // ----------\n\n    const setupListeners = (\n      target: EventTarget,\n      device: GestureDevice,\n      options: OnGestureOptionsInternal,\n    ): DeviceListeners => {\n      const intents = options._intents;\n      let hasAddedTabIndex = false;\n      let hasPreventedSelect = false;\n\n      if (\n        device === MC.S_KEY &&\n        MH.isElement(target) &&\n        !MH.getTabIndex(target)\n      ) {\n        hasAddedTabIndex = true;\n        // enable element to receive keydown events\n        MH.setTabIndex(target);\n      } else if (MH.isElement(target) && device === MC.S_TOUCH) {\n        if (options._preventDefault) {\n          addClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n        }\n\n        if (!intents || MH.includes(intents, MC.S_DRAG)) {\n          hasPreventedSelect = true;\n          preventSelect(target);\n        }\n      }\n\n      const addOrRemoveListeners = (\n        action: \"add\" | \"remove\",\n        listener: EventListener,\n        eventTypes: readonly (keyof GlobalEventHandlersEventMap)[],\n      ) => {\n        const method =\n          action === \"add\" ? addEventListenerTo : removeEventListenerFrom;\n        for (const eventType of eventTypes) {\n          debug: logger?.debug8(`${action} listener for ${eventType}`, target);\n          method(target, eventType, listener, {\n            passive: false,\n            capture: true,\n          });\n        }\n      };\n\n      const addInitialListener = () =>\n        addOrRemoveListeners(\"add\", initialListener, initiatingEvents[device]);\n\n      const removeInitialListener = () =>\n        addOrRemoveListeners(\n          \"remove\",\n          initialListener,\n          initiatingEvents[device],\n        );\n\n      const addOngoingListener = () =>\n        addOrRemoveListeners(\"add\", processEvent, ongoingEvents[device]);\n\n      const removeOngoingListener = () =>\n        addOrRemoveListeners(\"remove\", processEvent, ongoingEvents[device]);\n\n      const initialListener = (event: Event) => {\n        processEvent(event);\n        removeInitialListener();\n        addOngoingListener();\n      };\n\n      const processEvent = (event: Event) => {\n        const isTerminated = invokeCallbacks(target, device, event);\n        if (isTerminated) {\n          removeOngoingListener();\n          addInitialListener();\n        }\n      };\n\n      addInitialListener();\n\n      return {\n        _nCallbacks: 0,\n        _nPreventDefault: 0,\n        _remove: () => {\n          if (MH.isElement(target)) {\n            if (hasAddedTabIndex) {\n              MH.unsetTabIndex(target);\n            }\n\n            removeClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n\n            if (hasPreventedSelect) {\n              undoPreventSelect(target);\n            }\n          }\n\n          removeOngoingListener();\n          removeInitialListener();\n        },\n      };\n    };\n\n    // ----------\n\n    this.trackGesture = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n        // initial values\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, {\n            intent,\n            totalDeltaX: 0,\n            totalDeltaY: 0,\n            totalDeltaZ: 1,\n          });\n        }\n      }\n\n      return setupOnGesture(element, handler, options);\n    };\n\n    // ----------\n\n    this.noTrackGesture = (element, handler?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n\n        // delete the properties\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, { intent });\n        }\n      }\n\n      this.offGesture(element, handler);\n    };\n\n    // ----------\n\n    this.onGesture = setupOnGesture;\n\n    // ----------\n\n    this.offGesture = (target, handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type GestureWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnGestureOptions.preventDefault | preventDefault} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.debounceWindow | debounceWindow} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 150\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.deltaThreshold | deltaThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 5\n   */\n  deltaThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.angleDiffThreshold | angleDiffThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * It does not make much sense to set this to 0.\n   *\n   * The value is in _degrees_, not radians.\n   *\n   * @defaultValue 35\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.naturalTouchScroll | naturalTouchScroll} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragHoldTime | touchDragHoldTime} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 500\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragNumFingers | touchDragNumFingers} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 1\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * @interface\n */\nexport type OnGestureOptions = {\n  /**\n   * One or more device types to listen for. If not specified, then all devices\n   * are enabled.\n   *\n   * It can be a comma-separated list of {@link GestureDevice}s or an array of\n   * such devices.\n   *\n   * @defaultValue undefined\n   */\n  devices?: CommaSeparatedStr<GestureDevice> | GestureDevice[];\n\n  /**\n   * If given, callback will only be called if the gesture's direction is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link Direction}s or an array of such\n   * directions.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<Direction> | Direction[];\n\n  /**\n   * If given, callback will only be called if the gesture's intent is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link GestureIntent}s or an\n   * array of such intents.\n   *\n   * @defaultValue undefined\n   */\n  intents?: CommaSeparatedStr<GestureIntent> | GestureIntent[];\n\n  /**\n   * Set minimum total delta X. Further reductions in delta X below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaX?: number;\n\n  /**\n   * Set maximum total delta X. Further increase in delta X above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaX?: number;\n\n  /**\n   * Set minimum total delta Y. Further reductions in delta Y below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaY?: number;\n\n  /**\n   * Set maximum total delta Y. Further increase in delta Y above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaY?: number;\n\n  /**\n   * Set minimum total delta Z. Further reductions in delta Z below this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and can be less than 1 but\n   * must be > 0.1 which is a hard minimum.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaZ?: number;\n\n  /**\n   * Set maximum total delta Z. Further increase in delta Z above this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and must be positive.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaZ?: number;\n\n  /**\n   * If true, the events of the gesture, e.g. relevant key presses or touch\n   * moves, etc, will have their default action prevented.\n   *\n   * **IMPORTANT:** For pointer gestures, then pointer/mouse down and click\n   * will be prevented.\n   *\n   * @defaultValue {@link GestureWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If given, callback will be called at most once every `debounceWindow`\n   * milliseconds.\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n\n  /**\n   * Callback will only be called when the gesture's accumulated delta, since\n   * the last time callback was called, exceeds `deltaThreshold`.\n   *\n   * At least one of the three deltas (X, Y or Z) must exceed this number (in\n   * absolute value). Note that when comparing `deltaZ`, it is multiplied by\n   * 100 since it represents fractions of 1 (100%). So supplying\n   * `deltaThreshold` of 10 means is equivalent to the following condition:\n   *\n   * ```\n   * abs(deltaX) >= 10 || abs(deltaY) >= 10 ||  abs(1 - deltaZ) >= 0.1\n   * ```\n   *\n   * Accumulation of the delta ends if the gesture is terminated, for example,\n   * in case of touch gestures, by a \"touchcancel\" event of by the final finger\n   * lifting off..\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.deltaThreshold}\n   */\n  deltaThreshold?: number;\n\n  /**\n   * See {@link Utils.getVectorDirection | getVectorDirection}.\n   *\n   * @defaultValue {@link GestureWatcherConfig.angleDiffThreshold}\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * Whether touch scroll gestures follow the natural direction: swipe up\n   * with scroll intent results in direction down and swipe down results in\n   * direction up.\n   *\n   * @defaultValue {@link GestureWatcherConfig.naturalTouchScroll}\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * If the user presses and holds on a touchscreen for at least the given\n   * amount of milliseconds before moving the finger(s), touch gestures other\n   * than pinch will be treated as a drag intent instead of scroll as long as\n   * the number of fingers touching the screen is {@link touchDragNumFingers}.\n   *\n   * Set to 0 in order to treat _all_ non-pinch touch gestures as drag.\n   *\n   * Set to a negative number in order to treat _all_ non-pinch touch gestures\n   * as scroll.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The number of fingers that could be considered a drag intent for touch\n   * gestures.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link GestureWatcher.onGesture}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link GestureData} that describes the gesture's progression since the\n *   last time the callback was called and since the callback was added.\n */\nexport type OnGestureHandlerArgs = [EventTarget, GestureData, Event[]];\nexport type OnGestureCallback = Callback<OnGestureHandlerArgs>;\nexport type OnGestureHandler =\n  | CallbackHandler<OnGestureHandlerArgs>\n  | OnGestureCallback;\n\nexport type GestureData = {\n  device: GestureDevice;\n  direction: Direction;\n  intent: GestureIntent;\n\n  /**\n   * Delta in the horizontal direction since the start of the gesture.\n   */\n  deltaX: number;\n\n  /**\n   * Delta in the vertical direction since the start of the gesture.\n   */\n  deltaY: number;\n\n  /**\n   * Relative fractional zoom in or out for zoom intents since the start of\n   * the gesture.\n   *\n   * For zoom in, `deltaZ` is always > 1, and for zoom out it is < 1.\n   *\n   * For non-zoom gestures it is 1.\n   */\n  deltaZ: number;\n\n  /**\n   * The time in milliseconds it took for the gesture. This will be the\n   * difference in timestamps between the first and last event that composed\n   * the gesture. For key and wheel gestures this could be 0, since 1 event is\n   * sufficient for them.\n   */\n  time: number;\n\n  /**\n   * Delta in the horizontal direction since the callback was added.\n   */\n  totalDeltaX: number;\n\n  /**\n   * Delta in the vertical direction since the callback was added.\n   */\n  totalDeltaY: number;\n\n  /**\n   * Percentage (relative) zoom in or out for zoom intents since the callback\n   * was added.\n   */\n  totalDeltaZ: number;\n};\n\n// ----------------------------------------\n\ntype GestureWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureOptionsInternal = {\n  _devices: GestureDevice[] | null;\n  _directions: Direction[] | null;\n  _intents: GestureIntent[] | null;\n  _minTotalDeltaX: number | null;\n  _maxTotalDeltaX: number | null;\n  _minTotalDeltaY: number | null;\n  _maxTotalDeltaY: number | null;\n  _minTotalDeltaZ: number | null;\n  _maxTotalDeltaZ: number | null;\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureHandlerWrapper = (\n  _target: EventTarget,\n  _device: GestureDevice,\n  _event: Event,\n  _preventDefault: boolean,\n) => boolean;\n\n// Specific to a combination of target + device\ntype DeviceListeners = {\n  _nCallbacks: number; // total number of callbacks\n  _nPreventDefault: number; // total number wanting to prevent default action\n  _remove: () => void;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, GestureWatcher>();\n\nconst getConfig = (\n  config: GestureWatcherConfig,\n): GestureWatcherConfigInternal => {\n  return {\n    _preventDefault: config.preventDefault ?? true,\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 150),\n    _deltaThreshold: toNonNegNum(config.deltaThreshold, 5),\n    _angleDiffThreshold: toPosNum(config.angleDiffThreshold, 35),\n    _naturalTouchScroll: config.naturalTouchScroll ?? true,\n    _touchDragHoldTime: config.touchDragHoldTime ?? 500,\n    _touchDragNumFingers: config.touchDragNumFingers ?? 1,\n  };\n};\n\nconst initiatingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform it into mousedown\n  //\n  // We need to listen for click, since that occurs after a pointerup (i.e.\n  // after a gesure is terminated and the ongoing listeners removed), but it\n  // needs to have its default action prevented.\n  pointer: [MC.S_POINTERDOWN, MC.S_CLICK],\n  touch: [MC.S_TOUCHSTART],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst ongoingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  pointer: [\n    // If the browser doesn't support point events, then\n    // addEventListenerTo will transform them into mouse*\n    MC.S_POINTERDOWN,\n    MC.S_POINTERUP, // would terminate\n    MC.S_POINTERMOVE,\n    MC.S_POINTERCANCEL, // would terminate\n    MC.S_CLICK, // would terminate; can be default-prevented\n  ],\n  touch: [MC.S_TOUCHSTART, MC.S_TOUCHEND, MC.S_TOUCHMOVE, MC.S_TOUCHCANCEL],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst fragmentGetters: {\n  [D in GestureDevice]: (\n    events: Event[],\n    options: {\n      deltaThreshold?: number;\n      angleDiffThreshold?: number;\n      reverseScroll?: boolean;\n      dragHoldTime?: number;\n      dragNumFingers?: number;\n    },\n  ) => GestureFragment | null | false;\n} = {\n  [MC.S_KEY]: getKeyGestureFragment,\n  [MC.S_POINTER]: getPointerGestureFragment,\n  [MC.S_TOUCH]: getTouchGestureFragment,\n  [MC.S_WHEEL]: getWheelGestureFragment,\n};\n\nconst getOptions = (\n  config: GestureWatcherConfigInternal,\n  options: OnGestureOptions,\n): OnGestureOptionsInternal => {\n  const debounceWindow = toNonNegNum(\n    options[MC.S_DEBOUNCE_WINDOW],\n    config._debounceWindow, // watcher is never debounced, so apply default here\n  );\n  const deltaThreshold = toNonNegNum(\n    options.deltaThreshold,\n    config._deltaThreshold,\n  );\n\n  return {\n    _devices:\n      validateStrList(\"devices\", options.devices, isValidInputDevice) || null,\n    _directions:\n      validateStrList(\"directions\", options.directions, isValidDirection) ||\n      null,\n    _intents:\n      validateStrList(\"intents\", options.intents, isValidIntent) || null,\n    _minTotalDeltaX: options.minTotalDeltaX ?? null,\n    _maxTotalDeltaX: options.maxTotalDeltaX ?? null,\n    _minTotalDeltaY: options.minTotalDeltaY ?? null,\n    _maxTotalDeltaY: options.maxTotalDeltaY ?? null,\n    _minTotalDeltaZ: options.minTotalDeltaZ ?? null,\n    _maxTotalDeltaZ: options.maxTotalDeltaZ ?? null,\n    _preventDefault: options.preventDefault ?? config._preventDefault,\n    _debounceWindow: debounceWindow,\n    _deltaThreshold: deltaThreshold,\n    _angleDiffThreshold: toNonNegNum(\n      options.angleDiffThreshold,\n      config._angleDiffThreshold,\n    ),\n    _naturalTouchScroll:\n      options.naturalTouchScroll ?? config._naturalTouchScroll,\n    _touchDragHoldTime: options.touchDragHoldTime ?? config._touchDragHoldTime,\n    _touchDragNumFingers:\n      options.touchDragNumFingers ?? config._touchDragNumFingers,\n  };\n};\n\n// Since each callback needs to accumulate events during its debounce window\n// and until its threshold is exceeded, we use a wrapper around the\n// user-supplied handler to do that.\nconst getCallbackAndWrapper = (\n  handler: OnGestureHandler,\n  options: OnGestureOptionsInternal,\n  logger: LoggerInterface | null,\n): { _callback: OnGestureCallback; _wrapper: OnGestureHandlerWrapper } => {\n  let totalDeltaX = 0,\n    totalDeltaY = 0,\n    totalDeltaZ = 1;\n  // When there's a pointer down, drag then pointerup, since we prevent\n  // pointerdown default action, this results in a click event shortly\n  // afterwards even when there's been a movement of the mouse. We detect that\n  // and prevent this click.\n  let preventNextClick = false;\n\n  const directions = options._directions;\n  const intents = options._intents;\n  const minTotalDeltaX = options._minTotalDeltaX;\n  const maxTotalDeltaX = options._maxTotalDeltaX;\n  const minTotalDeltaY = options._minTotalDeltaY;\n  const maxTotalDeltaY = options._maxTotalDeltaY;\n  const minTotalDeltaZ = options._minTotalDeltaZ;\n  const maxTotalDeltaZ = options._maxTotalDeltaZ;\n  const deltaThreshold = options._deltaThreshold;\n  const angleDiffThreshold = options._angleDiffThreshold;\n  const reverseScroll = !options._naturalTouchScroll;\n  const dragHoldTime = options._touchDragHoldTime;\n  const dragNumFingers = options._touchDragNumFingers;\n\n  // The event queue is cleared when the threshold is exceeded AND the debounce\n  // window has passed. It's not necessary for the actual handler to be called\n  // then (e.g. if the direction or intent doesn't match, it won't be).\n  const eventQueue: Event[] = [];\n  const id = randId();\n\n  // Since handler could be a function or a callback (not callable), we wrap it\n  // so that in case it's already a callback, its removal will result in\n  // deleteHandler getting called. It is not debounced itself, instead there's\n  // a debounced wrapper that invokes it.\n  const callback = wrapCallback(handler);\n\n  // The debounced callback wrapper is what is debounced.\n  // It accumulates total deltas and checks if the conditions (of threshold,\n  // direction and intent) are satisfied before calling the real handler.\n  //\n  // Most importantly, since it is only called when the debounce window has\n  // expired it can clear the event queue if the threshold is also exceeded.\n  const debouncedWrapper = getDebouncedHandler(\n    options._debounceWindow,\n    (\n      target: EventTarget,\n      fragment: GestureFragment,\n      eventQueueCopy: Event[],\n    ) => {\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      const deltaX = fragment.deltaX;\n      const deltaY = fragment.deltaY;\n      const deltaZ = fragment.deltaZ;\n      const device = fragment.device;\n\n      if (\n        MH.round(maxAbs(deltaX, deltaY, (1 - deltaZ) * 100)) < deltaThreshold\n      ) {\n        debug: logger?.debug7(\n          `[${id}] Delta threshold not exceeded for callback`,\n        );\n        return;\n      }\n\n      debug: logger?.debug9(`[${id}] Done summing events for ${device}`);\n      clearEventQueue(device, eventQueue);\n\n      const newTotalDeltaX = toNumWithBounds(totalDeltaX + deltaX, {\n        min: minTotalDeltaX,\n        max: maxTotalDeltaX,\n      });\n\n      const newTotalDeltaY = toNumWithBounds(totalDeltaY + deltaY, {\n        min: minTotalDeltaY,\n        max: maxTotalDeltaY,\n      });\n\n      const newTotalDeltaZ = toNumWithBounds(addDeltaZ(totalDeltaZ, deltaZ), {\n        min: minTotalDeltaZ,\n        max: maxTotalDeltaZ,\n      });\n\n      if (\n        newTotalDeltaX === totalDeltaX &&\n        newTotalDeltaY === totalDeltaY &&\n        newTotalDeltaZ === totalDeltaZ\n      ) {\n        return;\n      }\n\n      totalDeltaX = newTotalDeltaX;\n      totalDeltaY = newTotalDeltaY;\n      totalDeltaZ = newTotalDeltaZ;\n\n      const direction = fragment.direction;\n      const intent = fragment.intent;\n      const time =\n        eventQueueCopy[MH.lengthOf(eventQueueCopy) - 1]?.timeStamp -\n          eventQueueCopy[0]?.timeStamp || 0;\n\n      const data = {\n        device,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n        time,\n        totalDeltaX,\n        totalDeltaY,\n        totalDeltaZ,\n      };\n\n      if (\n        direction !== MC.S_NONE &&\n        (!directions || MH.includes(directions, direction)) &&\n        (!intents || MH.includes(intents, intent))\n      ) {\n        callback.invoke(target, data, eventQueueCopy).catch(logError);\n      } else {\n        debug: logger?.debug7(\n          `[${id}] Directions or intents not matching for callback`,\n        );\n      }\n    },\n  );\n\n  // This wrapper is NOT debounced and adds the events to the queue, prevents\n  // default action if needed, and indicates whether the gesture is terminated.\n  const wrapper = (\n    target: EventTarget,\n    device: GestureDevice,\n    event: Event,\n    preventDefault: boolean,\n  ) => {\n    eventQueue.push(event);\n\n    const fragment = fragmentGetters[device](eventQueue, {\n      angleDiffThreshold,\n      deltaThreshold,\n      reverseScroll,\n      dragHoldTime,\n      dragNumFingers,\n    });\n\n    debug: logger?.debug8(\n      `[${id}] Got fragment for ${device} (${event.type})`,\n      fragment,\n      [...eventQueue].map((e) => e.type),\n    );\n\n    if (preventDefault) {\n      preventDefaultActionFor(\n        event,\n        !!fragment || (event.type === MC.S_CLICK && preventNextClick),\n      );\n    }\n\n    if (fragment === false) {\n      // not enough events in the queue, pass\n      debug: logger?.debug9(`[${id}] Not enough events for gesture ${device}`);\n      return false;\n    } else if (fragment === null) {\n      // consider the gesture terminated\n      clearEventQueue(device, eventQueue);\n      debug: logger?.debug9(`[${id}] Gesture for ${device} terminated`);\n      return true;\n    }\n\n    if (device === MC.S_POINTER) {\n      // If we're here, there's been a drag, expect a click immediately\n      // afterwards and prevent default action.\n      preventNextClick = true;\n      MH.setTimer(() => {\n        preventNextClick = false;\n      }, 10);\n    }\n\n    debouncedWrapper(\n      target,\n      fragment,\n      [...eventQueue], // copy\n    );\n\n    return false;\n  };\n\n  return { _callback: callback, _wrapper: wrapper };\n};\n\nconst clearEventQueue = (device: GestureDevice, queue: Event[]) => {\n  const keepLastEvent = device === MC.S_POINTER || device === MC.S_TOUCH;\n  queue.splice(0, MH.lengthOf(queue) - (keepLastEvent ? 1 : 0));\n};\n\nconst preventDefaultActionFor = (event: Event, isActualGesture: boolean) => {\n  const target = event.currentTarget;\n  const eventType = event.type;\n  const isPointerDown =\n    eventType === MC.S_POINTERDOWN || eventType === MC.S_MOUSEDOWN;\n\n  if (\n    eventType === MC.S_TOUCHMOVE ||\n    eventType === MC.S_WHEEL ||\n    ((eventType === MC.S_CLICK || eventType === MC.S_KEYDOWN) &&\n      isActualGesture) ||\n    (isPointerDown && (event as MouseEvent).buttons === 1)\n  ) {\n    MH.preventDefault(event);\n\n    if (isPointerDown && MH.isHTMLElement(target)) {\n      // Otherwise capturing key events won't work\n      target.focus({ preventScroll: true });\n    }\n  }\n};\n\nconst setGestureCssProps = (\n  target: EventTarget,\n  data: Partial<GestureData>,\n) => {\n  const intent = data.intent;\n\n  if (!MH.isElement(target) || !intent || intent === MC.S_UNKNOWN) {\n    return;\n  }\n\n  const prefix = `${intent}-`;\n\n  if (intent === MC.S_ZOOM) {\n    setNumericStyleProps(\n      target,\n      {\n        deltaZ: data.totalDeltaZ,\n      },\n      {\n        _prefix: prefix,\n        _numDecimal: 2,\n      },\n    ); // don't await here\n  } else {\n    setNumericStyleProps(\n      target,\n      {\n        deltaX: data.totalDeltaX,\n        deltaY: data.totalDeltaY,\n      },\n      {\n        _prefix: prefix,\n      },\n    ); // don't await here\n  }\n};\n"],"mappings":"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","ignoreList":[]}