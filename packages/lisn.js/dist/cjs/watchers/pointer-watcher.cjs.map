{"version":3,"file":"pointer-watcher.cjs","names":["MC","_interopRequireWildcard","require","MH","_event","_log","_pointer","_text","_validation","_callback","_xMap","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","PointerWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","objToStrKey","instance","instances","constructor","key","illegalConstructorError","allCallbacks","newXWeakMap","newMap","createCallback","target","handler","_allCallbacks$get","remove","callback","wrapCallback","onRemove","deleteKey","sGet","setupOnPointer","startHandler","endHandler","userOptions","options","getOptions","startCallback","endCallback","action","_actions","listenerSetupFn","onPointer","offPointer","entry","exports","SYMBOL","_config$preventDefaul","_config$preventSelect","_preventDefault","preventDefault","_preventSelect","preventSelect","_options$preventDefau","_options$preventSelec","validateStrList","actions","isValidPointerAction","POINTER_ACTIONS","setupClickListener","toggleState","wrapper","event","data","S_CLICK","state","invokeCallback","addEventListenerTo","removeEventListenerFrom","setupPointerListeners","startEventSuff","S_HOVER","endEventSuff","startEvent","S_POINTER","endEvent","strReplace","type","startListener","endListener","undoPreventSelect","click","hover","args","press","S_PRESS","actionData","invoke","copyObject","catch","logError"],"sources":["../../../src/ts/watchers/pointer-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/PointerWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { PointerAction, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { isValidPointerAction, POINTER_ACTIONS } from \"@lisn/utils/pointer\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * {@link PointerWatcher} listens for simple pointer actions like clicks, press\n * and hold or hover.\n */\nexport class PointerWatcher {\n  /**\n   * Call the `startHandler` whenever the pointer action begins.\n   * Call the `endHandler` whenever the pointer action ends. If `endHandler` is\n   * not given, it defaults to `startHandler`.\n   *\n   * For an explanation of what \"begins\" and \"ends\" means for each supported\n   * action, see {@link OnPointerOptions.actions}.\n   *\n   * **IMPORTANT:** The same handlers can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, then it will be removed and re-added with the\n   * current options.\n   */\n  readonly onPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n    options?: OnPointerOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes previously added handlers.\n   */\n  readonly offPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n  ) => void;\n\n  /**\n   * Creates a new instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: PointerWatcherConfig = {}) {\n    return new PointerWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: PointerWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new PointerWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: PointerWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"PointerWatcher.create\");\n    }\n\n    // Keep this watcher super simple. The events we listen for don't fire at a\n    // high rate and it's unlikely for there to be many many callbacks for each\n    // target and event type, so don't bother with using a delegating listener,\n    // etc.\n\n    // Keep a map of callbacks so we can lookup the callback by the handler\n    // (and also to prevent duplicate handler for each target, for consistency\n    // with other watchers).\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<OnPointerHandler, OnPointerCallback>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnPointerHandler,\n    ): OnPointerCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler));\n\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        MH.deleteKey(allCallbacks.get(target), handler);\n      });\n\n      allCallbacks.sGet(target).set(handler, callback);\n      return callback;\n    };\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnPointer = async (\n      target: EventTarget,\n      startHandler: OnPointerHandler,\n      endHandler: OnPointerHandler | undefined,\n      userOptions: OnPointerOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions);\n      const startCallback = createCallback(target, startHandler);\n      const endCallback =\n        endHandler && endHandler !== startHandler\n          ? createCallback(target, endHandler)\n          : startCallback;\n\n      for (const action of options._actions) {\n        listenerSetupFn[action](target, startCallback, endCallback, options);\n      }\n    };\n\n    // ----------\n\n    this.onPointer = setupOnPointer;\n\n    // ----------\n\n    this.offPointer = (target, startHandler, endHandler?) => {\n      const entry = allCallbacks.get(target);\n      MH.remove(entry?.get(startHandler));\n      if (endHandler) {\n        MH.remove(entry?.get(endHandler));\n      }\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type PointerWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventDefault | preventDefault} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue false\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventSelect | preventSelect} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue true\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * @interface\n */\nexport type OnPointerOptions = {\n  /**\n   * One or more of of \"click\", \"hover\" or \"press\". If not specified, then all\n   * actions are enabled.\n   *\n   * It can be a comma-separated list of {@link PointerAction}s or an array of\n   * such actions.\n   *\n   * For click actions, the start handler is called for every odd number of\n   * clicks (1st, 3rd, 5th, etc), and the end handler is called for every other\n   * click. It functions like a toggle.\n   *\n   * For hover and press actions, the start handler is called when the pointer\n   * enters or presses down on the target respectively, and the end handler is\n   * called when the pointer leaves or comes off the target respectively.\n   *\n   * Note that on touch screens, hover and press actions behave identically.\n   *\n   * @defaultValue undefined\n   */\n  actions?: CommaSeparatedStr<PointerAction> | PointerAction[];\n\n  /**\n   * If true, the events of the pointer actions, e.g. click, will have their\n   * default action prevented.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If true (default), then for press actions (and hover actions on touch\n   * screens) it will prevent starting a text selection.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventSelect}\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link PointerWatcher.onPointer}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link PointerActionData} describing the state of the action.\n */\nexport type OnPointerHandlerArgs = [EventTarget, PointerActionData, Event];\nexport type OnPointerCallback = Callback<OnPointerHandlerArgs>;\nexport type OnPointerHandler =\n  | CallbackHandler<OnPointerHandlerArgs>\n  | OnPointerCallback;\n\nexport type PointerActionData = {\n  action: PointerAction;\n  state: \"ON\" | \"OFF\";\n};\n\n// ----------------------------------------\n\ntype PointerWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\ntype OnPointerOptionsInternal = {\n  _actions: PointerAction[];\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, PointerWatcher>();\n\nconst getConfig = (\n  config: PointerWatcherConfig | undefined,\n): PointerWatcherConfigInternal => {\n  return {\n    _preventDefault: config?.preventDefault ?? false,\n    _preventSelect: config?.preventSelect ?? true,\n  };\n};\n\nconst getOptions = (\n  config: PointerWatcherConfigInternal,\n  options: OnPointerOptions | undefined,\n): OnPointerOptionsInternal => {\n  return {\n    _actions:\n      validateStrList(\"actions\", options?.actions, isValidPointerAction) ||\n      POINTER_ACTIONS,\n    _preventDefault: options?.preventDefault ?? config._preventDefault,\n    _preventSelect: options?.preventSelect ?? config._preventSelect,\n  };\n};\n\nconst setupClickListener = (\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // false if next will start; true if next will end.\n  let toggleState = false;\n\n  const wrapper = (event: Event) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    toggleState = !toggleState;\n\n    const data: PointerActionData = {\n      action: MC.S_CLICK,\n      state: toggleState ? \"ON\" : \"OFF\",\n    };\n\n    invokeCallback(\n      toggleState ? startCallback : endCallback,\n      target,\n      data,\n      event,\n    );\n  };\n\n  addEventListenerTo(target, MC.S_CLICK, wrapper);\n\n  const remove = () => removeEventListenerFrom(target, MC.S_CLICK, wrapper);\n\n  startCallback.onRemove(remove);\n  endCallback.onRemove(remove);\n};\n\nconst setupPointerListeners = (\n  action: typeof MC.S_HOVER | typeof MC.S_PRESS,\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform these into mouse*\n  const startEventSuff = action === MC.S_HOVER ? \"enter\" : \"down\";\n  const endEventSuff = action === MC.S_HOVER ? \"leave\" : \"up\";\n  const startEvent = MC.S_POINTER + startEventSuff;\n  const endEvent = MC.S_POINTER + endEventSuff;\n\n  const wrapper = (event: Event, callback: OnPointerCallback) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    const data: PointerActionData = {\n      action,\n      state:\n        MH.strReplace(event.type, /pointer|mouse/, \"\") === startEventSuff\n          ? \"ON\"\n          : \"OFF\",\n    };\n\n    invokeCallback(callback, target, data, event);\n  };\n  const startListener = (event: Event) => wrapper(event, startCallback);\n  const endListener = (event: Event) => wrapper(event, endCallback);\n\n  addEventListenerTo(target, startEvent, startListener);\n  addEventListenerTo(target, endEvent, endListener);\n\n  // On some touch screen devices pressing and holding will initiate select\n  // and result in touchend, so we prevent text select\n  if (options._preventSelect) {\n    preventSelect(target);\n  }\n\n  startCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, startEvent, startListener);\n  });\n\n  endCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, endEvent, endListener);\n  });\n};\n\nconst listenerSetupFn: {\n  [D in PointerAction]: (\n    target: EventTarget,\n    startCallback: OnPointerCallback,\n    endCallback: OnPointerCallback,\n    options: OnPointerOptionsInternal,\n  ) => void;\n} = {\n  click: setupClickListener,\n  hover: (...args) => setupPointerListeners(MC.S_HOVER, ...args),\n  press: (...args) => setupPointerListeners(MC.S_PRESS, ...args),\n} as const;\n\nconst invokeCallback = (\n  callback: OnPointerCallback,\n  target: EventTarget,\n  actionData: PointerActionData,\n  event: Event,\n) => callback.invoke(target, MH.copyObject(actionData), event).catch(logError);\n"],"mappings":"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","ignoreList":[]}