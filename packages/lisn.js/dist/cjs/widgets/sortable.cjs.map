{"version":3,"file":"sortable.cjs","names":["MC","_interopRequireWildcard","require","MH","_cssAlter","_domAlter","_domOptimize","_domQuery","_event","_math","_validation","_callback","_widget","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","Sortable","Widget","element","instance","DUMMY_ID","isInstanceOf","register","registerWidget","WIDGET_NAME","config","configValidator","constructor","_Sortable$get","destroyPromise","destroy","id","items","lengthOf","push","querySelectorAll","getDefaultWidgetSelector","PREFIX_ITEM__FOR_SELECT","S_DRAGGABLE","getVisibleContentChildren","usageError","methods","getMethods","promiseResolve","then","isDestroyed","init","disableItem","_disableItem","enableItem","_enableItem","toggleItem","_toggleItem","isItemDisabled","_isItemDisabled","onMove","_onMove","getItems","currentOrder","_getSortedItems","exports","PREFIXED_NAME","prefixName","PREFIX_IS_DRAGGABLE","PREFIX_ITEM","PREFIX_FLOATING_CLONE","mode","key","validateString","v","touchMoveOptions","passive","capture","isItemDraggable","item","getBooleanData","widget","currentDraggedItem","floatingClone","ignoreCancel","grabOffset","setIgnoreCancel","onDragStart","event","currTarget","currentTargetOf","isElement","isMouseEvent","setAttr","isTouchPointerEvent","target","targetOf","releasePointerCapture","pointerId","addEventListenerTo","getDoc","S_TOUCHMOVE","onTouchMove","waitForMeasureTime","rect","getBoundingClientRect","clientX","left","clientY","top","onDragEnd","type","S_POINTERCANCEL","unsetAttr","removeEventListenerFrom","moveElement","isTouchEvent","touches","parentEl","parentOf","preventDefault","touch","cloneElement","addClasses","copyStyle","to","setNumericStyleJsVars","_units","onDragEnter","dragged","S_DRAGENTER","_dragItemOnto","setupEvents","preventSelect","S_POINTERDOWN","S_DRAGSTART","S_POINTERENTER","S_DRAGOVER","S_DRAGEND","S_DROP","S_POINTERUP","setBooleanData","onEnable","onDisable","undoPreventSelect","onDestroy","removeClasses","delData","doSwap","disabledItems","callbacks","newSet","getSortedItems","sort","a","b","isNodeBAfterA","getOrigItemNumber","itemNum","indexOf","toInt","isDisabled","unsetBooleanData","handler","add","wrapCallback","dragItemOnto","draggedOver","swapElements","ignoreMove","position","callback","invoke"],"sources":["../../../src/ts/widgets/sortable.ts"],"sourcesContent":["/**\n * @module Widgets\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  addClasses,\n  removeClasses,\n  getBooleanData,\n  setBooleanData,\n  unsetBooleanData,\n  delData,\n  copyStyle,\n  setNumericStyleJsVars,\n} from \"@lisn/utils/css-alter\";\nimport { moveElement, swapElements, cloneElement } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { getVisibleContentChildren } from \"@lisn/utils/dom-query\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { toInt } from \"@lisn/utils/math\";\nimport { validateString } from \"@lisn/utils/validation\";\n\nimport { wrapCallback } from \"@lisn/modules/callback\";\n\nimport {\n  Widget,\n  WidgetConfigValidatorObject,\n  WidgetCallback,\n  WidgetHandler,\n  registerWidget,\n  getDefaultWidgetSelector,\n} from \"@lisn/widgets/widget\";\n\n/**\n * Configures the given element as a {@link Sortable} widget.\n *\n * The Sortable widget allows the user to reorder elements by dragging and\n * dropping. It works on touch devices as well. However, it does not yet\n * support automatic scrolling when dragging beyond edge of screen on mobile\n * devices. For this, you may want to use\n * {@link https://github.com/SortableJS/Sortable | SortableJS} instead.\n *\n * The widget should have more than one draggable item.\n *\n * **IMPORTANT:** You should not instantiate more than one {@link Sortable}\n * widget on a given element. Use {@link Sortable.get} to get an existing\n * instance if any. If there is already a widget instance, it will be destroyed!\n *\n * -----\n *\n * You can use the following dynamic attributes or CSS properties in your\n * stylesheet:\n *\n * The following dynamic attributes are set on each item element:\n * - `data-lisn-is-draggable`: `\"true\"` or `\"false\"` (false if the item is disabled)\n *\n * -----\n *\n * To use with auto-widgets (HTML API) (see\n * {@link Settings.settings.autoWidgets | settings.autoWidgets}), the following\n * CSS classes or data attributes are recognized:\n * - `lisn-sortable` class or `data-lisn-sortable` attribute set on the\n *   container element that constitutes the sortable container\n * - `lisn-sortable-item` class or `data-lisn-sortable-item` attribute set on\n *   elements that should act as the items.\n *\n * When using auto-widgets, the elements that will be used as items are\n * discovered in the following way:\n * 1. The top-level element that constitutes the widget is searched for any\n *    elements that contain the `lisn-sortable-item` class or\n *    `data-lisn-sortable-item` attribute. They do not have to be immediate\n *    children of the root element.\n * 2. If there are no such elements, all of the immediate children of the\n *    widget element (other than `script` and `style` elements) are taken as\n *    the items.\n *\n * @example\n * ```html\n * <div class=\"lisn-sortable\">\n *   <div class=\"box\">Item 1</div>\n *   <div class=\"box\">Item 2</div>\n *   <div class=\"box\">Item 3</div>\n *   <div class=\"box\">Item 4</div>\n * </div>\n * ```\n */\nexport class Sortable extends Widget {\n  /**\n   * Disables the given item number. Note that item numbers start at 1.\n   *\n   * @param currentOrder If false (default), the item numbers refer to the\n   *                     original order. If true, they refer to the current\n   *                     document order.\n   */\n  readonly disableItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Re-enables the given item number. Note that item numbers start at 1.\n   *\n   * @param currentOrder If false (default), the item numbers refer to the\n   *                     original order. If true, they refer to the current\n   *                     document order.\n   */\n  readonly enableItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Re-enables the given item number if it is disabled, otherwise disables it.\n   * Note that item numbers start at 1.\n   *\n   * @param currentOrder If false (default), the item numbers refer to the\n   *                     original order. If true, they refer to the current\n   *                     document order.\n   */\n  readonly toggleItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Returns true if the given item number is disabled. Note that item numbers\n   * start at 1.\n   *\n   * @param currentOrder If false (default), the item numbers refer to the\n   *                     original order. If true, they refer to the current\n   *                     document order.\n   */\n  readonly isItemDisabled: (itemNum: number, currentOrder?: boolean) => boolean;\n\n  /**\n   * The given handler will be called whenever the user moves an item to\n   * another position. It will be called after the item is moved so\n   * {@link getItems} called with `currentOrder = true` will return the updated\n   * order.\n   *\n   * If the handler returns a promise, it will be awaited upon.\n   */\n  readonly onMove: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns the item elements.\n   *\n   * @param currentOrder If false (default), returns the items in the\n   *                     original order. If true, they are returned in the\n   *                     current document order.\n   */\n  readonly getItems: (currentOrder?: boolean) => Element[];\n\n  static get(element: Element): Sortable | null {\n    const instance = super.get(element, DUMMY_ID);\n    if (MH.isInstanceOf(instance, Sortable)) {\n      return instance;\n    }\n    return null;\n  }\n\n  static register() {\n    registerWidget(\n      WIDGET_NAME,\n      (element, config) => {\n        if (!Sortable.get(element)) {\n          return new Sortable(element, config);\n        }\n        return null;\n      },\n      configValidator,\n    );\n  }\n\n  /**\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If there are less than 2 items given or found.\n   */\n  constructor(element: Element, config?: SortableConfig) {\n    const destroyPromise = Sortable.get(element)?.destroy();\n    super(element, { id: DUMMY_ID });\n\n    const items = config?.items || [];\n    if (!MH.lengthOf(items)) {\n      items.push(\n        ...MH.querySelectorAll(\n          element,\n          getDefaultWidgetSelector(PREFIX_ITEM__FOR_SELECT),\n        ),\n      );\n\n      if (!MH.lengthOf(items)) {\n        items.push(...MH.querySelectorAll(element, `[${MC.S_DRAGGABLE}]`));\n\n        if (!MH.lengthOf(items)) {\n          items.push(...getVisibleContentChildren(element));\n        }\n      }\n    }\n\n    if (MH.lengthOf(items) < 2) {\n      throw MH.usageError(\"Sortable must have more than 1 item\");\n    }\n\n    const methods = getMethods(this, items, config);\n\n    (destroyPromise || MH.promiseResolve()).then(() => {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      init(this, element, items, methods);\n    });\n\n    this.disableItem = methods._disableItem;\n    this.enableItem = methods._enableItem;\n    this.toggleItem = methods._toggleItem;\n    this.isItemDisabled = methods._isItemDisabled;\n    this.onMove = methods._onMove;\n\n    this.getItems = (currentOrder = false) =>\n      currentOrder ? methods._getSortedItems() : [...items];\n  }\n}\n\n/**\n * @interface\n */\nexport type SortableConfig = {\n  /**\n   * The elements that will be used as the draggable items.\n   *\n   * The widget should have more than one draggable item.\n   *\n   * If this is not specified, then\n   * 1. The top-level element that constitutes the widget is searched for any\n   *    elements that contain the class `lisn-sortable-item`. They do not\n   *    have to be immediate children of the root element.\n   * 2. If there are no such elements, all of the immediate children of the\n   *    widget element (other than `script` and `style` elements) are taken as\n   *    the items.\n   */\n  items?: Element[];\n\n  /**\n   * Whether to move the dragged item to before/after the drop target, or swap\n   * it with the drop target.\n   *\n   * Note that the moving/swapping action is being done as the user is dragging\n   * as soon as they drag over another item, so in order to achieve a swap\n   * effect, the user needs to be able to drag an item from one location to\n   * another without the path of the mouse crossing over all in-between items.\n   *\n   * @defaultValue \"move\";\n   */\n  mode?: \"move\" | \"swap\";\n};\n\n// --------------------\n\nconst WIDGET_NAME = \"sortable\";\nconst PREFIXED_NAME = MH.prefixName(WIDGET_NAME);\nconst PREFIX_IS_DRAGGABLE = MH.prefixName(\"is-draggable\");\n\n// Use different classes for styling items to the one used for auto-discovering\n// them, so that re-creating existing widgets can correctly find the items to\n// be used by the new widget synchronously before the current one is destroyed.\nconst PREFIX_ITEM = `${PREFIXED_NAME}__item`;\nconst PREFIX_ITEM__FOR_SELECT = `${PREFIXED_NAME}-item`;\n\nconst PREFIX_FLOATING_CLONE = `${PREFIXED_NAME}__ghost`;\n\n// Only one Sortable widget per element is allowed, but Widget requires a\n// non-blank ID.\nconst DUMMY_ID = PREFIXED_NAME;\n\nconst configValidator: WidgetConfigValidatorObject<SortableConfig> = {\n  mode: (key, value) =>\n    validateString(key, value, (v) => v === \"swap\" || v === \"move\"),\n};\n\nconst touchMoveOptions = { passive: false, capture: true };\n\nconst isItemDraggable = (item: Element) =>\n  getBooleanData(item, PREFIX_IS_DRAGGABLE);\n\nconst init = (\n  widget: Sortable,\n  element: Element,\n  items: Element[],\n  methods: ReturnType<typeof getMethods>,\n) => {\n  let currentDraggedItem: Element | null = null;\n  let floatingClone: Element | null = null;\n  let ignoreCancel = false;\n  let grabOffset = [0, 0];\n\n  const setIgnoreCancel = () => (ignoreCancel = true);\n\n  const onDragStart = (event: Event) => {\n    const currTarget = MH.currentTargetOf(event);\n\n    if (\n      MH.isElement(currTarget) &&\n      isItemDraggable(currTarget) &&\n      MH.isMouseEvent(event)\n    ) {\n      currentDraggedItem = currTarget;\n      MH.setAttr(currTarget, MC.S_DRAGGABLE);\n\n      if (MH.isTouchPointerEvent(event)) {\n        const target = MH.targetOf(event);\n        if (MH.isElement(target)) {\n          target.releasePointerCapture(event.pointerId);\n        }\n      }\n\n      addEventListenerTo(\n        MH.getDoc(),\n        MC.S_TOUCHMOVE,\n        onTouchMove,\n        touchMoveOptions,\n      );\n\n      waitForMeasureTime().then(() => {\n        // Get pointer offset relative to the current item being dragged\n        // regardless of what the event target is and what transforms is has\n        // applied.\n        const rect = MH.getBoundingClientRect(currTarget);\n        grabOffset = [event.clientX - rect.left, event.clientY - rect.top];\n      });\n    }\n  };\n\n  const onDragEnd = (event: Event) => {\n    if (ignoreCancel && event.type === MC.S_POINTERCANCEL) {\n      ignoreCancel = false;\n      return;\n    }\n\n    if (currentDraggedItem) {\n      MH.unsetAttr(currentDraggedItem, MC.S_DRAGGABLE);\n      currentDraggedItem = null;\n\n      removeEventListenerFrom(\n        MH.getDoc(),\n        MC.S_TOUCHMOVE,\n        onTouchMove,\n        touchMoveOptions,\n      );\n\n      if (floatingClone) {\n        moveElement(floatingClone);\n        floatingClone = null;\n      }\n    }\n  };\n\n  const onTouchMove = (event: Event) => {\n    if (MH.isTouchEvent(event) && MH.lengthOf(event.touches) === 1) {\n      const parentEl = MH.parentOf(currentDraggedItem);\n      if (parentEl && currentDraggedItem) {\n        MH.preventDefault(event);\n\n        const touch = event.touches[0];\n        const clientX = touch.clientX;\n        const clientY = touch.clientY;\n\n        if (!floatingClone) {\n          floatingClone = cloneElement(currentDraggedItem);\n          addClasses(floatingClone, PREFIX_FLOATING_CLONE);\n          copyStyle(currentDraggedItem, floatingClone, [\n            \"width\",\n            \"height\",\n          ]).then(() => {\n            if (floatingClone) {\n              moveElement(floatingClone, { to: parentEl });\n            }\n          });\n        }\n\n        if (floatingClone) {\n          setNumericStyleJsVars(\n            floatingClone,\n            {\n              clientX: clientX - grabOffset[0],\n              clientY: clientY - grabOffset[1],\n            },\n            { _units: \"px\" },\n          );\n        }\n      }\n    }\n  };\n\n  const onDragEnter = (event: Event) => {\n    const currTarget = MH.currentTargetOf(event);\n    const dragged = currentDraggedItem;\n\n    if (\n      (MH.isTouchPointerEvent(event) || event.type === MC.S_DRAGENTER) &&\n      dragged &&\n      MH.isElement(currTarget) &&\n      currTarget !== dragged\n    ) {\n      methods._dragItemOnto(dragged, currTarget); // no need to await\n    }\n  };\n\n  const setupEvents = () => {\n    for (const item of items) {\n      preventSelect(item);\n\n      addEventListenerTo(item, MC.S_POINTERDOWN, onDragStart);\n\n      addEventListenerTo(item, MC.S_DRAGSTART, setIgnoreCancel); // non-touch\n\n      addEventListenerTo(item, MC.S_POINTERENTER, onDragEnter); // touch\n      addEventListenerTo(item, MC.S_DRAGENTER, onDragEnter); // non-touch\n\n      addEventListenerTo(item, MC.S_DRAGOVER, MH.preventDefault); // non-touch\n\n      addEventListenerTo(item, MC.S_DRAGEND, onDragEnd); // non-touch\n      addEventListenerTo(item, MC.S_DROP, onDragEnd); // non-touch\n\n      addEventListenerTo(MH.getDoc(), MC.S_POINTERUP, onDragEnd);\n      addEventListenerTo(MH.getDoc(), MC.S_POINTERCANCEL, onDragEnd);\n    }\n  };\n\n  // SETUP ------------------------------\n\n  for (const item of items) {\n    addClasses(item, PREFIX_ITEM);\n    setBooleanData(item, PREFIX_IS_DRAGGABLE);\n  }\n\n  widget.onEnable(setupEvents);\n\n  widget.onDisable(() => {\n    for (const item of items) {\n      undoPreventSelect(item);\n\n      removeEventListenerFrom(item, MC.S_POINTERDOWN, onDragStart);\n\n      removeEventListenerFrom(item, MC.S_DRAGSTART, setIgnoreCancel);\n\n      removeEventListenerFrom(item, MC.S_POINTERENTER, onDragEnter);\n      removeEventListenerFrom(item, MC.S_DRAGENTER, onDragEnter);\n\n      removeEventListenerFrom(item, MC.S_DRAGOVER, MH.preventDefault);\n\n      removeEventListenerFrom(item, MC.S_POINTERUP, onDragEnd);\n      removeEventListenerFrom(item, MC.S_POINTERCANCEL, onDragEnd);\n      removeEventListenerFrom(item, MC.S_DRAGEND, onDragEnd);\n      removeEventListenerFrom(item, MC.S_DROP, onDragEnd);\n    }\n  });\n\n  widget.onDestroy(async () => {\n    for (const item of items) {\n      await removeClasses(item, PREFIX_ITEM);\n      await delData(item, PREFIX_IS_DRAGGABLE);\n    }\n  });\n\n  setupEvents();\n};\n\nconst getMethods = (\n  widget: Sortable,\n  items: Element[],\n  config: SortableConfig | undefined,\n) => {\n  const doSwap = config?.mode === \"swap\";\n\n  const disabledItems: Record<number, boolean> = {};\n  const callbacks = MH.newSet<WidgetCallback>();\n\n  const getSortedItems = () =>\n    [...items].sort((a, b) => (MH.isNodeBAfterA(a, b) ? -1 : 1));\n\n  const getOrigItemNumber = (itemNum: number, currentOrder = false) =>\n    currentOrder ? items.indexOf(getSortedItems()[itemNum - 1]) + 1 : itemNum;\n\n  const isItemDisabled = (itemNum: number, currentOrder = false) =>\n    disabledItems[getOrigItemNumber(itemNum, currentOrder)] === true;\n\n  const disableItem = async (itemNum: number, currentOrder = false) => {\n    itemNum = getOrigItemNumber(toInt(itemNum), currentOrder);\n    if (widget.isDisabled() || itemNum < 1 || itemNum > MH.lengthOf(items)) {\n      return;\n    }\n\n    // set immediately for toggle to work without awaiting on it\n    disabledItems[itemNum] = true;\n    await unsetBooleanData(items[itemNum - 1], PREFIX_IS_DRAGGABLE);\n  };\n\n  const enableItem = async (itemNum: number, currentOrder = false) => {\n    itemNum = getOrigItemNumber(toInt(itemNum), currentOrder);\n    if (widget.isDisabled() || !isItemDisabled(itemNum)) {\n      return;\n    }\n\n    // set immediately for toggle to work without awaiting on it\n    disabledItems[itemNum] = false;\n    await setBooleanData(items[itemNum - 1], PREFIX_IS_DRAGGABLE);\n  };\n\n  const toggleItem = (itemNum: number, currentOrder = false) =>\n    isItemDisabled(itemNum, currentOrder)\n      ? enableItem(itemNum, currentOrder)\n      : disableItem(itemNum, currentOrder);\n\n  const onMove = (handler: WidgetHandler) =>\n    callbacks.add(wrapCallback(handler));\n\n  // This is internal only for now...\n  const dragItemOnto = async (dragged: Element, draggedOver: Element) => {\n    if (doSwap) {\n      await swapElements(dragged, draggedOver, { ignoreMove: true });\n    } else {\n      await moveElement(dragged, {\n        to: draggedOver,\n        position: MH.isNodeBAfterA(dragged, draggedOver) ? \"after\" : \"before\",\n        ignoreMove: true,\n      });\n    }\n\n    for (const callback of callbacks) {\n      await callback.invoke(widget);\n    }\n  };\n\n  return {\n    _getSortedItems: getSortedItems,\n    _disableItem: disableItem,\n    _enableItem: enableItem,\n    _toggleItem: toggleItem,\n    _isItemDisabled: isItemDisabled,\n    _onMove: onMove,\n    _dragItemOnto: dragItemOnto,\n  };\n};\n"],"mappings":"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","ignoreList":[]}