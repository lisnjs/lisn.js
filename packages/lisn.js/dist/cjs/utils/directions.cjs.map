{"version":3,"file":"directions.cjs","names":["MC","_interopRequireWildcard","require","MH","_math","_validation","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getMaxDeltaDirection","deltaX","deltaY","abs","S_NONE","S_AMBIGUOUS","S_LEFT","S_RIGHT","S_UP","S_DOWN","exports","getVectorDirection","vector","angleDiffThreshold","min","maxAbs","areParallel","getOppositeDirection","direction","OPPOSITE_DIRECTIONS","usageError","getOppositeXYDirections","directions","directionList","validateStrList","isValidXYDirection","opposites","opposite","includes","push","lengthOf","XY_DIRECTIONS","isValidZDirection","Z_DIRECTIONS","isValidDirection","DIRECTIONS","isValidDirectionList","isValidStrList","S_IN","S_OUT","SCROLL_DIRECTIONS"],"sources":["../../../src/ts/utils/directions.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  XYDirection,\n  ZDirection,\n  NoDirection,\n  AmbiguousDirection,\n  CommaSeparatedStr,\n  Vector,\n} from \"@lisn/globals/types\";\n\nimport { maxAbs, areParallel } from \"@lisn/utils/math\";\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\n/**\n * Returns the cardinal direction in the XY plane for the larger of the two\n * deltas (horizontal vs vertical).\n *\n * If both deltas are 0, returns \"none\".\n *\n * If both deltas are equal and non-0, returns \"ambiguous\".\n *\n * @category Directions\n */\nexport const getMaxDeltaDirection = (\n  deltaX: number,\n  deltaY: number,\n): XYDirection | NoDirection | AmbiguousDirection => {\n  if (!MH.abs(deltaX) && !MH.abs(deltaY)) {\n    return MC.S_NONE;\n  }\n\n  if (MH.abs(deltaX) === MH.abs(deltaY)) {\n    return MC.S_AMBIGUOUS;\n  }\n\n  if (MH.abs(deltaX) > MH.abs(deltaY)) {\n    return deltaX < 0 ? MC.S_LEFT : MC.S_RIGHT;\n  }\n  return deltaY < 0 ? MC.S_UP : MC.S_DOWN;\n};\n\n/**\n * Returns the approximate direction of the given 2D vector as one of the\n * cardinal (XY plane) ones: \"up\", \"down\", \"left\" or \"right\"; or \"ambiguous\".\n *\n * @param {} angleDiffThreshold  See {@link areParallel} or\n *                               {@link Utils.areAntiParallel | areAntiParallel}.\n *                               This determines whether the inferred direction\n *                               is ambiguous. For it to _not_ be ambiguous it\n *                               must align with one of the four cardinal\n *                               directions to within `angleDiffThreshold`.\n *                               It doesn't make sense for this value to be < 0\n *                               or >= 45 degrees. If it is, it's forced to be\n *                               positive (absolute) and <= 44.99.\n *\n * @category Directions\n */\nexport const getVectorDirection = (\n  vector: Vector,\n  angleDiffThreshold = 0,\n): XYDirection | AmbiguousDirection | NoDirection => {\n  angleDiffThreshold = MH.min(44.99, MH.abs(angleDiffThreshold));\n\n  if (!maxAbs(...vector)) {\n    return MC.S_NONE;\n  } else if (areParallel(vector, [1, 0], angleDiffThreshold)) {\n    return MC.S_RIGHT;\n  } else if (areParallel(vector, [0, 1], angleDiffThreshold)) {\n    return MC.S_DOWN;\n  } else if (areParallel(vector, [-1, 0], angleDiffThreshold)) {\n    return MC.S_LEFT;\n  } else if (areParallel(vector, [0, -1], angleDiffThreshold)) {\n    return MC.S_UP;\n  }\n\n  return MC.S_AMBIGUOUS;\n};\n\n/**\n * Returns the opposite direction to the given direction or null if the given\n * direction has no opposite.\n *\n * @example\n * ```javascript\n * getOppositeDirection(\"up\"); // -> \"down\"\n * getOppositeDirection(\"down\"); // -> \"up\"\n * getOppositeDirection(\"left\"); // -> \"right\"\n * getOppositeDirection(\"right\"); // -> \"left\"\n * getOppositeDirection(\"none\"); // -> null\n * getOppositeDirection(\"ambiguous\"); // -> null\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeDirection = (\n  direction: Direction,\n): Direction | null => {\n  if (!(direction in OPPOSITE_DIRECTIONS)) {\n    throw MH.usageError(\"Invalid 'direction'\");\n  }\n\n  return OPPOSITE_DIRECTIONS[direction];\n};\n\n/**\n * Returns the set of directions which are opposite to the given set of directions.\n *\n * There are two sets of opposite pairs (\"up\"/\"down\" and \"left\"/\"right\") and at\n * least one of the two opposing directions of a pair must be present for the\n * other one to be included. If both directions that constitute a pair of\n * opposites is given, then the other pair is returned instead (minus any that\n * are present in the input). See examples below for clarification.\n *\n * @example\n * ```javascript\n * getOppositeXYDirections(\"up\"); // -> [\"down\"]\n * getOppositeXYDirections(\"left\"); // -> [\"right\"]\n * getOppositeXYDirections(\"up,down\"); // -> [\"left\",\"right\"]\n * getOppositeXYDirections(\"up,left\"); // -> [\"down\",\"right\"]\n * getOppositeXYDirections(\"up,left,right\"); // -> [\"down\"]\n * getOppositeXYDirections(\"none\"); // -> throws\n * getOppositeXYDirections(\"ambiguous\"); // -> throws\n * getOppositeXYDirections(\"in\"); // -> throws\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeXYDirections = (\n  directions: CommaSeparatedStr<XYDirection> | XYDirection[],\n): XYDirection[] => {\n  const directionList = validateStrList(\n    \"directions\",\n    directions,\n    isValidXYDirection,\n  );\n\n  if (!directionList) {\n    throw MH.usageError(\"'directions' is required\");\n  }\n\n  const opposites: XYDirection[] = [];\n  for (const direction of directionList) {\n    const opposite = getOppositeDirection(direction);\n    if (\n      opposite &&\n      isValidXYDirection(opposite) &&\n      !MH.includes(directionList, opposite)\n    ) {\n      opposites.push(opposite);\n    }\n  }\n\n  if (!MH.lengthOf(opposites)) {\n    for (const direction of XY_DIRECTIONS) {\n      if (!MH.includes(directionList, direction)) {\n        opposites.push(direction);\n      }\n    }\n  }\n\n  return opposites;\n};\n\n/**\n * Returns true if the given direction is one of the known XY ones.\n *\n * @category Validation\n */\nexport const isValidXYDirection = (\n  direction: string,\n): direction is XYDirection => MH.includes(XY_DIRECTIONS, direction);\n\n/**\n * Returns true if the given direction is one of the known Z ones.\n *\n * @category Validation\n */\nexport const isValidZDirection = (direction: string): direction is ZDirection =>\n  MH.includes(Z_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string is a valid direction.\n *\n * @category Validation\n */\nexport const isValidDirection = (direction: string): direction is Direction =>\n  MH.includes(DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid directions.\n *\n * @category Validation\n */\nexport const isValidDirectionList = (\n  directions: string | string[],\n): directions is CommaSeparatedStr<Direction> | Direction[] =>\n  isValidStrList(directions, isValidDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const XY_DIRECTIONS = [\n  MC.S_UP,\n  MC.S_DOWN,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const Z_DIRECTIONS = [MC.S_IN, MC.S_OUT] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const SCROLL_DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  ...Z_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n// --------------------\n\nconst OPPOSITE_DIRECTIONS = {\n  [MC.S_UP]: MC.S_DOWN,\n  [MC.S_DOWN]: MC.S_UP,\n  [MC.S_LEFT]: MC.S_RIGHT,\n  [MC.S_RIGHT]: MC.S_LEFT,\n  [MC.S_IN]: MC.S_OUT,\n  [MC.S_OUT]: MC.S_IN,\n  [MC.S_NONE]: null,\n  [MC.S_AMBIGUOUS]: null,\n} as const;\n"],"mappings":"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","ignoreList":[]}