{"version":3,"file":"sortable.js","names":["MC","MH","addClasses","removeClasses","getBooleanData","setBooleanData","unsetBooleanData","delData","copyStyle","setNumericStyleProps","moveElement","swapElements","cloneElement","waitForMeasureTime","getVisibleContentChildren","addEventListenerTo","removeEventListenerFrom","preventSelect","undoPreventSelect","toInt","validateString","wrapCallback","Widget","registerWidget","getDefaultWidgetSelector","Sortable","get","element","instance","DUMMY_ID","isInstanceOf","register","WIDGET_NAME","config","configValidator","constructor","_Sortable$get","destroyPromise","destroy","id","_defineProperty","items","lengthOf","push","querySelectorAll","PREFIX_ITEM__FOR_SELECT","S_DRAGGABLE","usageError","methods","getMethods","promiseResolve","then","isDestroyed","init","disableItem","_disableItem","enableItem","_enableItem","toggleItem","_toggleItem","isItemDisabled","_isItemDisabled","onMove","_onMove","getItems","currentOrder","_getSortedItems","PREFIXED_NAME","prefixName","PREFIX_IS_DRAGGABLE","PREFIX_ITEM","PREFIX_FLOATING_CLONE","mode","key","value","v","touchMoveOptions","passive","capture","isItemDraggable","item","widget","currentDraggedItem","floatingClone","ignoreCancel","grabOffset","setIgnoreCancel","onDragStart","event","currTarget","currentTargetOf","isElement","isMouseEvent","setAttr","isTouchPointerEvent","target","targetOf","releasePointerCapture","pointerId","getDoc","S_TOUCHMOVE","onTouchMove","rect","getBoundingClientRect","clientX","left","clientY","top","onDragEnd","type","S_POINTERCANCEL","unsetAttr","isTouchEvent","touches","parentEl","parentOf","preventDefault","touch","to","_units","onDragEnter","dragged","S_DRAGENTER","_dragItemOnto","setupEvents","S_POINTERDOWN","S_DRAGSTART","S_POINTERENTER","S_DRAGOVER","S_DRAGEND","S_DROP","S_POINTERUP","onEnable","onDisable","onDestroy","doSwap","disabledItems","callbacks","newSet","getSortedItems","sort","a","b","isNodeBAfterA","getOrigItemNumber","itemNum","indexOf","isDisabled","handler","add","dragItemOnto","draggedOver","ignoreMove","position","callback","invoke"],"sources":["../../../src/ts/widgets/sortable.ts"],"sourcesContent":["/**\n * @module Widgets\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  addClasses,\n  removeClasses,\n  getBooleanData,\n  setBooleanData,\n  unsetBooleanData,\n  delData,\n  copyStyle,\n  setNumericStyleProps,\n} from \"@lisn/utils/css-alter\";\nimport { moveElement, swapElements, cloneElement } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { getVisibleContentChildren } from \"@lisn/utils/dom-query\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { toInt } from \"@lisn/utils/math\";\nimport { validateString } from \"@lisn/utils/validation\";\n\nimport { wrapCallback } from \"@lisn/modules/callback\";\n\nimport {\n  Widget,\n  WidgetConfigValidatorObject,\n  WidgetCallback,\n  WidgetHandler,\n  registerWidget,\n  getDefaultWidgetSelector,\n} from \"@lisn/widgets/widget\";\n\n/**\n * Configures the given element as a {@link Sortable} widget.\n *\n * The Sortable widget allows the user to reorder elements by dragging and\n * dropping. It works on touch devices as well. However, it does not yet\n * support automatic scrolling when dragging beyond edge of screen on mobile\n * devices. For this, you may want to use\n * {@link https://github.com/SortableJS/Sortable | SortableJS} instead.\n *\n * The widget should have more than one draggable item.\n *\n * **IMPORTANT:** You should not instantiate more than one {@link Sortable}\n * widget on a given element. Use {@link Sortable.get} to get an existing\n * instance if any. If there is already a widget instance, it will be destroyed!\n *\n * -----\n *\n * You can use the following dynamic attributes or CSS properties in your\n * stylesheet:\n *\n * The following dynamic attributes are set on each item element:\n * - `data-lisn-is-draggable`: `\"true\"` or `\"false\"` (false if the item is disabled)\n *\n * -----\n *\n * To use with auto-widgets (HTML API) (see\n * {@link Settings.settings.autoWidgets | settings.autoWidgets}), the following\n * CSS classes or data attributes are recognized:\n * - `lisn-sortable` class or `data-lisn-sortable` attribute set on the\n *   container element that constitutes the sortable container\n * - `lisn-sortable-item` class or `data-lisn-sortable-item` attribute set on\n *   elements that should act as the items.\n *\n * When using auto-widgets, the elements that will be used as items are\n * discovered in the following way:\n * 1. The top-level element that constitutes the widget is searched for any\n *    elements that contain the `lisn-sortable-item` class or\n *    `data-lisn-sortable-item` attribute. They do not have to be immediate\n *    children of the root element.\n * 2. If there are no such elements, all of the immediate children of the\n *    widget element (other than `script` and `style` elements) are taken as\n *    the items.\n *\n * @example\n * ```html\n * <div class=\"lisn-sortable\">\n *   <div class=\"box\">Item 1</div>\n *   <div class=\"box\">Item 2</div>\n *   <div class=\"box\">Item 3</div>\n *   <div class=\"box\">Item 4</div>\n * </div>\n * ```\n */\nexport class Sortable extends Widget {\n  /**\n   * Disables the given item number. Note that item numbers start at 1.\n   *\n   * @param {} currentOrder If false (default), the item numbers refer to the\n   *                        original order. If true, they refer to the current\n   *                        document order.\n   */\n  readonly disableItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Re-enables the given item number. Note that item numbers start at 1.\n   *\n   * @param {} currentOrder If false (default), the item numbers refer to the\n   *                        original order. If true, they refer to the current\n   *                        document order.\n   */\n  readonly enableItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Re-enables the given item number if it is disabled, otherwise disables it.\n   * Note that item numbers start at 1.\n   *\n   * @param {} currentOrder If false (default), the item numbers refer to the\n   *                        original order. If true, they refer to the current\n   *                        document order.\n   */\n  readonly toggleItem: (\n    itemNum: number,\n    currentOrder?: boolean,\n  ) => Promise<void>;\n\n  /**\n   * Returns true if the given item number is disabled. Note that item numbers\n   * start at 1.\n   *\n   * @param {} currentOrder If false (default), the item numbers refer to the\n   *                        original order. If true, they refer to the current\n   *                        document order.\n   */\n  readonly isItemDisabled: (itemNum: number, currentOrder?: boolean) => boolean;\n\n  /**\n   * The given handler will be called whenever the user moves an item to\n   * another position. It will be called after the item is moved so\n   * {@link getItems} called with `currentOrder = true` will return the updated\n   * order.\n   *\n   * If the handler returns a promise, it will be awaited upon.\n   */\n  readonly onMove: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns the item elements.\n   *\n   * @param {} currentOrder If false (default), returns the items in the\n   *                        original order. If true, they are returned in the\n   *                        current document order.\n   */\n  readonly getItems: (currentOrder?: boolean) => Element[];\n\n  static get(element: Element): Sortable | null {\n    const instance = super.get(element, DUMMY_ID);\n    if (MH.isInstanceOf(instance, Sortable)) {\n      return instance;\n    }\n    return null;\n  }\n\n  static register() {\n    registerWidget(\n      WIDGET_NAME,\n      (element, config) => {\n        if (!Sortable.get(element)) {\n          return new Sortable(element, config);\n        }\n        return null;\n      },\n      configValidator,\n    );\n  }\n\n  /**\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If there are less than 2 items given or found.\n   */\n  constructor(element: Element, config?: SortableConfig) {\n    const destroyPromise = Sortable.get(element)?.destroy();\n    super(element, { id: DUMMY_ID });\n\n    const items = config?.items || [];\n    if (!MH.lengthOf(items)) {\n      items.push(\n        ...MH.querySelectorAll(\n          element,\n          getDefaultWidgetSelector(PREFIX_ITEM__FOR_SELECT),\n        ),\n      );\n\n      if (!MH.lengthOf(items)) {\n        items.push(...MH.querySelectorAll(element, `[${MC.S_DRAGGABLE}]`));\n\n        if (!MH.lengthOf(items)) {\n          items.push(...getVisibleContentChildren(element));\n        }\n      }\n    }\n\n    if (MH.lengthOf(items) < 2) {\n      throw MH.usageError(\"Sortable must have more than 1 item\");\n    }\n\n    const methods = getMethods(this, items, config);\n\n    (destroyPromise || MH.promiseResolve()).then(() => {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      init(this, element, items, methods);\n    });\n\n    this.disableItem = methods._disableItem;\n    this.enableItem = methods._enableItem;\n    this.toggleItem = methods._toggleItem;\n    this.isItemDisabled = methods._isItemDisabled;\n    this.onMove = methods._onMove;\n\n    this.getItems = (currentOrder = false) =>\n      currentOrder ? methods._getSortedItems() : [...items];\n  }\n}\n\n/**\n * @interface\n */\nexport type SortableConfig = {\n  /**\n   * The elements that will be used as the draggable items.\n   *\n   * The widget should have more than one draggable item.\n   *\n   * If this is not specified, then\n   * 1. The top-level element that constitutes the widget is searched for any\n   *    elements that contain the class `lisn-sortable-item`. They do not\n   *    have to be immediate children of the root element.\n   * 2. If there are no such elements, all of the immediate children of the\n   *    widget element (other than `script` and `style` elements) are taken as\n   *    the items.\n   */\n  items?: Element[];\n\n  /**\n   * Whether to move the dragged item to before/after the drop target, or swap\n   * it with the drop target.\n   *\n   * Note that the moving/swapping action is being done as the user is dragging\n   * as soon as they drag over another item, so in order to achieve a swap\n   * effect, the user needs to be able to drag an item from one location to\n   * another without the path of the mouse crossing over all in-between items.\n   *\n   * @defaultValue \"move\";\n   */\n  mode?: \"move\" | \"swap\";\n};\n\n// --------------------\n\nconst WIDGET_NAME = \"sortable\";\nconst PREFIXED_NAME = MH.prefixName(WIDGET_NAME);\nconst PREFIX_IS_DRAGGABLE = MH.prefixName(\"is-draggable\");\n\n// Use different classes for styling items to the one used for auto-discovering\n// them, so that re-creating existing widgets can correctly find the items to\n// be used by the new widget synchronously before the current one is destroyed.\nconst PREFIX_ITEM = `${PREFIXED_NAME}__item`;\nconst PREFIX_ITEM__FOR_SELECT = `${PREFIXED_NAME}-item`;\n\nconst PREFIX_FLOATING_CLONE = `${PREFIXED_NAME}__ghost`;\n\n// Only one Sortable widget per element is allowed, but Widget requires a\n// non-blank ID.\n// In fact, it doesn't make much sense to have more than 1 scroll-to-top button\n// on the whole page, but we support it, hence use a class rather than a DOM ID.\nconst DUMMY_ID = PREFIXED_NAME;\n\nconst configValidator: WidgetConfigValidatorObject<SortableConfig> = {\n  mode: (key, value) =>\n    validateString(key, value, (v) => v === \"swap\" || v === \"move\"),\n};\n\nconst touchMoveOptions = { passive: false, capture: true };\n\nconst isItemDraggable = (item: Element) =>\n  getBooleanData(item, PREFIX_IS_DRAGGABLE);\n\nconst init = (\n  widget: Sortable,\n  element: Element,\n  items: Element[],\n  methods: ReturnType<typeof getMethods>,\n) => {\n  let currentDraggedItem: Element | null = null;\n  let floatingClone: Element | null = null;\n  let ignoreCancel = false;\n  let grabOffset = [0, 0];\n\n  const setIgnoreCancel = () => (ignoreCancel = true);\n\n  const onDragStart = (event: Event) => {\n    const currTarget = MH.currentTargetOf(event);\n\n    if (\n      MH.isElement(currTarget) &&\n      isItemDraggable(currTarget) &&\n      MH.isMouseEvent(event)\n    ) {\n      currentDraggedItem = currTarget;\n      MH.setAttr(currTarget, MC.S_DRAGGABLE);\n\n      if (MH.isTouchPointerEvent(event)) {\n        const target = MH.targetOf(event);\n        if (MH.isElement(target)) {\n          target.releasePointerCapture(event.pointerId);\n        }\n      }\n\n      addEventListenerTo(\n        MH.getDoc(),\n        MC.S_TOUCHMOVE,\n        onTouchMove,\n        touchMoveOptions,\n      );\n\n      waitForMeasureTime().then(() => {\n        // Get pointer offset relative to the current item being dragged\n        // regardless of what the event target is and what transforms is has\n        // applied.\n        const rect = MH.getBoundingClientRect(currTarget);\n        grabOffset = [event.clientX - rect.left, event.clientY - rect.top];\n      });\n    }\n  };\n\n  const onDragEnd = (event: Event) => {\n    if (ignoreCancel && event.type === MC.S_POINTERCANCEL) {\n      ignoreCancel = false;\n      return;\n    }\n\n    if (currentDraggedItem) {\n      MH.unsetAttr(currentDraggedItem, MC.S_DRAGGABLE);\n      currentDraggedItem = null;\n\n      removeEventListenerFrom(\n        MH.getDoc(),\n        MC.S_TOUCHMOVE,\n        onTouchMove,\n        touchMoveOptions,\n      );\n\n      if (floatingClone) {\n        moveElement(floatingClone);\n        floatingClone = null;\n      }\n    }\n  };\n\n  const onTouchMove = (event: Event) => {\n    if (MH.isTouchEvent(event) && MH.lengthOf(event.touches) === 1) {\n      const parentEl = MH.parentOf(currentDraggedItem);\n      if (parentEl && currentDraggedItem) {\n        MH.preventDefault(event);\n\n        const touch = event.touches[0];\n        const clientX = touch.clientX;\n        const clientY = touch.clientY;\n\n        if (!floatingClone) {\n          floatingClone = cloneElement(currentDraggedItem);\n          addClasses(floatingClone, PREFIX_FLOATING_CLONE);\n          copyStyle(currentDraggedItem, floatingClone, [\n            \"width\",\n            \"height\",\n          ]).then(() => {\n            if (floatingClone) {\n              moveElement(floatingClone, { to: parentEl });\n            }\n          });\n        }\n\n        if (floatingClone) {\n          setNumericStyleProps(\n            floatingClone,\n            {\n              clientX: clientX - grabOffset[0],\n              clientY: clientY - grabOffset[1],\n            },\n            { _units: \"px\" },\n          );\n        }\n      }\n    }\n  };\n\n  const onDragEnter = (event: Event) => {\n    const currTarget = MH.currentTargetOf(event);\n    const dragged = currentDraggedItem;\n\n    if (\n      (MH.isTouchPointerEvent(event) || event.type === MC.S_DRAGENTER) &&\n      dragged &&\n      MH.isElement(currTarget) &&\n      currTarget !== dragged\n    ) {\n      methods._dragItemOnto(dragged, currTarget); // no need to await\n    }\n  };\n\n  const setupEvents = () => {\n    for (const item of items) {\n      preventSelect(item);\n\n      addEventListenerTo(item, MC.S_POINTERDOWN, onDragStart);\n\n      addEventListenerTo(item, MC.S_DRAGSTART, setIgnoreCancel); // non-touch\n\n      addEventListenerTo(item, MC.S_POINTERENTER, onDragEnter); // touch\n      addEventListenerTo(item, MC.S_DRAGENTER, onDragEnter); // non-touch\n\n      addEventListenerTo(item, MC.S_DRAGOVER, MH.preventDefault); // non-touch\n\n      addEventListenerTo(item, MC.S_DRAGEND, onDragEnd); // non-touch\n      addEventListenerTo(item, MC.S_DROP, onDragEnd); // non-touch\n\n      addEventListenerTo(MH.getDoc(), MC.S_POINTERUP, onDragEnd);\n      addEventListenerTo(MH.getDoc(), MC.S_POINTERCANCEL, onDragEnd);\n    }\n  };\n\n  // SETUP ------------------------------\n\n  for (const item of items) {\n    addClasses(item, PREFIX_ITEM);\n    setBooleanData(item, PREFIX_IS_DRAGGABLE);\n  }\n\n  widget.onEnable(setupEvents);\n\n  widget.onDisable(() => {\n    for (const item of items) {\n      undoPreventSelect(item);\n\n      removeEventListenerFrom(item, MC.S_POINTERDOWN, onDragStart);\n\n      removeEventListenerFrom(item, MC.S_DRAGSTART, setIgnoreCancel);\n\n      removeEventListenerFrom(item, MC.S_POINTERENTER, onDragEnter);\n      removeEventListenerFrom(item, MC.S_DRAGENTER, onDragEnter);\n\n      removeEventListenerFrom(item, MC.S_DRAGOVER, MH.preventDefault);\n\n      removeEventListenerFrom(item, MC.S_POINTERUP, onDragEnd);\n      removeEventListenerFrom(item, MC.S_POINTERCANCEL, onDragEnd);\n      removeEventListenerFrom(item, MC.S_DRAGEND, onDragEnd);\n      removeEventListenerFrom(item, MC.S_DROP, onDragEnd);\n    }\n  });\n\n  widget.onDestroy(async () => {\n    for (const item of items) {\n      await removeClasses(item, PREFIX_ITEM);\n      await delData(item, PREFIX_IS_DRAGGABLE);\n    }\n  });\n\n  setupEvents();\n};\n\nconst getMethods = (\n  widget: Sortable,\n  items: Element[],\n  config: SortableConfig | undefined,\n) => {\n  const doSwap = config?.mode === \"swap\";\n\n  const disabledItems: Record<number, boolean> = {};\n  const callbacks = MH.newSet<WidgetCallback>();\n\n  const getSortedItems = () =>\n    [...items].sort((a, b) => (MH.isNodeBAfterA(a, b) ? -1 : 1));\n\n  const getOrigItemNumber = (itemNum: number, currentOrder = false) =>\n    currentOrder ? items.indexOf(getSortedItems()[itemNum - 1]) + 1 : itemNum;\n\n  const isItemDisabled = (itemNum: number, currentOrder = false) =>\n    disabledItems[getOrigItemNumber(itemNum, currentOrder)] === true;\n\n  const disableItem = async (itemNum: number, currentOrder = false) => {\n    itemNum = getOrigItemNumber(toInt(itemNum), currentOrder);\n    if (widget.isDisabled() || itemNum < 1 || itemNum > MH.lengthOf(items)) {\n      return;\n    }\n\n    // set immediately for toggle to work without awaiting on it\n    disabledItems[itemNum] = true;\n    await unsetBooleanData(items[itemNum - 1], PREFIX_IS_DRAGGABLE);\n  };\n\n  const enableItem = async (itemNum: number, currentOrder = false) => {\n    itemNum = getOrigItemNumber(toInt(itemNum), currentOrder);\n    if (widget.isDisabled() || !isItemDisabled(itemNum)) {\n      return;\n    }\n\n    // set immediately for toggle to work without awaiting on it\n    disabledItems[itemNum] = false;\n    await setBooleanData(items[itemNum - 1], PREFIX_IS_DRAGGABLE);\n  };\n\n  const toggleItem = (itemNum: number, currentOrder = false) =>\n    isItemDisabled(itemNum, currentOrder)\n      ? enableItem(itemNum, currentOrder)\n      : disableItem(itemNum, currentOrder);\n\n  const onMove = (handler: WidgetHandler) =>\n    callbacks.add(wrapCallback(handler));\n\n  // This is internal only for now...\n  const dragItemOnto = async (dragged: Element, draggedOver: Element) => {\n    if (doSwap) {\n      await swapElements(dragged, draggedOver, { ignoreMove: true });\n    } else {\n      await moveElement(dragged, {\n        to: draggedOver,\n        position: MH.isNodeBAfterA(dragged, draggedOver) ? \"after\" : \"before\",\n        ignoreMove: true,\n      });\n    }\n\n    for (const callback of callbacks) {\n      await callback.invoke(widget);\n    }\n  };\n\n  return {\n    _getSortedItems: getSortedItems,\n    _disableItem: disableItem,\n    _enableItem: enableItem,\n    _toggleItem: toggleItem,\n    _isItemDisabled: isItemDisabled,\n    _onMove: onMove,\n    _dragItemOnto: dragItemOnto,\n  };\n};\n"],"mappings":"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","ignoreList":[]}