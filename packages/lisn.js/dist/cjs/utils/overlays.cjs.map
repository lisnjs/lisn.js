{"version":3,"file":"overlays.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_cssAlter","_domAlter","_domEvents","_domOptimize","_log","_text","_scroll","_xMap","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","getOverlay","userOptions","_overlays$get","options","tryGetOverlayOptions","overlays","_parent","_overlayKey","exports","createOverlay","fetchOverlayOptions","canReuse","_id","_overlays$get2","existingOverlay","parentOf","waitForMutateTime","overlay","createOnlyOverlay","sGet","id","isPercentageHOffset","includes","_style","left","right","isPercentageVOffset","top","bottom","needsContentWrapping","parentEl","isScrollable","axis","settings","contentWrappingAllowed","wrapScrollingContent","logWarn","position","S_ABSOLUTE","addClasses","prefixName","moveElement","to","newXWeakMap","newMap","_userOptions$data","_userOptions$id","style","getCssProperties","data","tryGetParent","parent","_data","getOverlayKey","_userOptions$data2","_userOptions$id2","fetchParent","objToStrKey","finalCssProperties","merge","S_FIXED","isEmpty","userSuppliedParent","getBody","tryGetMainContentElement","waitForElement","fetchMainContentElement","createElement","addClassesNow","attr","keysOf","setDataNow","camelToKebabCase","prop","setStylePropNow"],"sources":["../../../src/ts/utils/overlays.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  addClasses,\n  addClassesNow,\n  setDataNow,\n  setStylePropNow,\n} from \"@lisn/utils/css-alter\";\nimport { moveElement, wrapScrollingContent } from \"@lisn/utils/dom-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { waitForMutateTime } from \"@lisn/utils/dom-optimize\";\nimport { logWarn } from \"@lisn/utils/log\";\nimport { camelToKebabCase, objToStrKey } from \"@lisn/utils/text\";\nimport {\n  isScrollable,\n  tryGetMainContentElement,\n  fetchMainContentElement,\n} from \"@lisn/utils/scroll\";\n\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Overlays\n * @interface\n */\nexport type OverlayOptions = {\n  /**\n   * The parent element to insert the overlay into.\n   *\n   * If not given, then:\n   * - if the overlay is to have a `position: fixed`, then `document.body` is used\n   * - otherwise,\n   *   {@link Watchers/ScrollWatcher.ScrollWatcher.fetchMainContentElement | ScrollWatcher.fetchMainContentElement} is\n   *   used\n   */\n  parent?: HTMLElement;\n\n  /**\n   * If set, then it will be assigned as the DOM element ID for the new\n   * overlay.\n   *\n   * Furthermore, the new overlay will be created and will not be saved for\n   * future reuse.\n   *\n   * By default, if `id` is not given, the overlay will be saved, and if\n   * {@link createOverlay} is called again with the same `style`, `data` and\n   * parent, the previous overlay is returned.\n   */\n  id?: string;\n\n  /**\n   * Every entry in this object will be set on the `style` of the new overlay.\n   *\n   * **IMPORTANT:** By default overlays are positioned absolutely, so if you need\n   * another positioning, override this here by setting a `position` key in\n   * `style`. If position is either \"absolute\" (by default or explicitly set) or\n   * \"fixed\", and none of `top` or `bottom` is given, `top: 0` is set; and\n   * similarly, if none of `left` or `right` is given, `left: 0` is set.\n   */\n  style?: Record<string, string>;\n\n  /**\n   * Every entry in this object will be set as a data attribute on the new\n   * overlay.\n   *\n   * Keys can be either kebab-case or camelCase (they will be converted if\n   * needed). Do _not_ include the \"data-\" prefix which will be added\n   * automatically. E.g. both \"foo-bar\" and \"fooBar\" will result in\n   * \"data-foo-bar\" being set.\n   */\n  data?: Record<string, string>;\n};\n\n/**\n * Returns an existing overlay for this specification. If the overlay was just\n * created it may not yet be attached to the DOM.\n *\n * @category Overlays\n */\nexport const getOverlay = (userOptions?: OverlayOptions) => {\n  const options = tryGetOverlayOptions(userOptions);\n  if (!options) {\n    return null;\n  }\n\n  return overlays.get(options._parent)?.get(options._overlayKey) || null;\n};\n\n/**\n * Creates a new overlay, and inserts it into the DOM as soon as\n * {@link waitForMutateTime} resolves, or returns an already existing matching\n * overlay.\n *\n * **Note** that if {@link OverlayOptions.id} is set, a new overlay will\n * _always_ be created.\n *\n * @category Overlays\n */\nexport const createOverlay = async (userOptions?: OverlayOptions) => {\n  const options = await fetchOverlayOptions(userOptions);\n  const canReuse = !options._id;\n\n  if (canReuse) {\n    const existingOverlay = overlays\n      .get(options._parent)\n      ?.get(options._overlayKey);\n\n    if (existingOverlay) {\n      if (!MH.parentOf(existingOverlay)) {\n        // not yet inserted into the DOM, so wait until it is\n        await waitForMutateTime();\n      }\n      return existingOverlay;\n    }\n  }\n\n  // Create a new one\n  const overlay = createOnlyOverlay(options);\n  if (canReuse) {\n    // Save it now before awating, so that concurrent requests to create the\n    // same one use it\n    overlays.sGet(options._parent).set(options._overlayKey, overlay);\n  } else {\n    overlay.id = options._id;\n  }\n\n  const isPercentageHOffset = MH.includes(\n    (options._style.left || \"\") + (options._style.right || \"\"),\n    \"%\",\n  );\n\n  const isPercentageVOffset = MH.includes(\n    (options._style.top || \"\") + (options._style.bottom || \"\"),\n    \"%\",\n  );\n\n  let needsContentWrapping = false;\n  let parentEl = options._parent;\n  if (isPercentageHOffset || isPercentageVOffset) {\n    needsContentWrapping =\n      (isPercentageHOffset && isScrollable(parentEl, { axis: \"x\" })) ||\n      (isPercentageVOffset && isScrollable(parentEl, { axis: \"y\" }));\n  }\n\n  if (needsContentWrapping) {\n    if (settings.contentWrappingAllowed) {\n      parentEl = await wrapScrollingContent(parentEl);\n    } else {\n      logWarn(\n        \"Percentage offset view trigger with scrolling root requires contentWrappingAllowed\",\n      );\n    }\n  }\n\n  if (options._style.position === MC.S_ABSOLUTE) {\n    // Ensure parent has non-static positioning\n    addClasses(parentEl, MH.prefixName(\"overlay-container\"));\n  }\n\n  await moveElement(overlay, { to: parentEl });\n\n  return overlay;\n};\n\n// ----------------------------------------\n\ntype OverlayOptionsInternal = {\n  _parent: HTMLElement;\n  _id: string;\n  _style: Record<string, string>;\n  _data: Record<string, string>;\n  _overlayKey: string;\n};\n\nconst overlays = newXWeakMap<HTMLElement, Map<string, HTMLElement>>(() =>\n  MH.newMap(),\n);\n\nconst tryGetOverlayOptions = (\n  userOptions: OverlayOptions | undefined,\n): OverlayOptionsInternal | null => {\n  const style = getCssProperties(userOptions?.style);\n  const data = userOptions?.data ?? {};\n  const parentEl = tryGetParent(userOptions?.parent, style.position);\n  if (!parentEl) {\n    return null;\n  }\n\n  return {\n    _parent: parentEl,\n    _id: userOptions?.id ?? \"\",\n    _style: style,\n    _data: data,\n    _overlayKey: getOverlayKey(style, data),\n  };\n};\n\nconst fetchOverlayOptions = async (\n  userOptions: OverlayOptions | undefined,\n): Promise<OverlayOptionsInternal> => {\n  const style = getCssProperties(userOptions?.style);\n  const data = userOptions?.data ?? {};\n  const parentEl = await fetchParent(userOptions?.parent, style.position);\n\n  return {\n    _parent: parentEl,\n    _id: userOptions?.id ?? \"\",\n    _style: style,\n    _data: data,\n    _overlayKey: getOverlayKey(style, data),\n  };\n};\n\nconst getOverlayKey = (\n  style: Record<string, string>,\n  data: Record<string, string>,\n) => objToStrKey(style) + \"|\" + objToStrKey(data);\n\nconst getCssProperties = (style: Record<string, string> | undefined) => {\n  const finalCssProperties: Record<string, string> = MH.merge(\n    { position: MC.S_ABSOLUTE }, // default\n    style,\n  );\n\n  if (\n    finalCssProperties.position === MC.S_ABSOLUTE ||\n    finalCssProperties.position === MC.S_FIXED\n  ) {\n    if (\n      MH.isEmpty(finalCssProperties.top) &&\n      MH.isEmpty(finalCssProperties.bottom)\n    ) {\n      finalCssProperties.top = \"0px\";\n    }\n\n    if (\n      MH.isEmpty(finalCssProperties.left) &&\n      MH.isEmpty(finalCssProperties.right)\n    ) {\n      finalCssProperties.left = \"0px\";\n    }\n  }\n\n  return finalCssProperties;\n};\n\nconst tryGetParent = (\n  userSuppliedParent: HTMLElement | undefined | null,\n  position: string,\n) =>\n  userSuppliedParent ??\n  (position === MC.S_FIXED ? MH.getBody() : tryGetMainContentElement());\n\nconst fetchParent = async (\n  userSuppliedParent: HTMLElement | undefined | null,\n  position: string,\n) =>\n  userSuppliedParent ??\n  (position === MC.S_FIXED\n    ? await waitForElement(MH.getBody)\n    : await fetchMainContentElement());\n\nconst createOnlyOverlay = (options: OverlayOptionsInternal) => {\n  const overlay = MH.createElement(\"div\");\n\n  addClassesNow(overlay, MH.prefixName(\"overlay\"));\n\n  const data = options._data;\n  for (const attr of MH.keysOf(data)) {\n    setDataNow(overlay, camelToKebabCase(attr), data[attr]);\n  }\n\n  const style = options._style;\n  for (const prop of MH.keysOf(style)) {\n    setStylePropNow(overlay, prop, style[prop]);\n  }\n\n  return overlay;\n};\n"],"mappings":"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","ignoreList":[]}