{"version":3,"file":"dom-search.js","names":["MH","getData","waitForElement","logError","getReferenceElement","spec","thisElement","referenceElement","getElementById","slice","relation","find","p","startsWith","usageError","rest","lengthOf","matchOp","refOrCls","selector","PREFIX_REF","DATA_REF","getFirstReferenceElement","getLastReferenceElement","getThisReferenceElement","getNextReferenceElement","getPrevReferenceElement","bugError","waitForReferenceElement","timeout","prefixName","prefixData","getAllReferenceElements","docQuerySelectorAll","docQuerySelector","allRefs","closest","getNextOrPrevReferenceElement","goBackward","getDoc","contains","numRefs","refIndex","i","currentIsAfter","isNodeBAfterA"],"sources":["../../../src/ts/utils/dom-search.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Searching for reference elements\n * The functions allow you to find elements that match a given string\n * specification.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { logError } from \"@lisn/utils/log\";\n\n/**\n * Get the element that matches the given reference specification.\n *\n * The specification is of the form:\n *\n * ```\n * <FullSpec> ::=\n *     <Relation> \".\" <ClassName>  |\n *     <Relation> [\"-\" <ReferenceName>] |\n *     #<DOM_ID>\n *\n * <Relation> :==\n *     \"next\"  |\n *     \"prev\"  |\n *     \"this\"  |\n *     \"first\" |\n *     \"last\"\n * ```\n *\n * - `<DOM_ID>` is the unique ID of the element\n * - `<ClassName>` is a CSS class on the element\n * - `<ReferenceName>` is the value of the `data-lisn-ref` attribute on the\n *   element you are targeting. If not given, defaults to the value of the\n *   `data-lisn-ref` attribute on `thisElement`.\n *\n * There now follows an explanation of how \"next\", \"prev\", \"this\", \"first\" and\n * \"last\" search the DOM:\n * - \"next\": the tree is search in document order (depth first, then breadth),\n *   so the returned element could be a descendant of `thisElement`\n * - \"prev\": the tree is search in document order (depth first, then breadth),\n *   but excluding ancestors of `thisElement`, so the returned element is\n *   guaranteed to _not_ be an ancestor or descendant of `thisElement`.\n * - \"this\": if the given element itself matches the specification, it is\n *   returned, otherwise the closest ancestor of the given element that matches\n *   the specification\n * - \"first\": the first element matching; the tree is search in document order\n *   (depth first, then breadth).\n * - \"last\": the last element matching; the tree is search in document order\n *   (depth first, then breadth).\n *\n * @category DOM: Searching for reference elements\n *\n * @param thisElement The element to search relative to\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                        If the specification is invalid or if thisElement is\n *                        not given for a specification of \"next\", \"prev\" or \"this\"\n */\nexport const getReferenceElement = (\n  spec: string,\n  thisElement: Element,\n): Element | null => {\n  if (!spec) {\n    return thisElement;\n  }\n\n  if (spec[0] === \"#\") {\n    // element ID\n    const referenceElement = MH.getElementById(spec.slice(1));\n    if (!referenceElement) {\n      return null;\n    }\n    return referenceElement;\n  }\n\n  const relation = [\"next\", \"prev\", \"this\", \"first\", \"last\"].find(\n    (p) => spec.startsWith(`${p}.`) || spec.startsWith(`${p}-`) || spec === p,\n  );\n\n  if (!relation) {\n    throw MH.usageError(`Invalid search specification '${spec}'`);\n  }\n\n  const rest = spec.slice(MH.lengthOf(relation));\n  const matchOp = rest.slice(0, 1);\n  let refOrCls = rest.slice(1);\n\n  let selector: string;\n  if (matchOp === \".\") {\n    selector = matchOp + refOrCls;\n  } else {\n    if (!refOrCls) {\n      refOrCls = getData(thisElement, PREFIX_REF) || \"\";\n    }\n\n    if (!refOrCls) {\n      throw MH.usageError(`No reference name in '${spec}'`);\n    }\n\n    selector = `[${DATA_REF}=\"${refOrCls}\"]`;\n  }\n\n  let referenceElement;\n  if (relation === \"first\") {\n    referenceElement = getFirstReferenceElement(selector);\n  } else if (relation === \"last\") {\n    referenceElement = getLastReferenceElement(selector);\n  } else {\n    if (relation === \"this\") {\n      referenceElement = getThisReferenceElement(selector, thisElement);\n    } else if (relation === \"next\") {\n      referenceElement = getNextReferenceElement(selector, thisElement);\n    } else if (relation === \"prev\") {\n      referenceElement = getPrevReferenceElement(selector, thisElement);\n    } else {\n      /* istanbul ignore next */ {\n        logError(MH.bugError(`Unhandled relation case ${relation}`));\n        return null;\n      }\n    }\n  }\n\n  if (!referenceElement) {\n    return null;\n  }\n\n  return referenceElement;\n};\n\n/**\n * Like {@link getReferenceElement} excepts if no element matches the\n * specification if will wait for at most the given time for such an element.\n *\n * @category DOM: Searching for reference elements\n */\nexport const waitForReferenceElement = (\n  spec: string,\n  thisElement: Element,\n  timeout = 200,\n) => waitForElement(() => getReferenceElement(spec, thisElement), timeout);\n\n// ----------------------------------------\n\nconst PREFIX_REF = MH.prefixName(\"ref\");\nconst DATA_REF = MH.prefixData(PREFIX_REF);\n\nconst getAllReferenceElements = (\n  selector: string,\n): NodeListOf<Element> | null => MH.docQuerySelectorAll(selector);\n\nconst getFirstReferenceElement = (selector: string): Element | null =>\n  MH.docQuerySelector(selector);\n\nconst getLastReferenceElement = (selector: string): Element | null => {\n  const allRefs = getAllReferenceElements(selector);\n  return (allRefs && allRefs[MH.lengthOf(allRefs) - 1]) || null;\n};\n\nconst getThisReferenceElement = (\n  selector: string,\n  thisElement: Element,\n): Element | null => thisElement.closest(selector);\n\nconst getNextReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, false);\n\nconst getPrevReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, true);\n\nconst getNextOrPrevReferenceElement = (\n  selector: string,\n  thisElement: Element,\n  goBackward: boolean,\n): Element | null => {\n  thisElement = getThisReferenceElement(selector, thisElement) || thisElement;\n\n  if (!MH.getDoc().contains(thisElement)) {\n    return null;\n  }\n\n  const allRefs = getAllReferenceElements(selector);\n  if (!allRefs) {\n    return null;\n  }\n\n  const numRefs = MH.lengthOf(allRefs);\n  let refIndex = goBackward ? numRefs - 1 : -1;\n  for (let i = 0; i < numRefs; i++) {\n    const currentIsAfter = MH.isNodeBAfterA(thisElement, allRefs[i]);\n\n    // As soon as we find either the starting element or the first element\n    // that follows it, stop iteration.\n    // - If we're looking for the previous reference, then take the previous\n    //   element in the iteration.\n    // - Otherwise, if the current element in the iteration is the same as the\n    //   starting one, then take either the next element in the iteration.\n    //   - Otherwise, (if the current element follows the starting one, as\n    //     would happen if the starting element was not in the list of matched\n    //     elements, take the current element in the iteration.\n    if (allRefs[i] === thisElement || currentIsAfter) {\n      refIndex = i + (goBackward ? -1 : currentIsAfter ? 0 : 1);\n      break;\n    }\n  }\n\n  return allRefs[refIndex] || null;\n};\n"],"mappings":"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","ignoreList":[]}