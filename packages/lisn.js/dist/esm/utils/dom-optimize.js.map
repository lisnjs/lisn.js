{"version":3,"file":"dom-optimize.js","names":["MH","logError","scheduleHighPriorityTask","waitForMutateTime","newPromise","resolve","scheduleDOMTask","scheduledDOMMutations","waitForMeasureTime","scheduledDOMMeasurements","waitForSubsequentMutateTime","then","waitForSubsequentMeasureTime","asyncMutatorFor","func","args","asyncMeasurerFor","hasScheduledDOMTasks","queue","push","onAnimationFrame","runAllDOMTasks","lengthOf","runDOMTaskQueue","shift","err"],"sources":["../../../src/ts/utils/dom-optimize.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Preventing layout trashing\n *\n * {@link waitForMeasureTime} allows you to schedule tasks that read or\n * \"measure\", the DOM, for example getting computed styles, taking the\n * `offsetWidth` or the `scrollTop` of an element, etc... anything that _would_\n * force a layout if it runs after the layout has been invalidated by a\n * \"mutation\".\n *\n * See https://gist.github.com/paulirish/5d52fb081b3570c81e3 for a list of\n * operations that should be run on a valid layout to avoid forced layouts.\n *\n * {@link waitForMutateTime} allows you to schedule tasks that invalidate the\n * DOM layout by making changes to the style, inserting or removing elements,\n * etc.\n *\n * These ensure that:\n * - All mutation tasks that would invalidate the style run together before the\n *   next repaint.\n * - All measurement tasks that need a valid style will run as soon as possible\n *   after the next repaint.\n * - If a mutation task is scheduled by another mutation task, it will run in\n *   the same batch.\n * - If a measurement task is scheduled by either a mutation or another\n *   measurement task, it will run in the same batch.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { logError } from \"@lisn/utils/log\";\nimport { scheduleHighPriorityTask } from \"@lisn/utils/tasks\";\n\n/**\n * Returns a Promise that is resolved before the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMutateTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMutations, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved as soon as possible after the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMeasureTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMeasurements, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved before the repaint that follows the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMutateTime = () =>\n  waitForMutateTime().then(waitForMeasureTime).then(waitForMutateTime);\n\n/**\n * Returns a Promise that is resolved as soon as possible after the repaint\n * that follows the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMeasureTime = () =>\n  waitForMeasureTime().then(waitForMutateTime).then(waitForMeasureTime);\n\n/**\n * @ignore\n * @internal\n *\n * @since v1.2.0\n */\nexport const asyncMutatorFor =\n  <Args extends unknown[], Ret>(func: (...args: Args) => Ret) =>\n  async (...args: Args) =>\n    waitForMutateTime().then(() => func(...args));\n\n/**\n * @ignore\n * @internal\n *\n * @since v1.2.0\n */\nexport const asyncMeasurerFor =\n  <Args extends unknown[], Ret>(func: (...args: Args) => Ret) =>\n  async (...args: Args) =>\n    waitForMeasureTime().then(() => func(...args));\n\n// ----------------------------------------\n\ntype TaskResolver = () => void;\ntype DOMTaskQueue = TaskResolver[];\n\nconst scheduledDOMMeasurements: DOMTaskQueue = [];\nconst scheduledDOMMutations: DOMTaskQueue = [];\nlet hasScheduledDOMTasks = false;\n\nconst scheduleDOMTask = (queue: DOMTaskQueue, resolve: TaskResolver) => {\n  queue.push(resolve);\n  if (!hasScheduledDOMTasks) {\n    hasScheduledDOMTasks = true;\n    MH.onAnimationFrame(runAllDOMTasks);\n  }\n};\n\nconst runAllDOMTasks = async () => {\n  // We suspend (await null) after each queue to ensure that microtasks that\n  // have been added by await waitFor* or waitFor*().then run before the next\n  // queue, so that if they schedule more measurements and/or mutations, they\n  // can be flushed now, in the same batch.\n\n  // We're inside an animation frame. Run all mutation tasks now.\n  while (MH.lengthOf(scheduledDOMMutations)) {\n    runDOMTaskQueue(scheduledDOMMutations);\n    // wait for tasks awaiting on the resolved promises, then check queue again\n    await null;\n  }\n\n  // The measurement queue is now empty => scheduling measurements after\n  // this point will result in rescheduling both queues again in the next\n  // frame.\n  //\n  // Schedule the measurement tasks as soon as possible, after the upcoming\n  // paint. Use a macro task with as high priority as possible.\n  scheduleHighPriorityTask(async () => {\n    while (MH.lengthOf(scheduledDOMMeasurements)) {\n      runDOMTaskQueue(scheduledDOMMeasurements);\n      // wait for tasks awaiting on the resolved promises, then check queue again\n      await null;\n    }\n\n    if (MH.lengthOf(scheduledDOMMutations)) {\n      // There have been mutations added. Schedule another flush.\n      MH.onAnimationFrame(runAllDOMTasks);\n    } else {\n      hasScheduledDOMTasks = false;\n    }\n  });\n};\n\nconst runDOMTaskQueue = (queue: DOMTaskQueue) => {\n  let resolve: TaskResolver | undefined;\n  while ((resolve = queue.shift())) {\n    try {\n      resolve();\n    } catch (err) /* istanbul ignore next */ {\n      logError(err);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]}