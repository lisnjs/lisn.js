{"version":3,"file":"dom-events.js","names":["MH","settings","waitForElement","checkFn","timeout","newPromise","resolve","callFn","result","isNullish","setTimer","observer","disconnect","newMutationObserver","observe","getDocElement","childList","subtree","waitForElementOrInteractive","isInteractive","then","res","waitForInteractive","readyState","getReadyState","INTERACTIVE","COMPLETE","getDoc","addEventListener","waitForComplete","waitForPageReady","pageIsReady","timer","dispatchReady","clearTimer","pageLoadTimeout","isPageReady","hasDOM"],"sources":["../../../src/ts/utils/dom-events.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { NonNullableReturnType } from \"@lisn/globals/types\";\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined`.\n *\n * The Promise is resolved with `checkFn`'s return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @param {} timeout If given, then if no such element is present after this\n *                    many milliseconds, the promise will resolve to `null`.\n *\n * @category DOM: Events\n */\nexport const waitForElement = <\n  F extends () => unknown,\n  T extends number | undefined = undefined,\n>(\n  checkFn: F,\n  timeout?: number,\n) =>\n  MH.newPromise<\n    T extends undefined\n      ? NonNullableReturnType<F>\n      : null | NonNullableReturnType<F>\n  >((resolve) => {\n    const callFn = () => {\n      const result = checkFn();\n      if (!MH.isNullish(result)) {\n        resolve(result as NonNullableReturnType<F>);\n        return true; // done\n      }\n      return false;\n    };\n\n    if (callFn()) {\n      return; // resolved already\n    }\n\n    if (!MH.isNullish(timeout)) {\n      MH.setTimer(() => {\n        resolve(\n          null as T extends undefined\n            ? NonNullableReturnType<F>\n            : null | NonNullableReturnType<F>,\n        );\n        observer.disconnect();\n      }, timeout);\n    }\n\n    const observer = MH.newMutationObserver(() => {\n      if (callFn()) {\n        observer.disconnect();\n      }\n    });\n\n    observer.observe(MH.getDocElement(), {\n      childList: true,\n      subtree: true,\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined` or the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * becomes \"interactive\".\n *\n * It always calls the given `checkFn` first before examining the `readyState`.\n *\n * If the `readyState` became interactive before the element was found, the\n * Promise resolves to `null`. Otherwise the Promise is resolved with `checkFn`'s\n * return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @category DOM: Events\n */\nexport const waitForElementOrInteractive = <F extends () => unknown>(\n  checkFn: F,\n) =>\n  MH.newPromise<NonNullableReturnType<F> | null>((resolve) => {\n    let isInteractive = false;\n    // Check element first, then readyState. The callback to waitForElement is\n    // run synchronously first time, so isInteractive will be false and checkFn\n    // will run.\n    waitForElement(() => isInteractive || checkFn()).then((res) => {\n      if (!isInteractive) {\n        resolve(res as NonNullableReturnType<F>);\n      } // else already resolved to null\n    });\n\n    waitForInteractive().then(() => {\n      isInteractive = true;\n      resolve(null);\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"interactive\" (or if it's already \"interactive\" or \"complete\", the\n * Promise is fulfilled immediately).\n *\n * @category DOM: Events\n */\nexport const waitForInteractive = () =>\n  MH.newPromise<void>((resolve) => {\n    const readyState = MH.getReadyState();\n    if (readyState === INTERACTIVE || readyState === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"DOMContentLoaded\", () => resolve());\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" (or if it's already \"complete\", the Promise is fulfilled\n * immediately).\n *\n * @category DOM: Events\n */\nexport const waitForComplete = () =>\n  MH.newPromise<void>((resolve) => {\n    if (MH.getReadyState() === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"readystatechange\", () => {\n      if (MH.getReadyState() === COMPLETE) {\n        resolve();\n      }\n    });\n  });\n\n/**\n * Returns a Promise that is resolved either when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" or the `readyState` is \"interactive\" and at least\n * {@link settings.pageLoadTimeout} milliseconds have passed (if > 0) since it\n * became \"interactive\".\n *\n * @category DOM: Events\n */\nexport const waitForPageReady = () =>\n  MH.newPromise<void>((resolve) => {\n    if (pageIsReady) {\n      resolve();\n      return;\n    }\n\n    return waitForInteractive().then(() => {\n      // Setup a listener for the complete state but wait at most\n      // <pageLoadTimeout> (if specified)\n      let timer: ReturnType<typeof setTimeout> | null = null;\n\n      const dispatchReady = () => {\n        pageIsReady = true;\n        if (timer) {\n          MH.clearTimer(timer);\n          timer = null;\n        }\n        resolve();\n      };\n\n      if (settings.pageLoadTimeout > 0) {\n        timer = MH.setTimer(() => {\n          dispatchReady();\n        }, settings.pageLoadTimeout);\n      }\n\n      waitForComplete().then(dispatchReady);\n    });\n  });\n\n/**\n * Returns true if the page is \"ready\". See {@link waitForPageReady}.\n *\n * @category DOM: Events\n */\nexport const isPageReady = () => pageIsReady;\n\n// --------------------\n\nconst COMPLETE = \"complete\";\nconst INTERACTIVE = \"interactive\";\n\nlet pageIsReady = false;\n\nif (!MH.hasDOM()) {\n  pageIsReady = true;\n} else {\n  waitForPageReady(); // ensure pageIsReady is set even if waitForPageReady is not called\n}\n"],"mappings":"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","ignoreList":[]}