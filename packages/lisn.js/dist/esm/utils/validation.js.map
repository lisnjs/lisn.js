{"version":3,"file":"validation.js","names":["MH","LisnUsageError","toNum","toBoolean","splitOn","isValidStrList","value","checkFn","allowEmpty","res","validateStrList","isNullish","err","isInstanceOf","key","_toArray","filterBlank","toArray","map","v","_validateString","validateNumList","_toArray2","_validateNumber","validateNumber","validateBoolean","_validateBoolean","validateString","validateStringRequired","result","isEmpty","usageError","validateBooleanOrString","stringCheckFn","_validateBooleanOrString","isArray","isIterableObject","arrayFrom","isLiteralString","trim","undefined","typeDescription","numVal","boolVal"],"sources":["../../../src/ts/utils/validation.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { toNum } from \"@lisn/utils/math\";\nimport { toBoolean } from \"@lisn/utils/misc\";\nimport { splitOn } from \"@lisn/utils/text\";\n\n/**\n * Returns true if the input is a string array or comma-separated string, whose\n * elements are valid according to the `validator` function.\n *\n * @param {} allowEmpty If `false`, then input without any entries is\n * considered _invalid_.\n *\n * @category Validation\n */\nexport const isValidStrList = <T extends string = string>(\n  value: unknown,\n  checkFn: (value: string) => value is T,\n  allowEmpty = true,\n): value is CommaSeparatedStr<T> | T[] => {\n  try {\n    const res = validateStrList(\"\", value, checkFn);\n    return allowEmpty || !MH.isNullish(res);\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns an array of strings from the given list while validating each one\n * using the `checkFn` function.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a string or array of strings, or if any\n *                entries do not pass `checkFn`.\n *\n * @param {} key Used in the error message thrown\n *\n * @returns {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateStrList = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateString(key, v, checkFn, \"a string or a string array\"),\n    ),\n  );\n\n/**\n * Returns an array of numbers from the given list.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a number or array of numbers. Numerical\n *                strings are accepted.\n *\n * @param {} key Used in the error message thrown\n *\n * @returns {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateNumList = (\n  key: string,\n  value: unknown,\n): number[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateNumber(key, v, \"a number or a number array\"),\n    ),\n  );\n\n/**\n * Returns a number corresponding to the supplied value, ensuring the supplied\n * value is a valid number or a string containing only a number.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @returns {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateNumber = (key: string, value: unknown) =>\n  _validateNumber(key, value);\n\n/**\n * Returns a boolean corresponding to the given value as follows:\n *\n * - `null` and `undefined` result in `undefined`\n * - `false` and `\"false\"` result in `false`\n * - `\"\"`, `true` and `\"true\"` result in `true`\n * - other values throw an error error\n *\n * Note that an empty string is treated as `true`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is not a valid boolean or boolean string.\n *\n * @returns {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateBoolean = (key: string, value: unknown) =>\n  _validateBoolean(key, value);\n\n/**\n * Returns a valid string from the supplied value, ensuring the supplied value\n * is a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} checkFn      If given and the supplied value is a string, then it\n *                        is called with the value as a single argument. It\n *                        must return true if the value is valid and false\n *                        otherwise.\n *                        If it is not given, then any literal string is\n *                        accepted.\n *\n * @returns {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n) => _validateString(key, value, checkFn);\n\n/**\n * Like {@link validateString} except it requires input to be given and\n * non-empty.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid or empty.\n *\n * @category Validation\n */\nexport const validateStringRequired = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T => {\n  const result = _validateString(key, value, checkFn);\n\n  if (MH.isEmpty(result)) {\n    throw MH.usageError(`'${key}' is required`);\n  }\n\n  return result;\n};\n\n/**\n * Returns a valid boolean or a string from the supplied value, ensuring the\n * supplied value is either a boolean or boolean string (see\n * {@link validateBoolean}), or a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} stringCheckFn If given and the supplied value is a string _other\n *                         than a boolean string_, then it is called with the\n *                         value as a single argument. It must return true if\n *                         the value is valid and false otherwise.\n *                         If it is not given, then any literal string is\n *                         accepted.\n *\n * @category Validation\n */\nexport const validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n) => _validateBooleanOrString(key, value, stringCheckFn);\n\n// --------------------\n\nconst toArray = (value: unknown): unknown[] | undefined => {\n  let result: unknown[] | null;\n  if (MH.isArray(value)) {\n    result = value;\n  } else if (MH.isIterableObject(value)) {\n    result = MH.arrayFrom(value);\n  } else if (MH.isLiteralString(value)) {\n    result = splitOn(value, \",\");\n  } else if (!MH.isNullish(value)) {\n    result = [value];\n  } else {\n    result = null;\n  }\n\n  return result\n    ? MH.filterBlank(result.map((v) => (MH.isLiteralString(v) ? v.trim() : v)))\n    : undefined;\n};\n\nconst _validateNumber = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const numVal = toNum(value, null);\n  if (numVal === null) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a number\"}`);\n  }\n\n  return numVal;\n};\n\nconst _validateBoolean = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBoolean(value);\n  if (boolVal === null) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? '\"true\" or \"false\"'}`,\n    );\n  }\n\n  return boolVal;\n};\n\nconst _validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n  typeDescription?: string,\n): (typeof checkFn extends null | undefined ? string : T) | undefined => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a string\"}`);\n  } else if (checkFn && !checkFn(value)) {\n    throw MH.usageError(`Invalid value for '${key}'`);\n  }\n\n  return value as typeof checkFn extends null | undefined ? string : T;\n};\n\nconst _validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBoolean(value);\n  if (boolVal !== null) {\n    return boolVal;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? \"a boolean or string\"}`,\n    );\n  }\n\n  return _validateString(key, value, stringCheckFn);\n};\n"],"mappings":"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","ignoreList":[]}