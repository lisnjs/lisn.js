{"version":3,"file":"widget.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_cssAlter","_domEvents","_log","_misc","_tasks","_text","_callback","_xMap","_domWatcher","_debug","_interopRequireDefault","e","__esModule","default","_getRequireWildcardCache","WeakMap","r","t","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","Widget","element","id","_instances$get","instances","constructor","config","logger","debug","Logger","name","formatAsString","logAtCreation","_instances$get2","destroy","sGet","isDisabled","isDestroyed","destroyPromise","enableCallbacks","newSet","disableCallbacks","destroyCallbacks","disable","debug8","callback","invoke","enable","toggleEnable","onDisable","handler","add","wrapCallback","onEnable","clear","elInstances","deleteKey","prune","onDestroy","getElement","exports","registerWidget","newWidget","configValidator","options","_options$selector","registeredWidgets","waitForInteractive","prefixedName","prefixName","selector","getDefaultWidgetSelector","settings","autoWidgets","domWatcher","DOMWatcher","reuse","onMutation","operation","currentTargetOf","thisConfigValidator","isFunction","widgets","configSpecs","dataAttr","getData","supportsMultiple","hasClass","push","splitOn","spec","fetchWidgetConfig","undefined","theseWidgets","toArrayIfSingle","lengthOf","w","target","categories","S_REMOVED","S_ADDED","getWidgetConfig","input","validator","separator","toOptionsObject","key","configPromises","prefix","fetchUniqueWidget","Type","widget","waitForDelay","logWarn","newXWeakMap","newMap","entry","filter","v","isEmpty","kebabToCamelCase"],"sources":["../../../src/ts/widgets/widget.ts"],"sourcesContent":["/**\n * ## Specification for the HTML API for widgets\n *\n * The following describes the general syntax when using the HTML API for\n * automatic creation of widgets based on data attributes\n * ({@link Settings.settings.autoWidgets | settings.autoWidgets} must be true.\n *\n * A widget specification should be given as a\n * `data-lisn-<WidgetName>=\"<WidgetConfList>\"` attribute.\n *\n * Alternatively, if using all default configurations, you can simply add the\n * `lisn-<WidgetName>` CSS class. Specifying a configuration using CSS classes\n * is not currently possible for widgets, only triggers.\n *\n * The general specification for a widget is of the form:\n *\n * ```\n * <WidgetConfList> ::= <WidgetConf> { \";\" <WidgetConf> }\n *\n * <WidgetConf> ::= [ <WidgetOption> { \"|\" <WidgetOption> } ]\n *\n * <WidgetOption> ::=\n *     <BooleanOptionName> [ \"=\" ( \"false\" | \"true\" ) ] |\n *     <OptionName> \"=\" <OptionValue>\n * ```\n *\n * **NOTE:**\n *\n * There can be 0 or more spaces around any of the separator characters.\n *\n * Not all widgets support multiple instances per single element and therefore\n * multiple configurations. Refer to the specific widget.\n *\n * The characters \"|\", \";\", \"=\" are reserved separators and cannot be used\n * literally as part of an option value.\n *\n * @module Widgets\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { hasClass, getData } from \"@lisn/utils/css-alter\";\nimport { waitForInteractive } from \"@lisn/utils/dom-events\";\nimport { logWarn } from \"@lisn/utils/log\";\nimport { toArrayIfSingle } from \"@lisn/utils/misc\";\nimport { waitForDelay } from \"@lisn/utils/tasks\";\nimport { formatAsString, kebabToCamelCase, splitOn } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { DOMWatcher } from \"@lisn/watchers/dom-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\nexport class Widget {\n  /**\n   * Disables the functionality of the widget. What this means is specific to\n   * each widget.\n   */\n  readonly disable: () => Promise<void>;\n\n  /**\n   * Re-enables the functionality of the widget. What this means is specific to\n   * each widget.\n   */\n  readonly enable: () => Promise<void>;\n\n  /**\n   * Re-enables the widget if disabled, otherwise disables it.\n   */\n  readonly toggleEnable: () => Promise<void>;\n\n  /**\n   * The given handler will be called when the widget is disabled.\n   */\n  readonly onDisable: (handler: WidgetHandler) => void;\n\n  /**\n   * The given handler will be called when the widget is enabled.\n   */\n  readonly onEnable: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns true if the widget is currently disabled.\n   */\n  readonly isDisabled: () => boolean;\n\n  /**\n   * Undoes all modifications to the element and returns it to its original state.\n   *\n   * You will need to recreate it if you want to enable its functionality again.\n   */\n  readonly destroy: () => Promise<void>;\n\n  /**\n   * The given handler will be called when the widget is destroyed.\n   */\n  readonly onDestroy: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns true if the widget is destroyed.\n   */\n  readonly isDestroyed: () => boolean;\n\n  /**\n   * Returns the element passed to the widget constructor.\n   */\n  readonly getElement: () => Element;\n\n  /**\n   * Retrieve an existing widget by element and ID.\n   */\n  static get(element: Element, id: string): Widget | null {\n    return instances.get(element)?.get(id) || null;\n  }\n\n  /**\n   * **IMPORTANT:** If ID is given and there's already a widget with this ID on\n   * this element, it will be destroyed!\n   */\n  constructor(element: Element, config?: { id?: string }) {\n    const logger = debug\n      ? new debug.Logger({\n          name: `${this.constructor.name}-${formatAsString(element)}`,\n          logAtCreation: this,\n        })\n      : null;\n\n    const id = config?.id;\n    if (id) {\n      instances.get(element)?.get(id)?.destroy(); // don't await here\n      instances.sGet(element).set(id, this);\n    }\n\n    let isDisabled = false;\n    let isDestroyed = false;\n    let destroyPromise: Promise<void>;\n\n    const enableCallbacks = MH.newSet<WidgetCallback>();\n    const disableCallbacks = MH.newSet<WidgetCallback>();\n    const destroyCallbacks = MH.newSet<WidgetCallback>();\n\n    this.disable = async () => {\n      if (!isDisabled) {\n        debug: logger?.debug8(\"Disabling\");\n        isDisabled = true;\n\n        for (const callback of disableCallbacks) {\n          await callback.invoke(this);\n        }\n      }\n    };\n\n    this.enable = async () => {\n      if (!isDestroyed && isDisabled) {\n        debug: logger?.debug8(\"Enabling\");\n        isDisabled = false;\n\n        for (const callback of enableCallbacks) {\n          await callback.invoke(this);\n        }\n      }\n    };\n\n    this.toggleEnable = async () => {\n      if (!isDestroyed) {\n        await (isDisabled ? this.enable : this.disable)();\n      }\n    };\n\n    this.onDisable = (handler) => disableCallbacks.add(wrapCallback(handler));\n    this.onEnable = (handler) => enableCallbacks.add(wrapCallback(handler));\n\n    this.isDisabled = () => isDisabled;\n\n    this.destroy = () => {\n      if (!destroyPromise) {\n        destroyPromise = (async () => {\n          debug: logger?.debug8(\"Destroying\");\n          isDestroyed = true;\n          await this.disable();\n\n          for (const callback of destroyCallbacks) {\n            await callback.invoke(this);\n          }\n\n          enableCallbacks.clear();\n          disableCallbacks.clear();\n          destroyCallbacks.clear();\n\n          if (id) {\n            const elInstances = instances.get(element);\n            if (elInstances?.get(id) === this) {\n              MH.deleteKey(elInstances, id);\n              instances.prune(element);\n            }\n          }\n        })();\n      }\n\n      return destroyPromise;\n    };\n\n    this.onDestroy = (handler) => destroyCallbacks.add(wrapCallback(handler));\n\n    this.isDestroyed = () => isDestroyed;\n\n    this.getElement = () => element;\n  }\n}\n\nexport type WidgetCallbackArgs = [Widget];\nexport type WidgetCallback = Callback<WidgetCallbackArgs>;\nexport type WidgetHandler =\n  | WidgetCallback\n  | CallbackHandler<WidgetCallbackArgs>;\n\n/**\n * **NOTE:** If the function returns a widget or a list of widgets created for\n * the given element, then each one will be automatically destroyed if the\n * element is removed from the DOM.\n */\nexport type WidgetCreateFn<Config extends Record<string, unknown>> = (\n  element: Element,\n  config?: Config,\n) => Widget | Widget[] | null | Promise<Widget | Widget[] | null>;\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidatorObject<\n  Config extends Record<string, unknown>,\n> = {\n  [K in keyof Config]: (key: K, v: unknown) => Config[K];\n};\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigAsyncValidatorObject<\n  Config extends Record<string, unknown>,\n> = {\n  [K in keyof Config]: (key: K, v: unknown) => Config[K] | Promise<Config[K]>;\n};\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidatorFunc<Config extends Record<string, unknown>> =\n  (\n    element: Element,\n  ) =>\n    | WidgetConfigValidatorObject<Config>\n    | WidgetConfigAsyncValidatorObject<Config>;\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidator<Config extends Record<string, unknown>> =\n  | WidgetConfigValidatorObject<Config>\n  | WidgetConfigValidatorFunc<Config>;\n\n/**\n * Enables automatic setting up of a widget from an elements matching the given\n * selector.\n *\n * If {@link settings.autoWidgets} is true, nothing is done. Otherwise,\n * when an element matching the selector is added to the DOM, `newWidget` will\n * be called and it's expected to setup the widget.\n *\n * **IMPORTANT:** The widget that is returned by `newWidget` will be\n * automatically destroyed when the element that created them is removed from\n * the DOM.\n *\n * **IMPORTANT:** If a widget by that name is already registered, the current\n * call does nothing, even if the remaining arguments differ.\n *\n * @param {} name       The name of the widget. Should be in kebab-case.\n * @param {} newWidget  Called for every element matching the widget selector.\n * @param {} configValidator\n *                      A validator object, or a function that returns such an\n *                      object, for all options supported by the widget. If\n *                      given, then the `newWidget` function will also be\n *                      passed a configuration object constructed from the\n *                      element's data attribute.\n * @param {} [options.selector]\n *                      The selector to match elements for. If not given, then\n *                      uses a default value of `[data-lisn-<name>], .lisn-<name>`\n * @param {} [options.supportsMultiple]\n *                      If true, and if `configValidator` is given, then the\n *                      value of the element's widget specific data attribute\n *                      will be split on \";\" and each one parsed individually\n *                      as a configuration. Then the `newWidget` function will\n *                      be called once for each configuration.\n */\nexport const registerWidget = async <Config extends Record<string, unknown>>(\n  name: string,\n  newWidget: WidgetCreateFn<Config>,\n  configValidator?: null | WidgetConfigValidator<Config>,\n  options?: {\n    selector?: string;\n    supportsMultiple?: boolean;\n  },\n) => {\n  if (registeredWidgets.has(name)) {\n    return;\n  }\n\n  registeredWidgets.add(name);\n\n  // init after DOM loaded so that the settings can be configured by the user\n  // straight after loading LISN.js\n  await waitForInteractive();\n\n  const prefixedName = MH.prefixName(name);\n  const selector = options?.selector ?? getDefaultWidgetSelector(prefixedName);\n\n  if (settings.autoWidgets) {\n    const domWatcher = DOMWatcher.reuse();\n    domWatcher.onMutation(\n      async (operation) => {\n        const element = MH.currentTargetOf(operation);\n        const thisConfigValidator = MH.isFunction(configValidator)\n          ? await configValidator(element)\n          : configValidator;\n\n        const widgets: Widget[] = [];\n        const configSpecs: string[] = [];\n        const dataAttr = getData(element, prefixedName);\n\n        if (options?.supportsMultiple) {\n          if (hasClass(element, prefixedName)) {\n            configSpecs.push(\"\");\n          }\n\n          if (dataAttr !== null) {\n            configSpecs.push(\n              ...(dataAttr ? splitOn(dataAttr, \";\", true) : [\"\"]),\n            );\n          }\n        } else {\n          configSpecs.push(dataAttr ?? \"\");\n        }\n\n        for (const spec of configSpecs) {\n          const config = thisConfigValidator\n            ? await fetchWidgetConfig(spec, thisConfigValidator)\n            : undefined;\n\n          const theseWidgets = await newWidget(element, config);\n          if (theseWidgets) {\n            widgets.push(...toArrayIfSingle(theseWidgets));\n          }\n        }\n\n        // auto-destroy on element remove\n        if (MH.lengthOf(widgets)) {\n          domWatcher.onMutation(\n            () => {\n              for (const w of widgets) {\n                w.destroy();\n              }\n            },\n            {\n              target: element,\n              categories: [MC.S_REMOVED],\n            },\n          );\n        }\n      },\n      {\n        selector,\n        categories: [MC.S_ADDED],\n      },\n    );\n  }\n};\n\n/**\n * Returns a configuration object from the given user input, which can be\n * either an object or a `<separator>` separated string of key=values.\n *\n * If `input` is a string, it must be of the format:\n *\n * ```\n * <UserConfigString> ::= <OptionSpec> { <Separator> <OptionSpec> }\n *\n * <OptionSpec> ::=\n *     <BooleanOptionName> [ \"=\" ( \"false\" | \"true\" ) ] |\n *     <OptionName> \"=\" <OptionValue>\n * ```\n *\n * By default, for widgets `<separator>` is \"|\".\n *\n * **NOTE:** If `input` is a string, option names will be converted from\n * kebab-case to camelCase.\n *\n * The given `validator` defines the shape of the returned object. It is called\n * for each entry _in the `validator` object_, with that key and the\n * corresponding value from the input configuration, as the two parameters.\n *\n * If a key is not found in the input, the value passed to the validating\n * function will be `undefined`.\n *\n * If the input is a string and a key has no value, the value passed to the\n * validating function will be an empty string `\"\"`.\n *\n * The final configuration contains all keys from the `validator` object with\n * the value that the validating function for each key returned.\n *\n * There are several built-in validating functions that you can make use of.\n *\n * @see {@link Utils.validateStrList}\n * @see {@link Utils.validateNumber}\n * @see {@link Utils.validateBoolean}\n * @see {@link Utils.validateString}\n * @see {@link Utils.validateBooleanOrString}\n */\nexport const getWidgetConfig = <Config extends Record<string, unknown>>(\n  input: Record<string, unknown> | string | null | undefined,\n  validator: WidgetConfigValidatorObject<Config>,\n  separator = \"|\",\n): Config => {\n  const config = {} as Config;\n  if (!(input instanceof Object)) {\n    input = toOptionsObject(input, separator);\n  }\n\n  for (const key in validator) {\n    config[key] = validator[key](key, input[key]);\n  }\n  return config;\n};\n\n/**\n * Like {@link getWidgetConfig} but it accepts an object whose validator\n * functions may return a promise.\n */\nexport const fetchWidgetConfig = async <Config extends Record<string, unknown>>(\n  input: Record<string, unknown> | string | null | undefined,\n  validator: WidgetConfigAsyncValidatorObject<Config>,\n  separator = \"|\",\n): Promise<Config> => {\n  const config = {} as Config;\n  const configPromises = getWidgetConfig<{\n    [K in keyof Config]: Config[K] | Promise<Config[K]>;\n  }>(input, validator, separator);\n\n  for (const key in configPromises) {\n    config[key] = await configPromises[key];\n  }\n\n  return config;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getDefaultWidgetSelector = (prefix: string) =>\n  `.${prefix},[data-${prefix}]`;\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchUniqueWidget = async <W extends Widget>(\n  name: string,\n  element: Element,\n  Type: { get: (element: Element) => W | null },\n): Promise<W | null> => {\n  let widget = Type.get(element);\n  if (!widget) {\n    await waitForDelay(0); // in case it's being processed now\n    widget = Type.get(element);\n\n    if (!widget) {\n      logWarn(`No ${name} widget for element ${formatAsString(element)}`);\n      return null;\n    }\n  }\n\n  return widget;\n};\n\nconst instances = newXWeakMap<Element, Map<string, Widget>>(() => MH.newMap());\nconst registeredWidgets = MH.newSet<string>();\n\n// --------------------\n\nconst toOptionsObject = (\n  input: string | null | undefined,\n  separator: string,\n) => {\n  const options: Record<string, string> = {};\n  for (const entry of MH.filter(\n    splitOn(input ?? \"\", separator, true),\n    (v) => !MH.isEmpty(v),\n  )) {\n    const [key, value] = splitOn(entry, /\\s*=\\s*/, true, 1);\n    options[kebabToCamelCase(key)] = value ?? \"\";\n  }\n  return options;\n};\n"],"mappings":"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","ignoreList":[]}