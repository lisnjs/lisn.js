{"version":3,"file":"pointer-watcher.js","names":["MC","MH","addEventListenerTo","removeEventListenerFrom","preventSelect","undoPreventSelect","logError","isValidPointerAction","POINTER_ACTIONS","objToStrKey","validateStrList","wrapCallback","newXWeakMap","PointerWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","instance","instances","get","set","constructor","key","_defineProperty","illegalConstructorError","allCallbacks","newMap","createCallback","target","handler","_allCallbacks$get","remove","callback","onRemove","deleteKey","sGet","setupOnPointer","startHandler","endHandler","userOptions","options","getOptions","startCallback","endCallback","action","_actions","listenerSetupFn","onPointer","offPointer","entry","SYMBOL","_config$preventDefaul","_config$preventSelect","_preventDefault","preventDefault","_preventSelect","_options$preventDefau","_options$preventSelec","actions","setupClickListener","toggleState","wrapper","event","data","S_CLICK","state","invokeCallback","setupPointerListeners","startEventSuff","S_HOVER","endEventSuff","startEvent","S_POINTER","endEvent","strReplace","type","startListener","endListener","click","hover","args","press","S_PRESS","actionData","invoke","copyObject","catch"],"sources":["../../../src/ts/watchers/pointer-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/PointerWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { PointerAction, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { isValidPointerAction, POINTER_ACTIONS } from \"@lisn/utils/pointer\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * {@link PointerWatcher} listens for simple pointer actions like clicks, press\n * and hold or hover.\n */\nexport class PointerWatcher {\n  /**\n   * Call the `startHandler` whenever the pointer action begins.\n   * Call the `endHandler` whenever the pointer action ends. If `endHandler` is\n   * not given, it defaults to `startHandler`.\n   *\n   * For an explanation of what \"begins\" and \"ends\" means for each supported\n   * action, see {@link OnPointerOptions.actions}.\n   *\n   * **IMPORTANT:** The same handlers can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, then it will be removed and re-added with the\n   * current options.\n   */\n  readonly onPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n    options?: OnPointerOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes previously added handlers.\n   */\n  readonly offPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n  ) => void;\n\n  /**\n   * Creates a new instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config?: PointerWatcherConfig) {\n    return new PointerWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config?: PointerWatcherConfig) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new PointerWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: PointerWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"PointerWatcher.create\");\n    }\n\n    // Keep this watcher super simple. The events we listen for don't fire at a\n    // high rate and it's unlikely for there to be many many callbacks for each\n    // target and event type, so don't bother with using a delegating listener,\n    // etc.\n\n    // Keep a map of callbacks so we can lookup the callback by the handler\n    // (and also to prevent duplicate handler for each target, for consistency\n    // with other watchers).\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<OnPointerHandler, OnPointerCallback>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnPointerHandler,\n    ): OnPointerCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler));\n\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        MH.deleteKey(allCallbacks.get(target), handler);\n      });\n\n      allCallbacks.sGet(target).set(handler, callback);\n      return callback;\n    };\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnPointer = async (\n      target: EventTarget,\n      startHandler: OnPointerHandler,\n      endHandler: OnPointerHandler | undefined,\n      userOptions: OnPointerOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions);\n      const startCallback = createCallback(target, startHandler);\n      const endCallback =\n        endHandler && endHandler !== startHandler\n          ? createCallback(target, endHandler)\n          : startCallback;\n\n      for (const action of options._actions) {\n        listenerSetupFn[action](target, startCallback, endCallback, options);\n      }\n    };\n\n    // ----------\n\n    this.onPointer = setupOnPointer;\n\n    // ----------\n\n    this.offPointer = (target, startHandler, endHandler?) => {\n      const entry = allCallbacks.get(target);\n      MH.remove(entry?.get(startHandler));\n      if (endHandler) {\n        MH.remove(entry?.get(endHandler));\n      }\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type PointerWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventDefault | preventDefault} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue false\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventSelect | preventSelect} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue true\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * @interface\n */\nexport type OnPointerOptions = {\n  /**\n   * One or more of of \"click\", \"hover\" or \"press\". If not specified, then all\n   * actions are enabled.\n   *\n   * It can be a comma-separated list of {@link PointerAction}s or an array of\n   * such actions.\n   *\n   * For click actions, the start handler is called for every odd number of\n   * clicks (1st, 3rd, 5th, etc), and the end handler is called for every other\n   * click. It functions like a toggle.\n   *\n   * For hover and press actions, the start handler is called when the pointer\n   * enters or presses down on the target respectively, and the end handler is\n   * called when the pointer leaves or comes off the target respectively.\n   *\n   * Note that on touch screens, hover and press actions behave identically.\n   *\n   * @defaultValue undefined\n   */\n  actions?: CommaSeparatedStr<PointerAction> | PointerAction[];\n\n  /**\n   * If true, the events of the pointer actions, e.g. click, will have their\n   * default action prevented.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If true (default), then for press actions (and hover actions on touch\n   * screens) it will prevent starting a text selection.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventSelect}\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link PointerWatcher.onPointer}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link PointerActionData} describing the state of the action.\n */\nexport type OnPointerHandlerArgs = [EventTarget, PointerActionData, Event];\nexport type OnPointerCallback = Callback<OnPointerHandlerArgs>;\nexport type OnPointerHandler =\n  | CallbackHandler<OnPointerHandlerArgs>\n  | OnPointerCallback;\n\nexport type PointerActionData = {\n  action: PointerAction;\n  state: \"ON\" | \"OFF\";\n};\n\n// ----------------------------------------\n\ntype PointerWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\ntype OnPointerOptionsInternal = {\n  _actions: PointerAction[];\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, PointerWatcher>();\n\nconst getConfig = (\n  config: PointerWatcherConfig | undefined,\n): PointerWatcherConfigInternal => {\n  return {\n    _preventDefault: config?.preventDefault ?? false,\n    _preventSelect: config?.preventSelect ?? true,\n  };\n};\n\nconst getOptions = (\n  config: PointerWatcherConfigInternal,\n  options: OnPointerOptions | undefined,\n): OnPointerOptionsInternal => {\n  return {\n    _actions:\n      validateStrList(\"actions\", options?.actions, isValidPointerAction) ||\n      POINTER_ACTIONS,\n    _preventDefault: options?.preventDefault ?? config._preventDefault,\n    _preventSelect: options?.preventSelect ?? config._preventSelect,\n  };\n};\n\nconst setupClickListener = (\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // false if next will start; true if next will end.\n  let toggleState = false;\n\n  const wrapper = (event: Event) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    toggleState = !toggleState;\n\n    const data: PointerActionData = {\n      action: MC.S_CLICK,\n      state: toggleState ? \"ON\" : \"OFF\",\n    };\n\n    invokeCallback(\n      toggleState ? startCallback : endCallback,\n      target,\n      data,\n      event,\n    );\n  };\n\n  addEventListenerTo(target, MC.S_CLICK, wrapper);\n\n  const remove = () => removeEventListenerFrom(target, MC.S_CLICK, wrapper);\n\n  startCallback.onRemove(remove);\n  endCallback.onRemove(remove);\n};\n\nconst setupPointerListeners = (\n  action: typeof MC.S_HOVER | typeof MC.S_PRESS,\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform these into mouse*\n  const startEventSuff = action === MC.S_HOVER ? \"enter\" : \"down\";\n  const endEventSuff = action === MC.S_HOVER ? \"leave\" : \"up\";\n  const startEvent = MC.S_POINTER + startEventSuff;\n  const endEvent = MC.S_POINTER + endEventSuff;\n\n  const wrapper = (event: Event, callback: OnPointerCallback) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    const data: PointerActionData = {\n      action,\n      state:\n        MH.strReplace(event.type, /pointer|mouse/, \"\") === startEventSuff\n          ? \"ON\"\n          : \"OFF\",\n    };\n\n    invokeCallback(callback, target, data, event);\n  };\n  const startListener = (event: Event) => wrapper(event, startCallback);\n  const endListener = (event: Event) => wrapper(event, endCallback);\n\n  addEventListenerTo(target, startEvent, startListener);\n  addEventListenerTo(target, endEvent, endListener);\n\n  // On some touch screen devices pressing and holding will initiate select\n  // and result in touchend, so we prevent text select\n  if (options._preventSelect) {\n    preventSelect(target);\n  }\n\n  startCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, startEvent, startListener);\n  });\n\n  endCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, endEvent, endListener);\n  });\n};\n\nconst listenerSetupFn: {\n  [D in PointerAction]: (\n    target: EventTarget,\n    startCallback: OnPointerCallback,\n    endCallback: OnPointerCallback,\n    options: OnPointerOptionsInternal,\n  ) => void;\n} = {\n  click: setupClickListener,\n  hover: (...args) => setupPointerListeners(MC.S_HOVER, ...args),\n  press: (...args) => setupPointerListeners(MC.S_PRESS, ...args),\n} as const;\n\nconst invokeCallback = (\n  callback: OnPointerCallback,\n  target: EventTarget,\n  actionData: PointerActionData,\n  event: Event,\n) => callback.invoke(target, MH.copyObject(actionData), event).catch(logError);\n"],"mappings":"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","ignoreList":[]}