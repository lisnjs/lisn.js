{"version":3,"file":"validation.cjs","names":["MH","_interopRequireWildcard","require","_errors","_math","_misc","_text","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","isValidStrList","value","checkFn","allowEmpty","res","validateStrList","isNullish","err","isInstanceOf","LisnUsageError","exports","key","_toArray","filterBlank","toArray","map","v","_validateString","validateNumList","_toArray2","_validateNumber","validateNumber","validateBoolean","_validateBoolean","validateString","validateStringRequired","result","isEmpty","usageError","validateBooleanOrString","stringCheckFn","_validateBooleanOrString","isArray","isIterableObject","arrayFrom","isLiteralString","splitOn","trim","undefined","typeDescription","numVal","toNum","boolVal","toBool"],"sources":["../../../src/ts/utils/validation.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { toNum } from \"@lisn/utils/math\";\nimport { toBool } from \"@lisn/utils/misc\";\nimport { splitOn } from \"@lisn/utils/text\";\n\n/**\n * Returns true if the input is a string array or comma-separated string, whose\n * elements are valid according to the `validator` function.\n *\n * @param {} allowEmpty If `false`, then input without any entries is\n * considered _invalid_.\n *\n * @category Validation\n */\nexport const isValidStrList = <T extends string = string>(\n  value: unknown,\n  checkFn: (value: string) => value is T,\n  allowEmpty = true,\n): value is CommaSeparatedStr<T> | T[] => {\n  try {\n    const res = validateStrList(\"\", value, checkFn);\n    return allowEmpty || !MH.isNullish(res);\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns an array of strings from the given list while validating each one\n * using the `checkFn` function.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a string or array of strings, or if any\n *                entries do not pass `checkFn`.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateStrList = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateString(key, v, checkFn, \"a string or a string array\"),\n    ),\n  );\n\n/**\n * Returns an array of numbers from the given list.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a number or array of numbers. Numerical\n *                strings are accepted.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateNumList = (\n  key: string,\n  value: unknown,\n): number[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateNumber(key, v, \"a number or a number array\"),\n    ),\n  );\n\n/**\n * Returns a number corresponding to the supplied value, ensuring the supplied\n * value is a valid number or a string containing only a number.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateNumber = (key: string, value: unknown) =>\n  _validateNumber(key, value);\n\n/**\n * Returns a boolean corresponding to the given value as follows:\n *\n * - `null` and `undefined` result in `undefined`\n * - `false` and `\"false\"` result in `false`\n * - `\"\"`, `true` and `\"true\"` result in `true`\n * - other values throw an error error\n *\n * Note that an empty string is treated as `true`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is not a valid boolean or boolean string.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateBoolean = (key: string, value: unknown) =>\n  _validateBoolean(key, value);\n\n/**\n * Returns a valid string from the supplied value, ensuring the supplied value\n * is a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} checkFn      If given and the supplied value is a string, then it\n *                        is called with the value as a single argument. It\n *                        must return true if the value is valid and false\n *                        otherwise.\n *                        If it is not given, then any literal string is\n *                        accepted.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n) => _validateString(key, value, checkFn);\n\n/**\n * Like {@link validateString} except it requires input to be given and\n * non-empty.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid or empty.\n *\n * @category Validation\n */\nexport const validateStringRequired = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T => {\n  const result = _validateString(key, value, checkFn);\n\n  if (MH.isEmpty(result)) {\n    throw MH.usageError(`'${key}' is required`);\n  }\n\n  return result;\n};\n\n/**\n * Returns a valid boolean or a string from the supplied value, ensuring the\n * supplied value is either a boolean or boolean string (see\n * {@link validateBoolean}), or a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} stringCheckFn If given and the supplied value is a string _other\n *                         than a boolean string_, then it is called with the\n *                         value as a single argument. It must return true if\n *                         the value is valid and false otherwise.\n *                         If it is not given, then any literal string is\n *                         accepted.\n *\n * @category Validation\n */\nexport const validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n) => _validateBooleanOrString(key, value, stringCheckFn);\n\n// --------------------\n\nconst toArray = (value: unknown): unknown[] | undefined => {\n  let result: unknown[] | null;\n  if (MH.isArray(value)) {\n    result = value;\n  } else if (MH.isIterableObject(value)) {\n    result = MH.arrayFrom(value);\n  } else if (MH.isLiteralString(value)) {\n    result = splitOn(value, \",\");\n  } else if (!MH.isNullish(value)) {\n    result = [value];\n  } else {\n    result = null;\n  }\n\n  return result\n    ? MH.filterBlank(result.map((v) => (MH.isLiteralString(v) ? v.trim() : v)))\n    : undefined;\n};\n\nconst _validateNumber = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const numVal = toNum(value, null);\n  if (numVal === null) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a number\"}`);\n  }\n\n  return numVal;\n};\n\nconst _validateBoolean = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal === null) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? '\"true\" or \"false\"'}`,\n    );\n  }\n\n  return boolVal;\n};\n\nconst _validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n  typeDescription?: string,\n): (typeof checkFn extends null | undefined ? string : T) | undefined => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a string\"}`);\n  } else if (checkFn && !checkFn(value)) {\n    throw MH.usageError(`Invalid value for '${key}'`);\n  }\n\n  return value as typeof checkFn extends null | undefined ? string : T;\n};\n\nconst _validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal !== null) {\n    return boolVal;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? \"a boolean or string\"}`,\n    );\n  }\n\n  return _validateString(key, value, stringCheckFn);\n};\n"],"mappings":"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","ignoreList":[]}