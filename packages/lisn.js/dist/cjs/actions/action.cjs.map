{"version":3,"file":"action.cjs","names":["MH","_interopRequireWildcard","require","_text","_widget","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","registerAction","name","newAction","configValidator","registeredActions","newActionFromSpec","element","argsAndOptions","thisConfigValidator","isFunction","args","config","fetchWidgetConfig","undefined","entry","splitOn","includes","push","exports","fetchAction","usageError","newMap"],"sources":["../../../src/ts/actions/action.ts"],"sourcesContent":["/**\n * @module Actions\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { splitOn } from \"@lisn/utils/text\";\n\nimport { WidgetConfigValidator, fetchWidgetConfig } from \"@lisn/widgets/widget\";\n\n/**\n * @interface\n */\nexport type Action = {\n  do: () => void;\n  undo: () => void;\n  toggle: () => void;\n};\n\nexport type ActionCreateFn<Config extends Record<string, unknown>> = (\n  element: Element,\n  args: string[],\n  config?: Config,\n) => Action | Promise<Action>;\n\n/**\n * Registers the given action so that it can be parsed by\n * {@link Triggers.registerTrigger}.\n *\n * **IMPORTANT:** If an action by that name is already registered, the current\n * call does nothing, even if the remaining arguments differ.\n *\n * @param {} name      The name of the action. Should be in kebab-case.\n * @param {} newAction Called for every action specification for a trigger\n *                     parsed by {@link Triggers.registerTrigger}\n */\nexport const registerAction = <Config extends Record<string, unknown>>(\n  name: string,\n  newAction: ActionCreateFn<Config>,\n  configValidator?: null | WidgetConfigValidator<Config>,\n) => {\n  if (registeredActions.has(name)) {\n    return;\n  }\n\n  const newActionFromSpec = async (\n    element: Element,\n    argsAndOptions: string,\n  ) => {\n    const thisConfigValidator = MH.isFunction(configValidator)\n      ? await configValidator(element)\n      : configValidator;\n\n    const args: string[] = [];\n    const config = thisConfigValidator\n      ? await fetchWidgetConfig(argsAndOptions, thisConfigValidator, \",\")\n      : undefined;\n\n    for (const entry of splitOn(argsAndOptions, \",\", true)) {\n      if (entry) {\n        if (!MH.includes(entry, \"=\")) {\n          args.push(entry);\n        }\n      }\n    }\n\n    return newAction(element, args, config);\n  };\n\n  registeredActions.set(name, newActionFromSpec);\n};\n\n/**\n * Returns an {@link Action} registered under the given name and instantiated\n * with the given element and arguments and options parsed from the given string.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given spec is not valid.\n */\nexport const fetchAction = async (\n  element: Element,\n  name: string,\n  argsAndOptions?: string,\n): Promise<Action> => {\n  const newActionFromSpec = registeredActions.get(name);\n  if (!newActionFromSpec) {\n    throw MH.usageError(`Unknown action '${name}'`);\n  }\n\n  return await newActionFromSpec(element, argsAndOptions || \"\");\n};\n\n// --------------------\n\nconst registeredActions = MH.newMap<\n  string,\n  (element: Element, spec: string) => Action | Promise<Action>\n>();\n"],"mappings":";;;;;;AAIA,IAAAA,EAAA,GAAAC,uBAAA,CAAAC,OAAA;AAEA,IAAAC,KAAA,GAAAD,OAAA;AAEA,IAAAE,OAAA,GAAAF,OAAA;AAAgF,SAAAG,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAAL,wBAAAK,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AARhF;AACA;AACA;;AAQA;AACA;AACA;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMW,cAAc,GAAGA,CAC5BC,IAAY,EACZC,SAAiC,EACjCC,eAAsD,KACnD;EACH,IAAIC,iBAAiB,CAACjB,GAAG,CAACc,IAAI,CAAC,EAAE;IAC/B;EACF;EAEA,MAAMI,iBAAiB,GAAG,MAAAA,CACxBC,OAAgB,EAChBC,cAAsB,KACnB;IACH,MAAMC,mBAAmB,GAAGjC,EAAE,CAACkC,UAAU,CAACN,eAAe,CAAC,GACtD,MAAMA,eAAe,CAACG,OAAO,CAAC,GAC9BH,eAAe;IAEnB,MAAMO,IAAc,GAAG,EAAE;IACzB,MAAMC,MAAM,GAAGH,mBAAmB,GAC9B,MAAM,IAAAI,yBAAiB,EAACL,cAAc,EAAEC,mBAAmB,EAAE,GAAG,CAAC,GACjEK,SAAS;IAEb,KAAK,MAAMC,KAAK,IAAI,IAAAC,aAAO,EAACR,cAAc,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE;MACtD,IAAIO,KAAK,EAAE;QACT,IAAI,CAACvC,EAAE,CAACyC,QAAQ,CAACF,KAAK,EAAE,GAAG,CAAC,EAAE;UAC5BJ,IAAI,CAACO,IAAI,CAACH,KAAK,CAAC;QAClB;MACF;IACF;IAEA,OAAOZ,SAAS,CAACI,OAAO,EAAEI,IAAI,EAAEC,MAAM,CAAC;EACzC,CAAC;EAEDP,iBAAiB,CAACL,GAAG,CAACE,IAAI,EAAEI,iBAAiB,CAAC;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAa,OAAA,CAAAlB,cAAA,GAAAA,cAAA;AAOO,MAAMmB,WAAW,GAAG,MAAAA,CACzBb,OAAgB,EAChBL,IAAY,EACZM,cAAuB,KACH;EACpB,MAAMF,iBAAiB,GAAGD,iBAAiB,CAAChB,GAAG,CAACa,IAAI,CAAC;EACrD,IAAI,CAACI,iBAAiB,EAAE;IACtB,MAAM9B,EAAE,CAAC6C,UAAU,CAAC,mBAAmBnB,IAAI,GAAG,CAAC;EACjD;EAEA,OAAO,MAAMI,iBAAiB,CAACC,OAAO,EAAEC,cAAc,IAAI,EAAE,CAAC;AAC/D,CAAC;;AAED;AAAAW,OAAA,CAAAC,WAAA,GAAAA,WAAA;AAEA,MAAMf,iBAAiB,GAAG7B,EAAE,CAAC8C,MAAM,CAGjC,CAAC","ignoreList":[]}