{"version":3,"file":"gesture-watcher.js","names":["MC","MH","addClasses","removeClasses","setNumericStyleJsVars","isValidDirection","addEventListenerTo","removeEventListenerFrom","preventSelect","undoPreventSelect","getDebouncedHandler","addDeltaZ","isValidInputDevice","isValidIntent","DEVICES","INTENTS","getKeyGestureFragment","getPointerGestureFragment","getTouchGestureFragment","getWheelGestureFragment","logError","maxAbs","toNonNegNum","toPosNum","toNumWithBounds","randId","objToStrKey","validateStrList","wrapCallback","newXWeakMap","debug","GestureWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","instance","instances","get","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","allCallbacks","newMap","allListeners","createCallback","target","handler","options","_allCallbacks$get","remove","_callback","debug5","_wrapper","getCallbackAndWrapper","onRemove","deleteHandler","sGet","_options","setupOnGesture","userOptions","getOptions","device","_options$_devices","_devices","_allListeners$get","listeners","debug4","setupListeners","_nCallbacks","_preventDefault","_nPreventDefault","deleteKey","prune","_options$_devices2","_allListeners$get2","_remove","invokeCallbacks","event","_allListeners$get$get","_allListeners$get3","preventDefault","isTerminated","_allCallbacks$get2","values","intents","_intents","hasAddedTabIndex","hasPreventedSelect","S_KEY","isElement","getTabIndex","setTabIndex","S_TOUCH","PREFIX_NO_TOUCH_ACTION","includes","S_DRAG","addOrRemoveListeners","action","listener","eventTypes","method","eventType","debug8","passive","capture","addInitialListener","initialListener","initiatingEvents","removeInitialListener","addOngoingListener","processEvent","ongoingEvents","removeOngoingListener","unsetTabIndex","trackGesture","element","setGestureCssProps","intent","totalDeltaX","totalDeltaY","totalDeltaZ","noTrackGesture","offGesture","onGesture","_allCallbacks$get3","SYMBOL","_config$preventDefaul","_config$naturalTouchS","_config$touchDragHold","_config$touchDragNumF","_debounceWindow","S_DEBOUNCE_WINDOW","_deltaThreshold","deltaThreshold","_angleDiffThreshold","angleDiffThreshold","_naturalTouchScroll","naturalTouchScroll","_touchDragHoldTime","touchDragHoldTime","_touchDragNumFingers","touchDragNumFingers","S_KEYDOWN","pointer","S_POINTERDOWN","S_CLICK","touch","S_TOUCHSTART","wheel","S_WHEEL","S_POINTERUP","S_POINTERMOVE","S_POINTERCANCEL","S_TOUCHEND","S_TOUCHMOVE","S_TOUCHCANCEL","fragmentGetters","S_POINTER","_validateStrList","_validateStrList2","_validateStrList3","_options$minTotalDelt","_options$maxTotalDelt","_options$minTotalDelt2","_options$maxTotalDelt2","_options$minTotalDelt3","_options$maxTotalDelt3","_options$preventDefau","_options$naturalTouch","_options$touchDragHol","_options$touchDragNum","debounceWindow","devices","_directions","directions","_minTotalDeltaX","minTotalDeltaX","_maxTotalDeltaX","maxTotalDeltaX","_minTotalDeltaY","minTotalDeltaY","_maxTotalDeltaY","maxTotalDeltaY","_minTotalDeltaZ","minTotalDeltaZ","_maxTotalDeltaZ","maxTotalDeltaZ","preventNextClick","reverseScroll","dragHoldTime","dragNumFingers","eventQueue","id","callback","debouncedWrapper","fragment","eventQueueCopy","_eventQueueCopy","_eventQueueCopy$","isRemoved","deltaX","deltaY","deltaZ","round","debug7","debug9","clearEventQueue","newTotalDeltaX","min","max","newTotalDeltaY","newTotalDeltaZ","direction","time","lengthOf","timeStamp","data","S_NONE","invoke","catch","wrapper","push","type","map","e","preventDefaultActionFor","setTimer","queue","keepLastEvent","splice","isActualGesture","currentTarget","isPointerDown","S_MOUSEDOWN","buttons","isHTMLElement","focus","preventScroll","S_UNKNOWN","prefix","S_ZOOM","_prefix","_numDecimal"],"sources":["../../../src/ts/watchers/gesture-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/GestureWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  GestureIntent,\n  GestureDevice,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport {\n  addClasses,\n  removeClasses,\n  setNumericStyleJsVars,\n} from \"@lisn/utils/css-alter\";\nimport { isValidDirection } from \"@lisn/utils/directions\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport { addDeltaZ } from \"@lisn/utils/gesture\";\n\nimport {\n  isValidInputDevice,\n  isValidIntent,\n  GestureFragment,\n  DEVICES,\n  INTENTS,\n} from \"@lisn/utils/gesture\";\nimport { getKeyGestureFragment } from \"@lisn/utils/gesture-key\";\nimport { getPointerGestureFragment } from \"@lisn/utils/gesture-pointer\";\nimport { getTouchGestureFragment } from \"@lisn/utils/gesture-touch\";\nimport { getWheelGestureFragment } from \"@lisn/utils/gesture-wheel\";\nimport { logError } from \"@lisn/utils/log\";\nimport {\n  maxAbs,\n  toNonNegNum,\n  toPosNum,\n  toNumWithBounds,\n} from \"@lisn/utils/math\";\nimport { randId, objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { LoggerInterface } from \"@lisn/debug/types\";\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link GestureWatcher} listens for user gestures resulting from wheel,\n * pointer, touch or key input events.\n *\n * It supports scroll, zoom or drag type gestures.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class GestureWatcher {\n  /**\n   * Call the given handler whenever the user performs a gesture on the target\n   * matching the given options.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, either using {@link onGesture} or\n   * {@link trackGesture}, then it will be removed and re-added with the\n   * current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onGesture: (\n    target: EventTarget,\n    handler: OnGestureHandler,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offGesture: (target: EventTarget, handler: OnGestureHandler) => void;\n\n  /**\n   * This is the same as {@link onGesture} except that if `handler` is not\n   * given, then it defaults to an internal handler that updates a set of CSS\n   * variables on the target's style:\n   *\n   *   - `--lisn-js--<Intent>-delta-x`\n   *   - `--lisn-js--<Intent>-delta-y`\n   *   - `--lisn-js--<Intent>-delta-z`\n   *\n   * where and `<Intent>` is one of {@link GestureIntent} and the delta X, Y\n   * and Z are the _total summed up_ `deltaX`, `deltaY` and `deltaZ` since the\n   * callback was added, summed over all devices used (key, touch, etc).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackGesture} or using\n   * {@link onGesture}, then it will be removed and re-added with the current\n   * options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackGesture}.\n   */\n  readonly noTrackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n  ) => void;\n\n  /**\n   * Creates a new instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config?: GestureWatcherConfig) {\n    return new GestureWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config?: GestureWatcherConfig) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new GestureWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: GestureWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"GestureWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"GestureWatcher\", logAtCreation: config })\n      : null;\n\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<\n        OnGestureHandler,\n        {\n          _callback: OnGestureCallback;\n          _wrapper: OnGestureHandlerWrapper;\n          _options: OnGestureOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    // For each target and event type, add only 1 global listener that will then\n    // manage the event queues and callbacks.\n    const allListeners = newXWeakMap<\n      EventTarget,\n      Map<GestureDevice, DeviceListeners>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ): OnGestureCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler for\", options);\n      const { _callback, _wrapper } = getCallbackAndWrapper(\n        handler,\n        options,\n        logger,\n      );\n\n      _callback.onRemove(() => deleteHandler(target, handler, options));\n\n      allCallbacks.sGet(target).set(handler, {\n        _callback,\n        _wrapper,\n        _options: options,\n      });\n\n      return _callback;\n    };\n\n    // ----------\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnGesture = async (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      userOptions: OnGestureOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions ?? {});\n      createCallback(target, handler, options);\n\n      for (const device of options._devices ?? DEVICES) {\n        let listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          debug: logger?.debug4(\n            `Listeners already added for ${device}`,\n            target,\n            options,\n          );\n        } else {\n          debug: logger?.debug4(\n            `Adding listeners for ${device}`,\n            target,\n            options,\n          );\n\n          listeners = setupListeners(target, device, options);\n          allListeners.sGet(target).set(device, listeners);\n        }\n\n        listeners._nCallbacks++;\n        if (options._preventDefault) {\n          listeners._nPreventDefault++;\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ) => {\n      MH.deleteKey(allCallbacks.get(target), handler);\n      allCallbacks.prune(target);\n\n      for (const device of options._devices ?? DEVICES) {\n        const listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          listeners._nCallbacks--;\n          if (options._preventDefault) {\n            listeners._nPreventDefault--;\n          }\n\n          if (!listeners._nCallbacks) {\n            debug: logger?.debug4(\n              `No more callbacks for target and device ${device}; removing listeners`,\n              target,\n            );\n\n            MH.deleteKey(allListeners.get(target), device);\n            listeners._remove();\n          }\n        }\n      }\n    };\n\n    // ----------\n\n    const invokeCallbacks = (\n      target: EventTarget,\n      device: GestureDevice,\n      event: Event,\n    ): boolean /* true if terminated */ => {\n      const preventDefault =\n        (allListeners.get(target)?.get(device)?._nPreventDefault ?? 0) > 0;\n\n      let isTerminated = false;\n      for (const { _wrapper } of allCallbacks.get(target)?.values() || []) {\n        isTerminated =\n          _wrapper(target, device, event, preventDefault) || isTerminated;\n      }\n\n      return isTerminated;\n    };\n\n    // ----------\n\n    const setupListeners = (\n      target: EventTarget,\n      device: GestureDevice,\n      options: OnGestureOptionsInternal,\n    ): DeviceListeners => {\n      const intents = options._intents;\n      let hasAddedTabIndex = false;\n      let hasPreventedSelect = false;\n\n      if (\n        device === MC.S_KEY &&\n        MH.isElement(target) &&\n        !MH.getTabIndex(target)\n      ) {\n        hasAddedTabIndex = true;\n        // enable element to receive keydown events\n        MH.setTabIndex(target);\n      } else if (MH.isElement(target) && device === MC.S_TOUCH) {\n        if (options._preventDefault) {\n          addClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n        }\n\n        if (!intents || MH.includes(intents, MC.S_DRAG)) {\n          hasPreventedSelect = true;\n          preventSelect(target);\n        }\n      }\n\n      const addOrRemoveListeners = (\n        action: \"add\" | \"remove\",\n        listener: EventListener,\n        eventTypes: readonly (keyof GlobalEventHandlersEventMap)[],\n      ) => {\n        const method =\n          action === \"add\" ? addEventListenerTo : removeEventListenerFrom;\n        for (const eventType of eventTypes) {\n          debug: logger?.debug8(`${action} listener for ${eventType}`, target);\n          method(target, eventType, listener, {\n            passive: false,\n            capture: true,\n          });\n        }\n      };\n\n      const addInitialListener = () =>\n        addOrRemoveListeners(\"add\", initialListener, initiatingEvents[device]);\n\n      const removeInitialListener = () =>\n        addOrRemoveListeners(\n          \"remove\",\n          initialListener,\n          initiatingEvents[device],\n        );\n\n      const addOngoingListener = () =>\n        addOrRemoveListeners(\"add\", processEvent, ongoingEvents[device]);\n\n      const removeOngoingListener = () =>\n        addOrRemoveListeners(\"remove\", processEvent, ongoingEvents[device]);\n\n      const initialListener = (event: Event) => {\n        processEvent(event);\n        removeInitialListener();\n        addOngoingListener();\n      };\n\n      const processEvent = (event: Event) => {\n        const isTerminated = invokeCallbacks(target, device, event);\n        if (isTerminated) {\n          removeOngoingListener();\n          addInitialListener();\n        }\n      };\n\n      addInitialListener();\n\n      return {\n        _nCallbacks: 0,\n        _nPreventDefault: 0,\n        _remove: () => {\n          if (MH.isElement(target)) {\n            if (hasAddedTabIndex) {\n              MH.unsetTabIndex(target);\n            }\n\n            removeClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n\n            if (hasPreventedSelect) {\n              undoPreventSelect(target);\n            }\n          }\n\n          removeOngoingListener();\n          removeInitialListener();\n        },\n      };\n    };\n\n    // ----------\n\n    this.trackGesture = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n        // initial values\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, {\n            intent,\n            totalDeltaX: 0,\n            totalDeltaY: 0,\n            totalDeltaZ: 1,\n          });\n        }\n      }\n\n      return setupOnGesture(element, handler, options);\n    };\n\n    // ----------\n\n    this.noTrackGesture = (element, handler?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n\n        // delete the properties\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, { intent });\n        }\n      }\n\n      this.offGesture(element, handler);\n    };\n\n    // ----------\n\n    this.onGesture = setupOnGesture;\n\n    // ----------\n\n    this.offGesture = (target, handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type GestureWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnGestureOptions.preventDefault | preventDefault} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.debounceWindow | debounceWindow} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 150\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.deltaThreshold | deltaThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 5\n   */\n  deltaThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.angleDiffThreshold | angleDiffThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * It does not make much sense to set this to 0.\n   *\n   * The value is in _degrees_, not radians.\n   *\n   * @defaultValue 35\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.naturalTouchScroll | naturalTouchScroll} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragHoldTime | touchDragHoldTime} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 500\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragNumFingers | touchDragNumFingers} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 1\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * @interface\n */\nexport type OnGestureOptions = {\n  /**\n   * One or more device types to listen for. If not specified, then all devices\n   * are enabled.\n   *\n   * It can be a comma-separated list of {@link GestureDevice}s or an array of\n   * such devices.\n   *\n   * @defaultValue undefined\n   */\n  devices?: CommaSeparatedStr<GestureDevice> | GestureDevice[];\n\n  /**\n   * If given, callback will only be called if the gesture's direction is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link Direction}s or an array of such\n   * directions.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<Direction> | Direction[];\n\n  /**\n   * If given, callback will only be called if the gesture's intent is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link GestureIntent}s or an\n   * array of such intents.\n   *\n   * @defaultValue undefined\n   */\n  intents?: CommaSeparatedStr<GestureIntent> | GestureIntent[];\n\n  /**\n   * Set minimum total delta X. Further reductions in delta X below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaX?: number;\n\n  /**\n   * Set maximum total delta X. Further increase in delta X above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaX?: number;\n\n  /**\n   * Set minimum total delta Y. Further reductions in delta Y below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaY?: number;\n\n  /**\n   * Set maximum total delta Y. Further increase in delta Y above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaY?: number;\n\n  /**\n   * Set minimum total delta Z. Further reductions in delta Z below this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and can be less than 1 but\n   * must be > 0.1 which is a hard minimum.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaZ?: number;\n\n  /**\n   * Set maximum total delta Z. Further increase in delta Z above this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and must be positive.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaZ?: number;\n\n  /**\n   * If true, the events of the gesture, e.g. relevant key presses or touch\n   * moves, etc, will have their default action prevented.\n   *\n   * **IMPORTANT:** For pointer gestures, then pointer/mouse down and click\n   * will be prevented.\n   *\n   * @defaultValue {@link GestureWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If given, callback will be called at most once every `debounceWindow`\n   * milliseconds.\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n\n  /**\n   * Callback will only be called when the gesture's accumulated delta, since\n   * the last time callback was called, exceeds `deltaThreshold`.\n   *\n   * At least one of the three deltas (X, Y or Z) must exceed this number (in\n   * absolute value). Note that when comparing `deltaZ`, it is multiplied by\n   * 100 since it represents fractions of 1 (100%). So supplying\n   * `deltaThreshold` of 10 means is equivalent to the following condition:\n   *\n   * ```\n   * abs(deltaX) >= 10 || abs(deltaY) >= 10 ||  abs(1 - deltaZ) >= 0.1\n   * ```\n   *\n   * Accumulation of the delta ends if the gesture is terminated, for example,\n   * in case of touch gestures, by a \"touchcancel\" event of by the final finger\n   * lifting off..\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.deltaThreshold}\n   */\n  deltaThreshold?: number;\n\n  /**\n   * See {@link Utils.getVectorDirection | getVectorDirection}.\n   *\n   * @defaultValue {@link GestureWatcherConfig.angleDiffThreshold}\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * Whether touch scroll gestures follow the natural direction: swipe up\n   * with scroll intent results in direction down and swipe down results in\n   * direction up.\n   *\n   * @defaultValue {@link GestureWatcherConfig.naturalTouchScroll}\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * If the user presses and holds on a touchscreen for at least the given\n   * amount of milliseconds before moving the finger(s), touch gestures other\n   * than pinch will be treated as a drag intent instead of scroll as long as\n   * the number of fingers touching the screen is {@link touchDragNumFingers}.\n   *\n   * Set to 0 in order to treat _all_ non-pinch touch gestures as drag.\n   *\n   * Set to a negative number in order to treat _all_ non-pinch touch gestures\n   * as scroll.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The number of fingers that could be considered a drag intent for touch\n   * gestures.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link GestureWatcher.onGesture}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link GestureData} that describes the gesture's progression since the\n *   last time the callback was called and since the callback was added.\n */\nexport type OnGestureHandlerArgs = [EventTarget, GestureData, Event[]];\nexport type OnGestureCallback = Callback<OnGestureHandlerArgs>;\nexport type OnGestureHandler =\n  | CallbackHandler<OnGestureHandlerArgs>\n  | OnGestureCallback;\n\nexport type GestureData = {\n  device: GestureDevice;\n  direction: Direction;\n  intent: GestureIntent;\n\n  /**\n   * Delta in the horizontal direction since the start of the gesture.\n   */\n  deltaX: number;\n\n  /**\n   * Delta in the vertical direction since the start of the gesture.\n   */\n  deltaY: number;\n\n  /**\n   * Relative fractional zoom in or out for zoom intents since the start of\n   * the gesture.\n   *\n   * For zoom in, `deltaZ` is always > 1, and for zoom out it is < 1.\n   *\n   * For non-zoom gestures it is 1.\n   */\n  deltaZ: number;\n\n  /**\n   * The time in milliseconds it took for the gesture. This will be the\n   * difference in timestamps between the first and last event that composed\n   * the gesture. For key and wheel gestures this could be 0, since 1 event is\n   * sufficient for them.\n   */\n  time: number;\n  // TODO totalTime, velocity (bound by max), averageVelocity (bound by max)\n\n  /**\n   * Delta in the horizontal direction since the callback was added.\n   */\n  totalDeltaX: number;\n\n  /**\n   * Delta in the vertical direction since the callback was added.\n   */\n  totalDeltaY: number;\n\n  /**\n   * Percentage (relative) zoom in or out for zoom intents since the callback\n   * was added.\n   */\n  totalDeltaZ: number;\n};\n\n// ----------------------------------------\n\ntype GestureWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureOptionsInternal = {\n  _devices: GestureDevice[] | null;\n  _directions: Direction[] | null;\n  _intents: GestureIntent[] | null;\n  _minTotalDeltaX: number | null;\n  _maxTotalDeltaX: number | null;\n  _minTotalDeltaY: number | null;\n  _maxTotalDeltaY: number | null;\n  _minTotalDeltaZ: number | null;\n  _maxTotalDeltaZ: number | null;\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureHandlerWrapper = (\n  _target: EventTarget,\n  _device: GestureDevice,\n  _event: Event,\n  _preventDefault: boolean,\n) => boolean;\n\n// Specific to a combination of target + device\ntype DeviceListeners = {\n  _nCallbacks: number; // total number of callbacks\n  _nPreventDefault: number; // total number wanting to prevent default action\n  _remove: () => void;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, GestureWatcher>();\n\nconst getConfig = (\n  config: GestureWatcherConfig | undefined,\n): GestureWatcherConfigInternal => {\n  config ??= {};\n  return {\n    _preventDefault: config.preventDefault ?? true,\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 150),\n    _deltaThreshold: toNonNegNum(config.deltaThreshold, 5),\n    _angleDiffThreshold: toPosNum(config.angleDiffThreshold, 35),\n    _naturalTouchScroll: config.naturalTouchScroll ?? true,\n    _touchDragHoldTime: config.touchDragHoldTime ?? 500,\n    _touchDragNumFingers: config.touchDragNumFingers ?? 1,\n  };\n};\n\nconst initiatingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform it into mousedown\n  //\n  // We need to listen for click, since that occurs after a pointerup (i.e.\n  // after a gesure is terminated and the ongoing listeners removed), but it\n  // needs to have its default action prevented.\n  pointer: [MC.S_POINTERDOWN, MC.S_CLICK],\n  touch: [MC.S_TOUCHSTART],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst ongoingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  pointer: [\n    // If the browser doesn't support point events, then\n    // addEventListenerTo will transform them into mouse*\n    MC.S_POINTERDOWN,\n    MC.S_POINTERUP, // would terminate\n    MC.S_POINTERMOVE,\n    MC.S_POINTERCANCEL, // would terminate\n    MC.S_CLICK, // would terminate; can be default-prevented\n  ],\n  touch: [MC.S_TOUCHSTART, MC.S_TOUCHEND, MC.S_TOUCHMOVE, MC.S_TOUCHCANCEL],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst fragmentGetters: {\n  [D in GestureDevice]: (\n    events: Event[],\n    options: {\n      deltaThreshold?: number;\n      angleDiffThreshold?: number;\n      reverseScroll?: boolean;\n      dragHoldTime?: number;\n      dragNumFingers?: number;\n    },\n  ) => GestureFragment | null | false;\n} = {\n  [MC.S_KEY]: getKeyGestureFragment,\n  [MC.S_POINTER]: getPointerGestureFragment,\n  [MC.S_TOUCH]: getTouchGestureFragment,\n  [MC.S_WHEEL]: getWheelGestureFragment,\n};\n\nconst getOptions = (\n  config: GestureWatcherConfigInternal,\n  options: OnGestureOptions,\n): OnGestureOptionsInternal => {\n  const debounceWindow = toNonNegNum(\n    options[MC.S_DEBOUNCE_WINDOW],\n    config._debounceWindow, // watcher is never debounced, so apply default here\n  );\n  const deltaThreshold = toNonNegNum(\n    options.deltaThreshold,\n    config._deltaThreshold,\n  );\n\n  return {\n    _devices:\n      validateStrList(\"devices\", options.devices, isValidInputDevice) ?? null,\n    _directions:\n      validateStrList(\"directions\", options.directions, isValidDirection) ??\n      null,\n    _intents:\n      validateStrList(\"intents\", options.intents, isValidIntent) ?? null,\n    _minTotalDeltaX: options.minTotalDeltaX ?? null,\n    _maxTotalDeltaX: options.maxTotalDeltaX ?? null,\n    _minTotalDeltaY: options.minTotalDeltaY ?? null,\n    _maxTotalDeltaY: options.maxTotalDeltaY ?? null,\n    _minTotalDeltaZ: options.minTotalDeltaZ ?? null,\n    _maxTotalDeltaZ: options.maxTotalDeltaZ ?? null,\n    _preventDefault: options.preventDefault ?? config._preventDefault,\n    _debounceWindow: debounceWindow,\n    _deltaThreshold: deltaThreshold,\n    _angleDiffThreshold: toNonNegNum(\n      options.angleDiffThreshold,\n      config._angleDiffThreshold,\n    ),\n    _naturalTouchScroll:\n      options.naturalTouchScroll ?? config._naturalTouchScroll,\n    _touchDragHoldTime: options.touchDragHoldTime ?? config._touchDragHoldTime,\n    _touchDragNumFingers:\n      options.touchDragNumFingers ?? config._touchDragNumFingers,\n  };\n};\n\n// Since each callback needs to accumulate events during its debounce window\n// and until its threshold is exceeded, we use a wrapper around the\n// user-supplied handler to do that.\nconst getCallbackAndWrapper = (\n  handler: OnGestureHandler,\n  options: OnGestureOptionsInternal,\n  logger: LoggerInterface | null,\n): { _callback: OnGestureCallback; _wrapper: OnGestureHandlerWrapper } => {\n  let totalDeltaX = 0,\n    totalDeltaY = 0,\n    totalDeltaZ = 1;\n  // When there's a pointer down, drag then pointerup, since we prevent\n  // pointerdown default action, this results in a click event shortly\n  // afterwards even when there's been a movement of the mouse. We detect that\n  // and prevent this click.\n  let preventNextClick = false;\n\n  const directions = options._directions;\n  const intents = options._intents;\n  const minTotalDeltaX = options._minTotalDeltaX;\n  const maxTotalDeltaX = options._maxTotalDeltaX;\n  const minTotalDeltaY = options._minTotalDeltaY;\n  const maxTotalDeltaY = options._maxTotalDeltaY;\n  const minTotalDeltaZ = options._minTotalDeltaZ;\n  const maxTotalDeltaZ = options._maxTotalDeltaZ;\n  const deltaThreshold = options._deltaThreshold;\n  const angleDiffThreshold = options._angleDiffThreshold;\n  const reverseScroll = !options._naturalTouchScroll;\n  const dragHoldTime = options._touchDragHoldTime;\n  const dragNumFingers = options._touchDragNumFingers;\n\n  // The event queue is cleared when the threshold is exceeded AND the debounce\n  // window has passed. It's not necessary for the actual handler to be called\n  // then (e.g. if the direction or intent doesn't match, it won't be).\n  const eventQueue: Event[] = [];\n  const id = randId();\n\n  // Since handler could be a function or a callback (not callable), we wrap it\n  // so that in case it's already a callback, its removal will result in\n  // deleteHandler getting called. It is not debounced itself, instead there's\n  // a debounced wrapper that invokes it.\n  const callback = wrapCallback(handler);\n\n  // The debounced callback wrapper is what is debounced.\n  // It accumulates total deltas and checks if the conditions (of threshold,\n  // direction and intent) are satisfied before calling the real handler.\n  //\n  // Most importantly, since it is only called when the debounce window has\n  // expired it can clear the event queue if the threshold is also exceeded.\n  const debouncedWrapper = getDebouncedHandler(\n    options._debounceWindow,\n    (\n      target: EventTarget,\n      fragment: GestureFragment,\n      eventQueueCopy: Event[],\n    ) => {\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      const deltaX = fragment.deltaX;\n      const deltaY = fragment.deltaY;\n      const deltaZ = fragment.deltaZ;\n      const device = fragment.device;\n\n      if (\n        MH.round(maxAbs(deltaX, deltaY, (1 - deltaZ) * 100)) < deltaThreshold\n      ) {\n        debug: logger?.debug7(\n          `[${id}] Delta threshold not exceeded for callback`,\n        );\n        return;\n      }\n\n      debug: logger?.debug9(`[${id}] Done summing events for ${device}`);\n      clearEventQueue(device, eventQueue);\n\n      const newTotalDeltaX = toNumWithBounds(totalDeltaX + deltaX, {\n        min: minTotalDeltaX,\n        max: maxTotalDeltaX,\n      });\n\n      const newTotalDeltaY = toNumWithBounds(totalDeltaY + deltaY, {\n        min: minTotalDeltaY,\n        max: maxTotalDeltaY,\n      });\n\n      const newTotalDeltaZ = toNumWithBounds(addDeltaZ(totalDeltaZ, deltaZ), {\n        min: minTotalDeltaZ,\n        max: maxTotalDeltaZ,\n      });\n\n      if (\n        newTotalDeltaX === totalDeltaX &&\n        newTotalDeltaY === totalDeltaY &&\n        newTotalDeltaZ === totalDeltaZ\n      ) {\n        return;\n      }\n\n      totalDeltaX = newTotalDeltaX;\n      totalDeltaY = newTotalDeltaY;\n      totalDeltaZ = newTotalDeltaZ;\n\n      const direction = fragment.direction;\n      const intent = fragment.intent;\n      const time =\n        eventQueueCopy[MH.lengthOf(eventQueueCopy) - 1]?.timeStamp -\n          eventQueueCopy[0]?.timeStamp || 0;\n\n      const data = {\n        device,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n        time,\n        totalDeltaX,\n        totalDeltaY,\n        totalDeltaZ,\n      };\n\n      if (\n        direction !== MC.S_NONE &&\n        (!directions || MH.includes(directions, direction)) &&\n        (!intents || MH.includes(intents, intent))\n      ) {\n        callback.invoke(target, data, eventQueueCopy).catch(logError);\n      } else {\n        debug: logger?.debug7(\n          `[${id}] Directions or intents not matching for callback`,\n        );\n      }\n    },\n  );\n\n  // This wrapper is NOT debounced and adds the events to the queue, prevents\n  // default action if needed, and indicates whether the gesture is terminated.\n  const wrapper = (\n    target: EventTarget,\n    device: GestureDevice,\n    event: Event,\n    preventDefault: boolean,\n  ) => {\n    eventQueue.push(event);\n\n    const fragment = fragmentGetters[device](eventQueue, {\n      angleDiffThreshold,\n      deltaThreshold,\n      reverseScroll,\n      dragHoldTime,\n      dragNumFingers,\n    });\n\n    debug: logger?.debug8(\n      `[${id}] Got fragment for ${device} (${event.type})`,\n      fragment,\n      [...eventQueue].map((e) => e.type),\n    );\n\n    if (preventDefault) {\n      preventDefaultActionFor(\n        event,\n        !!fragment || (event.type === MC.S_CLICK && preventNextClick),\n      );\n    }\n\n    if (fragment === false) {\n      // not enough events in the queue, pass\n      debug: logger?.debug9(`[${id}] Not enough events for gesture ${device}`);\n      return false;\n    } else if (fragment === null) {\n      // consider the gesture terminated\n      clearEventQueue(device, eventQueue);\n      debug: logger?.debug9(`[${id}] Gesture for ${device} terminated`);\n      return true;\n    }\n\n    if (device === MC.S_POINTER) {\n      // If we're here, there's been a drag, expect a click immediately\n      // afterwards and prevent default action.\n      preventNextClick = true;\n      MH.setTimer(() => {\n        preventNextClick = false;\n      }, 10);\n    }\n\n    debouncedWrapper(\n      target,\n      fragment,\n      [...eventQueue], // copy\n    );\n\n    return false;\n  };\n\n  return { _callback: callback, _wrapper: wrapper };\n};\n\nconst clearEventQueue = (device: GestureDevice, queue: Event[]) => {\n  const keepLastEvent = device === MC.S_POINTER || device === MC.S_TOUCH;\n  queue.splice(0, MH.lengthOf(queue) - (keepLastEvent ? 1 : 0));\n};\n\nconst preventDefaultActionFor = (event: Event, isActualGesture: boolean) => {\n  const target = event.currentTarget;\n  const eventType = event.type;\n  const isPointerDown =\n    eventType === MC.S_POINTERDOWN || eventType === MC.S_MOUSEDOWN;\n\n  if (\n    eventType === MC.S_TOUCHMOVE ||\n    eventType === MC.S_WHEEL ||\n    ((eventType === MC.S_CLICK || eventType === MC.S_KEYDOWN) &&\n      isActualGesture) ||\n    (isPointerDown && (event as MouseEvent).buttons === 1)\n  ) {\n    MH.preventDefault(event);\n\n    if (isPointerDown && MH.isHTMLElement(target)) {\n      // Otherwise capturing key events won't work\n      target.focus({ preventScroll: true });\n    }\n  }\n};\n\nconst setGestureCssProps = (\n  target: EventTarget,\n  data: Partial<GestureData>,\n) => {\n  const intent = data.intent;\n\n  if (!MH.isElement(target) || !intent || intent === MC.S_UNKNOWN) {\n    return;\n  }\n\n  const prefix = `${intent}-`;\n\n  if (intent === MC.S_ZOOM) {\n    setNumericStyleJsVars(\n      target,\n      {\n        deltaZ: data.totalDeltaZ,\n      },\n      {\n        _prefix: prefix,\n        _numDecimal: 2,\n      },\n    ); // don't await here\n  } else {\n    setNumericStyleJsVars(\n      target,\n      {\n        deltaX: data.totalDeltaX,\n        deltaY: data.totalDeltaY,\n      },\n      {\n        _prefix: prefix,\n      },\n    ); // don't await here\n  }\n};\n"],"mappings":"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","ignoreList":[]}