{"version":3,"file":"scroll-watcher.js","names":["MC","MH","setNumericStyleJsVars","getMaxDeltaDirection","moveElement","tryWrapContent","waitForMeasureTime","addEventListenerTo","removeEventListenerFrom","logError","toNonNegNum","maxAbs","scrollTo","getCurrentScrollAction","getClientWidthNow","getClientHeightNow","tryGetMainScrollableElement","fetchMainContentElement","fetchMainScrollableElement","fetchScrollableElement","isValidScrollDirection","objToStrKey","validateStrList","wrapCallback","newXWeakMap","DOMWatcher","SizeWatcher","debug","ScrollWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","instance","instances","get","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","allScrollData","newWeakMap","activeListeners","allCallbacks","newMap","fetchCurrentScroll","element","realtime","isScrollEvent","previousEventData","latestData","fetchScrollData","direction","createCallback","handler","options","trackType","_allCallbacks$get","_element","remove","_callback","debug5","callback","_debounceWindow","onRemove","deleteHandler","entry","_trackType","_options","sGet","setupOnScroll","userOptions","fetchOnScrollOptions","eventTarget","_eventTarget","scrollData","isRemoved","_data","TRACK_FULL","setupSizeTrack","listenerOptions","debug4","_nRealtime","S_SCROLL","scrollHandler","directions","_directions","skipInitial","directionMatches","invokeCallback","removeOnScroll","scrollable","_allCallbacks$get2","currEntry","setScrollCssProps","deleteKey","prune","has","scrollCallback","debug8","doc","getDoc","docScrollingElement","getDocScrollingElement","resizeCallback","thresholdsExceeded","hasExceededThreshold","debug9","sizeWatcher","setupOnResize","target","onResize","S_DEBOUNCE_WINDOW","threshold","_threshold","observedElements","newSet","wrapper","classNames","PREFIX_WRAPPER","add","child","childrenOf","domWatcher","root","subtree","onAddedCallback","operation","currentTargetOf","to","ignoreMove","onMutation","categories","S_ADDED","event","_activeListeners$get","targetOf","isElement","isDoc","_allCallbacks$get3","values","then","scroll","_options$amount","usageError","isVertical","S_UP","S_DOWN","sign","S_LEFT","targetCoordinate","amount","asFractionOf","el","S_SCROLL_TOP","S_SCROLL_LEFT","S_SCROLL_HEIGHT","S_SCROLL_WIDTH","undefined","top","left","merge","duration","_scrollDuration","fetchCurrentScrollAction","stopUserScrolling","stopScroll","elScrollTo","immediate","trackScroll","noTrackScroll","onScroll","TRACK_REGULAR","offScroll","SYMBOL","prefixName","_scrollThreshold","scrollThreshold","scrollDuration","_options$MC$S_DEBOUNC","getEventTarget","userDirections","latestDirection","includes","lastThresholdData","topDiff","S_CLIENT_HEIGHT","leftDiff","S_CLIENT_WIDTH","checkTop","checkLeft","S_NONE","S_AMBIGUOUS","S_RIGHT","scrollTop","ceil","scrollLeft","scrollWidth","scrollHeight","clientWidth","clientHeight","scrollTopFraction","round","INFINITY","scrollLeftFraction","prevScrollTop","prevScrollLeft","S_SCROLL_TOP_FRACTION","S_SCROLL_LEFT_FRACTION","prefix","getDocElement","props","_prefix","invoke","copyObject","catch"],"sources":["../../../src/ts/watchers/scroll-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/ScrollWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { XYDirection, ScrollDirection, SizeTarget } from \"@lisn/globals/types\";\n\nimport {\n  ScrollTarget,\n  TargetCoordinate,\n  TargetCoordinates,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { setNumericStyleJsVars } from \"@lisn/utils/css-alter\";\nimport { getMaxDeltaDirection } from \"@lisn/utils/directions\";\nimport { moveElement, tryWrapContent } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum, maxAbs } from \"@lisn/utils/math\";\nimport {\n  scrollTo,\n  getCurrentScrollAction,\n  getClientWidthNow,\n  getClientHeightNow,\n  tryGetMainScrollableElement,\n  fetchMainContentElement,\n  fetchMainScrollableElement,\n  fetchScrollableElement,\n  isValidScrollDirection,\n  ScrollAction,\n  ScrollToOptions,\n} from \"@lisn/utils/scroll\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { MutationOperation, DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n// re-export for convenience\nexport type { ScrollAction, ScrollToOptions } from \"@lisn/utils/scroll\";\n\n/**\n * {@link ScrollWatcher} listens for scroll events in any direction.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class ScrollWatcher {\n  /**\n   * Call the given handler whenever the given scrollable is scrolled.\n   *\n   * Unless {@link OnScrollOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest scroll data. If a scroll has\n   * not yet been observed on the scrollable and its `scrollTop` and\n   * `scrollLeft` are 0, then the direction is {@link Types.NoDirection} and\n   * the handler is only called if {@link Types.NoDirection} is part of the\n   * supplied {@link OnScrollOptions.directions | options.directions} (or\n   * {@link OnScrollOptions.directions | options.directions} is not given).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking content size changes using\n   * {@link trackScroll}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onScroll: (\n    handler: OnScrollHandler,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly offScroll: (\n    handler: OnScrollHandler,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * This everything that {@link onScroll} does plus more:\n   *\n   * In addition to a scroll event, the handler is also called when either the\n   * offset size or scroll (content) size of the scrollable changes as that\n   * would affect its `scrollTopFraction` and `scrollLeftFraction` and possibly\n   * the `scrollTop` and `scrollLeft` as well.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates a set of CSS variables on the scrollable element's style:\n   *\n   * - If {@link OnScrollOptions.scrollable | options.scrollable} is not given,\n   *   or is `null`, `window` or `document`, the following CSS variables are\n   *   set on the root (`html`) element and represent the scroll of the\n   *   {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}:\n   *   - `--lisn-js--page-scroll-top`\n   *   - `--lisn-js--page-scroll-top-fraction`\n   *   - `--lisn-js--page-scroll-left`\n   *   - `--lisn-js--page-scroll-left-fraction`\n   *   - `--lisn-js--page-scroll-width`\n   *   - `--lisn-js--page-scroll-height`\n   *\n   * - Otherwise, the following variables are set on the scrollable itself,\n   *   and represent its scroll offset:\n   *   - `--lisn-js--scroll-top`\n   *   - `--lisn-js--scroll-top-fraction`\n   *   - `--lisn-js--scroll-left`\n   *   - `--lisn-js--scroll-left-fraction`\n   *   - `--lisn-js--scroll-width`\n   *   - `--lisn-js--scroll-height`\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackScroll: (\n    handler?: OnScrollHandler | null,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackScroll}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly noTrackScroll: (\n    handler?: OnScrollHandler | null,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * Get the scroll offset of the given scrollable. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                 this only when doing realtime scroll-based animations\n   *                 as it may cause a forced layout.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScroll: (\n    scrollable?: ScrollTarget,\n    realtime?: boolean,\n  ) => Promise<ScrollData>;\n\n  /**\n   * Scrolls the given scrollable element to in the given direction.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the direction or options are invalid.\n   */\n  readonly scroll: (\n    direction: XYDirection,\n    options?: ScrollOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Scrolls the given scrollable element to the given `to` scrollable.\n   *\n   * Returns `null` if there's an ongoing scroll that is not cancellable.\n   *\n   * Note that if `to` is an element or a selector, then it _must_ be a\n   * descendant of the scrollable element.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the \"to\" coordinates or options are invalid.\n   *\n   * @param to If this is an element, then its top-left position is used as\n   *           the target coordinates. If it is a string, then it is treated\n   *           as a selector for an element using `querySelector`.\n   * @param [options.scrollable]\n   *           If not given, it defaults to\n   *           {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}.\n   *\n   * @returns `null` if there's an ongoing scroll that is not cancellable,\n   * otherwise a {@link ScrollAction}.\n   */\n  readonly scrollTo: (\n    to: TargetCoordinates | Element | string,\n    options?: ScrollToOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Returns the current {@link ScrollAction} if any.\n   *\n   * @param scrollable If not given, it defaults to\n   *                   {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScrollAction: (\n    scrollable?: Element,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Cancels the ongoing scroll that's resulting from smooth scrolling\n   * triggered in the past. Does not interrupt or prevent further scrolling.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   *\n   * @param [options.immediate] If true, then it will not use\n   *                            {@link waitForMeasureTime} or\n   *                            {@link Utils.waitForMutateTime | waitForMutateTime}.\n   *                            Warning: this will likely result in forced layout.\n   */\n  readonly stopUserScrolling: (options?: {\n    scrollable?: ScrollTarget;\n    immediate?: boolean;\n  }) => Promise<void>;\n\n  /**\n   * Returns the element that holds the main page content. By default it's\n   * `document.body` but is overridden by\n   * {@link Settings.settings.mainScrollableElementSelector}.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainContentElement(): Promise<HTMLElement> {\n    return fetchMainContentElement();\n  }\n\n  /**\n   * Returns the scrollable element that holds the wrapper around the main page\n   * content. By default it's `document.scrollable` (unless `document.body` is\n   * actually scrollable, in which case it will be used) but it will be\n   * different if {@link Settings.settings.mainScrollableElementSelector} is set.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainScrollableElement(): Promise<HTMLElement> {\n    return fetchMainScrollableElement();\n  }\n\n  /**\n   * Creates a new instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ScrollWatcherConfig = {}) {\n    return new ScrollWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ScrollWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new ScrollWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ScrollWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ScrollWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ScrollWatcher\", logAtCreation: config })\n      : null;\n\n    const allScrollData = MH.newWeakMap<Element, ScrollData>();\n\n    const activeListeners = MH.newWeakMap<\n      ScrollTarget,\n      { _nRealtime: number }\n    >();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnScrollHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const fetchCurrentScroll = async (\n      element: Element,\n      realtime = false,\n      isScrollEvent = false,\n    ): Promise<ScrollData> => {\n      // The scroll data can change event without a scroll event, e.g. by the\n      // element changing size, so always get the latest here.\n      const previousEventData = allScrollData.get(element);\n      const latestData = await fetchScrollData(\n        element,\n        previousEventData,\n        realtime,\n      );\n\n      // If there hasn't been a scroll event, use the old scroll direction\n      if (!isScrollEvent && previousEventData) {\n        latestData.direction = previousEventData.direction;\n      }\n      return latestData;\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n      trackType: TrackType,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      };\n      allCallbacks.sGet(element).set(handler, entry);\n\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnScroll = async (\n      handler: OnScrollHandler,\n      userOptions: OnScrollOptions | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, userOptions || {});\n      const element = options._element;\n\n      // Don't await for the scroll data before creating the callback so that\n      // setupOnScroll and removeOnScroll have the same \"timing\" and therefore\n      // calling onScroll and offScroll immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options, trackType);\n      const callback = entry._callback;\n\n      const eventTarget = options._eventTarget;\n      const scrollData = await fetchCurrentScroll(\n        element,\n        options._debounceWindow === 0,\n      );\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = scrollData;\n      allScrollData.set(element, scrollData);\n\n      if (trackType === TRACK_FULL) {\n        await setupSizeTrack(entry);\n      }\n\n      let listenerOptions = activeListeners.get(eventTarget);\n      if (!listenerOptions) {\n        debug: logger?.debug4(\"Adding scroll listener\", eventTarget);\n        listenerOptions = { _nRealtime: 0 };\n        activeListeners.set(eventTarget, listenerOptions);\n        // Don't debounce the scroll handler, only the callbacks.\n        addEventListenerTo(eventTarget, MC.S_SCROLL, scrollHandler);\n      }\n\n      if (options._debounceWindow === 0) {\n        listenerOptions._nRealtime++;\n      }\n\n      const directions = options._directions;\n      if (\n        !callback.isRemoved() &&\n        !userOptions?.skipInitial &&\n        directionMatches(directions, scrollData.direction)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", element, scrollData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, scrollData);\n      }\n    };\n\n    // ----------\n\n    const removeOnScroll = async (\n      handler: OnScrollHandler,\n      scrollable: ScrollTarget | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, { scrollable });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setScrollCssProps) {\n          // delete the properties\n          setScrollCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n    ) => {\n      const element = options._element;\n      const eventTarget = options._eventTarget;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      const listenerOptions = activeListeners.get(eventTarget);\n      if (listenerOptions && options._debounceWindow === 0) {\n        listenerOptions._nRealtime--;\n      }\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for scrollable; removing listener\",\n          element,\n        );\n\n        MH.deleteKey(allScrollData, element);\n        removeEventListenerFrom(eventTarget, MC.S_SCROLL, scrollHandler);\n        MH.deleteKey(activeListeners, eventTarget);\n        // TODO: Should we unwrap children if previously WE wrapped them?\n      }\n    };\n\n    // ----------\n\n    const setupSizeTrack = async (entry: CallbackEntry) => {\n      const options = entry._options;\n      const element = options._element;\n      const scrollCallback = entry._callback;\n      debug: logger?.debug8(\"Setting up size tracking\", element);\n\n      const doc = MH.getDoc();\n      const docScrollingElement = MH.getDocScrollingElement();\n\n      const resizeCallback = wrapCallback(async () => {\n        // Get the latest scroll data for the scrollable\n        // Currently, the resize callback is already delayed by a frame due to\n        // the SizeWatcher, so we don't need to treat this as realtime.\n        const latestData = await fetchCurrentScroll(element);\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n        } else if (!scrollCallback.isRemoved()) {\n          await invokeCallback(scrollCallback, element, latestData);\n        }\n      });\n\n      scrollCallback.onRemove(resizeCallback.remove);\n\n      // Don't use default instance as it has a high threshold.\n      const sizeWatcher = SizeWatcher.reuse();\n      const setupOnResize = (target?: SizeTarget) =>\n        sizeWatcher.onResize(resizeCallback, {\n          target,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          // TODO maybe accepts resizeThreshold option\n          threshold: options._threshold,\n        });\n\n      if (element === docScrollingElement) {\n        // In case we're tracking the main document scroll, then we only need to\n        // observe the viewport size and the size of the documentElement (which is\n        // the content size).\n\n        setupOnResize(); // viewport size\n        setupOnResize(doc); // content size\n\n        return;\n      }\n\n      // ResizeObserver only detects changes in offset width/height which is\n      // the visible size of the scrolling element, and that is not affected by the\n      // size of its content.\n      // But we also need to detect changes in the scroll width/height which is\n      // the size of the content.\n      // We also need to keep track of elements being added to the scrollable element.\n\n      const observedElements = MH.newSet<Element>([element]);\n\n      // Observe the scrolling element\n      setupOnResize(element);\n\n      // And also its children (if possible, a single wrapper around them\n      const wrapper = await tryWrapContent(element, {\n        classNames: [MC.PREFIX_WRAPPER, PREFIX_WRAPPER],\n      });\n      if (wrapper) {\n        setupOnResize(wrapper);\n        observedElements.add(wrapper);\n\n        //\n      } else {\n        for (const child of MH.childrenOf(element)) {\n          setupOnResize(child);\n          observedElements.add(child);\n        }\n      }\n\n      // Watch for newly added elements\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      const onAddedCallback = wrapCallback((operation: MutationOperation) => {\n        const child = MH.currentTargetOf(operation);\n        // If we've just added the wrapper, it will be in DOMWatcher's queue,\n        // so check.\n        if (child !== wrapper) {\n          if (wrapper) {\n            // Move this child into the wrapper. If this results in change of size\n            // for wrapper, SizeWatcher will call us.\n            moveElement(child, { to: wrapper, ignoreMove: true });\n          } else {\n            // Track the size of this child.\n            // Don't skip initial, call the callback now\n            setupOnResize(child);\n            observedElements.add(child);\n          }\n        }\n      });\n\n      domWatcher.onMutation(onAddedCallback, { categories: [MC.S_ADDED] });\n      resizeCallback.onRemove(onAddedCallback.remove);\n    };\n\n    // ----------\n\n    const scrollHandler = async (event: Event) => {\n      // We cannot use event.currentTarget because scrollHandler is called inside\n      // a setTimeout so by that time, currentTarget is null or something else.\n      //\n      // However, target and currentTarget only differ when the event is in the\n      // bubbling or capturing phase. Because\n      //\n      // - the scroll event only bubbles when fired on document, and (it only\n      //   bubbles up to window)\n      // - and we never attach the listener to the capturing phase\n      // - and we always use document instead of window to listen for scroll on\n      //   document\n      //\n      // then event.target suffices.\n      const scrollable = MH.targetOf(event);\n      /* istanbul ignore next */\n      if (!scrollable || !(MH.isElement(scrollable) || MH.isDoc(scrollable))) {\n        return;\n      }\n\n      const element = await fetchScrollableElement(scrollable);\n      const realtime = (activeListeners.get(scrollable)?._nRealtime || 0) > 0;\n      const latestData = await fetchCurrentScroll(element, realtime, true);\n      allScrollData.set(element, latestData);\n\n      debug: logger?.debug9(\"Scroll event\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        // Consider the direction since the last scroll event and not the\n        // direction based on the largest delta the last time the callback\n        // was called.\n        const options = entry._options;\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n          continue;\n        }\n\n        // If threshold has been exceeded, always update the latest data for\n        // this callback.\n        entry._data = latestData;\n\n        if (!directionMatches(options._directions, latestData.direction)) {\n          debug: logger?.debug9(\n            \"Direction does not match\",\n            options,\n            latestData,\n          );\n          continue;\n        }\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentScroll = (scrollable?, realtime?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        fetchCurrentScroll(element, realtime),\n      );\n\n    // ----------\n\n    this.scroll = (direction, options = {}) => {\n      if (!isValidScrollDirection(direction)) {\n        throw MH.usageError(`Unknown scroll direction: '${direction}'`);\n      }\n\n      const isVertical = direction === MC.S_UP || direction === MC.S_DOWN;\n      const sign = direction === MC.S_UP || direction === MC.S_LEFT ? -1 : 1;\n      let targetCoordinate: TargetCoordinate;\n\n      const amount = options.amount ?? 100;\n      const asFractionOf = options.asFractionOf;\n\n      if (asFractionOf === \"visible\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * getClientHeightNow(el)) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * getClientWidthNow(el)) / 100;\n\n        //\n      } else if (asFractionOf === \"content\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * el[MC.S_SCROLL_HEIGHT]) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * el[MC.S_SCROLL_WIDTH]) / 100;\n\n        //\n      } else if (asFractionOf !== undefined && asFractionOf !== \"pixel\") {\n        throw MH.usageError(\n          `Unknown 'asFractionOf' keyword: '${asFractionOf}'`,\n        );\n\n        //\n      } else {\n        targetCoordinate = isVertical\n          ? (el) => el[MC.S_SCROLL_TOP] + sign * amount\n          : (el) => el[MC.S_SCROLL_LEFT] + sign * amount;\n      }\n\n      const target = isVertical\n        ? { top: targetCoordinate }\n        : { left: targetCoordinate };\n\n      return this.scrollTo(target, options);\n    };\n\n    // ----------\n\n    this.scrollTo = async (to, options = {}) =>\n      scrollTo(\n        to,\n        MH.merge(\n          { duration: config._scrollDuration }, // default\n          options,\n          {\n            scrollable: await fetchScrollableElement(options.scrollable),\n          }, // override\n        ),\n      );\n\n    // ----------\n\n    this.fetchCurrentScrollAction = (scrollable?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        getCurrentScrollAction(element),\n      );\n\n    // ----------\n\n    this.stopUserScrolling = async (options = {}) => {\n      const element = await fetchScrollableElement(options.scrollable);\n      const stopScroll = () =>\n        MH.elScrollTo(element, {\n          top: element[MC.S_SCROLL_TOP],\n          left: element[MC.S_SCROLL_LEFT],\n        });\n\n      if (options.immediate) {\n        stopScroll();\n      } else {\n        waitForMeasureTime().then(stopScroll);\n      }\n    };\n\n    // ----------\n\n    this.trackScroll = (handler?, options?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      return setupOnScroll(handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackScroll = (handler?, scrollable?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      removeOnScroll(handler, scrollable, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onScroll = (handler, options?) =>\n      setupOnScroll(handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offScroll = (handler, scrollable?) => {\n      removeOnScroll(handler, scrollable, TRACK_REGULAR); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type ScrollWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnScrollOptions.debounceWindow | debounceWindow} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnScrollOptions.threshold | threshold} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 50\n   */\n  scrollThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link ScrollOptions.duration | duration} in calls to\n   * {@link ScrollWatcher.scroll} and {@link ScrollWatcher.scrollTo}.\n   *\n   * @defaultValue 1000\n   */\n  scrollDuration?: number;\n};\n\n/**\n * @interface\n */\nexport type OnScrollOptions = {\n  /**\n   * If it is not given, or is `null`, `window` or `document`, then it will\n   * track the scroll of the\n   * {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}.\n   *\n   * Other values must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  scrollable?: ScrollTarget;\n\n  /**\n   * If non-0, the scroll handler will only be called when the scrollable's\n   * scroll offset in the observed direction has changed at least\n   * `scrollThreshold` pixels since the last time the handler was called.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.scrollThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Specifies a list of {@link ScrollDirection}s to listen for.\n   *\n   * It can be a comma-separated list of direction names or an array of such\n   * names.\n   *\n   * If not given, then it listens for scrolls in any direction, including\n   * {@link Types.NoDirection} and {@link Types.AmbiguousDirection}.\n   *\n   * The {@link Types.NoDirection} occurs when the callback is called initially\n   * (if `skipInitial` is not `true`) and there hasn't yet been a scroll\n   * observed on the scrollable _and_ it's `scrollTop`/`scrollLeft` are 0.\n   *\n   * The {@link Types.AmbiguousDirection} occurs when the user scrolls\n   * diagonally with close to equal deltas in both horizontal and vertical\n   * direction.\n   *\n   * **IMPORTANT:**\n   *\n   * The direction of a scroll event is always based on comparing `deltaX` and\n   * `deltaY` relative to the _last scroll event_ (within the `debounceWindow`,\n   * and not to the scroll data for the last time the callback was called (in\n   * case it was skipped because `threshold` was not exceeded or in case it was\n   * debounced by a larger window than the watcher).\n   *\n   * I.e. if you have both `threshold` and `directions` restricted, or if the\n   * callback has a larger debounce window than the watcher, it is possible for\n   * there to be a change in the relevant `scrollTop`/`scrollLeft` offset that\n   * exceeds the threshold, and for the callback to _not_ be called.\n   *\n   * For a callback to be called, both of these must be true:\n   * - the change in `scrollTop`/`scrollLeft`, _compared to the last time the\n   *   callback was called_ must exceed the {@link threshold}\n   * - the effective scroll direction, _compared to the last scroll event_\n   *   prior to the _watcher's_ debounce window must be one of the given\n   *   {@link directions}.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<ScrollDirection> | ScrollDirection[];\n\n  /**\n   * Do not call the handler until there's a future scroll of the element.\n   *\n   * By default we call the handler (almost) immediately if there's been a\n   * scroll in one of the given directions, or if there has not been a scroll\n   * but directions includes {@link Types.NoDirection}, but you can disable\n   * this initial call here.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts, but you probably need this when doing\n   * scroll-based animations.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * @interface\n */\nexport type ScrollOptions = ScrollToOptions & {\n  /**\n   * How much to scroll in the given direction.\n   *\n   * @defaultValue 100\n   */\n  amount?: number;\n\n  /**\n   * If set to \"pixel\" (default), `amount` is taken as absolute pixels.\n   *\n   * If set to \"visible\", `amount` is taken as percent of the element's visible\n   * size in the scrolling direction (100 means full client width for\n   * horizontal or height for vertical scroll).\n   *\n   * If set to \"content\", `amount` is taken as percent of the element's full\n   * content size in the scrolling direction (100 means full scroll width for\n   * horizontal or height for vertical scroll).\n   *\n   * @defaultValue \"pixel\"\n   */\n  asFractionOf?: \"pixel\" | \"visible\" | \"content\";\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the element that has been resized\n * - the {@link ScrollData} for the element\n */\nexport type OnScrollHandlerArgs = [Element, ScrollData];\nexport type OnScrollCallback = Callback<OnScrollHandlerArgs>;\nexport type OnScrollHandler =\n  | CallbackHandler<OnScrollHandlerArgs>\n  | OnScrollCallback;\n\nexport type ScrollData = {\n  clientWidth: number;\n  clientHeight: number;\n\n  scrollTop: number;\n\n  /**\n   * This is the `scrollTop` relative to the full `scrollHeight` minus the\n   * `clientHeight`, ranging from 0 to 1.\n   */\n  scrollTopFraction: number;\n\n  scrollLeft: number;\n\n  /**\n   * This is the `scrollLeft` relative to the full `scrollWidth` minus the\n   * `clientWidth`, ranging from 0 to 1.\n   */\n  scrollLeftFraction: number;\n\n  scrollWidth: number;\n  scrollHeight: number;\n\n  /**\n   * This is the direction of the last scroll action, i.e. _compared to the\n   * last scroll event_, not necessarily based on the deltas compared to the\n   * last time this callback was called.\n   */\n  direction: ScrollDirection;\n};\n\n// ----------------------------------------\n\ntype ScrollWatcherConfigInternal = {\n  _debounceWindow: number;\n  _scrollThreshold: number;\n  _scrollDuration: number;\n};\n\ntype OnScrollOptionsInternal = {\n  _element: Element;\n  _eventTarget: ScrollTarget;\n  _directions: ScrollDirection[] | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnScrollCallback;\n  _trackType: TrackType;\n  _options: OnScrollOptionsInternal;\n  _data?: ScrollData;\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, ScrollWatcher>();\n\nconst PREFIX_WRAPPER = MH.prefixName(\"scroll-watcher-wrapper\");\n\nconst getConfig = (\n  config: ScrollWatcherConfig,\n): ScrollWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _scrollThreshold: toNonNegNum(config.scrollThreshold, 50) || 1,\n    _scrollDuration: toNonNegNum(config.scrollDuration, 1000),\n  };\n};\n\nconst TRACK_REGULAR = 1; // only scroll events\nconst TRACK_FULL = 2; // scroll + resizing of content and/or wrapper\n\n// --------------------\n\nconst fetchOnScrollOptions = async (\n  config: ScrollWatcherConfigInternal,\n  options: OnScrollOptions,\n): Promise<OnScrollOptionsInternal> => {\n  const directions =\n    validateStrList(\"directions\", options.directions, isValidScrollDirection) ||\n    null;\n\n  const element = await fetchScrollableElement(options.scrollable);\n\n  return {\n    _element: element,\n    _eventTarget: getEventTarget(element),\n    _directions: directions,\n    // If threshold is 0, internally treat as 1 (pixel)\n    _threshold: toNonNegNum(options.threshold, config._scrollThreshold) || 1,\n    _debounceWindow: options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n  };\n};\n\nconst directionMatches = (\n  userDirections: ScrollDirection[] | null,\n  latestDirection: ScrollDirection,\n) => !userDirections || MH.includes(userDirections, latestDirection);\n\nconst hasExceededThreshold = (\n  options: OnScrollOptionsInternal,\n  latestData: ScrollData,\n  lastThresholdData: ScrollData | undefined,\n): boolean => {\n  const directions = options._directions;\n  const threshold = options._threshold;\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  const topDiff = maxAbs(\n    latestData[MC.S_SCROLL_TOP] - lastThresholdData[MC.S_SCROLL_TOP],\n    latestData[MC.S_SCROLL_HEIGHT] - lastThresholdData[MC.S_SCROLL_HEIGHT],\n    latestData[MC.S_CLIENT_HEIGHT] - lastThresholdData[MC.S_CLIENT_HEIGHT],\n  );\n\n  const leftDiff = maxAbs(\n    latestData[MC.S_SCROLL_LEFT] - lastThresholdData[MC.S_SCROLL_LEFT],\n    latestData[MC.S_SCROLL_WIDTH] - lastThresholdData[MC.S_SCROLL_WIDTH],\n    latestData[MC.S_CLIENT_WIDTH] - lastThresholdData[MC.S_CLIENT_WIDTH],\n  );\n\n  // If the callback is only interested in up/down, then only check the\n  // scrollTop delta, and similarly for left/right.\n  let checkTop = false,\n    checkLeft = false;\n  if (\n    !directions ||\n    MH.includes(directions, MC.S_NONE) ||\n    MH.includes(directions, MC.S_AMBIGUOUS)\n  ) {\n    checkTop = checkLeft = true;\n  } else {\n    if (\n      MH.includes(directions, MC.S_UP) ||\n      MH.includes(directions, MC.S_DOWN)\n    ) {\n      checkTop = true;\n    }\n    if (\n      MH.includes(directions, MC.S_LEFT) ||\n      MH.includes(directions, MC.S_RIGHT)\n    ) {\n      checkLeft = true;\n    }\n  }\n\n  return (\n    (checkTop && topDiff >= threshold) || (checkLeft && leftDiff >= threshold)\n  );\n};\n\nconst fetchScrollData = async (\n  element: Element,\n  previousEventData: ScrollData | undefined,\n  realtime: boolean,\n): Promise<ScrollData> => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollTop = MH.ceil(element[MC.S_SCROLL_TOP]);\n  const scrollLeft = MH.ceil(element[MC.S_SCROLL_LEFT]);\n  const scrollWidth = element[MC.S_SCROLL_WIDTH];\n  const scrollHeight = element[MC.S_SCROLL_HEIGHT];\n  const clientWidth = getClientWidthNow(element);\n  const clientHeight = getClientHeightNow(element);\n\n  const scrollTopFraction =\n    MH.round(scrollTop) / (scrollHeight - clientHeight || MC.INFINITY);\n  const scrollLeftFraction =\n    MH.round(scrollLeft) / (scrollWidth - clientWidth || MC.INFINITY);\n\n  const prevScrollTop = previousEventData?.scrollTop || 0;\n  const prevScrollLeft = previousEventData?.scrollLeft || 0;\n\n  const direction = getMaxDeltaDirection(\n    scrollLeft - prevScrollLeft,\n    scrollTop - prevScrollTop,\n  );\n\n  return {\n    direction,\n    [MC.S_SCROLL_TOP]: scrollTop,\n    [MC.S_SCROLL_TOP_FRACTION]: scrollTopFraction,\n    [MC.S_SCROLL_LEFT]: scrollLeft,\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollLeftFraction,\n    [MC.S_SCROLL_WIDTH]: scrollWidth,\n    [MC.S_SCROLL_HEIGHT]: scrollHeight,\n    [MC.S_CLIENT_WIDTH]: clientWidth,\n    [MC.S_CLIENT_HEIGHT]: clientHeight,\n  };\n};\n\nconst setScrollCssProps = (\n  element: Element,\n  scrollData: Partial<ScrollData> | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetMainScrollableElement()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"page-\";\n  }\n\n  scrollData = scrollData || {};\n  const props = {\n    [MC.S_SCROLL_TOP]: scrollData[MC.S_SCROLL_TOP],\n    [MC.S_SCROLL_TOP_FRACTION]: scrollData[MC.S_SCROLL_TOP_FRACTION],\n    [MC.S_SCROLL_LEFT]: scrollData[MC.S_SCROLL_LEFT],\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollData[MC.S_SCROLL_LEFT_FRACTION],\n    [MC.S_SCROLL_WIDTH]: scrollData[MC.S_SCROLL_WIDTH],\n    [MC.S_SCROLL_HEIGHT]: scrollData[MC.S_SCROLL_HEIGHT],\n  };\n  setNumericStyleJsVars(element, props, { _prefix: prefix });\n};\n\nconst getEventTarget = (element: Element): ScrollTarget => {\n  if (element === MH.getDocScrollingElement()) {\n    return MH.getDoc();\n  }\n\n  return element;\n};\n\nconst invokeCallback = (\n  callback: OnScrollCallback,\n  element: Element,\n  scrollData: ScrollData,\n) => callback.invoke(element, MH.copyObject(scrollData)).catch(logError);\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAWd,SAASC,qBAAqB;AAC9B,SAASC,oBAAoB;AAC7B,SAASC,WAAW,EAAEC,cAAc;AACpC,SAASC,kBAAkB;AAC3B,SAASC,kBAAkB,EAAEC,uBAAuB;AACpD,SAASC,QAAQ;AACjB,SAASC,WAAW,EAAEC,MAAM;AAC5B,SACEC,QAAQ,EACRC,sBAAsB,EACtBC,iBAAiB,EACjBC,kBAAkB,EAClBC,2BAA2B,EAC3BC,uBAAuB,EACvBC,0BAA0B,EAC1BC,sBAAsB,EACtBC,sBAAsB;AAIxB,SAASC,WAAW;AACpB,SAASC,eAAe;AAExB,SAGEC,YAAY;AAEd,SAASC,WAAW;AAEpB,SAA4BC,UAAU;AACtC,SAASC,WAAW;AAEpB,OAAOC,KAAK;;AAEZ;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EAmLzB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOX,uBAAuBA,CAAA,EAAyB;IACrD,OAAOA,uBAAuB,CAAC,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,0BAA0BA,CAAA,EAAyB;IACxD,OAAOA,0BAA0B,CAAC,CAAC;EACrC;;EAEA;AACF;AACA;AACA;EACE,OAAOW,MAAMA,CAACC,MAA2B,GAAG,CAAC,CAAC,EAAE;IAC9C,OAAO,IAAIF,aAAa,CAACG,SAAS,CAACD,MAAM,CAAC,EAAEE,eAAe,CAAC;EAC9D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAKA,CAACH,MAA2B,GAAG,CAAC,CAAC,EAAE;IAC7C,MAAMI,QAAQ,GAAGH,SAAS,CAACD,MAAM,CAAC;IAClC,MAAMK,YAAY,GAAGd,WAAW,CAACa,QAAQ,CAAC;IAE1C,IAAIE,QAAQ,GAAGC,SAAS,CAACC,GAAG,CAACH,YAAY,CAAC;IAC1C,IAAI,CAACC,QAAQ,EAAE;MACbA,QAAQ,GAAG,IAAIR,aAAa,CAACM,QAAQ,EAAEF,eAAe,CAAC;MACvDK,SAAS,CAACE,GAAG,CAACJ,YAAY,EAAEC,QAAQ,CAAC;IACvC;IAEA,OAAOA,QAAQ;EACjB;EAEQI,WAAWA,CACjBV,MAAmC,EACnCW,GAA2B,EAC3B;IAxOF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApBEC,eAAA;IA0BA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAzCEA,eAAA;IA+CA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAVEA,eAAA;IAgBA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApBEA,eAAA;IA0BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAREA,eAAA;IAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAXEA,eAAA;IAwEE,IAAID,GAAG,KAAKT,eAAe,EAAE;MAC3B,MAAM/B,EAAE,CAAC0C,uBAAuB,CAAC,sBAAsB,CAAC;IAC1D;IAEA,MAAMC,MAAM,GAAGjB,KAAK,GAChB,IAAIA,KAAK,CAACkB,MAAM,CAAC;MAAEC,IAAI,EAAE,eAAe;MAAEC,aAAa,EAAEjB;IAAO,CAAC,CAAC,GAClE,IAAI;IAER,MAAMkB,aAAa,GAAG/C,EAAE,CAACgD,UAAU,CAAsB,CAAC;IAE1D,MAAMC,eAAe,GAAGjD,EAAE,CAACgD,UAAU,CAG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","ignoreList":[]}