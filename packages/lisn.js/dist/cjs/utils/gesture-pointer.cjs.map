{"version":3,"file":"gesture-pointer.cjs","names":["MC","_interopRequireWildcard","require","MH","_directions","_event","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","getPointerGestureFragment","events","options","isIterableObject","isCancelled","supports","getBrowserSupport","pointerEventClass","_pointer","PointerEvent","MouseEvent","pointerUpType","S_POINTERUP","S_MOUSEUP","filteredEvents","filter","event","eType","type","S_POINTERCANCEL","S_CLICK","isInstanceOf","buttons","isTouchPointerEvent","numEvents","lengthOf","firstEvent","lastEvent","getPointerType","deltaX","clientX","deltaY","clientY","direction","getVectorDirection","angleDiffThreshold","S_NONE","device","S_POINTER","intent","S_DRAG","deltaZ","exports"],"sources":["../../../src/ts/utils/gesture-pointer.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\nimport { getBrowserSupport } from \"@lisn/utils/event\";\nimport { GestureFragment } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. If the browser\n * supports Pointer events, then only \"pointermove\" events will be considered.\n * Otherwise, only \"mousemove\" events will be considered.\n *\n * If there are less than 2 such events in the given list of events, returns\n * `false`.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"pointercancel\" in the list or buttons other than the primary are pressed,\n * returns `null`.\n *\n * Pointer gestures always require the primary button to be pressed and the\n * resulting intent is always \"drag\", and `deltaZ` is always 1.\n *\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}\n *\n * @return {} `false` if there are less than 2 \"pointermove\"/\"mousemove\" events\n * in the list, `null` if the gesture is terminated, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getPointerGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let isCancelled = false;\n  const supports = getBrowserSupport();\n\n  // If the browser supports pointer events, then only take those; otherwise\n  // take the mouse events\n  const pointerEventClass = supports._pointer ? PointerEvent : MouseEvent;\n  const pointerUpType = supports._pointer ? MC.S_POINTERUP : MC.S_MOUSEUP;\n\n  const filteredEvents: MouseEvent[] = MH.filter(\n    events,\n    (event): event is MouseEvent => {\n      const eType = event.type;\n      isCancelled = isCancelled || eType === MC.S_POINTERCANCEL;\n      if (eType !== MC.S_CLICK && MH.isInstanceOf(event, pointerEventClass)) {\n        // Only events where the primary button is pressed (unless it's a\n        // pointerup event, in which case no buttons should be pressed) are\n        // considered, otherwise consider it terminated\n        isCancelled =\n          isCancelled ||\n          (eType === pointerUpType && event.buttons !== 0) ||\n          (eType !== pointerUpType && event.buttons !== 1);\n        // we don't handle touch pointer events\n        return !MH.isTouchPointerEvent(event);\n      }\n      return false;\n    },\n  );\n\n  const numEvents = MH.lengthOf(filteredEvents);\n  if (numEvents < 2) {\n    return false; // no enough events\n  }\n\n  if (isCancelled) {\n    return null; // terminated\n  }\n\n  const firstEvent = filteredEvents[0];\n  const lastEvent = filteredEvents[numEvents - 1];\n  if (MH.getPointerType(firstEvent) !== MH.getPointerType(lastEvent)) {\n    return null; // different devices, consider it terminated\n  }\n\n  const deltaX = lastEvent.clientX - firstEvent.clientX;\n  const deltaY = lastEvent.clientY - firstEvent.clientY;\n  const direction = getVectorDirection(\n    [deltaX, deltaY],\n    options?.angleDiffThreshold,\n  );\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_POINTER,\n        direction,\n        intent: MC.S_DRAG,\n        deltaX,\n        deltaY,\n        deltaZ: 1,\n      };\n};\n"],"mappings":"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","ignoreList":[]}