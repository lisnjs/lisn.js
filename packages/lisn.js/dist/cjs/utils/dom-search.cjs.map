{"version":3,"file":"dom-search.cjs","names":["MH","_interopRequireWildcard","require","_cssAlter","_domEvents","_log","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","getReferenceElement","spec","thisElement","referenceElement","getElementById","slice","relation","find","p","startsWith","usageError","rest","lengthOf","matchOp","refOrCls","selector","_getData","getData","PREFIX_REF","DATA_REF","getFirstReferenceElement","getLastReferenceElement","getThisReferenceElement","getNextReferenceElement","getPrevReferenceElement","logError","bugError","exports","waitForReferenceElement","timeout","waitForElement","prefixName","prefixData","getAllReferenceElements","docQuerySelectorAll","docQuerySelector","allRefs","closest","getNextOrPrevReferenceElement","goBackward","_getThisReferenceElem","_allRefs$refIndex","getDoc","contains","numRefs","refIndex","currentIsAfter","isNodeBAfterA"],"sources":["../../../src/ts/utils/dom-search.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Searching for reference elements\n * The functions allow you to find elements that match a given string\n * specification.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { logError } from \"@lisn/utils/log\";\n\n/**\n * Get the element that matches the given reference specification.\n *\n * The specification is of the form:\n *\n * ```\n * <FullSpec> ::=\n *     <Relation> \".\" <ClassName>  |\n *     <Relation> [\"-\" <ReferenceName>] |\n *     #<DOM_ID>\n *\n * <Relation> :==\n *     \"next\"  |\n *     \"prev\"  |\n *     \"this\"  |\n *     \"first\" |\n *     \"last\"\n * ```\n *\n * - `<DOM_ID>` is the unique ID of the element\n * - `<ClassName>` is a CSS class on the element\n * - `<ReferenceName>` is the value of the `data-lisn-ref` attribute on the\n *   element you are targeting. If not given, defaults to the value of the\n *   `data-lisn-ref` attribute on `thisElement`.\n *\n * There now follows an explanation of how \"next\", \"prev\", \"this\", \"first\" and\n * \"last\" search the DOM:\n * - \"next\": the tree is search in document order (depth first, then breadth),\n *   so the returned element could be a descendant of `thisElement`\n * - \"prev\": the tree is search in document order (depth first, then breadth),\n *   but excluding ancestors of `thisElement`, so the returned element is\n *   guaranteed to _not_ be an ancestor or descendant of `thisElement`.\n * - \"this\": if the given element itself matches the specification, it is\n *   returned, otherwise the closest ancestor of the given element that matches\n *   the specification\n * - \"first\": the first element matching; the tree is search in document order\n *   (depth first, then breadth).\n * - \"last\": the last element matching; the tree is search in document order\n *   (depth first, then breadth).\n *\n * @category DOM: Searching for reference elements\n *\n * @param thisElement The element to search relative to\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                        If the specification is invalid or if thisElement is\n *                        not given for a specification of \"next\", \"prev\" or \"this\"\n */\nexport const getReferenceElement = (\n  spec: string,\n  thisElement: Element,\n): Element | null => {\n  if (!spec) {\n    return thisElement;\n  }\n\n  if (spec[0] === \"#\") {\n    // element ID\n    const referenceElement = MH.getElementById(spec.slice(1));\n    if (!referenceElement) {\n      return null;\n    }\n    return referenceElement;\n  }\n\n  const relation = [\"next\", \"prev\", \"this\", \"first\", \"last\"].find(\n    (p) => spec.startsWith(`${p}.`) || spec.startsWith(`${p}-`) || spec === p,\n  );\n\n  if (!relation) {\n    throw MH.usageError(`Invalid search specification '${spec}'`);\n  }\n\n  const rest = spec.slice(MH.lengthOf(relation));\n  const matchOp = rest.slice(0, 1);\n  let refOrCls = rest.slice(1);\n\n  let selector: string;\n  if (matchOp === \".\") {\n    selector = matchOp + refOrCls;\n  } else {\n    if (!refOrCls) {\n      refOrCls = getData(thisElement, PREFIX_REF) ?? \"\";\n    }\n\n    if (!refOrCls) {\n      throw MH.usageError(`No reference name in '${spec}'`);\n    }\n\n    selector = `[${DATA_REF}=\"${refOrCls}\"]`;\n  }\n\n  let referenceElement;\n  if (relation === \"first\") {\n    referenceElement = getFirstReferenceElement(selector);\n  } else if (relation === \"last\") {\n    referenceElement = getLastReferenceElement(selector);\n  } else {\n    if (relation === \"this\") {\n      referenceElement = getThisReferenceElement(selector, thisElement);\n    } else if (relation === \"next\") {\n      referenceElement = getNextReferenceElement(selector, thisElement);\n    } else if (relation === \"prev\") {\n      referenceElement = getPrevReferenceElement(selector, thisElement);\n    } else {\n      /* istanbul ignore next */ {\n        logError(MH.bugError(`Unhandled relation case ${relation}`));\n        return null;\n      }\n    }\n  }\n\n  if (!referenceElement) {\n    return null;\n  }\n\n  return referenceElement;\n};\n\n/**\n * Like {@link getReferenceElement} excepts if no element matches the\n * specification if will wait for at most the given time for such an element.\n *\n * @category DOM: Searching for reference elements\n */\nexport const waitForReferenceElement = (\n  spec: string,\n  thisElement: Element,\n  timeout = 200,\n) => waitForElement(() => getReferenceElement(spec, thisElement), timeout);\n\n// ----------------------------------------\n\nconst PREFIX_REF = MH.prefixName(\"ref\");\nconst DATA_REF = MH.prefixData(PREFIX_REF);\n\nconst getAllReferenceElements = (\n  selector: string,\n): NodeListOf<Element> | null => MH.docQuerySelectorAll(selector);\n\nconst getFirstReferenceElement = (selector: string): Element | null =>\n  MH.docQuerySelector(selector);\n\nconst getLastReferenceElement = (selector: string): Element | null => {\n  const allRefs = getAllReferenceElements(selector);\n  return (allRefs && allRefs[MH.lengthOf(allRefs) - 1]) || null;\n};\n\nconst getThisReferenceElement = (\n  selector: string,\n  thisElement: Element,\n): Element | null => thisElement.closest(selector);\n\nconst getNextReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, false);\n\nconst getPrevReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, true);\n\nconst getNextOrPrevReferenceElement = (\n  selector: string,\n  thisElement: Element,\n  goBackward: boolean,\n): Element | null => {\n  thisElement = getThisReferenceElement(selector, thisElement) ?? thisElement;\n\n  if (!MH.getDoc().contains(thisElement)) {\n    return null;\n  }\n\n  const allRefs = getAllReferenceElements(selector);\n  if (!allRefs) {\n    return null;\n  }\n\n  const numRefs = MH.lengthOf(allRefs);\n  let refIndex = goBackward ? numRefs - 1 : -1;\n  for (let i = 0; i < numRefs; i++) {\n    const currentIsAfter = MH.isNodeBAfterA(thisElement, allRefs[i]);\n\n    // As soon as we find either the starting element or the first element\n    // that follows it, stop iteration.\n    // - If we're looking for the previous reference, then take the previous\n    //   element in the iteration.\n    // - Otherwise, if the current element in the iteration is the same as the\n    //   starting one, then take either the next element in the iteration.\n    //   - Otherwise, (if the current element follows the starting one, as\n    //     would happen if the starting element was not in the list of matched\n    //     elements, take the current element in the iteration.\n    if (allRefs[i] === thisElement || currentIsAfter) {\n      refIndex = i + (goBackward ? -1 : currentIsAfter ? 0 : 1);\n      break;\n    }\n  }\n\n  return allRefs[refIndex] ?? null;\n};\n"],"mappings":"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","ignoreList":[]}