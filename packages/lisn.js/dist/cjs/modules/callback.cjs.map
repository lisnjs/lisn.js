{"version":3,"file":"callback.cjs","names":["MC","_interopRequireWildcard","require","MH","_tasks","_debug","_interopRequireDefault","_Callback","e","__esModule","default","_getRequireWildcardCache","WeakMap","r","t","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","wrapCallback","handlerOrCallback","debounceWindow","isFunction","isRemoved","callback","callablesMap","handler","args","invoke","wrapper","Callback","getDebouncedHandler","onRemove","remove","exports","constructor","logger","debug","Logger","name","logAtCreation","id","SYMBOL","newSet","debug8","rmFn","CallbackScheduler","_clear","fn","add","newPromise","resolve","reject","usageError","_push","result","err","REMOVE","newWeakMap","queues","newMap","flush","queue","lengthOf","_running","_task","shift","item","_onRemove","deleteKey","task","push"],"sources":["../../../src/ts/modules/callback.ts"],"sourcesContent":["/**\n * @module Modules/Callback\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * @typeParam Args  See {@link Callback}\n */\nexport type CallbackHandler<Args extends unknown[] = []> = (\n  ...args: Args\n) => CallbackReturnType | Promise<CallbackReturnType>;\n\nexport type CallbackReturnType =\n  | typeof Callback.KEEP\n  | typeof Callback.REMOVE\n  | void;\n\n/**\n * For minification optimization. Exposed through Callback.wrap.\n *\n * @ignore\n * @internal\n */\nexport const wrapCallback = <Args extends unknown[] = []>(\n  handlerOrCallback: CallbackHandler<Args> | Callback<Args>,\n  debounceWindow = 0,\n): Callback<Args> => {\n  const isFunction = MH.isFunction(handlerOrCallback);\n  let isRemoved = () => false;\n\n  if (isFunction) {\n    // check if it's an invoke method\n    const callback = callablesMap.get(handlerOrCallback);\n    if (callback) {\n      return wrapCallback(callback);\n    }\n  } else {\n    isRemoved = handlerOrCallback.isRemoved;\n  }\n\n  const handler: CallbackHandler<Args> = isFunction\n    ? handlerOrCallback\n    : (...args: Args) => handlerOrCallback.invoke(...args);\n\n  const wrapper = new Callback<Args>(\n    getDebouncedHandler(debounceWindow, (...args: Args) => {\n      if (!isRemoved()) {\n        return handler(...args);\n      }\n    }),\n  );\n\n  if (!isFunction) {\n    handlerOrCallback.onRemove(wrapper.remove);\n  }\n\n  return wrapper;\n};\n\n/**\n * {@link Callback} wraps user-supplied callbacks. Supports\n * - removing a callback either when calling {@link remove} or if the user\n *   handler returns {@link Callback.REMOVE}\n * - calling custom {@link onRemove} hooks\n * - debouncing (via {@link wrap})\n * - awaiting on an asynchronous handler and ensuring that the handler does not\n *  run concurrently to itself, i.e. subsequent {@link invoke}s will be queued\n *\n * @typeParam Args  The type of arguments that the callback expects.\n */\nexport class Callback<Args extends unknown[] = []> {\n  /**\n   * Possible return value for the handler.\n   *\n   * Do not do anything. Same as not retuning anything from the function.\n   */\n  static readonly KEEP: unique symbol = MC.SYMBOL(\n    \"KEEP\",\n  ) as typeof Callback.KEEP;\n\n  /**\n   * Possible return value for the handler.\n   *\n   * Will remove this callback.\n   */\n  static readonly REMOVE: unique symbol = MC.SYMBOL(\n    \"REMOVE\",\n  ) as typeof Callback.REMOVE;\n\n  /**\n   * Call the handler with the given arguments.\n   *\n   * If the handler is asynchronous, it awaits on it. Furthermore, calls will\n   * always wait for previous calls to this handler to complete first, i.e. it\n   * never runs concurrently to itself. If you need multiple calls to the async\n   * handler to run concurrently, then wrap it in a non-async function that\n   * does not await it.\n   *\n   * The returned promise is rejected in two cases:\n   * - If the callback throws an error or returns a rejected Promise.\n   * - If the callback is removed _after_ you call {@link invoke} but before the\n   *   handler is actually called (while it's waiting in the queue to be called)\n   *   In this case, the rejection reason is {@link Callback.REMOVE}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the callback is already removed.\n   */\n  readonly invoke: (...args: Args) => Promise<void>;\n\n  /**\n   * Mark the callback as removed and call the registered {@link onRemove} hooks.\n   *\n   * Future attempts to call it will result in\n   * {@link Errors.LisnUsageError | LisnUsageError}.\n   */\n  readonly remove: () => void;\n\n  /**\n   * Returns true if the callback has been removed and cannot be called again.\n   */\n  readonly isRemoved: () => boolean;\n\n  /**\n   * Registers the given function to be called when the callback is removed.\n   *\n   * You can call {@link onRemove} multiple times to register multiple hooks.\n   */\n  readonly onRemove: (fn: () => void) => void;\n\n  /**\n   * Wraps the given handler or callback as a callback, optionally debounced by\n   * the given debounce window.\n   *\n   * If the argument is already a callback _or an invoke method of a callback_,\n   * then the wrapper will call that callback and return the same value as it.\n   * It will also set up the returned wrapper callback so that it is removed\n   * when the original (given) callback is removed. However, removing the\n   * returned wrapper callback will _not_ cause the original callback (being\n   * wrapped) to be removed. If you want to do this, then do\n   * `wrapper.onRemove(wrapped.remove)`.\n   *\n   * Note that if the argument is a callback that's already debounced by a\n   * _larger_ window, then `debounceWindow` will have no effect.\n   *\n   * @param {} debounceWindow  If non-0, the callback will be called at most\n   *                           every `debounceWindow` ms. The arguments it will\n   *                           be called with will be the last arguments the\n   *                           wrapper was called with.\n   */\n  static readonly wrap = wrapCallback;\n\n  /**\n   * @param {} handler     The actual function to call. This should return one of\n   *                       the known {@link CallbackReturnType} values.\n   */\n  constructor(handler: CallbackHandler<Args>) {\n    const logger = debug\n      ? new debug.Logger({ name: \"Callback\", logAtCreation: handler })\n      : null;\n\n    let isRemoved = false;\n    const id = MC.SYMBOL();\n\n    const onRemove = MH.newSet<() => void>();\n\n    this.isRemoved = () => isRemoved;\n\n    this.remove = () => {\n      debug: logger?.debug8(\"Removing\");\n      if (!isRemoved) {\n        isRemoved = true;\n\n        for (const rmFn of onRemove) {\n          rmFn();\n        }\n\n        CallbackScheduler._clear(id);\n      }\n    };\n\n    this.onRemove = (fn) => onRemove.add(fn);\n\n    this.invoke = (...args) =>\n      MH.newPromise((resolve, reject) => {\n        debug: logger?.debug8(\"Calling with\", args);\n        if (isRemoved) {\n          reject(MH.usageError(\"Callback has been removed\"));\n          return;\n        }\n\n        CallbackScheduler._push(\n          id,\n          async () => {\n            let result;\n            try {\n              result = await handler(...args);\n            } catch (err) {\n              reject(err);\n            }\n\n            if (result === Callback.REMOVE) {\n              this.remove();\n            }\n\n            resolve();\n          },\n          reject,\n        );\n      });\n\n    callablesMap.set(this.invoke, this);\n  }\n}\n\n// ----------------------------------------\n\ntype CallbackSchedulerTask = () => Promise<void>;\ntype CallbackSchedulerQueueItem = {\n  _task: CallbackSchedulerTask;\n  _running: boolean;\n  _onRemove: (reason: typeof Callback.REMOVE) => void;\n};\n\ntype CallableCallback<Args extends unknown[] = []> = (...args: Args) => void;\n\nconst callablesMap = MH.newWeakMap<CallableCallback, Callback>();\n\nconst CallbackScheduler = (() => {\n  const queues = MH.newMap<symbol, CallbackSchedulerQueueItem[]>();\n\n  const flush = async (queue: CallbackSchedulerQueueItem[]) => {\n    // So that callbacks are always called asynchronously for consistency,\n    // await here before calling 1st\n    await null;\n    while (MH.lengthOf(queue)) {\n      // shouldn't throw anything as Callback must catch errors\n      queue[0]._running = true;\n      await queue[0]._task();\n\n      // only remove when done\n      queue.shift();\n    }\n  };\n\n  return {\n    _clear: (id: symbol) => {\n      const queue = queues.get(id);\n      if (queue) {\n        let item: CallbackSchedulerQueueItem | undefined;\n        while ((item = queue.shift())) {\n          if (!item._running) {\n            item._onRemove(Callback.REMOVE);\n          }\n        }\n\n        MH.deleteKey(queues, id);\n      }\n    },\n\n    _push: (id: symbol, task: CallbackSchedulerTask, onRemove: () => void) => {\n      let queue = queues.get(id);\n      if (!queue) {\n        queue = [];\n        queues.set(id, queue);\n      }\n\n      queue.push({ _task: task, _onRemove: onRemove, _running: false });\n      if (MH.lengthOf(queue) === 1) {\n        flush(queue);\n      }\n    },\n  };\n})();\n"],"mappings":"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","ignoreList":[]}