{"version":3,"file":"directions.js","names":["MC","MH","maxAbs","areParallel","isValidStrList","validateStrList","getMaxDeltaDirection","deltaX","deltaY","abs","S_NONE","S_AMBIGUOUS","S_LEFT","S_RIGHT","S_UP","S_DOWN","getVectorDirection","vector","angleDiffThreshold","min","getOppositeDirection","direction","OPPOSITE_DIRECTIONS","usageError","getOppositeXYDirections","directions","directionList","isValidXYDirection","opposites","opposite","includes","push","lengthOf","XY_DIRECTIONS","isValidZDirection","Z_DIRECTIONS","isValidDirection","DIRECTIONS","isValidDirectionList","S_IN","S_OUT","SCROLL_DIRECTIONS"],"sources":["../../../src/ts/utils/directions.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  XYDirection,\n  ZDirection,\n  NoDirection,\n  AmbiguousDirection,\n  CommaSeparatedStr,\n  Vector,\n} from \"@lisn/globals/types\";\n\nimport { maxAbs, areParallel } from \"@lisn/utils/math\";\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\n/**\n * Returns the cardinal direction in the XY plane for the larger of the two\n * deltas (horizontal vs vertical).\n *\n * If both deltas are 0, returns \"none\".\n *\n * If both deltas are equal and non-0, returns \"ambiguous\".\n *\n * @category Directions\n */\nexport const getMaxDeltaDirection = (\n  deltaX: number,\n  deltaY: number,\n): XYDirection | NoDirection | AmbiguousDirection => {\n  if (!MH.abs(deltaX) && !MH.abs(deltaY)) {\n    return MC.S_NONE;\n  }\n\n  if (MH.abs(deltaX) === MH.abs(deltaY)) {\n    return MC.S_AMBIGUOUS;\n  }\n\n  if (MH.abs(deltaX) > MH.abs(deltaY)) {\n    return deltaX < 0 ? MC.S_LEFT : MC.S_RIGHT;\n  }\n  return deltaY < 0 ? MC.S_UP : MC.S_DOWN;\n};\n\n/**\n * Returns the approximate direction of the given 2D vector as one of the\n * cardinal (XY plane) ones: \"up\", \"down\", \"left\" or \"right\"; or \"ambiguous\".\n *\n * @param {} angleDiffThreshold  See {@link areParallel} or\n *                               {@link Utils.areAntiParallel | areAntiParallel}.\n *                               This determines whether the inferred direction\n *                               is ambiguous. For it to _not_ be ambiguous it\n *                               must align with one of the four cardinal\n *                               directions to within `angleDiffThreshold`.\n *                               It doesn't make sense for this value to be < 0\n *                               or >= 45 degrees. If it is, it's forced to be\n *                               positive (absolute) and <= 44.99.\n *\n * @category Directions\n */\nexport const getVectorDirection = (\n  vector: Vector,\n  angleDiffThreshold = 0,\n): XYDirection | AmbiguousDirection | NoDirection => {\n  angleDiffThreshold = MH.min(44.99, MH.abs(angleDiffThreshold));\n\n  if (!maxAbs(...vector)) {\n    return MC.S_NONE;\n  } else if (areParallel(vector, [1, 0], angleDiffThreshold)) {\n    return MC.S_RIGHT;\n  } else if (areParallel(vector, [0, 1], angleDiffThreshold)) {\n    return MC.S_DOWN;\n  } else if (areParallel(vector, [-1, 0], angleDiffThreshold)) {\n    return MC.S_LEFT;\n  } else if (areParallel(vector, [0, -1], angleDiffThreshold)) {\n    return MC.S_UP;\n  }\n\n  return MC.S_AMBIGUOUS;\n};\n\n/**\n * Returns the opposite direction to the given direction or null if the given\n * direction has no opposite.\n *\n * @example\n * ```javascript\n * getOppositeDirection(\"up\"); // -> \"down\"\n * getOppositeDirection(\"down\"); // -> \"up\"\n * getOppositeDirection(\"left\"); // -> \"right\"\n * getOppositeDirection(\"right\"); // -> \"left\"\n * getOppositeDirection(\"none\"); // -> null\n * getOppositeDirection(\"ambiguous\"); // -> null\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeDirection = (\n  direction: Direction,\n): Direction | null => {\n  if (!(direction in OPPOSITE_DIRECTIONS)) {\n    throw MH.usageError(\"Invalid 'direction'\");\n  }\n\n  return OPPOSITE_DIRECTIONS[direction];\n};\n\n/**\n * Returns the set of directions which are opposite to the given set of directions.\n *\n * There are two sets of opposite pairs (\"up\"/\"down\" and \"left\"/\"right\") and at\n * least one of the two opposing directions of a pair must be present for the\n * other one to be included. If both directions that constitute a pair of\n * opposites is given, then the other pair is returned instead (minus any that\n * are present in the input). See examples below for clarification.\n *\n * @example\n * ```javascript\n * getOppositeXYDirections(\"up\"); // -> [\"down\"]\n * getOppositeXYDirections(\"left\"); // -> [\"right\"]\n * getOppositeXYDirections(\"up,down\"); // -> [\"left\",\"right\"]\n * getOppositeXYDirections(\"up,left\"); // -> [\"down\",\"right\"]\n * getOppositeXYDirections(\"up,left,right\"); // -> [\"down\"]\n * getOppositeXYDirections(\"none\"); // -> throws\n * getOppositeXYDirections(\"ambiguous\"); // -> throws\n * getOppositeXYDirections(\"in\"); // -> throws\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeXYDirections = (\n  directions: CommaSeparatedStr<XYDirection> | XYDirection[],\n): XYDirection[] => {\n  const directionList = validateStrList(\n    \"directions\",\n    directions,\n    isValidXYDirection,\n  );\n\n  if (!directionList) {\n    throw MH.usageError(\"'directions' is required\");\n  }\n\n  const opposites: XYDirection[] = [];\n  for (const direction of directionList) {\n    const opposite = getOppositeDirection(direction);\n    if (\n      opposite &&\n      isValidXYDirection(opposite) &&\n      !MH.includes(directionList, opposite)\n    ) {\n      opposites.push(opposite);\n    }\n  }\n\n  if (!MH.lengthOf(opposites)) {\n    for (const direction of XY_DIRECTIONS) {\n      if (!MH.includes(directionList, direction)) {\n        opposites.push(direction);\n      }\n    }\n  }\n\n  return opposites;\n};\n\n/**\n * Returns true if the given direction is one of the known XY ones.\n *\n * @category Validation\n */\nexport const isValidXYDirection = (\n  direction: string,\n): direction is XYDirection => MH.includes(XY_DIRECTIONS, direction);\n\n/**\n * Returns true if the given direction is one of the known Z ones.\n *\n * @category Validation\n */\nexport const isValidZDirection = (direction: string): direction is ZDirection =>\n  MH.includes(Z_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string is a valid direction.\n *\n * @category Validation\n */\nexport const isValidDirection = (direction: string): direction is Direction =>\n  MH.includes(DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid directions.\n *\n * @category Validation\n */\nexport const isValidDirectionList = (\n  directions: string | string[],\n): directions is CommaSeparatedStr<Direction> | Direction[] =>\n  isValidStrList(directions, isValidDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const XY_DIRECTIONS = [\n  MC.S_UP,\n  MC.S_DOWN,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const Z_DIRECTIONS = [MC.S_IN, MC.S_OUT] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const SCROLL_DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  ...Z_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n// --------------------\n\nconst OPPOSITE_DIRECTIONS = {\n  [MC.S_UP]: MC.S_DOWN,\n  [MC.S_DOWN]: MC.S_UP,\n  [MC.S_LEFT]: MC.S_RIGHT,\n  [MC.S_RIGHT]: MC.S_LEFT,\n  [MC.S_IN]: MC.S_OUT,\n  [MC.S_OUT]: MC.S_IN,\n  [MC.S_NONE]: null,\n  [MC.S_AMBIGUOUS]: null,\n} as const;\n"],"mappings":"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","ignoreList":[]}