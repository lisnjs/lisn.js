{"version":3,"file":"scroll-watcher.cjs","names":["MC","_interopRequireWildcard","require","MH","_cssAlter","_directions","_domAlter","_domOptimize","_event","_log","_math","_scroll","_text","_validation","_callback","_xMap","_domWatcher","_sizeWatcher","_debug","_interopRequireDefault","e","__esModule","default","t","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","ScrollWatcher","fetchMainContentElement","fetchMainScrollableElement","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","objToStrKey","instance","instances","constructor","key","illegalConstructorError","logger","debug","Logger","name","logAtCreation","allScrollData","newWeakMap","activeListeners","allCallbacks","newXWeakMap","newMap","fetchCurrentScroll","element","realtime","isScrollEvent","previousEventData","latestData","fetchScrollData","direction","createCallback","handler","options","trackType","_allCallbacks$get","_element","remove","debug5","callback","wrapCallback","_debounceWindow","onRemove","deleteHandler","entry","_trackType","_options","sGet","setupOnScroll","userOptions","fetchOnScrollOptions","eventTarget","_eventTarget","scrollData","isRemoved","_data","TRACK_FULL","setupSizeTrack","listenerOptions","debug4","_nRealtime","addEventListenerTo","S_SCROLL","scrollHandler","directions","skipInitial","directionMatches","invokeCallback","removeOnScroll","scrollable","_allCallbacks$get2","currEntry","setScrollCssProps","deleteKey","prune","removeEventListenerFrom","scrollCallback","debug8","doc","getDoc","docScrollingElement","getDocScrollingElement","resizeCallback","thresholdsExceeded","hasExceededThreshold","debug9","sizeWatcher","SizeWatcher","setupOnResize","target","onResize","S_DEBOUNCE_WINDOW","threshold","_threshold","observedElements","newSet","wrapper","tryWrapContent","add","child","childrenOf","domWatcher","DOMWatcher","root","subtree","onAddedCallback","operation","currentTargetOf","moveElement","to","ignoreMove","onMutation","categories","S_ADDED","event","_activeListeners$get","targetOf","isElement","isDoc","fetchScrollableElement","_allCallbacks$get3","values","then","scroll","_options$amount","isValidScrollDirection","usageError","isVertical","S_UP","S_DOWN","sign","S_LEFT","targetCoordinate","amount","asFractionOf","el","S_SCROLL_TOP","getClientHeightNow","S_SCROLL_LEFT","getClientWidthNow","S_SCROLL_HEIGHT","S_SCROLL_WIDTH","undefined","top","left","scrollTo","merge","duration","_scrollDuration","fetchCurrentScrollAction","getCurrentScrollAction","stopUserScrolling","stopScroll","elScrollTo","immediate","waitForMeasureTime","trackScroll","noTrackScroll","onScroll","TRACK_REGULAR","offScroll","exports","SYMBOL","toNonNegNum","_scrollThreshold","scrollThreshold","scrollDuration","_options$MC$S_DEBOUNC","validateStrList","getEventTarget","userDirections","latestDirection","includes","lastThresholdData","topDiff","maxAbs","S_CLIENT_HEIGHT","leftDiff","S_CLIENT_WIDTH","checkTop","checkLeft","S_NONE","S_AMBIGUOUS","S_RIGHT","scrollTop","ceil","scrollLeft","scrollWidth","scrollHeight","clientWidth","clientHeight","scrollTopFraction","round","INFINITY","scrollLeftFraction","prevScrollTop","prevScrollLeft","getMaxDeltaDirection","S_SCROLL_TOP_FRACTION","S_SCROLL_LEFT_FRACTION","prefix","tryGetMainScrollableElement","getDocElement","props","setNumericStyleProps","_prefix","invoke","copyObject","catch","logError"],"sources":["../../../src/ts/watchers/scroll-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/ScrollWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { XYDirection, ScrollDirection, SizeTarget } from \"@lisn/globals/types\";\n\nimport {\n  ScrollTarget,\n  TargetCoordinate,\n  TargetCoordinates,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { setNumericStyleProps } from \"@lisn/utils/css-alter\";\nimport { getMaxDeltaDirection } from \"@lisn/utils/directions\";\nimport { moveElement, tryWrapContent } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum, maxAbs } from \"@lisn/utils/math\";\nimport {\n  scrollTo,\n  getCurrentScrollAction,\n  getClientWidthNow,\n  getClientHeightNow,\n  tryGetMainScrollableElement,\n  fetchMainContentElement,\n  fetchMainScrollableElement,\n  fetchScrollableElement,\n  isValidScrollDirection,\n  ScrollAction,\n  ScrollToOptions,\n} from \"@lisn/utils/scroll\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { MutationOperation, DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n// re-export for convenience\nexport type { ScrollAction, ScrollToOptions } from \"@lisn/utils/scroll\";\n\n/**\n * {@link ScrollWatcher} listens for scroll events in any direction.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class ScrollWatcher {\n  /**\n   * Call the given handler whenever the given scrollable is scrolled.\n   *\n   * Unless {@link OnScrollOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest scroll data. If a scroll has\n   * not yet been observed on the scrollable and its `scrollTop` and\n   * `scrollLeft` are 0, then the direction is {@link Types.NoDirection} and\n   * the handler is only called if {@link Types.NoDirection} is part of the\n   * supplied {@link OnScrollOptions.directions | options.directions} (or\n   * {@link OnScrollOptions.directions | options.directions} is not given).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking content size changes using\n   * {@link trackScroll}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onScroll: (\n    handler: OnScrollHandler,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly offScroll: (\n    handler: OnScrollHandler,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * This everything that {@link onScroll} does plus more:\n   *\n   * In addition to a scroll event, the handler is also called when either the\n   * offset size or scroll (content) size of the scrollable changes as that\n   * would affect its `scrollTopFraction` and `scrollLeftFraction` and possibly\n   * the `scrollTop` and `scrollLeft` as well.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates a set of CSS variables on the scrollable element's style:\n   *\n   * - If {@link OnScrollOptions.scrollable | options.scrollable} is not given,\n   *   or is `null`, `window` or `document`, the following CSS variables are\n   *   set on the root (`html`) element and represent the scroll of the\n   *   {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}:\n   *   - `--lisn-js--page-scroll-top`\n   *   - `--lisn-js--page-scroll-top-fraction`\n   *   - `--lisn-js--page-scroll-left`\n   *   - `--lisn-js--page-scroll-left-fraction`\n   *   - `--lisn-js--page-scroll-width`\n   *   - `--lisn-js--page-scroll-height`\n   *\n   * - Otherwise, the following variables are set on the scrollable itself,\n   *   and represent its scroll offset:\n   *   - `--lisn-js--scroll-top`\n   *   - `--lisn-js--scroll-top-fraction`\n   *   - `--lisn-js--scroll-left`\n   *   - `--lisn-js--scroll-left-fraction`\n   *   - `--lisn-js--scroll-width`\n   *   - `--lisn-js--scroll-height`\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackScroll: (\n    handler?: OnScrollHandler | null,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackScroll}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly noTrackScroll: (\n    handler?: OnScrollHandler | null,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * Get the scroll offset of the given scrollable. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param {} realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                    this only when doing realtime scroll-based animations\n   *                    as it may cause a forced layout.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScroll: (\n    scrollable?: ScrollTarget,\n    realtime?: boolean,\n  ) => Promise<ScrollData>;\n\n  /**\n   * Scrolls the given scrollable element to in the given direction.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the direction or options are invalid.\n   */\n  readonly scroll: (\n    direction: XYDirection,\n    options?: ScrollOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Scrolls the given scrollable element to the given `to` scrollable.\n   *\n   * Returns `null` if there's an ongoing scroll that is not cancellable.\n   *\n   * Note that if `to` is an element or a selector, then it _must_ be a\n   * descendant of the scrollable element.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the \"to\" coordinates or options are invalid.\n   *\n   * @param {} to  If this is an element, then its top-left position is used as\n   *               the target coordinates. If it is a string, then it is treated\n   *               as a selector for an element using `querySelector`.\n   * @param {} [options.scrollable]\n   *               If not given, it defaults to\n   *               {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}.\n   *\n   * @return {} `null` if there's an ongoing scroll that is not cancellable,\n   * otherwise a {@link ScrollAction}.\n   */\n  readonly scrollTo: (\n    to: TargetCoordinates | Element | string,\n    options?: ScrollToOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Returns the current {@link ScrollAction} if any.\n   *\n   * @param {} scrollable\n   *               If not given, it defaults to\n   *               {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScrollAction: (\n    scrollable?: Element,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Cancels the ongoing scroll that's resulting from smooth scrolling\n   * triggered in the past. Does not interrupt or prevent further scrolling.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   *\n   * @param {} [options.immediate]  If true, then it will not use\n   *                                {@link waitForMeasureTime} or\n   *                                {@link Utils.waitForMutateTime | waitForMutateTime}.\n   *                                Warning: this will likely result in forced layout.\n   */\n  readonly stopUserScrolling: (options?: {\n    scrollable?: ScrollTarget;\n    immediate?: boolean;\n  }) => Promise<void>;\n\n  /**\n   * Returns the element that holds the main page content. By default it's\n   * `document.body` but is overridden by\n   * {@link Settings.settings.mainScrollableElementSelector}.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainContentElement(): Promise<HTMLElement> {\n    return fetchMainContentElement();\n  }\n\n  /**\n   * Returns the scrollable element that holds the wrapper around the main page\n   * content. By default it's `document.scrollable` (unless `document.body` is\n   * actually scrollable, in which case it will be used) but it will be\n   * different if {@link Settings.settings.mainScrollableElementSelector} is set.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainScrollableElement(): Promise<HTMLElement> {\n    return fetchMainScrollableElement();\n  }\n\n  /**\n   * Creates a new instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ScrollWatcherConfig = {}) {\n    return new ScrollWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ScrollWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new ScrollWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ScrollWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ScrollWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ScrollWatcher\", logAtCreation: config })\n      : null;\n\n    const allScrollData = MH.newWeakMap<Element, ScrollData>();\n\n    const activeListeners = MH.newWeakMap<\n      ScrollTarget,\n      { _nRealtime: number }\n    >();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnScrollHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const fetchCurrentScroll = async (\n      element: Element,\n      realtime = false,\n      isScrollEvent = false,\n    ): Promise<ScrollData> => {\n      // The scroll data can change event without a scroll event, e.g. by the\n      // element changing size, so always get the latest here.\n      const previousEventData = allScrollData.get(element);\n      const latestData = await fetchScrollData(\n        element,\n        previousEventData,\n        realtime,\n      );\n\n      // If there hasn't been a scroll event, use the old scroll direction\n      if (!isScrollEvent && previousEventData) {\n        latestData.direction = previousEventData.direction;\n      }\n      return latestData;\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n      trackType: TrackType,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      };\n      allCallbacks.sGet(element).set(handler, entry);\n\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnScroll = async (\n      handler: OnScrollHandler,\n      userOptions: OnScrollOptions | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, userOptions || {});\n      const element = options._element;\n\n      // Don't await for the scroll data before creating the callback so that\n      // setupOnScroll and removeOnScroll have the same \"timing\" and therefore\n      // calling onScroll and offScroll immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options, trackType);\n      const callback = entry._callback;\n\n      const eventTarget = options._eventTarget;\n      const scrollData = await fetchCurrentScroll(\n        element,\n        options._debounceWindow === 0,\n      );\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = scrollData;\n      allScrollData.set(element, scrollData);\n\n      if (trackType === TRACK_FULL) {\n        await setupSizeTrack(entry);\n      }\n\n      let listenerOptions = activeListeners.get(eventTarget);\n      if (!listenerOptions) {\n        debug: logger?.debug4(\"Adding scroll listener\", eventTarget);\n        listenerOptions = { _nRealtime: 0 };\n        activeListeners.set(eventTarget, listenerOptions);\n        // Don't debounce the scroll handler, only the callbacks.\n        addEventListenerTo(eventTarget, MC.S_SCROLL, scrollHandler);\n      }\n\n      if (options._debounceWindow === 0) {\n        listenerOptions._nRealtime++;\n      }\n\n      const directions = options._directions;\n      if (\n        !callback.isRemoved() &&\n        !userOptions?.skipInitial &&\n        directionMatches(directions, scrollData.direction)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", element, scrollData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, scrollData);\n      }\n    };\n\n    // ----------\n\n    const removeOnScroll = async (\n      handler: OnScrollHandler,\n      scrollable: ScrollTarget | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, { scrollable });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setScrollCssProps) {\n          // delete the properties\n          setScrollCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n    ) => {\n      const element = options._element;\n      const eventTarget = options._eventTarget;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      const listenerOptions = activeListeners.get(eventTarget);\n      if (listenerOptions && options._debounceWindow === 0) {\n        listenerOptions._nRealtime--;\n      }\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for scrollable; removing listener\",\n          element,\n        );\n\n        MH.deleteKey(allScrollData, element);\n        removeEventListenerFrom(eventTarget, MC.S_SCROLL, scrollHandler);\n        MH.deleteKey(activeListeners, eventTarget);\n      }\n    };\n\n    // ----------\n\n    const setupSizeTrack = async (entry: CallbackEntry) => {\n      const options = entry._options;\n      const element = options._element;\n      const scrollCallback = entry._callback;\n      debug: logger?.debug8(\"Setting up size tracking\", element);\n\n      const doc = MH.getDoc();\n      const docScrollingElement = MH.getDocScrollingElement();\n\n      const resizeCallback = wrapCallback(async () => {\n        // Get the latest scroll data for the scrollable\n        // Currently, the resize callback is already delayed by a frame due to\n        // the SizeWatcher, so we don't need to treat this as realtime.\n        const latestData = await fetchCurrentScroll(element);\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n        } else if (!scrollCallback.isRemoved()) {\n          await invokeCallback(scrollCallback, element, latestData);\n        }\n      });\n\n      scrollCallback.onRemove(resizeCallback.remove);\n\n      // Don't use default instance as it has a high threshold.\n      const sizeWatcher = SizeWatcher.reuse();\n      const setupOnResize = (target?: SizeTarget) =>\n        sizeWatcher.onResize(resizeCallback, {\n          target,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          // TODO maybe accepts resizeThreshold option\n          threshold: options._threshold,\n        });\n\n      if (element === docScrollingElement) {\n        // In case we're tracking the main document scroll, then we only need to\n        // observe the viewport size and the size of the documentElement (which is\n        // the content size).\n\n        setupOnResize(); // viewport size\n        setupOnResize(doc); // content size\n\n        return;\n      }\n\n      // ResizeObserver only detects changes in offset width/height which is\n      // the visible size of the scrolling element, and that is not affected by the\n      // size of its content.\n      // But we also need to detect changes in the scroll width/height which is\n      // the size of the content.\n      // We also need to keep track of elements being added to the scrollable element.\n\n      const observedElements = MH.newSet<Element>([element]);\n\n      // Observe the scrolling element\n      setupOnResize(element);\n\n      // And also its children (if possible, a single wrapper around them\n      const wrapper = await tryWrapContent(element);\n      if (wrapper) {\n        setupOnResize(wrapper);\n        observedElements.add(wrapper);\n\n        //\n      } else {\n        for (const child of MH.childrenOf(element)) {\n          setupOnResize(child);\n          observedElements.add(child);\n        }\n      }\n\n      // Watch for newly added elements\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      const onAddedCallback = wrapCallback((operation: MutationOperation) => {\n        const child = MH.currentTargetOf(operation);\n        // If we've just added the wrapper, it will be in DOMWatcher's queue,\n        // so check.\n        if (child !== wrapper) {\n          if (wrapper) {\n            // Move this child into the wrapper. If this results in change of size\n            // for wrapper, SizeWatcher will call us.\n            moveElement(child, { to: wrapper, ignoreMove: true });\n          } else {\n            // Track the size of this child.\n            // Don't skip initial, call the callback now\n            setupOnResize(child);\n            observedElements.add(child);\n          }\n        }\n      });\n\n      domWatcher.onMutation(onAddedCallback, { categories: [MC.S_ADDED] });\n      resizeCallback.onRemove(onAddedCallback.remove);\n    };\n\n    // ----------\n\n    const scrollHandler = async (event: Event) => {\n      // We cannot use event.currentTarget because scrollHandler is called inside\n      // a setTimeout so by that time, currentTarget is null or something else.\n      //\n      // However, target and currentTarget only differ when the event is in the\n      // bubbling or capturing phase. Because\n      //\n      // - the scroll event only bubbles when fired on document, and (it only\n      //   bubbles up to window)\n      // - and we never attach the listener to the capturing phase\n      // - and we always use document instead of window to listen for scroll on\n      //   document\n      //\n      // then event.target suffices.\n      const scrollable = MH.targetOf(event);\n      /* istanbul ignore next */\n      if (!scrollable || !(MH.isElement(scrollable) || MH.isDoc(scrollable))) {\n        return;\n      }\n\n      const element = await fetchScrollableElement(scrollable);\n      const realtime = (activeListeners.get(scrollable)?._nRealtime || 0) > 0;\n      const latestData = await fetchCurrentScroll(element, realtime, true);\n      allScrollData.set(element, latestData);\n\n      debug: logger?.debug9(\"Scroll event\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        // Consider the direction since the last scroll event and not the\n        // direction based on the largest delta the last time the callback\n        // was called.\n        const options = entry._options;\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n          continue;\n        }\n\n        // If threshold has been exceeded, always update the latest data for\n        // this callback.\n        entry._data = latestData;\n\n        if (!directionMatches(options._directions, latestData.direction)) {\n          debug: logger?.debug9(\n            \"Direction does not match\",\n            options,\n            latestData,\n          );\n          continue;\n        }\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentScroll = (scrollable?, realtime?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        fetchCurrentScroll(element, realtime),\n      );\n\n    // ----------\n\n    this.scroll = (direction, options = {}) => {\n      if (!isValidScrollDirection(direction)) {\n        throw MH.usageError(`Unknown scroll direction: '${direction}'`);\n      }\n\n      const isVertical = direction === MC.S_UP || direction === MC.S_DOWN;\n      const sign = direction === MC.S_UP || direction === MC.S_LEFT ? -1 : 1;\n      let targetCoordinate: TargetCoordinate;\n\n      const amount = options.amount ?? 100;\n      const asFractionOf = options.asFractionOf;\n\n      if (asFractionOf === \"visible\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * getClientHeightNow(el)) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * getClientWidthNow(el)) / 100;\n\n        //\n      } else if (asFractionOf === \"content\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * el[MC.S_SCROLL_HEIGHT]) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * el[MC.S_SCROLL_WIDTH]) / 100;\n\n        //\n      } else if (asFractionOf !== undefined && asFractionOf !== \"pixel\") {\n        throw MH.usageError(\n          `Unknown 'asFractionOf' keyword: '${asFractionOf}'`,\n        );\n\n        //\n      } else {\n        targetCoordinate = isVertical\n          ? (el) => el[MC.S_SCROLL_TOP] + sign * amount\n          : (el) => el[MC.S_SCROLL_LEFT] + sign * amount;\n      }\n\n      const target = isVertical\n        ? { top: targetCoordinate }\n        : { left: targetCoordinate };\n\n      return this.scrollTo(target, options);\n    };\n\n    // ----------\n\n    this.scrollTo = async (to, options = {}) =>\n      scrollTo(\n        to,\n        MH.merge(\n          { duration: config._scrollDuration }, // default\n          options,\n          {\n            scrollable: await fetchScrollableElement(options.scrollable),\n          }, // override\n        ),\n      );\n\n    // ----------\n\n    this.fetchCurrentScrollAction = (scrollable?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        getCurrentScrollAction(element),\n      );\n\n    // ----------\n\n    this.stopUserScrolling = async (options = {}) => {\n      const element = await fetchScrollableElement(options.scrollable);\n      const stopScroll = () =>\n        MH.elScrollTo(element, {\n          top: element[MC.S_SCROLL_TOP],\n          left: element[MC.S_SCROLL_LEFT],\n        });\n\n      if (options.immediate) {\n        stopScroll();\n      } else {\n        waitForMeasureTime().then(stopScroll);\n      }\n    };\n\n    // ----------\n\n    this.trackScroll = (handler?, options?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      return setupOnScroll(handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackScroll = (handler?, scrollable?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      removeOnScroll(handler, scrollable, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onScroll = (handler, options?) =>\n      setupOnScroll(handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offScroll = (handler, scrollable?) => {\n      removeOnScroll(handler, scrollable, TRACK_REGULAR); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type ScrollWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnScrollOptions.debounceWindow | debounceWindow} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnScrollOptions.threshold | threshold} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 50\n   */\n  scrollThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link ScrollOptions.duration | duration} in calls to\n   * {@link ScrollWatcher.scroll} and {@link ScrollWatcher.scrollTo}.\n   *\n   * @defaultValue 1000\n   */\n  scrollDuration?: number;\n};\n\n/**\n * @interface\n */\nexport type OnScrollOptions = {\n  /**\n   * If it is not given, or is `null`, `window` or `document`, then it will\n   * track the scroll of the\n   * {@link Settings.settings.mainScrollableElementSelector | the main scrolling element}.\n   *\n   * Other values must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  scrollable?: ScrollTarget;\n\n  /**\n   * If non-0, the scroll handler will only be called when the scrollable's\n   * scroll offset in the observed direction has changed at least\n   * `scrollThreshold` pixels since the last time the handler was called.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.scrollThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Specifies a list of {@link ScrollDirection}s to listen for.\n   *\n   * It can be a comma-separated list of direction names or an array of such\n   * names.\n   *\n   * If not given, then it listens for scrolls in any direction, including\n   * {@link Types.NoDirection} and {@link Types.AmbiguousDirection}.\n   *\n   * The {@link Types.NoDirection} occurs when the callback is called initially\n   * (if `skipInitial` is not `true`) and there hasn't yet been a scroll\n   * observed on the scrollable _and_ it's `scrollTop`/`scrollLeft` are 0.\n   *\n   * The {@link Types.AmbiguousDirection} occurs when the user scrolls\n   * diagonally with close to equal deltas in both horizontal and vertical\n   * direction.\n   *\n   * **IMPORTANT:**\n   *\n   * The direction of a scroll event is always based on comparing `deltaX` and\n   * `deltaY` relative to the _last scroll event_ (within the `debounceWindow`,\n   * and not to the scroll data for the last time the callback was called (in\n   * case it was skipped because `threshold` was not exceeded or in case it was\n   * debounced by a larger window than the watcher).\n   *\n   * I.e. if you have both `threshold` and `directions` restricted, or if the\n   * callback has a larger debounce window than the watcher, it is possible for\n   * there to be a change in the relevant `scrollTop`/`scrollLeft` offset that\n   * exceeds the threshold, and for the callback to _not_ be called.\n   *\n   * For a callback to be called, both of these must be true:\n   * - the change in `scrollTop`/`scrollLeft`, _compared to the last time the\n   *   callback was called_ must exceed the {@link threshold}\n   * - the effective scroll direction, _compared to the last scroll event_\n   *   prior to the _watcher's_ debounce window must be one of the given\n   *   {@link directions}.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<ScrollDirection> | ScrollDirection[];\n\n  /**\n   * Do not call the handler until there's a future scroll of the element.\n   *\n   * By default we call the handler (almost) immediately if there's been a\n   * scroll in one of the given directions, or if there has not been a scroll\n   * but directions includes {@link Types.NoDirection}, but you can disable\n   * this initial call here.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts, but you probably need this when doing\n   * scroll-based animations.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * @interface\n */\nexport type ScrollOptions = ScrollToOptions & {\n  /**\n   * How much to scroll in the given direction.\n   *\n   * @defaultValue 100\n   */\n  amount?: number;\n\n  /**\n   * If set to \"pixel\" (default), `amount` is taken as absolute pixels.\n   *\n   * If set to \"visible\", `amount` is taken as percent of the element's visible\n   * size in the scrolling direction (100 means full client width for\n   * horizontal or height for vertical scroll).\n   *\n   * If set to \"content\", `amount` is taken as percent of the element's full\n   * content size in the scrolling direction (100 means full scroll width for\n   * horizontal or height for vertical scroll).\n   *\n   * @defaultValue \"pixel\"\n   */\n  asFractionOf?: \"pixel\" | \"visible\" | \"content\";\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the element that has been resized\n * - the {@link ScrollData} for the element\n */\nexport type OnScrollHandlerArgs = [Element, ScrollData];\nexport type OnScrollCallback = Callback<OnScrollHandlerArgs>;\nexport type OnScrollHandler =\n  | CallbackHandler<OnScrollHandlerArgs>\n  | OnScrollCallback;\n\nexport type ScrollData = {\n  clientWidth: number;\n  clientHeight: number;\n\n  scrollTop: number;\n\n  /**\n   * This is the `scrollTop` relative to the full `scrollHeight` minus the\n   * `clientHeight`, ranging from 0 to 1.\n   */\n  scrollTopFraction: number;\n\n  scrollLeft: number;\n\n  /**\n   * This is the `scrollLeft` relative to the full `scrollWidth` minus the\n   * `clientWidth`, ranging from 0 to 1.\n   */\n  scrollLeftFraction: number;\n\n  scrollWidth: number;\n  scrollHeight: number;\n\n  /**\n   * This is the direction of the last scroll action, i.e. _compared to the\n   * last scroll event_, not necessarily based on the deltas compared to the\n   * last time this callback was called.\n   */\n  direction: ScrollDirection;\n};\n\n// ----------------------------------------\n\ntype ScrollWatcherConfigInternal = {\n  _debounceWindow: number;\n  _scrollThreshold: number;\n  _scrollDuration: number;\n};\n\ntype OnScrollOptionsInternal = {\n  _element: Element;\n  _eventTarget: ScrollTarget;\n  _directions: ScrollDirection[] | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnScrollCallback;\n  _trackType: TrackType;\n  _options: OnScrollOptionsInternal;\n  _data?: ScrollData;\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, ScrollWatcher>();\n\nconst getConfig = (\n  config: ScrollWatcherConfig,\n): ScrollWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _scrollThreshold: toNonNegNum(config.scrollThreshold, 50) || 1,\n    _scrollDuration: toNonNegNum(config.scrollDuration, 1000),\n  };\n};\n\nconst TRACK_REGULAR = 1; // only scroll events\nconst TRACK_FULL = 2; // scroll + resizing of content and/or wrapper\n\n// --------------------\n\nconst fetchOnScrollOptions = async (\n  config: ScrollWatcherConfigInternal,\n  options: OnScrollOptions,\n): Promise<OnScrollOptionsInternal> => {\n  const directions =\n    validateStrList(\"directions\", options.directions, isValidScrollDirection) ||\n    null;\n\n  const element = await fetchScrollableElement(options.scrollable);\n\n  return {\n    _element: element,\n    _eventTarget: getEventTarget(element),\n    _directions: directions,\n    // If threshold is 0, internally treat as 1 (pixel)\n    _threshold: toNonNegNum(options.threshold, config._scrollThreshold) || 1,\n    _debounceWindow: options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n  };\n};\n\nconst directionMatches = (\n  userDirections: ScrollDirection[] | null,\n  latestDirection: ScrollDirection,\n) => !userDirections || MH.includes(userDirections, latestDirection);\n\nconst hasExceededThreshold = (\n  options: OnScrollOptionsInternal,\n  latestData: ScrollData,\n  lastThresholdData: ScrollData | undefined,\n): boolean => {\n  const directions = options._directions;\n  const threshold = options._threshold;\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  const topDiff = maxAbs(\n    latestData[MC.S_SCROLL_TOP] - lastThresholdData[MC.S_SCROLL_TOP],\n    latestData[MC.S_SCROLL_HEIGHT] - lastThresholdData[MC.S_SCROLL_HEIGHT],\n    latestData[MC.S_CLIENT_HEIGHT] - lastThresholdData[MC.S_CLIENT_HEIGHT],\n  );\n\n  const leftDiff = maxAbs(\n    latestData[MC.S_SCROLL_LEFT] - lastThresholdData[MC.S_SCROLL_LEFT],\n    latestData[MC.S_SCROLL_WIDTH] - lastThresholdData[MC.S_SCROLL_WIDTH],\n    latestData[MC.S_CLIENT_WIDTH] - lastThresholdData[MC.S_CLIENT_WIDTH],\n  );\n\n  // If the callback is only interested in up/down, then only check the\n  // scrollTop delta, and similarly for left/right.\n  let checkTop = false,\n    checkLeft = false;\n  if (\n    !directions ||\n    MH.includes(directions, MC.S_NONE) ||\n    MH.includes(directions, MC.S_AMBIGUOUS)\n  ) {\n    checkTop = checkLeft = true;\n  } else {\n    if (\n      MH.includes(directions, MC.S_UP) ||\n      MH.includes(directions, MC.S_DOWN)\n    ) {\n      checkTop = true;\n    }\n    if (\n      MH.includes(directions, MC.S_LEFT) ||\n      MH.includes(directions, MC.S_RIGHT)\n    ) {\n      checkLeft = true;\n    }\n  }\n\n  return (\n    (checkTop && topDiff >= threshold) || (checkLeft && leftDiff >= threshold)\n  );\n};\n\nconst fetchScrollData = async (\n  element: Element,\n  previousEventData: ScrollData | undefined,\n  realtime: boolean,\n): Promise<ScrollData> => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollTop = MH.ceil(element[MC.S_SCROLL_TOP]);\n  const scrollLeft = MH.ceil(element[MC.S_SCROLL_LEFT]);\n  const scrollWidth = element[MC.S_SCROLL_WIDTH];\n  const scrollHeight = element[MC.S_SCROLL_HEIGHT];\n  const clientWidth = getClientWidthNow(element);\n  const clientHeight = getClientHeightNow(element);\n\n  const scrollTopFraction =\n    MH.round(scrollTop) / (scrollHeight - clientHeight || MC.INFINITY);\n  const scrollLeftFraction =\n    MH.round(scrollLeft) / (scrollWidth - clientWidth || MC.INFINITY);\n\n  const prevScrollTop = previousEventData?.scrollTop || 0;\n  const prevScrollLeft = previousEventData?.scrollLeft || 0;\n\n  const direction = getMaxDeltaDirection(\n    scrollLeft - prevScrollLeft,\n    scrollTop - prevScrollTop,\n  );\n\n  return {\n    direction,\n    [MC.S_SCROLL_TOP]: scrollTop,\n    [MC.S_SCROLL_TOP_FRACTION]: scrollTopFraction,\n    [MC.S_SCROLL_LEFT]: scrollLeft,\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollLeftFraction,\n    [MC.S_SCROLL_WIDTH]: scrollWidth,\n    [MC.S_SCROLL_HEIGHT]: scrollHeight,\n    [MC.S_CLIENT_WIDTH]: clientWidth,\n    [MC.S_CLIENT_HEIGHT]: clientHeight,\n  };\n};\n\nconst setScrollCssProps = (\n  element: Element,\n  scrollData: Partial<ScrollData> | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetMainScrollableElement()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"page-\";\n  }\n\n  scrollData = scrollData || {};\n  const props = {\n    [MC.S_SCROLL_TOP]: scrollData[MC.S_SCROLL_TOP],\n    [MC.S_SCROLL_TOP_FRACTION]: scrollData[MC.S_SCROLL_TOP_FRACTION],\n    [MC.S_SCROLL_LEFT]: scrollData[MC.S_SCROLL_LEFT],\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollData[MC.S_SCROLL_LEFT_FRACTION],\n    [MC.S_SCROLL_WIDTH]: scrollData[MC.S_SCROLL_WIDTH],\n    [MC.S_SCROLL_HEIGHT]: scrollData[MC.S_SCROLL_HEIGHT],\n  };\n  setNumericStyleProps(element, props, { _prefix: prefix });\n};\n\nconst getEventTarget = (element: Element): ScrollTarget => {\n  if (element === MH.getDocScrollingElement()) {\n    return MH.getDoc();\n  }\n\n  return element;\n};\n\nconst invokeCallback = (\n  callback: OnScrollCallback,\n  element: Element,\n  scrollData: ScrollData,\n) => callback.invoke(element, MH.copyObject(scrollData)).catch(logError);\n"],"mappings":"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,eAAe,CAAC;EAC9D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAKA,CAACH,MAA2B,GAAG,CAAC,CAAC,EAAE;IAC7C,MAAMI,QAAQ,GAAGH,SAAS,CAACD,MAAM,CAAC;IAClC,MAAMK,YAAY,GAAG,IAAAC,iBAAW,EAACF,QAAQ,CAAC;IAE1C,IAAIG,QAAQ,GAAGC,SAAS,CAAC/B,GAAG,CAAC4B,YAAY,CAAC;IAC1C,IAAI,CAACE,QAAQ,EAAE;MACbA,QAAQ,GAAG,IAAIX,aAAa,CAACQ,QAAQ,EAAEF,eAAe,CAAC;MACvDM,SAAS,CAAC9B,GAAG,CAAC2B,YAAY,EAAEE,QAAQ,CAAC;IACvC;IAEA,OAAOA,QAAQ;EACjB;EAEQE,WAAWA,CACjBT,MAAmC,EACnCU,GAA2B,EAC3B;IAzOF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApBE1B,eAAA;IA0BA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAzCEA,eAAA;IA+CA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAVEA,eAAA;IAgBA;AACF;AACA;AACA;AACA;AACA;IALEA,eAAA;IAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApBEA,eAAA;IA0BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IATEA,eAAA;IAcA;AACF;AACA;AACA;AACA;AACA;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","ignoreList":[]}