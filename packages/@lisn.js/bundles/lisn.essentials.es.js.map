{"version":3,"file":"lisn.essentials.es.js","sources":["../../lisn.js/src/ts/globals/minification-constants.ts","../../lisn.js/src/ts/globals/errors.ts","../../lisn.js/src/ts/globals/minification-helpers.ts","../../lisn.js/src/ts/globals/settings.ts","../../lisn.js/src/ts/utils/math.ts","../../lisn.js/src/ts/utils/misc.ts","../../lisn.js/src/ts/utils/text.ts","../../lisn.js/src/ts/utils/validation.ts","../../lisn.js/src/ts/modules/bit-spaces.ts","../../lisn.js/src/ts/utils/dom.ts","../../lisn.js/src/ts/utils/tasks.ts","../../lisn.js/src/ts/modules/callback.ts","../../lisn.js/src/ts/utils/log.ts","../../lisn.js/src/ts/utils/dom-optimize.ts","../../lisn.js/src/ts/utils/dom-query.ts","../../lisn.js/src/ts/utils/css-alter.ts","../../lisn.js/src/ts/utils/dom-alter.ts","../../lisn.js/src/ts/utils/dom-events.ts","../../lisn.js/src/ts/modules/x-map.ts","../../lisn.js/src/ts/watchers/dom-watcher.ts","../../lisn.js/src/ts/utils/directions.ts","../../lisn.js/src/ts/utils/event.ts","../../lisn.js/src/ts/utils/gesture.ts","../../lisn.js/src/ts/utils/gesture-key.ts","../../lisn.js/src/ts/utils/gesture-pointer.ts","../../lisn.js/src/ts/utils/gesture-touch.ts","../../lisn.js/src/ts/utils/normalize-wheel.ts","../../lisn.js/src/ts/utils/gesture-wheel.ts","../../lisn.js/src/ts/watchers/gesture-watcher.ts","../../lisn.js/src/ts/utils/layout.ts","../../lisn.js/src/ts/utils/scroll.ts","../../lisn.js/src/ts/utils/overlays.ts","../../lisn.js/src/ts/utils/size.ts","../../lisn.js/src/ts/modules/x-resize-observer.ts","../../lisn.js/src/ts/watchers/size-watcher.ts","../../lisn.js/src/ts/watchers/layout-watcher.ts","../../lisn.js/src/ts/utils/pointer.ts","../../lisn.js/src/ts/watchers/pointer-watcher.ts","../../lisn.js/src/ts/watchers/scroll-watcher.ts","../../lisn.js/src/ts/utils/views.ts","../../lisn.js/src/ts/modules/x-intersection-observer.ts","../../lisn.js/src/ts/watchers/view-watcher.ts","../../lisn.js/src/ts/bundle-essentials.ts"],"sourcesContent":["/**\n * For minification optimization.\n *\n * @module\n * @ignore\n * @internal\n */\n\nexport const PREFIX = \"lisn\";\nexport const LOG_PREFIX = \"[LISN.js]\";\n\nexport const OBJECT = Object;\nexport const SYMBOL = Symbol;\nexport const ARRAY = Array;\nexport const STRING = String;\nexport const FUNCTION = Function;\nexport const MATH = Math;\nexport const NUMBER = Number;\nexport const PROMISE = Promise;\n\nexport const PI = MATH.PI;\nexport const INFINITY = Infinity;\n\nexport const S_ABSOLUTE = \"absolute\";\nexport const S_FIXED = \"fixed\";\nexport const S_STICKY = \"sticky\";\n\nexport const S_WIDTH = \"width\";\nexport const S_HEIGHT = \"height\";\n\nexport const S_TOP = \"top\";\nexport const S_BOTTOM = \"bottom\";\n\nexport const S_UP = \"up\";\nexport const S_DOWN = \"down\";\n\nexport const S_LEFT = \"left\";\nexport const S_RIGHT = \"right\";\n\nexport const S_AT = \"at\";\nexport const S_ABOVE = \"above\";\nexport const S_BELOW = \"below\";\n\nexport const S_IN = \"in\";\nexport const S_OUT = \"out\";\n\nexport const S_NONE = \"none\";\nexport const S_AMBIGUOUS = \"ambiguous\";\n\nexport const S_ADDED = \"added\";\nexport const S_REMOVED = \"removed\";\nexport const S_ATTRIBUTE = \"attribute\";\n\nexport const S_KEY = \"key\";\nexport const S_MOUSE = \"mouse\";\nexport const S_POINTER = \"pointer\";\nexport const S_TOUCH = \"touch\";\nexport const S_WHEEL = \"wheel\";\nexport const S_CLICK = \"click\";\nexport const S_HOVER = \"hover\";\nexport const S_PRESS = \"press\";\n\nexport const S_SCROLL = \"scroll\";\nexport const S_ZOOM = \"zoom\";\nexport const S_DRAG = \"drag\";\nexport const S_UNKNOWN = \"unknown\";\n\nexport const S_SCROLL_TOP = `${S_SCROLL}Top` as `${typeof S_SCROLL}Top`;\nexport const S_SCROLL_LEFT = `${S_SCROLL}Left` as `${typeof S_SCROLL}Left`;\n\nexport const S_SCROLL_WIDTH = `${S_SCROLL}Width` as `${typeof S_SCROLL}Width`;\nexport const S_SCROLL_HEIGHT =\n  `${S_SCROLL}Height` as `${typeof S_SCROLL}Height`;\n\nexport const S_CLIENT_WIDTH = \"clientWidth\";\nexport const S_CLIENT_HEIGHT = \"clientHeight\";\n\nexport const S_SCROLL_TOP_FRACTION =\n  `${S_SCROLL}TopFraction` as `${typeof S_SCROLL}TopFraction`;\nexport const S_SCROLL_LEFT_FRACTION =\n  `${S_SCROLL}LeftFraction` as `${typeof S_SCROLL}LeftFraction`;\n\nexport const S_HORIZONTAL = \"horizontal\";\nexport const S_VERTICAL = \"vertical\";\nexport const S_SKIP_INITIAL = \"skipInitial\";\nexport const S_DEBOUNCE_WINDOW = \"debounceWindow\";\nexport const S_TOGGLE = \"toggle\";\n\nexport const S_CANCEL = \"cancel\";\n\nexport const S_KEYDOWN = (S_KEY + S_DOWN) as `${typeof S_KEY}${typeof S_DOWN}`;\n\nexport const S_MOUSEUP = (S_MOUSE + S_UP) as `${typeof S_MOUSE}${typeof S_UP}`;\nexport const S_MOUSEDOWN = (S_MOUSE +\n  S_DOWN) as `${typeof S_MOUSE}${typeof S_DOWN}`;\nexport const S_MOUSEMOVE = `${S_MOUSE}move` as `${typeof S_MOUSE}move`;\n\nexport const S_POINTERUP = (S_POINTER +\n  S_UP) as `${typeof S_POINTER}${typeof S_UP}`;\nexport const S_POINTERDOWN = (S_POINTER +\n  S_DOWN) as `${typeof S_POINTER}${typeof S_DOWN}`;\nexport const S_POINTERENTER = `${S_POINTER}enter` as `${typeof S_POINTER}enter`;\nexport const S_POINTERLEAVE = `${S_POINTER}leave` as `${typeof S_POINTER}leave`;\nexport const S_POINTERMOVE = `${S_POINTER}move` as `${typeof S_POINTER}move`;\nexport const S_POINTERCANCEL = (S_POINTER +\n  S_CANCEL) as `${typeof S_POINTER}${typeof S_CANCEL}`;\n\nexport const S_TOUCHSTART = `${S_TOUCH}start` as `${typeof S_TOUCH}start`;\nexport const S_TOUCHEND = `${S_TOUCH}end` as `${typeof S_TOUCH}end`;\nexport const S_TOUCHMOVE = `${S_TOUCH}move` as `${typeof S_TOUCH}move`;\nexport const S_TOUCHCANCEL = (S_TOUCH +\n  S_CANCEL) as `${typeof S_TOUCH}${typeof S_CANCEL}`;\n\nexport const S_DRAGSTART = `${S_DRAG}start` as `${typeof S_DRAG}start`;\nexport const S_DRAGEND = `${S_DRAG}end` as `${typeof S_DRAG}end`;\nexport const S_DRAGENTER = `${S_DRAG}enter` as `${typeof S_DRAG}enter`;\nexport const S_DRAGOVER = `${S_DRAG}over` as `${typeof S_DRAG}over`;\nexport const S_DRAGLEAVE = `${S_DRAG}leave` as `${typeof S_DRAG}leave`;\nexport const S_DROP = \"drop\";\n\nexport const S_SELECTSTART = \"selectstart\";\n\nexport const S_ATTRIBUTES = \"attributes\";\nexport const S_CHILD_LIST = \"childList\";\n\nexport const S_REVERSE = \"reverse\";\nexport const S_DRAGGABLE = \"draggable\";\nexport const S_DISABLED = \"disabled\";\n\nexport const S_ARROW = \"arrow\";\n\nexport const S_ROLE = \"role\";\n\nexport const ARIA_PREFIX = \"aria-\";\nexport const S_ARIA_CONTROLS = ARIA_PREFIX + \"controls\";\n\nexport const PREFIX_WRAPPER = `${PREFIX}-wrapper`;\nexport const PREFIX_INLINE_WRAPPER = `${PREFIX_WRAPPER}-inline`;\nexport const PREFIX_TRANSITION = `${PREFIX}-transition`;\nexport const PREFIX_TRANSITION_DISABLE = `${PREFIX_TRANSITION}__disable`;\nexport const PREFIX_HIDE = `${PREFIX}-hide`;\nexport const PREFIX_SHOW = `${PREFIX}-show`;\nexport const PREFIX_DISPLAY = `${PREFIX}-display`;\nexport const PREFIX_UNDISPLAY = `${PREFIX}-undisplay`;\nexport const PREFIX_PLACE = `${PREFIX}-place`;\nexport const PREFIX_ORIENTATION = `${PREFIX}-orientation`;\nexport const PREFIX_POSITION = `${PREFIX}-position`;\nexport const PREFIX_GHOST = `${PREFIX}-ghost`;\nexport const PREFIX_BORDER_SIZE = `${PREFIX}-border-size`;\nexport const PREFIX_NO_SELECT = `${PREFIX}-no-select`;\nexport const PREFIX_NO_TOUCH_ACTION = `${PREFIX}-no-touch-action`;\nexport const PREFIX_NO_WRAP = `${PREFIX}-no-wrap`;\n\nexport const S_ANIMATE = \"animate\";\nexport const ANIMATE_PREFIX = `${PREFIX}-${S_ANIMATE}__`;\nexport const PREFIX_ANIMATE_DISABLE = `${ANIMATE_PREFIX}disable`;\nexport const PREFIX_ANIMATE_PAUSE = `${ANIMATE_PREFIX}pause`;\nexport const PREFIX_ANIMATE_REVERSE = `${ANIMATE_PREFIX}${S_REVERSE}`;\nexport const PREFIX_ANIMATE_INFINITE = `${ANIMATE_PREFIX}infinite`;\n\nexport const USER_AGENT =\n  typeof navigator === \"undefined\" ? \"\" : navigator.userAgent;\n\nexport const IS_MOBILE =\n  USER_AGENT.match(\n    /Mobile|Android|Silk\\/|Kindle|BlackBerry|Opera Mini|Opera Mobi/,\n  ) !== null;\n","/**\n * @module Errors\n */\n\nimport { LOG_PREFIX } from \"@lisn/globals/minification-constants\";\n\n/**\n * Base error type emitted by LISN.\n */\nexport abstract class LisnError extends Error {}\n\n/**\n * Error type emitted for invalid input or incorrect usage of a function.\n */\nexport class LisnUsageError extends LisnError {\n  constructor(message = \"\") {\n    super(`${LOG_PREFIX} Incorrect usage: ${message}`);\n    this.name = \"LisnUsageError\";\n  }\n}\n\n/**\n * Error type emitted if an assertion is wrong => report bug.\n */\nexport class LisnBugError extends LisnError {\n  constructor(message = \"\") {\n    super(`${LOG_PREFIX} Please report a bug: ${message}`);\n    this.name = \"LisnBugError\";\n  }\n}\n","/**\n * For minification optimization\n *\n * @module\n * @ignore\n * @internal\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\n\nimport {\n  BoundingRect,\n  IterableObject,\n  Constructor,\n  InstanceType,\n  MapBase,\n  SetBase,\n  Spread,\n} from \"@lisn/globals/types\";\n\nimport { LisnUsageError, LisnBugError } from \"@lisn/globals/errors\";\n\n// credit: underscore.js\nconst root =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global == \"object\" && global.global === global && global) ||\n  Function(\"return this\")() ||\n  {};\n\nexport const kebabToCamelCase = (str: string) =>\n  str.replace(/-./g, (m) => toUpperCase(m.charAt(1)));\n\nexport const camelToKebabCase = (str: string) =>\n  str\n    .replace(/[A-Z][a-z]/g, (m) => \"-\" + toLowerCase(m))\n    .replace(/[A-Z]+/, (m) => \"-\" + toLowerCase(m));\n\nexport const prefixName = (name: string) => `${MC.PREFIX}-${name}`;\n\nexport const prefixCssVar = (name: string) => \"--\" + prefixName(name);\n\nexport const prefixCssJsVar = (name: string) => prefixCssVar(\"js--\" + name);\n\nexport const prefixData = (name: string) => `data-${camelToKebabCase(name)}`;\n\nexport const prefixLisnData = (name: string) => prefixData(prefixName(name));\n\nexport const toLowerCase = (s: string) => s.toLowerCase();\n\nexport const toUpperCase = (s: string) => s.toUpperCase();\n\nexport const timeNow = Date.now.bind(Date);\n\nexport const timeSince = (startTime: number) => timeNow() - startTime;\n\nexport const hasDOM = () => typeof document !== \"undefined\";\n\nexport const getWindow = () => window;\n\nexport const getDoc = () => document;\n\nexport const getDocElement = () => getDoc().documentElement;\n\nexport const getDocScrollingElement = () =>\n  getDoc().scrollingElement as HTMLElement | null;\n\nexport const getBody = () => getDoc().body;\n\nexport const getReadyState = () => getDoc().readyState;\n\nexport const getPointerType = (event: Event) =>\n  isPointerEvent(event)\n    ? event.pointerType\n    : isMouseEvent(event)\n      ? \"mouse\"\n      : null;\n\nexport const onAnimationFrame = hasDOM()\n  ? root.requestAnimationFrame.bind(root)\n  : () => {};\n\nexport const createElement = (\n  tagName: string,\n  options?: ElementCreationOptions,\n) => getDoc().createElement(tagName, options);\n\nexport const createButton = (label = \"\", tag = \"button\") => {\n  const btn = createElement(tag);\n  setTabIndex(btn);\n  setAttr(btn, MC.S_ROLE, \"button\");\n  setAttr(btn, MC.ARIA_PREFIX + \"label\", label);\n  return btn;\n};\n\nexport const isNullish = (v: unknown): v is null | undefined =>\n  v === undefined || v === null;\n\nexport const isEmpty = (v: unknown): v is null | undefined | \"\" =>\n  isNullish(v) || v === \"\";\n\nexport const isIterableObject = (v: unknown): v is IterableObject<unknown> =>\n  isNonPrimitive(v) && MC.SYMBOL.iterator in v;\n\nexport const isArray = (v: unknown) => isInstanceOf(v, MC.ARRAY);\n\nexport const isObject = (v: unknown) => isInstanceOf(v, MC.OBJECT);\n\nexport const isNonPrimitive = (v: unknown): v is object =>\n  v !== null && typeOf(v) === \"object\";\n\n// only primitive number\nexport const isNumber = (v: unknown): v is number => typeOf(v) === \"number\";\n\n/* eslint-disable-next-line @typescript-eslint/no-wrapper-object-types */\nexport const isString = (v: unknown): v is string | String =>\n  typeOf(v) === \"string\" || isInstanceOf(v, MC.STRING);\n\nexport const isLiteralString = (v: unknown): v is string =>\n  typeOf(v) === \"string\";\n\nexport const isBoolean = (v: unknown): v is boolean => typeOf(v) === \"boolean\";\n\n/* eslint-disable-next-line @typescript-eslint/no-unsafe-function-type */\nexport const isFunction = (v: unknown): v is Function =>\n  typeOf(v) === \"function\" || isInstanceOf(v, MC.FUNCTION);\n\nexport const isDoc = (target: unknown): target is Document =>\n  target === getDoc();\n\nexport const isMouseEvent = (event: Event): event is MouseEvent =>\n  isInstanceOf(event, MouseEvent);\n\nexport const isPointerEvent = (event: Event): event is PointerEvent =>\n  isInstanceOf(event, PointerEvent);\n\nexport const isTouchPointerEvent = (event: Event): event is PointerEvent =>\n  isPointerEvent(event) && getPointerType(event) === MC.S_TOUCH;\n\nexport const isWheelEvent = (event: Event): event is WheelEvent =>\n  isInstanceOf(event, WheelEvent);\n\nexport const isKeyboardEvent = (event: Event): event is KeyboardEvent =>\n  isInstanceOf(event, KeyboardEvent);\n\nexport const isTouchEvent = (event: Event): event is TouchEvent =>\n  isInstanceOf(event, TouchEvent);\n\nexport const isNode = (target: unknown) => isInstanceOf(target, Node);\n\nexport const isElement = (target: unknown) => isInstanceOf(target, Element);\n\nexport const isHTMLElement = (target: unknown) =>\n  isInstanceOf(target, HTMLElement);\n\nexport const isNodeBAfterA = (nodeA: Node, nodeB: Node) =>\n  (nodeA.compareDocumentPosition(nodeB) & Node.DOCUMENT_POSITION_FOLLOWING) !==\n  0;\n\nexport const strReplace = (\n  s: string,\n  match: string | RegExp,\n  replacement: string,\n) => s.replace(match, replacement);\n\nexport const setTimer = root.setTimeout.bind(root);\n\nexport const clearTimer = root.clearTimeout.bind(root);\n\nexport const getBoundingClientRect = (el: Element) =>\n  el.getBoundingClientRect();\n\n// Copy size properties explicitly to another object so they can be used with\n// the spread operator (DOMRect/DOMRectReadOnly's properties are not enumerable)\nexport const copyBoundingRectProps = (rect: BoundingRect): BoundingRect => {\n  return {\n    x: rect.x,\n    left: rect.left,\n    right: rect.right,\n    [MC.S_WIDTH]: rect[MC.S_WIDTH],\n    y: rect.y,\n    top: rect.top,\n    bottom: rect.bottom,\n    [MC.S_HEIGHT]: rect[MC.S_HEIGHT],\n  };\n};\n\nexport const querySelector = (root: Element | Document, selector: string) =>\n  root.querySelector(selector);\n\nexport const querySelectorAll = (root: Element | Document, selector: string) =>\n  root.querySelectorAll(selector);\n\nexport const docQuerySelector = (selector: string) =>\n  querySelector(getDoc(), selector);\n\nexport const docQuerySelectorAll = (selector: string) =>\n  querySelectorAll(getDoc(), selector);\n\nexport const getElementById = (id: string) => getDoc().getElementById(id);\n\nexport const getAttr = (el: Element, name: string) => el.getAttribute(name);\n\nexport const setAttr = (el: Element, name: string, value = \"true\") =>\n  el.setAttribute(name, value);\n\nexport const unsetAttr = (el: Element, name: string) =>\n  el.setAttribute(name, \"false\");\n\nexport const delAttr = (el: Element, name: string) => el.removeAttribute(name);\n\nexport const includes = (\n  arr: readonly unknown[] | string,\n  v: unknown,\n  startAt?: number,\n) => (arr.indexOf as (v: unknown, startAt?: number) => number)(v, startAt) >= 0;\n\nexport const filter = <\n  A extends readonly unknown[],\n  T extends A[number],\n  C extends FilterFn<A[number]> | FilterFnTypeP<A[number], T>,\n>(\n  array: A,\n  filterFn: C,\n) => array.filter(filterFn) as FilteredType<C, A[number], T>[];\n\nexport const filterBlank = <A extends readonly unknown[]>(\n  array: A | null | undefined,\n) => {\n  const result = array\n    ? filter(array, (v): v is NonNullable<A[number]> => !isEmpty(v))\n    : undefined;\n\n  return lengthOf(result) ? result : undefined;\n};\n\nexport const sizeOf = (obj: { size: number } | null | undefined) =>\n  obj?.size ?? 0;\n\nexport const lengthOf = (obj: { length: number } | null | undefined) =>\n  obj?.length ?? 0;\n\nexport const tagName = (el: Element) => el.tagName;\n\nexport const preventDefault = (event: Event) => event.preventDefault();\n\nexport const arrayFrom = MC.ARRAY.from.bind(MC.ARRAY);\n\nexport const keysOf = <T extends Record<string | symbol, unknown>>(\n  obj: T,\n): Array<keyof T & string> => MC.OBJECT.keys(obj);\n\nexport const defineProperty = MC.OBJECT.defineProperty.bind(MC.OBJECT);\n\n// use it in place of object spread\nexport const merge = <A extends readonly (object | null | undefined)[]>(\n  ...a: [...A]\n) => {\n  return MC.OBJECT.assign({}, ...a) as Spread<A>;\n};\n\nexport const copyObject = <T extends object>(obj: T) => merge(obj);\n\nexport const promiseResolve = MC.PROMISE.resolve.bind(MC.PROMISE);\n\nexport const promiseAll = MC.PROMISE.all.bind(MC.PROMISE);\n\nexport const assign = MC.OBJECT.assign.bind(MC.OBJECT);\n\nexport const freezeObj = MC.OBJECT.freeze.bind(MC.OBJECT);\n\nexport const hasOwnProp = (o: object, prop: string | symbol) =>\n  MC.OBJECT.prototype.hasOwnProperty.call(o, prop);\n\nexport const preventExtensions = MC.OBJECT.preventExtensions.bind(MC.OBJECT);\n\nexport const stringify = JSON.stringify.bind(JSON);\n\nexport const floor = MC.MATH.floor.bind(MC.MATH);\n\nexport const ceil = MC.MATH.ceil.bind(MC.MATH);\n\nexport const log2 = MC.MATH.log2.bind(MC.MATH);\n\nexport const sqrt = MC.MATH.sqrt.bind(MC.MATH);\n\nexport const max = MC.MATH.max.bind(MC.MATH);\n\nexport const min = MC.MATH.min.bind(MC.MATH);\n\nexport const abs = MC.MATH.abs.bind(MC.MATH);\n\nexport const round = MC.MATH.round.bind(MC.MATH);\n\nexport const pow = MC.MATH.pow.bind(MC.MATH);\n\nexport const parseFloat = MC.NUMBER.parseFloat.bind(MC.NUMBER);\n\nexport const isNaN = MC.NUMBER.isNaN.bind(MC.NUMBER);\n\nexport const isInstanceOf = <C extends Constructor<unknown>>(\n  value: unknown,\n  Class: C,\n): value is InstanceType<C> => value instanceof Class;\n\nexport const constructorOf = (obj: object) => obj.constructor;\n\nexport const typeOf = (obj: unknown) => typeof obj;\n\nexport const typeOrClassOf = (obj: unknown) =>\n  isObject(obj) ? constructorOf(obj)?.name : typeOf(obj);\n\nexport const parentOf = (element: Element | undefined | null) =>\n  element?.parentElement || null;\n\nexport const childrenOf = (element: Element | undefined | null) =>\n  element?.children || [];\n\nexport const targetOf = <O extends { target?: unknown } | null | undefined>(\n  obj: O,\n) =>\n  obj?.target as O extends { target: infer T }\n    ? T\n    : O extends { target?: infer T }\n      ? T | undefined\n      : undefined;\n\nexport const currentTargetOf = <\n  O extends { currentTarget?: unknown } | null | undefined,\n>(\n  obj: O,\n) =>\n  obj?.currentTarget as O extends { currentTarget: infer T }\n    ? T\n    : O extends { currentTarget?: infer T }\n      ? T | undefined\n      : undefined;\n\nexport const classList = <T extends Element | null | undefined>(el: T) =>\n  el?.classList as T extends Element ? DOMTokenList : undefined;\n\nconst S_TABINDEX = \"tabindex\";\nexport const getTabIndex = (el: Element) => getAttr(el, S_TABINDEX);\n\nexport const setTabIndex = (el: Element, index = \"0\") =>\n  setAttr(el, S_TABINDEX, index);\n\nexport const unsetTabIndex = (el: Element) => delAttr(el, S_TABINDEX);\n\nexport const remove = (obj: { remove: () => void } | null | undefined) =>\n  obj?.remove();\n\nexport const deleteObjKey = <O extends object>(obj: O, key: keyof O) =>\n  delete obj[key];\n\nexport const deleteKey = <K, V>(\n  map: MapBase<K, V> | SetBase<K> | null | undefined,\n  key: K,\n) => map?.delete(key);\n\nexport const elScrollTo = (\n  el: Element,\n  coords: { top?: number; left?: number },\n  behavior: ScrollBehavior = \"instant\",\n) => el.scrollTo(merge({ behavior }, coords));\n\nexport const elScrollBy = (\n  el: Element,\n  coords: { top?: number; left?: number },\n  behavior: ScrollBehavior = \"instant\",\n) => el.scrollBy(merge({ behavior }, coords));\n\nexport const newPromise = <T>(\n  executor: (\n    resolve: (value: T) => void,\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    reject: (reason?: any) => void,\n  ) => void,\n) => new Promise(executor);\n\nexport const newMap = <K, V>(entries?: readonly (readonly [K, V])[] | null) =>\n  new Map(entries);\n\nexport const newWeakMap = <K extends WeakKey, V>(\n  entries?: readonly (readonly [K, V])[] | null,\n) => new WeakMap(entries);\n\nexport const newSet = <T>(values?: readonly T[] | null) => new Set(values);\n\nexport const newWeakSet = <T extends WeakKey>(values?: readonly T[] | null) =>\n  new WeakSet(values);\n\nexport const newIntersectionObserver = (\n  callback: IntersectionObserverCallback,\n  options?: IntersectionObserverInit,\n) => new IntersectionObserver(callback, options);\n\nexport const newResizeObserver = (callback: ResizeObserverCallback) =>\n  typeof ResizeObserver === \"undefined\" ? null : new ResizeObserver(callback);\n\nexport const newMutationObserver = (callback: MutationCallback) =>\n  new MutationObserver(callback);\n\nexport const usageError = (msg: string) => new LisnUsageError(msg);\n\nexport const bugError = (msg: string) => new LisnBugError(msg);\n\nexport const illegalConstructorError = (useWhat: string) =>\n  usageError(`Illegal constructor. Use ${useWhat}.`);\n\nconst CONSOLE = console;\nexport const consoleDebug = CONSOLE.debug.bind(CONSOLE);\n\nexport const consoleLog = CONSOLE.log.bind(CONSOLE);\n\nexport const consoleInfo = CONSOLE.info.bind(CONSOLE);\n\nexport const consoleWarn = CONSOLE.warn.bind(CONSOLE);\n\nexport const consoleError = CONSOLE.error.bind(CONSOLE);\n\n// --------------------\n\ntype FilterFn<V> = (value: V, index: number, array: readonly V[]) => unknown;\ntype FilterFnTypeP<V, T extends V> = (\n  value: V,\n  index: number,\n  array: readonly V[],\n) => value is T;\ntype FilteredType<C extends FilterFn<V> | FilterFnTypeP<V, T>, V, T extends V> =\n  C extends FilterFnTypeP<V, infer T> ? T : V;\n","/**\n * @module Settings\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\n/**\n * LISN's settings.\n * @readonly\n *\n * If you wish to modify them, then you need to do so immediately after loading\n * LISN before you instantiate any watchers, etc. For example:\n *\n * ```html\n * <!doctype html>\n * <html>\n *   <head>\n *     <meta charset=\"UTF-8\" />\n *     <meta name=\"viewport\" content=\"width=device-width\" />\n *     <script src=\"lisn.js\" charset=\"utf-8\"></script>\n *     <script charset=\"utf-8\">\n *       // modify LISN settings, for example:\n *       LISN.settings.deviceBreakpoints.desktop = 1024;\n *     </script>\n *   </head>\n *   <body>\n *   </body>\n * </html>\n * ```\n */\nexport const settings = MH.preventExtensions({\n  /**\n   * A unique selector (preferably `#some-id`) for the element that holds the\n   * main page content, if other than `document.body`.\n   *\n   * E.g. if your main content is inside a custom scrollable container, rather\n   * than directly in `document.body`, then pass a selector for it here.\n   *\n   * The element must be scrollable, i.e. have a fixed size and `overflow: scroll`.\n   *\n   * **IMPORTANT:** You must set this before initializing any watchers, widgets,\n   * etc. If you are using the HTML API, then you must set this before the\n   * document `readyState` becomes interactive.\n   *\n   * @defaultValue null\n   * @category Generic\n   */\n  mainScrollableElementSelector: null as string | null,\n\n  /**\n   * This setting allows us to automatically wrap certain elements or groups of\n   * elements into a single `div` or `span` element to allow for more reliable\n   * or efficient working of certain features. In particular:\n   *\n   * 1. View tracking using relative offsets and a scrolling root **requires wrapping**\n   *\n   * When using view position tracking with a percentage offset specification\n   * (e.g. `top: 50%`) _and_ a custom root element that is scrollable_ (and\n   * obviously has a size smaller than the content), you **MUST** enable\n   * content wrapping, otherwise the trigger offset elements cannot be\n   * positioned relative to the scrolling _content size_.\n   *\n   * 2. Scroll tracking\n   *\n   * When using scroll tracking, including scrollbars, on a scrolling element\n   * (that obviously has a size smaller than the content), it's recommended for\n   * the content of the scrollable element to be wrapped in a single `div`\n   * container, to allow for more efficient and reliable detection of changes\n   * in the _scrollable content_ size.\n   *\n   * If content wrapping is disabled, when scroll tracking is used on a given\n   * element (other than the root of the document), each of the immediate\n   * children of the scrollable element have their sizes tracked, which could\n   * lead to more resource usage.\n   *\n   * 3. Scrollbars on custom elements\n   *\n   * When you setup a {@link Widgets.Scrollbar} widget for a custom\n   * scrollable element that may not be the main scrollable (and therefore\n   * won't take up the full viewport all the time), then to be able to position\n   * to scrollbar relative to the scrollable element, its content needs to be\n   * wrapped.\n   *\n   * If this setting is OFF, then the scrollbars on custom elements have to\n   * rely on position sticky which doesn't have as wide browser support as the\n   * default option.\n   *\n   * 4. Animating on viewport enter/leave\n   *\n   * For elements that have transforms applied as part of an animation or\n   * transition, if you wish to run or reverse the animation when the element\n   * enters or leaves the viewport, then the transform can interfere with the\n   * viewport tracking. For example, if undoing the animation as soon as the\n   * element leaves the viewport makes it enter it again (because it's moved),\n   * then this will result in a glitch.\n   *\n   * If content wrapping is disabled, then to get around such issues, a dummy\n   * element is positioned on top of the actual element and is the one tracked\n   * across the viewport instead. Either approach could cause issues depending\n   * on your CSS, so it's your choice which one is applied.\n   *\n   * ----------\n   *\n   * If you can, it's recommended to leave this setting ON. You can still\n   * disable wrapping on a per-element basis by setting `data-lisn-no-wrap`\n   * attribute on it.\n   *\n   * @defaultValue true\n   * @category Generic\n   */\n  contentWrappingAllowed: true,\n\n  /**\n   * The timeout in milliseconds for waiting for the `document.readyState` to\n   * become `complete`. The timer begins _once the `readyState` becomes\n   * `interactive`_.\n   *\n   * The page will be considered \"ready\" either when the `readyState` becomes\n   * `complete` or this many milliseconds after it becomes `interactive`,\n   * whichever is first.\n   *\n   * Set to 0 or a negative number to disable timeout.\n   *\n   * @defaultValue 2000 // i.e. 2s\n   * @category Generic\n   */\n  pageLoadTimeout: 2000,\n\n  /**\n   * This enables LISN's HTML API. Then the page will be parsed (and watched\n   * for dynamically added elements at any time) for any elements matching a\n   * widget selector. Any element that has a matching CSS class or data\n   * attribute will be setup according to the relevant widget, which may wrap,\n   * clone or add attributes to the element.\n   *\n   * This is enabled by default for bundles, and disabled otherwise.\n   *\n   * **IMPORTANT:** You must set this before the document `readyState` becomes\n   * interactive.\n   *\n   * @defaultValue `false` in general, but `true` in browser bundles\n   * @category Widgets\n   */\n  autoWidgets: false,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.hideNative | ScrollbarConfig.hideNative}.\n   *\n   * @defaultValue true\n   * @category Widgets/Scrollbar\n   */\n  scrollbarHideNative: true,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.onMobile | ScrollbarConfig.onMobile}.\n   *\n   * @defaultValue false\n   * @category Widgets/Scrollbar\n   */\n  scrollbarOnMobile: false,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.positionH | ScrollbarConfig.positionH}.\n   *\n   * @defaultValue \"bottom\"\n   * @category Widgets/Scrollbar\n   */\n  scrollbarPositionH: \"bottom\",\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.positionV | ScrollbarConfig.positionV}.\n   *\n   * @defaultValue \"right\"\n   * @category Widgets/Scrollbar\n   */\n  scrollbarPositionV: \"right\",\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.autoHide | ScrollbarConfig.autoHide}.\n   *\n   * @defaultValue -1\n   * @category Widgets/Scrollbar\n   */\n  scrollbarAutoHide: -1,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.clickScroll | ScrollbarConfig.clickScroll}.\n   *\n   * @defaultValue true\n   * @category Widgets/Scrollbar\n   */\n  scrollbarClickScroll: true,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.dragScroll | ScrollbarConfig.dragScroll}.\n   *\n   * @defaultValue true\n   * @category Widgets/Scrollbar\n   */\n  scrollbarDragScroll: true,\n\n  /**\n   * Default setting for\n   * {@link Widgets.ScrollbarConfig.useHandle | ScrollbarConfig.useHandle}.\n   *\n   * @defaultValue false\n   * @category Widgets/Scrollbar\n   */\n  scrollbarUseHandle: false,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.diffTolerance | SameHeightConfig.diffTolerance}.\n   *\n   * @defaultValue 15\n   * @category Widgets/SameHeight\n   */\n  sameHeightDiffTolerance: 15,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.resizeThreshold | SameHeightConfig.resizeThreshold}.\n   *\n   * @defaultValue 5\n   * @category Widgets/SameHeight\n   */\n  sameHeightResizeThreshold: 5,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.debounceWindow | SameHeightConfig.debounceWindow}.\n   *\n   * @defaultValue 100\n   * @category Widgets/SameHeight\n   */\n  sameHeightDebounceWindow: 100,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.minGap | SameHeightConfig.minGap}.\n   *\n   * @defaultValue 30\n   * @category Widgets/SameHeight\n   */\n  sameHeightMinGap: 30,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.maxFreeR | SameHeightConfig.maxFreeR}.\n   *\n   * @defaultValue 0.4\n   * @category Widgets/SameHeight\n   */\n  sameHeightMaxFreeR: 0.4,\n\n  /**\n   * Default setting for\n   * {@link Widgets.SameHeightConfig.maxWidthR | SameHeightConfig.maxWidthR}.\n   *\n   * @defaultValue 1.7\n   * @category Widgets/SameHeight\n   */\n  sameHeightMaxWidthR: 1.7,\n\n  /**\n   * Set custom device breakpoints as width in pixels.\n   *\n   * The value of each sets its lower limit, i.e. it specifies a device whose\n   * width is larger than the given value (and up to the next larger one).\n   *\n   * If you specify only some of the below devices, then the other ones will\n   * keep their default breakpoint values.\n   *\n   * Adding device types, other than the ones listed below is not supported.\n   *\n   * @category Device layouts\n   */\n  deviceBreakpoints: {\n    /**\n     * This should be left as 0 as it's the catch-all for anything narrower\n     * than \"mobile-wide\".\n     *\n     * @defaultValue 0\n     */\n    mobile: 0,\n\n    /**\n     * Anything wider than the given value is \"mobile-wide\", up to the value of\n     * \"tablet\".\n     *\n     * @defaultValue 576\n     */\n    \"mobile-wide\": 576,\n\n    /**\n     * Anything wider than the given value is \"tablet\", up to the value of\n     * \"desktop\".\n     *\n     * @defaultValue 768\n     */\n    tablet: 768, // tablet is anything above this (up to desktop)\n\n    /**\n     * Anything wider than the given value is \"desktop\".\n     *\n     * @defaultValue 992\n     */\n    desktop: 992, // desktop is anything above this\n  },\n\n  /**\n   * Set custom aspect ratio breakpoints (as ratio of width to height).\n   *\n   * The value of each sets its lower limit, i.e. it specifies an aspect ratio\n   * that is wider than the given value (and up to the next wider one).\n   *\n   * If you specify only some of the below aspect ratios, then the other ones\n   * will keep their default breakpoint values.\n   *\n   * Adding aspect ratio types, other than the ones listed below is not\n   * supported.\n   *\n   * @category Device layouts\n   */\n  aspectRatioBreakpoints: {\n    /**\n     * This should be left as 0 as it's the catch-all for anything with\n     * a narrower aspect ratio than \"tall\".\n     *\n     * @defaultValue 0\n     */\n    \"very-tall\": 0, // very tall is up to 9:16\n\n    /**\n     * Anything with a wider aspect ratio than the given value is \"tall\", up to\n     * the value of \"square\".\n     *\n     * @defaultValue 9 / 16\n     */\n    tall: 9 / 16, // tall is between 9:16 and 3:4\n\n    /**\n     * Anything with a wider aspect ratio than the given value is \"square\", up\n     * to the value of \"wide\".\n     *\n     * @defaultValue 3 / 4\n     */\n    square: 3 / 4, // square is between 3:4 and 4:3\n\n    /**\n     * Anything with a wider aspect ratio than the given value is \"wide\", up to\n     * the value of \"very-wide\".\n     *\n     * @defaultValue 4 / 3\n     */\n    wide: 4 / 3, // wide is between 4:3 and 16:9\n\n    /**\n     * Anything with a wider aspect ratio than the given value is \"very-wide\".\n     *\n     * @defaultValue 16 / 9\n     */\n    \"very-wide\": 16 / 9, // very wide is above 16:9\n  },\n\n  /**\n   * The CSS class that enables light theme.\n   *\n   * **IMPORTANT:** If you change this, you should also change the\n   * `$light-theme-cls` variable in the SCSS configuration, or otherwise add the\n   * following to your CSS:\n   *\n   * :root,\n   * .custom-light-theme-cls {\n   *   --lisn-color-fg: some-dark-color;\n   *   --lisn-color-fg-t: some-dark-color-with-transparency;\n   *   --lisn-color-bg: some-light-color;\n   *   --lisn-color-bg-t: some-light-color-with-transparency;\n   * }\n   */\n  lightThemeClassName: \"light-theme\",\n\n  /**\n   * The CSS class that enables dark theme.\n   *\n   * **IMPORTANT:** If you change this, you should also change the\n   * `$dark-theme-cls` variable in the SCSS configuration, or otherwise add the\n   * following to your CSS:\n   *\n   * .custom-dark-theme-cls {\n   *   --lisn-color-fg: some-light-color;\n   *   --lisn-color-fg-t: some-light-color-with-transparency;\n   *   --lisn-color-bg: some-dark-color;\n   *   --lisn-color-bg-t: some-dark-color-with-transparency;\n   * }\n   */\n  darkThemeClassName: \"dark-theme\",\n\n  /**\n   * Used to determine the effective delta in pixels for gestures triggered by\n   * some key (arrows) and wheel events (where the browser reports the delta\n   * mode to be LINE).\n   *\n   * Value is in pixels.\n   *\n   * @defaultValue 40\n   * @category Gestures\n   */\n  deltaLineHeight: 40,\n\n  /**\n   * Used to determine the effective delta in pixels for gestures triggered by\n   * some wheel events (where the browser reports the delta mode to be PAGE).\n   *\n   * Value is in pixels.\n   *\n   * @defaultValue 1600\n   * @category Gestures\n   */\n  deltaPageWidth: 1600,\n\n  /**\n   * Used to determine the effective delta in pixels for gestures triggered by\n   * some key (PageUp/PageDown/Space) and wheel events (where the browser\n   * reports the delta mode to be PAGE).\n   *\n   * Value is in pixels.\n   *\n   * @defaultValue 800\n   * @category Gestures\n   */\n  deltaPageHeight: 800,\n\n  /**\n   * Controls the debugging verbosity level. Values from 0 (none) to 10 (insane)\n   * are recognized.\n   *\n   * **Note:** Logging is not available in bundles except in the \"debug\" bundle.\n   *\n   * @defaultValue `0` except in the \"debug\" bundle where it defaults to 10\n   * @category Logging\n   */\n  verbosityLevel: 0,\n\n  /**\n   * The URL of the remote logger to connect to. LISN uses\n   * {@link https://socket.io/docs/v4/client-api/ | socket.io-client}\n   * to talk to the client and emits messages on the following namespaces:\n   *\n   * - `console.debug`\n   * - `console.log`\n   * - `console.info`\n   * - `console.warn`\n   * - `console.error`\n   *\n   * There is a simple logging server that ships with LISN, see the source\n   * code repository.\n   *\n   * You can always explicitly disable remote logging on a given page by\n   * setting `disableRemoteLog=1` query parameter in the URL.\n   *\n   * **Note:** Logging is not available in bundles (except in the `debug` bundle).\n   *\n   * @defaultValue null\n   * @category Logging\n   */\n  remoteLoggerURL: null as string | null,\n\n  /**\n   * Enable remote logging only on mobile devices.\n   *\n   * You can always disable remote logging for any page by setting\n   * `disableRemoteLog=1` URL query parameter.\n   *\n   * **Note:** Logging is not available in bundles (except in the `debug` bundle).\n   *\n   * @defaultValue false\n   * @category Logging\n   */\n  remoteLoggerOnMobileOnly: false,\n});\n\n// --------------------\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Point, Vector, AtLeastOne } from \"@lisn/globals/types\";\n\n/**\n * Round a number to the given decimal precision (default is 0).\n *\n * @param {} [numDecimal = 0]\n *\n * @category Math\n */\nexport const roundNumTo = (value: number, numDecimal = 0) => {\n  const multiplicationFactor = MH.pow(10, numDecimal);\n  return MH.round(value * multiplicationFactor) / multiplicationFactor;\n};\n\n/**\n * Returns true if the given value is a valid _finite_ number.\n *\n * @category Validation\n */\nexport const isValidNum = (value: unknown): value is number =>\n  MH.isNumber(value) && MC.NUMBER.isFinite(value);\n\n/**\n * If the given value is a valid _finite_ number, it is returned, otherwise\n * the default is returned.\n *\n * @category Math\n */\nexport const toNum = <D extends number | false | null = 0>(\n  value: unknown,\n  defaultValue: D | 0 = 0,\n): number | D => {\n  const numValue = MH.isLiteralString(value) ? MH.parseFloat(value) : value;\n\n  // parseFloat will strip trailing non-numeric characters, so we check that\n  // the parsed number is equal to the string, if it was a string, using loose\n  // equality, in order to make sure the entire string was a number.\n  return isValidNum(numValue) && numValue == value ? numValue : defaultValue;\n};\n\n/**\n * If the given value is a valid _finite integer_ number, it is returned,\n * otherwise the default is returned.\n *\n * @category Math\n */\nexport const toInt = <D extends number | false | null = 0>(\n  value: unknown,\n  defaultValue: D | 0 = 0,\n): number | D => {\n  let numValue = toNum(value, null);\n  numValue = numValue === null ? numValue : MH.floor(numValue);\n\n  // Ensure that the parsed int equaled the original by loose equality.\n  return isValidNum(numValue) && numValue == value ? numValue : defaultValue;\n};\n\n/**\n * If the given value is a valid non-negative _finite_ number, it is returned,\n * otherwise the default is returned.\n *\n * @category Math\n */\nexport const toNonNegNum = <D extends number | false | null = 0>(\n  value: unknown,\n  defaultValue: D | 0 = 0,\n): number | D => {\n  const numValue = toNum(value, null);\n  return numValue !== null && numValue >= 0 ? numValue : defaultValue;\n};\n\n/**\n * If the given value is a valid positive number, it is returned, otherwise the\n * default is returned.\n *\n * @category Math\n */\nexport const toPosNum = <D extends number | false | null = 0>(\n  value: unknown,\n  defaultValue: D | 0 = 0,\n): number | D => {\n  const numValue = toNum(value, null);\n  return numValue !== null && numValue > 0 ? numValue : defaultValue;\n};\n\n/**\n * Returns the given number bound by min and/or max value.\n *\n * If the value is not a valid number, then `defaultValue` is returned if given\n * (_including if it is null_), otherwise `limits.min` if given and not null,\n * otherwise `limits.max` if given and not null, or finally 0.\n *\n * If the value is outside the bounds, then:\n * - if `defaultValue` is given, `defaultValue` is returned (_including if it\n *   is null_)\n * - otherwise, the min or the max value (whichever one is violated) is\n *   returned\n *\n * @category Math\n */\nexport const toNumWithBounds = <D extends number | false | null = number>(\n  value: unknown,\n  limits: AtLeastOne<{ min: number | null; max: number | null }>,\n  defaultValue?: D,\n): number | D => {\n  const isDefaultGiven = defaultValue !== undefined;\n  const numValue = toNum(value, null);\n  const min = limits?.min ?? null;\n  const max = limits?.max ?? null;\n\n  let result: number | D;\n  if (!isValidNum(numValue)) {\n    result = isDefaultGiven ? defaultValue : (min ?? max ?? 0);\n  } else if (min !== null && numValue < min) {\n    result = isDefaultGiven ? defaultValue : min;\n  } else if (max !== null && numValue > max) {\n    result = isDefaultGiven ? defaultValue : max;\n  } else {\n    result = numValue;\n  }\n\n  return result;\n};\n\n/**\n * Returns the largest absolute value among the given ones.\n *\n * The result is always positive.\n *\n * @category Math\n */\nexport const maxAbs = (...values: number[]) =>\n  MH.max(...values.map((v) => MH.abs(v)));\n\n/**\n * Returns the smallest absolute value among the given ones.\n *\n * The result is always positive.\n *\n * @category Math\n */\nexport const minAbs = (...values: number[]) =>\n  MH.min(...values.map((v) => MH.abs(v)));\n\n/**\n * Returns the value with the largest absolute value among the given ones.\n *\n * The result can be negative.\n *\n * @category Math\n */\nexport const havingMaxAbs = (...values: number[]): number =>\n  MH.lengthOf(values)\n    ? values.sort((a, b) => MH.abs(b) - MH.abs(a))[0]\n    : -MC.INFINITY;\n\n/**\n * Returns the value with the smallest absolute value among the given ones.\n *\n * The result can be negative.\n *\n * @category Math\n */\nexport const havingMinAbs = (...values: number[]) =>\n  MH.lengthOf(values)\n    ? values.sort((a, b) => MH.abs(a) - MH.abs(b))[0]\n    : MC.INFINITY;\n\n/**\n * Returns the angle (in radians) that the vector defined by the given x, y\n * makes with the positive horizontal axis.\n *\n * The angle returned is in the range -PI to PI, not including -PI.\n *\n * @category Math\n */\nexport const hAngle = (x: number, y: number) =>\n  normalizeAngle(MC.MATH.atan2(y, x)); // ensure that -PI is transformed to +PI\n\n/**\n * Normalizes the given angle (in radians) so that it's in the range -PI to PI,\n * not including -PI.\n *\n * @category Math\n */\nexport const normalizeAngle = (a: number) => {\n  // ensure it's positive in the range 0 to 2 PI\n  while (a < 0 || a > MC.PI * 2) {\n    a += (a < 0 ? 1 : -1) * MC.PI * 2;\n  }\n\n  // then, if > PI, offset by - 2PI\n  return a > MC.PI ? a - MC.PI * 2 : a;\n};\n\n/**\n * Converts the given angle in degrees to radians.\n *\n * @category Math\n */\nexport const degToRad = (a: number) => (a * MC.PI) / 180;\n\n/**\n * Converts the given angle in radians to degrees.\n *\n * @category Math\n */\nexport const radToDeg = (a: number) => (a * 180) / MC.PI;\n\n/**\n * Returns true if the given vectors point in the same direction.\n *\n * @param {} angleDiffThreshold\n *                  Sets the threshold in degrees when comparing the angles of\n *                  two vectors. E.g. for 5 degrees threshold, directions\n *                  whose vectors are within 5 degrees of each other are\n *                  considered parallel.\n *                  It doesn't make sense for this value to be < 0 or >= 90\n *                  degrees. If it is, it's forced to be positive (absolute)\n *                  and <= 89.99.\n *\n * @category Math\n */\nexport const areParallel = (vA: Vector, vB: Vector, angleDiffThreshold = 0) => {\n  const angleA = hAngle(vA[0], vA[1]);\n  const angleB = hAngle(vB[0], vB[1]);\n  angleDiffThreshold = MH.min(89.99, MH.abs(angleDiffThreshold));\n\n  return (\n    MH.abs(normalizeAngle(angleA - angleB)) <= degToRad(angleDiffThreshold)\n  );\n};\n\n/**\n * Returns true if the given vectors point in the opposite direction.\n *\n * @param {} angleDiffThreshold\n *                  Sets the threshold in degrees when comparing the angles of\n *                  two vectors. E.g. for 5 degrees threshold, directions\n *                  whose vectors are within 175-185 degrees of each other are\n *                  considered antiparallel.\n *                  It doesn't make sense for this value to be < 0 or >= 90\n *                  degrees. If it is, it's forced to be positive (absolute)\n *                  and <= 89.99.\n *\n * @category Math\n */\nexport const areAntiParallel = (\n  vA: Vector,\n  vB: Vector,\n  angleDiffThreshold = 0,\n) => areParallel(vA, [-vB[0], -vB[1]], angleDiffThreshold);\n\n/**\n * Returns the distance between two points on the screen.\n *\n * @category Math\n */\nexport const distanceBetween = (ptA: Point, ptB: Point) =>\n  MH.sqrt(MH.pow(ptA[0] - ptB[0], 2) + MH.pow(ptA[1] - ptB[1], 2));\n\n/**\n * Returns the two roots of the quadratic equation with coefficients\n * `a`, `b` & `c`, i.e. `a * x^2 + b * x + c = 0`\n *\n * The roots may be `NaN` if the quadratic has no real solutions.\n *\n * @category Math\n */\nexport const quadraticRoots = (a: number, b: number, c: number) => {\n  const z = MH.sqrt(b * b - 4 * a * c);\n  return [(-b + z) / (2 * a), (-b - z) / (2 * a)];\n};\n\n/**\n * Returns the value that an \"easing\" quadratic function would have at the\n * given x.\n *\n * @see https://easings.net/#easeInOutQuad\n *\n * @category Math\n */\nexport const easeInOutQuad = (x: number) =>\n  x < 0.5 ? 2 * x * x : 1 - MH.pow(-2 * x + 2, 2) / 2;\n\n/**\n * Returns an array of object's keys sorted by the numeric value they hold.\n *\n * @category Math\n */\nexport const sortedKeysByVal = <T extends Record<string, number>>(\n  obj: T,\n  descending = false,\n): Array<keyof T> => {\n  if (descending) {\n    return MH.keysOf(obj).sort((x: keyof T, y: keyof T) => obj[y] - obj[x]);\n  }\n\n  return MH.keysOf(obj).sort((x: keyof T, y: keyof T) => obj[x] - obj[y]);\n};\n\n/**\n * Returns the key in the given object which holds the largest numeric value.\n *\n * If the object is empty, returns `undefined`.\n *\n * @category Math\n */\nexport const keyWithMaxVal = (\n  obj: Record<string, number>,\n): string | undefined => {\n  return sortedKeysByVal(obj).slice(-1)[0];\n};\n\n/**\n * Returns the key in the given object which holds the smallest numeric value.\n *\n * If the object is empty, returns `undefined`.\n *\n * @category Math\n */\nexport const keyWithMinVal = (\n  obj: Record<string, number>,\n): string | undefined => {\n  return sortedKeysByVal(obj).slice(0, 1)[0];\n};\n\n/**\n * Takes two integers and returns a bitmask that covers all values between\n * 1 << start and 1 << end, _including the starting and ending one_.\n *\n * If pStart > pEnd, they are reversed.\n *\n * getBitmask(start, start) always returns 1 << start\n * getBitmask(start, end) always returns same as getBitmask(end, start)\n *\n * @category Math\n */\nexport const getBitmask = (start: number, end: number): number =>\n  start > end\n    ? getBitmask(end, start)\n    : (~0 >>> (32 - end - 1 + start)) << start;\n","/**\n * @module\n * @ignore\n * @internal\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { roundNumTo } from \"@lisn/utils/math\";\n\nexport const isTouchScreen = () =>\n  MH.hasDOM() ? matchMedia(\"(any-pointer: coarse)\").matches : false;\n\nexport const copyExistingKeys = <T extends object>(fromObj: T, toObj: T) => {\n  for (const key in toObj) {\n    if (!MH.hasOwnProp(toObj, key)) {\n      continue;\n    }\n\n    if (key in fromObj) {\n      if (MH.isNonPrimitive(fromObj[key]) && MH.isNonPrimitive(toObj[key])) {\n        copyExistingKeys(fromObj[key], toObj[key]);\n      } else {\n        toObj[key] = fromObj[key];\n      }\n    }\n  }\n};\n\n// Omits the keys in object keysToRm from obj. This is to avoid hardcording the\n// key names as a string so as to allow minifier to mangle them, and to avoid\n// using object spread.\nexport const omitKeys = <\n  O extends object,\n  R extends { [K in keyof O]?: unknown },\n>(\n  obj: O,\n  keysToRm: R,\n): Omit<O, keyof R> => {\n  const res: Partial<O> = {};\n  let key: keyof O;\n\n  for (key in obj) {\n    if (!(key in keysToRm)) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res as Omit<O, keyof R>;\n};\n\n// Returns true if the two objects are equal. If values are numeric, it will\n// round to the given number of decimal places.\nexport const compareValuesIn = <T extends object>(\n  objA: T,\n  objB: T,\n  roundTo = 3,\n) => {\n  for (const key in objA) {\n    if (!MH.hasOwnProp(objA, key)) {\n      continue;\n    }\n\n    const valA = objA[key];\n    const valB = objB[key];\n\n    if (MH.isNonPrimitive(valA) && MH.isNonPrimitive(valB)) {\n      if (!compareValuesIn(valA, valB)) {\n        return false;\n      }\n    } else if (MH.isNumber(valA) && MH.isNumber(valB)) {\n      if (roundNumTo(valA, roundTo) !== roundNumTo(valB, roundTo)) {\n        return false;\n      }\n    } else if (valA !== valB) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const keyExists = <T extends object>(\n  obj: T,\n  key: string | number | symbol,\n): key is keyof T => MH.isNonPrimitive(obj) && key in obj;\n\nexport const toArrayIfSingle = <T>(value?: T | T[] | null | undefined): T[] =>\n  MH.isArray(value) ? value : !MH.isNullish(value) ? [value] : [];\n\nexport const toBool = (value: unknown) =>\n  value === true || value === \"true\" || value === \"\"\n    ? true\n    : MH.isNullish(value) || value === false || value === \"false\"\n      ? false\n      : null;\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Size, StrRecord } from \"@lisn/globals/types\";\n\n/**\n * Formats an object as a string. It supports more meaningful formatting as\n * string for certain types rather than using the default string\n * representation.\n *\n * **NOTE:** This is not intended for serialization of data that needs to be\n * de-serialized. Only for debugging output.\n *\n * @param {} value     The value to format as string.\n * @param {} [maxLen]  Maximum length of the returned string. If not given or\n *                     is <= 0, the string is not truncated. Otherwise, if the\n *                     result is longer than maxLen, it is truncated to\n *                     `maxLen - 3` and added a suffix of \"...\".\n *                     Note that if `maxLen` is > 0 but <= 3, the result is\n *                     always \"...\"\n *\n * @category Text\n */\nexport const formatAsString = (value: unknown, maxLen?: number) => {\n  const result = maybeConvertToString(value, false);\n\n  if (!MH.isNullish(maxLen) && maxLen > 0 && MH.lengthOf(result) > maxLen) {\n    return result.slice(0, MH.max(0, maxLen - 3)) + \"...\";\n  }\n\n  return result;\n};\n\n/**\n * Join an array of values as string using separator. It uses\n * {@link formatAsString} rather than the default string representation as\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join | Array:join} would.\n *\n * @param {} separator  The separator to use to delimit each argument.\n * @param {} args       Objects or values to convert to string and join.\n *\n * @category Text\n */\nexport const joinAsString = (separator: string, ...args: unknown[]) =>\n  args.map((a) => formatAsString(a)).join(separator);\n\n/**\n * Similar to\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split | String.prototype.split}\n * except that\n * 1. `limit` is interpreted as the maximum number of splits, and the\n *   returned array contains `limit + 1` entries. Also if `limit` is given and\n *   the number of substrings is greater than the limit, all the remaining\n *   substrings are present in the final substring.\n * 2. If input is an empty string (or containing only whitespace), returns an\n *    empty array.\n *\n * @example\n * ```javascript\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 0); // -> ['foo, bar, baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 1); // -> ['foo', 'bar, baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 2); // -> ['foo', 'bar', 'baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 3); // -> ['foo', 'bar', 'baz']\n * ```\n *\n * @param {} trim  If true, entries will be trimmed for whitespace after splitting.\n *\n * @param {} limit If not given or < 0, the string will be split on every\n *                 occurrence of `separator`. Otherwise, it will be split on\n *                 the first `limit` number of occurrences of `separator`.\n *\n * @category Text\n */\nexport const splitOn = (\n  input: string,\n  separator: string | RegExp,\n  trim?: boolean,\n  limit?: number,\n) => {\n  if (!input.trim()) {\n    return [];\n  }\n\n  limit = limit ?? -1;\n\n  const output: string[] = [];\n  const addEntry = (s: string) => output.push(trim ? s.trim() : s);\n\n  while (limit--) {\n    let matchIndex = -1,\n      matchLength = 0;\n    if (MH.isLiteralString(separator)) {\n      matchIndex = input.indexOf(separator);\n      matchLength = MH.lengthOf(separator);\n    } else {\n      const match = separator.exec(input);\n      matchIndex = match?.index ?? -1;\n      matchLength = match ? MH.lengthOf(match[0]) : 0;\n    }\n\n    if (matchIndex < 0) {\n      break;\n    }\n\n    addEntry(input.slice(0, matchIndex));\n    input = input.slice(matchIndex + matchLength);\n  }\n\n  addEntry(input);\n  return output;\n};\n\n/**\n * Converts a kebab-cased-string to camelCase.\n * The result is undefined if the input string is not formatted in\n * kebab-case.\n *\n * @category Text\n */\nexport const kebabToCamelCase = MH.kebabToCamelCase;\n\n/**\n * Converts a camelCasedString to kebab-case.\n * The result is undefined if the input string is not formatted in\n * camelCase.\n *\n * @category Text\n */\nexport const camelToKebabCase = MH.camelToKebabCase;\n\n/**\n * Generates a random string of a fixed length.\n *\n * **IMPORTANT:** This is _not_ suitable for cryptographic applications.\n *\n * @param {} [nChars = 8]  The length of the returned stirng.\n *\n * @category Text\n */\nexport const randId = (nChars = 8) => {\n  const segment = () =>\n    MH.floor(100000 + MC.MATH.random() * 900000).toString(36);\n\n  let s = \"\";\n  while (MH.lengthOf(s) < nChars) {\n    s += segment();\n  }\n  return s.slice(0, nChars);\n};\n\n/**\n * Returns an array of numeric margins in pixels from the given margin string.\n * The string should contain margins in either pixels or percentage; other\n * units are not supported.\n *\n * Percentage values are converted to pixels relative to the given\n * `absoluteSize`: left/right margins relative to the width, and top/bottom\n * margins relative to the height.\n *\n * Note that for the margin property, percentages are always relative to the\n * WIDTH of the parent, so you should pass the parent width as both the width\n * and the height keys in `absoluteSize`. But for IntersectionObserver's\n * `rootMargin`, top/bottom margin is relative to the height of the root, so\n * pass the actual root size.\n *\n * @return {} [topMarginInPx, rightMarginInPx, bottomMarginInPx, leftMarginInPx]\n *\n * @category Text\n */\nexport const toMargins = (value: string, absoluteSize: Size) => {\n  const toPxValue = (strValue: string | undefined, index: number) => {\n    let margin = MH.parseFloat(strValue || \"\") || 0;\n\n    if (strValue === margin + \"%\") {\n      margin *=\n        index % 2 ? absoluteSize[MC.S_HEIGHT] : absoluteSize[MC.S_WIDTH];\n    }\n\n    return margin;\n  };\n\n  const parts = splitOn(value, \" \", true);\n  const margins: [number, number, number, number] = [\n    // top\n    toPxValue(parts[0], 0),\n    // right\n    toPxValue(parts[1] ?? parts[0], 1),\n    // bottom\n    toPxValue(parts[2] ?? parts[0], 2),\n    // left\n    toPxValue(parts[3] ?? parts[1] ?? parts[0], 3),\n  ];\n\n  return margins;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const objToStrKey = (obj: StrRecord): string =>\n  MH.stringify(flattenForSorting(obj));\n\n// --------------------\n\nconst flattenForSorting = (obj: StrRecord): unknown[] => {\n  const array = MH.isArray(obj)\n    ? obj\n    : MH.keysOf(obj)\n        .sort()\n        .map((k) => obj[k]);\n\n  return array.map((value) => {\n    if (\n      MH.isArray(value) ||\n      (MH.isNonPrimitive(value) && MH.constructorOf(value) === MC.OBJECT)\n    ) {\n      return flattenForSorting(value);\n    }\n    return value;\n  });\n};\n\nconst stringifyReplacer = (key: string, value: unknown) =>\n  key ? maybeConvertToString(value, true) : value;\n\nconst maybeConvertToString = <B extends boolean, V>(\n  value: V,\n  nested: B,\n): B extends false ? string : string | V => {\n  let result: string | V = \"\";\n\n  if (MH.isElement(value)) {\n    const classStr = MH.classList(value).toString().trim();\n\n    result = value.id\n      ? \"#\" + value.id\n      : `<${MH.tagName(value)}${classStr ? ' class=\"' + classStr + '\"' : \"\"}>`;\n\n    //\n  } else if (MH.isInstanceOf(value, Error)) {\n    /* istanbul ignore else */\n    if (\"stack\" in value && MH.isString(value.stack)) {\n      result = value.stack;\n    } else {\n      result = `Error: ${value.message}`;\n    }\n\n    //\n  } else if (MH.isArray(value)) {\n    result =\n      \"[\" +\n      value\n        .map((v) =>\n          MH.isString(v) ? MH.stringify(v) : maybeConvertToString(v, false),\n        )\n        .join(\",\") +\n      \"]\";\n\n    //\n  } else if (MH.isIterableObject(value)) {\n    result =\n      MH.typeOrClassOf(value) +\n      \"(\" +\n      maybeConvertToString(MH.arrayFrom(value), false) +\n      \")\";\n\n    //\n  } else if (MH.isNonPrimitive(value)) {\n    result = nested ? value : MH.stringify(value, stringifyReplacer);\n\n    //\n  } else {\n    // primitive\n    result = nested ? value : MC.STRING(value);\n  }\n\n  return result as B extends false ? string : string | V;\n};\n","/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { toNum } from \"@lisn/utils/math\";\nimport { toBool } from \"@lisn/utils/misc\";\nimport { splitOn } from \"@lisn/utils/text\";\n\n/**\n * Returns true if the input is a string array or comma-separated string, whose\n * elements are valid according to the `validator` function.\n *\n * @param {} allowEmpty If `false`, then input without any entries is\n * considered _invalid_.\n *\n * @category Validation\n */\nexport const isValidStrList = <T extends string = string>(\n  value: unknown,\n  checkFn: (value: string) => value is T,\n  allowEmpty = true,\n): value is CommaSeparatedStr<T> | T[] => {\n  try {\n    const res = validateStrList(\"\", value, checkFn);\n    return allowEmpty || !MH.isNullish(res);\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns an array of strings from the given list while validating each one\n * using the `checkFn` function.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a string or array of strings, or if any\n *                entries do not pass `checkFn`.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateStrList = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateString(key, v, checkFn, \"a string or a string array\"),\n    ),\n  );\n\n/**\n * Returns an array of numbers from the given list.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a number or array of numbers. Numerical\n *                strings are accepted.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateNumList = (\n  key: string,\n  value: unknown,\n): number[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateNumber(key, v, \"a number or a number array\"),\n    ),\n  );\n\n/**\n * Returns a number corresponding to the supplied value, ensuring the supplied\n * value is a valid number or a string containing only a number.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateNumber = (key: string, value: unknown) =>\n  _validateNumber(key, value);\n\n/**\n * Returns a boolean corresponding to the given value as follows:\n *\n * - `null` and `undefined` result in `undefined`\n * - `false` and `\"false\"` result in `false`\n * - `\"\"`, `true` and `\"true\"` result in `true`\n * - other values throw an error error\n *\n * Note that an empty string is treated as `true`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is not a valid boolean or boolean string.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateBoolean = (key: string, value: unknown) =>\n  _validateBoolean(key, value);\n\n/**\n * Returns a valid string from the supplied value, ensuring the supplied value\n * is a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} checkFn      If given and the supplied value is a string, then it\n *                        is called with the value as a single argument. It\n *                        must return true if the value is valid and false\n *                        otherwise.\n *                        If it is not given, then any literal string is\n *                        accepted.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n) => _validateString(key, value, checkFn);\n\n/**\n * Like {@link validateString} except it requires input to be given and\n * non-empty.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid or empty.\n *\n * @category Validation\n */\nexport const validateStringRequired = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T => {\n  const result = _validateString(key, value, checkFn);\n\n  if (MH.isEmpty(result)) {\n    throw MH.usageError(`'${key}' is required`);\n  }\n\n  return result;\n};\n\n/**\n * Returns a valid boolean or a string from the supplied value, ensuring the\n * supplied value is either a boolean or boolean string (see\n * {@link validateBoolean}), or a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} stringCheckFn If given and the supplied value is a string _other\n *                         than a boolean string_, then it is called with the\n *                         value as a single argument. It must return true if\n *                         the value is valid and false otherwise.\n *                         If it is not given, then any literal string is\n *                         accepted.\n *\n * @category Validation\n */\nexport const validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n) => _validateBooleanOrString(key, value, stringCheckFn);\n\n// --------------------\n\nconst toArray = (value: unknown): unknown[] | undefined => {\n  let result: unknown[] | null;\n  if (MH.isArray(value)) {\n    result = value;\n  } else if (MH.isIterableObject(value)) {\n    result = MH.arrayFrom(value);\n  } else if (MH.isLiteralString(value)) {\n    result = splitOn(value, \",\");\n  } else if (!MH.isNullish(value)) {\n    result = [value];\n  } else {\n    result = null;\n  }\n\n  return result\n    ? MH.filterBlank(result.map((v) => (MH.isLiteralString(v) ? v.trim() : v)))\n    : undefined;\n};\n\nconst _validateNumber = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const numVal = toNum(value, null);\n  if (numVal === null) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a number\"}`);\n  }\n\n  return numVal;\n};\n\nconst _validateBoolean = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal === null) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? '\"true\" or \"false\"'}`,\n    );\n  }\n\n  return boolVal;\n};\n\nconst _validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n  typeDescription?: string,\n): (typeof checkFn extends null | undefined ? string : T) | undefined => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a string\"}`);\n  } else if (checkFn && !checkFn(value)) {\n    throw MH.usageError(`Invalid value for '${key}'`);\n  }\n\n  return value as typeof checkFn extends null | undefined ? string : T;\n};\n\nconst _validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal !== null) {\n    return boolVal;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? \"a boolean or string\"}`,\n    );\n  }\n\n  return _validateString(key, value, stringCheckFn);\n};\n","/**\n * @module Modules/BitSpaces\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getBitmask } from \"@lisn/utils/math\";\n\nexport type BitPropName = string;\n\n/**\n * A union of all property names in the space.\n */\nexport type BitSpaceKey<S> = S extends BitSpace<infer T> ? T : never;\n\n/**\n * {@link BitSpace} represents a single set of mutually exclusive (or\n * orthogonal) properties.\n *\n * Each property has a numeric value equal to 1 bit-shifted by a certain number\n * of bits.\n *\n * Created using {@link BitSpaces.create}\n *\n * @interface\n */\nexport type BitSpace<T extends BitPropName> = {\n  /**\n   * The starting bit of the space. It's 0 for the first space created in a\n   * given set of {@link BitSpaces}.\n   */\n  start: number;\n\n  /**\n   * The ending bit of the space. It's always equal to\n   * start + (# of properties in space) - 1\n   */\n  end: number;\n\n  /**\n   * A bitmask of all values in the space.\n   */\n  bitmask: number;\n\n  /**\n   * Returns true if the given name is one of the properties in the space.\n   * It is case-sensitive.\n   */\n  has: (p: string) => p is T;\n\n  /**\n   * Takes the names of two properties within the space and returns a bitmask\n   * that covers all values between them _including the starting and ending\n   * one_.*\n   *\n   * If pStart > pEnd, they are reversed.\n   *\n   * * The numeric values of the properties are guaranteed to be in the same\n   *   order, increasing in value, as the keys passed to the `BitSpaces.create`,\n   *   function.\n   *\n   * @param {} pStart  The name of the property that holds the start value.\n   *                   If null the bitmask will cover from the lowest property.\n   * @param {} pEnd    The name of the property that holds the end cut-off\n   *                   value for the bitmask. The bitmask with _not_ include\n   *                   pEnd's value.\n   *                   If null the bitmask will cover to the highest property,\n   *                   _including_.\n   *\n   * @returns {} Returns a non-0 bitmask containing all values in the space\n   *             between the given ones.\n   *             Returns 0 if one or both of the given properties do not exist\n   *             in the space.\n   */\n  bitmaskFor: (pStart?: T | null, pEnd?: T | null) => number;\n\n  /**\n   * Returns the name of the property with the given value, or null if the\n   * value does not correspond to one of the space properties.\n   */\n  nameOf: (val: number) => T | null;\n\n  /**\n   * Holds properties whose numeric values are non-overlapping binary values,\n   * suitable for bitmasking.\n   *\n   * The given properties are set under the \"bit\" key in the object and hold\n   * the numeric value.\n   *\n   * @example\n   * ```javascript\n   * const space = new BitSpaces().create(\"up\", \"down\", \"left\", \"right\");\n   *\n   * // {\n   * //     bit: {\n   * //         up:    1, // at bit 0, i.e. 1 << 0\n   * //         down:  2, // at bit 1, i.e. 1 << 1\n   * //         left:  4, // at bit 2, i.e. 1 << 2\n   * //         right: 8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      0,\n   * //     end:        3,\n   * //     bitmask:    15, // 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"up\" || p === \"down\" || p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : v === 4 ...\n   * // }\n   *\n   * space.bitmaskFor(); // => space.bitmask (15)\n   * space.bitmaskFor(\"left\"); // => space.bit.left | space.bit.right (12)\n   * space.bitmaskFor(null, \"down\"); // => space.bit.up | space.bit.down (3)\n   * ```\n   */\n  bit: {\n    [key in T]: number;\n  };\n};\n\n/**\n * {@link BitSpaces} represents one or more related {@link BitSpace}s whose bit\n * values will not overlap.\n */\nexport class BitSpaces {\n  /**\n   * Creates and returns a new BitSpace that is bit shifted to the left as\n   * many bits as the ending bit of the previous space created by this\n   * instances, so that each new space created is non-overlapping with previous\n   * ones.\n   *\n   * The numeric values of the properties are guaranteed to be in the same\n   * order, increasing in value, as the keys passed to the function.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the number of bits in the space will exceed 32.\n   *\n   * @example\n   * ```javascript\n   * const spaces = new BitSpaces();\n   * const spaceA = spaces.create(\"up\", \"down\");\n   *\n   * // spaces.nBits   => 2\n   * // spaces.bitmask => 3\n   * //\n   * // spaceA:\n   * // {\n   * //     bit: {\n   * //         up:     1, // at bit 0, i.e. 1 << 0\n   * //         down:   2, // at bit 1, i.e. 1 << 1\n   * //     },\n   * //     start:      0,\n   * //     end:        1,\n   * //     bitmask:    3, // 1 << 0 | 1 << 1\n   * //     has:        (p) => p === \"up\" || p === \"down\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : null\n   * // }\n   *\n   * const spaceB = spaces.create(\"left\", \"right\");\n   *\n   * // spaces.nBits   => 4\n   * // spaces.bitmask => 15\n   * //\n   * // spaceB:\n   * // {\n   * //     bit: {\n   * //         left:   4, // at bit 2, i.e. 1 << 2\n   * //         right:  8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      2,\n   * //     end:        3,\n   * //     bitmask:    12, // 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 4 ? \"left\" : v === 8 ? \"right\" : null\n   * // }\n   *\n   * ```\n   */\n  readonly create: <T extends BitPropName>(\n    ...propNames: readonly T[]\n  ) => BitSpace<T>;\n\n  /**\n   * Returns the number of bits all created spaces span, i.e. the end bit of\n   * the one + 1.\n   */\n  readonly nBits!: number;\n\n  /**\n   * Returns a bitmask containing all values in all created spaces.\n   */\n  readonly bitmask!: number;\n\n  constructor() {\n    const counter = newCounter();\n\n    this.create = (...propNames) => newBitSpace(counter, propNames);\n    MH.defineProperty(this, \"nBits\", { get: () => counter._nBits });\n    MH.defineProperty(this, \"bitmask\", { get: () => counter._bitmask });\n  }\n}\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newBitSpaces = () => new BitSpaces();\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const createBitSpace = <T extends BitPropName>(\n  spaces: BitSpaces,\n  ...propNames: readonly T[]\n): BitSpace<T> => spaces.create(...propNames);\n\n// ----------------------------------------\n\ntype BitCounter = {\n  _nBits: number;\n  _bitmask: number;\n};\n\nconst newCounter = (): BitCounter => ({\n  _nBits: 0,\n  _bitmask: 0,\n});\n\nconst newBitSpace = <T extends BitPropName>(\n  counter: BitCounter,\n  propNames: readonly T[],\n): BitSpace<T> => {\n  const start = counter._nBits;\n  const end = start + MH.lengthOf(propNames) - 1;\n  if (end >= 31) {\n    throw MH.usageError(\"BitSpaces overflow\");\n  }\n\n  const bitmask = getBitmask(start, end);\n  const space: BitSpace<T> = {\n    bit: {},\n    start,\n    end,\n    bitmask,\n\n    has: (p) =>\n      MH.isString(p) &&\n      p in space.bit &&\n      MH.isNumber((space.bit as Record<string, unknown>)[p]),\n\n    bitmaskFor: (pStart, pEnd) => {\n      if (\n        (!MH.isEmpty(pStart) && !space.has(pStart)) ||\n        (!MH.isEmpty(pEnd) && !space.has(pEnd))\n      ) {\n        return 0;\n      }\n\n      const thisStart = !MH.isEmpty(pStart)\n        ? MH.log2(space.bit[pStart])\n        : start;\n      const thisEnd = !MH.isEmpty(pEnd) ? MH.log2(space.bit[pEnd]) : end;\n\n      return getBitmask(thisStart, thisEnd);\n    },\n\n    nameOf: (val) => propNames[MH.log2(val) - start] ?? null,\n  } as BitSpace<T>;\n\n  for (const name of propNames) {\n    MH.defineProperty(space.bit, name, {\n      value: 1 << counter._nBits++,\n      enumerable: true,\n    });\n  }\n\n  counter._bitmask |= bitmask;\n\n  return space;\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\n\nimport { MutationCategory } from \"@lisn/globals/types\";\n\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\nimport { newBitSpaces, createBitSpace } from \"@lisn/modules/bit-spaces\";\n\n/**\n * Returns true if the given string is a valid category.\n *\n * @category Validation\n */\nexport const isValidMutationCategory = (\n  category: string,\n): category is MutationCategory => DOM_CATEGORIES_SPACE.has(category);\n\n/**\n * Returns true if the given string or array is a list of valid categories.\n *\n * @category Validation\n */\nexport const isValidMutationCategoryList = (categories: string | string[]) =>\n  isValidStrList(categories, isValidMutationCategory, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const DOM_CATEGORIES_SPACE = createBitSpace<MutationCategory>(\n  newBitSpaces(),\n  MC.S_ADDED,\n  MC.S_REMOVED,\n  MC.S_ATTRIBUTE,\n);\n","/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\n/**\n * @category Tasks\n */\nexport type SchedulerPostTaskOptions = {\n  delay?: number;\n  priority?: TaskPriority;\n  signal?: AbortSignal;\n};\n\n/**\n * @category Tasks\n */\nexport type Scheduler = {\n  postTask<T, P extends readonly unknown[] | []>(\n    callback: (...params: P) => T,\n    options?: SchedulerPostTaskOptions,\n    ...args: P\n  ): Promise<T>;\n};\n\n/**\n * @category Tasks\n */\nexport type TaskPriority = \"user-blocking\" | \"user-visible\" | \"background\";\n\n/* eslint-disable-next-line no-var */\ndeclare var scheduler: Scheduler;\n\n/**\n * Schedules a task with high priority to be executed as soon as possible.\n *\n * It uses {@link https://developer.mozilla.org/en-US/docs/Web/API/Scheduler/postTask | Scheduler:postTask}\n * if available, otherwise falls back to\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel | MessageChannel}.\n *\n * @category Tasks\n */\nexport const scheduleHighPriorityTask = (task: () => void) => {\n  if (typeof scheduler !== \"undefined\") {\n    scheduler.postTask(task, {\n      priority: \"user-blocking\",\n    });\n  } else {\n    // Fallback to MessageChannel\n    const channel = new MessageChannel();\n    channel.port1.onmessage = () => {\n      channel.port1.close();\n      task();\n    };\n    channel.port2.postMessage(\"\");\n  }\n};\n\n/**\n * Returns a wrapper around the given handler that is debounced by the given\n * debounce window.\n *\n * @category Tasks\n */\nexport const getDebouncedHandler = <Args extends unknown[]>(\n  debounceWindow: number,\n  handler: (...args: Args) => void,\n) => {\n  if (!debounceWindow) {\n    return handler;\n  }\n\n  let timer: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Args;\n\n  return (...args: Args) => {\n    lastArgs = args;\n\n    if (timer === null) {\n      timer = MH.setTimer(async () => {\n        await handler(...lastArgs);\n        timer = null;\n      }, debounceWindow);\n    }\n  };\n};\n\n/**\n * Returns a promise that resolves at least the given number of delay (in\n * milliseconds) later. Uses `setTimeout`.\n *\n * @category Tasks\n */\nexport const waitForDelay = (delay?: number) =>\n  MH.newPromise<void>((resolve) => {\n    MH.setTimer(resolve, delay);\n  });\n","/**\n * @module Modules/Callback\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * @typeParam Args  See {@link Callback}\n */\nexport type CallbackHandler<Args extends unknown[] = []> = (\n  ...args: Args\n) => CallbackReturnType | Promise<CallbackReturnType>;\n\nexport type CallbackReturnType =\n  | typeof Callback.KEEP\n  | typeof Callback.REMOVE\n  | void;\n\n/**\n * For minification optimization. Exposed through Callback.wrap.\n *\n * @ignore\n * @internal\n */\nexport const wrapCallback = <Args extends unknown[] = []>(\n  handlerOrCallback: CallbackHandler<Args> | Callback<Args>,\n  debounceWindow = 0,\n): Callback<Args> => {\n  const isFunction = MH.isFunction(handlerOrCallback);\n  let isRemoved = () => false;\n\n  if (isFunction) {\n    // check if it's an invoke method\n    const callback = callablesMap.get(handlerOrCallback);\n    if (callback) {\n      return wrapCallback(callback);\n    }\n  } else {\n    isRemoved = handlerOrCallback.isRemoved;\n  }\n\n  const handler: CallbackHandler<Args> = isFunction\n    ? handlerOrCallback\n    : (...args: Args) => handlerOrCallback.invoke(...args);\n\n  const wrapper = new Callback<Args>(\n    getDebouncedHandler(debounceWindow, (...args: Args) => {\n      if (!isRemoved()) {\n        return handler(...args);\n      }\n    }),\n  );\n\n  if (!isFunction) {\n    handlerOrCallback.onRemove(wrapper.remove);\n  }\n\n  return wrapper;\n};\n\n/**\n * {@link Callback} wraps user-supplied callbacks. Supports\n * - removing a callback either when calling {@link remove} or if the user\n *   handler returns {@link Callback.REMOVE}\n * - calling custom {@link onRemove} hooks\n * - debouncing (via {@link wrap})\n * - awaiting on an asynchronous handler and ensuring that the handler does not\n *  run concurrently to itself, i.e. subsequent {@link invoke}s will be queued\n *\n * @typeParam Args  The type of arguments that the callback expects.\n */\nexport class Callback<Args extends unknown[] = []> {\n  /**\n   * Possible return value for the handler.\n   *\n   * Do not do anything. Same as not retuning anything from the function.\n   */\n  static readonly KEEP: unique symbol = MC.SYMBOL(\n    \"KEEP\",\n  ) as typeof Callback.KEEP;\n\n  /**\n   * Possible return value for the handler.\n   *\n   * Will remove this callback.\n   */\n  static readonly REMOVE: unique symbol = MC.SYMBOL(\n    \"REMOVE\",\n  ) as typeof Callback.REMOVE;\n\n  /**\n   * Call the handler with the given arguments.\n   *\n   * If the handler is asynchronous, it awaits on it. Furthermore, calls will\n   * always wait for previous calls to this handler to complete first, i.e. it\n   * never runs concurrently to itself. If you need multiple calls to the async\n   * handler to run concurrently, then wrap it in a non-async function that\n   * does not await it.\n   *\n   * The returned promise is rejected in two cases:\n   * - If the callback throws an error or returns a rejected Promise.\n   * - If the callback is removed _after_ you call {@link invoke} but before the\n   *   handler is actually called (while it's waiting in the queue to be called)\n   *   In this case, the rejection reason is {@link Callback.REMOVE}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the callback is already removed.\n   */\n  readonly invoke: (...args: Args) => Promise<void>;\n\n  /**\n   * Mark the callback as removed and call the registered {@link onRemove} hooks.\n   *\n   * Future attempts to call it will result in\n   * {@link Errors.LisnUsageError | LisnUsageError}.\n   */\n  readonly remove: () => void;\n\n  /**\n   * Returns true if the callback has been removed and cannot be called again.\n   */\n  readonly isRemoved: () => boolean;\n\n  /**\n   * Registers the given function to be called when the callback is removed.\n   *\n   * You can call {@link onRemove} multiple times to register multiple hooks.\n   */\n  readonly onRemove: (fn: () => void) => void;\n\n  /**\n   * Wraps the given handler or callback as a callback, optionally debounced by\n   * the given debounce window.\n   *\n   * If the argument is already a callback _or an invoke method of a callback_,\n   * then the wrapper will call that callback and return the same value as it.\n   * It will also set up the returned wrapper callback so that it is removed\n   * when the original (given) callback is removed. However, removing the\n   * returned wrapper callback will _not_ cause the original callback (being\n   * wrapped) to be removed. If you want to do this, then do\n   * `wrapper.onRemove(wrapped.remove)`.\n   *\n   * Note that if the argument is a callback that's already debounced by a\n   * _larger_ window, then `debounceWindow` will have no effect.\n   *\n   * @param {} debounceWindow  If non-0, the callback will be called at most\n   *                           every `debounceWindow` ms. The arguments it will\n   *                           be called with will be the last arguments the\n   *                           wrapper was called with.\n   */\n  static readonly wrap = wrapCallback;\n\n  /**\n   * @param {} handler     The actual function to call. This should return one of\n   *                       the known {@link CallbackReturnType} values.\n   */\n  constructor(handler: CallbackHandler<Args>) {\n    const logger = debug\n      ? new debug.Logger({ name: \"Callback\", logAtCreation: handler })\n      : null;\n\n    let isRemoved = false;\n    const id = MC.SYMBOL();\n\n    const onRemove = MH.newSet<() => void>();\n\n    this.isRemoved = () => isRemoved;\n\n    this.remove = () => {\n      debug: logger?.debug8(\"Removing\");\n      if (!isRemoved) {\n        isRemoved = true;\n\n        for (const rmFn of onRemove) {\n          rmFn();\n        }\n\n        CallbackScheduler._clear(id);\n      }\n    };\n\n    this.onRemove = (fn) => onRemove.add(fn);\n\n    this.invoke = (...args) =>\n      MH.newPromise((resolve, reject) => {\n        debug: logger?.debug8(\"Calling with\", args);\n        if (isRemoved) {\n          reject(MH.usageError(\"Callback has been removed\"));\n          return;\n        }\n\n        CallbackScheduler._push(\n          id,\n          async () => {\n            let result;\n            try {\n              result = await handler(...args);\n            } catch (err) {\n              reject(err);\n            }\n\n            if (result === Callback.REMOVE) {\n              this.remove();\n            }\n\n            resolve();\n          },\n          reject,\n        );\n      });\n\n    callablesMap.set(this.invoke, this);\n  }\n}\n\n// ----------------------------------------\n\ntype CallbackSchedulerTask = () => Promise<void>;\ntype CallbackSchedulerQueueItem = {\n  _task: CallbackSchedulerTask;\n  _running: boolean;\n  _onRemove: (reason: typeof Callback.REMOVE) => void;\n};\n\ntype CallableCallback<Args extends unknown[] = []> = (...args: Args) => void;\n\nconst callablesMap = MH.newWeakMap<CallableCallback, Callback>();\n\nconst CallbackScheduler = (() => {\n  const queues = MH.newMap<symbol, CallbackSchedulerQueueItem[]>();\n\n  const flush = async (queue: CallbackSchedulerQueueItem[]) => {\n    // So that callbacks are always called asynchronously for consistency,\n    // await here before calling 1st\n    await null;\n    while (MH.lengthOf(queue)) {\n      // shouldn't throw anything as Callback must catch errors\n      queue[0]._running = true;\n      await queue[0]._task();\n\n      // only remove when done\n      queue.shift();\n    }\n  };\n\n  return {\n    _clear: (id: symbol) => {\n      const queue = queues.get(id);\n      if (queue) {\n        let item: CallbackSchedulerQueueItem | undefined;\n        while ((item = queue.shift())) {\n          if (!item._running) {\n            item._onRemove(Callback.REMOVE);\n          }\n        }\n\n        MH.deleteKey(queues, id);\n      }\n    },\n\n    _push: (id: symbol, task: CallbackSchedulerTask, onRemove: () => void) => {\n      let queue = queues.get(id);\n      if (!queue) {\n        queue = [];\n        queues.set(id, queue);\n      }\n\n      queue.push({ _task: task, _onRemove: onRemove, _running: false });\n      if (MH.lengthOf(queue) === 1) {\n        flush(queue);\n      }\n    },\n  };\n})();\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LogFunction } from \"@lisn/globals/types\";\n\nimport { joinAsString } from \"@lisn/utils/text\";\n\nimport { Callback } from \"@lisn/modules/callback\";\n\n/**\n * Like `console.info` except if the string representation of the given\n * arguments has already been logged, it does nothing.\n *\n * @category Logging\n */\nexport const logInfo: LogFunction = (...args) => {\n  if (!isMessageSeen(args)) {\n    MH.consoleInfo(MC.LOG_PREFIX, ...args);\n  }\n};\n\n/**\n * Like `console.warn` except if the string representation of the given\n * arguments has already been logged, it does nothing.\n *\n * @category Logging\n */\nexport const logWarn: LogFunction = (...args) => {\n  if (!isMessageSeen(args)) {\n    MH.consoleWarn(MC.LOG_PREFIX, ...args);\n  }\n};\n\n/**\n * Like `console.error` except if the string representation of the given\n * arguments has already been logged, it does nothing.\n *\n * @category Logging\n */\nexport const logError: LogFunction = (...args) => {\n  if (\n    (MH.lengthOf(args) > 1 || args[0] !== Callback.REMOVE) &&\n    !isMessageSeen(args)\n  ) {\n    MH.consoleError(MC.LOG_PREFIX, ...args);\n  }\n};\n\nconst discardMessages = MH.newSet<string>();\nconst isMessageSeen = (args: unknown[]) => {\n  const msg = joinAsString(\" \", ...args);\n  const isSeen = discardMessages.has(msg);\n  discardMessages.add(msg);\n  return isSeen;\n};\n","/**\n * @module Utils\n *\n * @categoryDescription DOM: Preventing layout trashing\n *\n * {@link waitForMeasureTime} allows you to schedule tasks that read or\n * \"measure\", the DOM, for example getting computed styles, taking the\n * `offsetWidth` or the `scrollTop` of an element, etc... anything that _would_\n * force a layout if it runs after the layout has been invalidated by a\n * \"mutation\".\n *\n * See https://gist.github.com/paulirish/5d52fb081b3570c81e3 for a list of\n * operations that should be run on a valid layout to avoid forced layouts.\n *\n * {@link waitForMutateTime} allows you to schedule tasks that invalidate the\n * DOM layout by making changes to the style, inserting or removing elements,\n * etc.\n *\n * These ensure that:\n * - All mutation tasks that would invalidate the style run together before the\n *   next repaint.\n * - All measurement tasks that need a valid style will run as soon as possible\n *   after the next repaint.\n * - If a mutation task is scheduled by another mutation task, it will run in\n *   the same batch.\n * - If a measurement task is scheduled by either a mutation or another\n *   measurement task, it will run in the same batch.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { logError } from \"@lisn/utils/log\";\nimport { scheduleHighPriorityTask } from \"@lisn/utils/tasks\";\n\n/**\n * Returns a Promise that is resolved before the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMutateTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMutations, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved as soon as possible after the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMeasureTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMeasurements, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved before the repaint that follows the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMutateTime = () =>\n  waitForMutateTime().then(waitForMeasureTime).then(waitForMutateTime);\n\n/**\n * Returns a Promise that is resolved as soon as possible after the repaint\n * that follows the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMeasureTime = () =>\n  waitForMeasureTime().then(waitForMutateTime).then(waitForMeasureTime);\n\n// ----------------------------------------\n\ntype TaskResolver = () => void;\ntype DOMTaskQueue = TaskResolver[];\n\nconst scheduledDOMMeasurements: DOMTaskQueue = [];\nconst scheduledDOMMutations: DOMTaskQueue = [];\nlet hasScheduledDOMTasks = false;\n\nconst scheduleDOMTask = (queue: DOMTaskQueue, resolve: TaskResolver) => {\n  queue.push(resolve);\n  if (!hasScheduledDOMTasks) {\n    hasScheduledDOMTasks = true;\n    MH.onAnimationFrame(runAllDOMTasks);\n  }\n};\n\nconst runAllDOMTasks = async () => {\n  // We suspend (await null) after each queue to ensure that microtasks that\n  // have been added by await waitFor* or waitFor*().then run before the next\n  // queue, so that if they schedule more measurements and/or mutations, they\n  // can be flushed now, in the same batch.\n\n  // We're inside an animation frame. Run all mutation tasks now.\n  while (MH.lengthOf(scheduledDOMMutations)) {\n    runDOMTaskQueue(scheduledDOMMutations);\n    // wait for tasks awaiting on the resolved promises, then check queue again\n    await null;\n  }\n\n  // The measurement queue is now empty => scheduling measurements after\n  // this point will result in rescheduling both queues again in the next\n  // frame.\n  //\n  // Schedule the measurement tasks as soon as possible, after the upcoming\n  // paint. Use a macro task with as high priority as possible.\n  scheduleHighPriorityTask(async () => {\n    while (MH.lengthOf(scheduledDOMMeasurements)) {\n      runDOMTaskQueue(scheduledDOMMeasurements);\n      // wait for tasks awaiting on the resolved promises, then check queue again\n      await null;\n    }\n\n    if (MH.lengthOf(scheduledDOMMutations)) {\n      // There have been mutations added. Schedule another flush.\n      MH.onAnimationFrame(runAllDOMTasks);\n    } else {\n      hasScheduledDOMTasks = false;\n    }\n  });\n};\n\nconst runDOMTaskQueue = (queue: DOMTaskQueue) => {\n  let resolve: TaskResolver | undefined;\n  while ((resolve = queue.shift())) {\n    try {\n      resolve();\n    } catch (err) /* istanbul ignore next */ {\n      logError(err);\n    }\n  }\n};\n","/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { DOMElement } from \"@lisn/globals/types\";\n\n/**\n * Returns all the child elements of the given element that are not `script` or\n * `style` tags.\n *\n * @category DOM: Querying\n */\nexport const getVisibleContentChildren = (el: Element) =>\n  MH.filter([...MH.childrenOf(el)], (e) => isVisibleContentTag(MH.tagName(e)));\n\n/**\n * Returns whether the given tag is _not_ `script` or `style`. Comparison is\n * case insensitive.\n *\n * @category DOM: Querying\n */\nexport const isVisibleContentTag = (tagName: string) =>\n  !MH.includes([\"script\", \"style\"], MH.toLowerCase(tagName));\n\n/**\n * Returns whether the given tag name has by default an inline display.\n * Comparison is case insensitive.\n *\n * @category DOM: Querying\n */\nexport const isInlineTag = (tagName: string) =>\n  inlineTags.has(tagName.toLowerCase());\n\n/**\n * Returns whether the given element is as {@link DOMElement}.\n *\n * @category DOM: Querying\n */\nexport const isDOMElement = (target: unknown): target is DOMElement =>\n  MH.isHTMLElement(target) ||\n  MH.isInstanceOf(target, SVGElement) ||\n  (typeof MathMLElement !== \"undefined\" &&\n    MH.isInstanceOf(target, MathMLElement));\n\n// --------------------\n\nconst inlineTags = MH.newSet([\n  \"a\",\n  \"abbr\",\n  \"acronym\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"big\",\n  \"button\",\n  \"cite\",\n  \"code\",\n  \"data\",\n  \"dfn\",\n  \"em\",\n  \"i\",\n  \"img\",\n  \"input\",\n  \"kbd\",\n  \"label\",\n  \"mark\",\n  \"map\",\n  \"object\",\n  \"output\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"select\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"sup\",\n  \"textarea\",\n  \"time\",\n  \"tt\",\n  \"u\",\n  \"var\",\n]);\n","/**\n * @module Utils\n *\n * @categoryDescription CSS: Altering\n * These functions transition an element from one CSS class to another, but\n * could lead to forced layout if not scheduled using {@link waitForMutateTime}.\n * If a delay is supplied, then the transition is \"scheduled\" and if the\n * opposite transition is executed before the scheduled one, the original one\n * is cancelled. See {@link transitionElement} for an example.\n *\n * @categoryDescription CSS: Altering (optimized)\n * These functions transition an element from one CSS class to another in an\n * optimized way using {@link waitForMutateTime} and so are asynchronous.\n * If a delay is supplied, then the transition is \"scheduled\" and if the\n * opposite transition is executed before the scheduled one, the original one\n * is cancelled. See {@link transitionElement} for an example.\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { DOMElement } from \"@lisn/globals/types\";\n\nimport {\n  waitForMeasureTime,\n  waitForMutateTime,\n  waitForSubsequentMutateTime,\n} from \"@lisn/utils/dom-optimize\";\nimport { isDOMElement } from \"@lisn/utils/dom-query\";\nimport { isValidNum, roundNumTo } from \"@lisn/utils/math\";\nimport { waitForDelay } from \"@lisn/utils/tasks\";\nimport { camelToKebabCase, splitOn } from \"@lisn/utils/text\";\n\n/**\n * Removes the given `fromCls` class and adds the given `toCls` class to the\n * element.\n *\n * Unlike {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/replace | DOMTokenList:replace},\n * this will always add `toCls` even if `fromCls` isn't in the element's class list.\n *\n * @returns {} True if there was a change made (class removed or added),\n *             false otherwise.\n *\n * @category CSS: Altering\n */\nexport const transitionElementNow = (\n  element: Element,\n  fromCls: string,\n  toCls: string,\n) => {\n  cancelCSSTransitions(element, fromCls, toCls);\n\n  // Avoid triggering MutationObserver unnecessarily.\n  let didChange = false;\n  if (hasClass(element, fromCls)) {\n    didChange = true;\n    removeClassesNow(element, fromCls);\n  }\n\n  if (!hasClass(element, toCls)) {\n    addClassesNow(element, toCls);\n    didChange = true;\n  }\n\n  return didChange;\n};\n\n/**\n * Like {@link transitionElementNow} except it will {@link waitForMutateTime},\n * and optionally a delay, and it finally awaits for the effective style's\n * transition-duration.\n *\n * If a delay is supplied, then the transition is \"scheduled\" and if the\n * opposite transition is executed before the scheduled one, this one is\n * cancelled.\n *\n * @example\n *\n * - {@link showElement} with delay of 100 schedules `lisn-hide` -> `lisn-show`\n *   in 100ms\n * - then if {@link hideElementNow} is called, or a scheduled\n *   {@link hideElement} completes  before that timer runs out, this call to\n *   {@link showElement} aborts\n *\n * ```javascript\n * hideElement(someElement, 10);\n * // this will be aborted in 10ms when the scheduled hideElement above\n * // completes\n * showElement(someElement, 100);\n * ```\n *\n * ```javascript\n * // this will be aborted in 10ms when the hideElement that will be scheduled\n * // below completes\n * showElement(someElement, 100);\n * hideElement(someElement, 10);\n * ```\n *\n * ```javascript\n * // this will be aborted immediately by hideElementNow that runs straight\n * // afterwards\n * showElement(someElement, 100);\n * hideElementNow(someElement);\n * ```\n *\n * ```javascript\n * hideElementNow(someElement);\n * // this will NOT be aborted because hideElementNow has completed already\n * showElement(someElement, 100);\n * ```\n *\n * @category CSS: Altering (optimized)\n */\nexport const transitionElement = async (\n  element: Element,\n  fromCls: string,\n  toCls: string,\n  delay = 0,\n) => {\n  const thisTransition = scheduleCSSTransition(element, toCls);\n\n  if (delay) {\n    await waitForDelay(delay);\n  }\n\n  await waitForMutateTime();\n  if (thisTransition._isCancelled()) {\n    // it has been overridden by a later transition\n    return false;\n  }\n\n  const didChange = transitionElementNow(element, fromCls, toCls);\n  thisTransition._finish();\n\n  if (!didChange) {\n    return false;\n  }\n\n  // Await for the transition duration so that caller awaiting on us knows when\n  // it's complete.\n  const transitionDuration = await getMaxTransitionDuration(element);\n  if (transitionDuration) {\n    await waitForDelay(transitionDuration);\n  }\n\n  return true;\n};\n\n/**\n * Transitions an element from class `lisn-undisplay` (which applies `display:\n * none`) to `lisn-display` (no style associated with this).\n *\n * The difference between this and simply removing the `lisn-undisplay` class\n * is that previously scheduled transitions to `lisn-undisplay` will be\n * cancelled.\n *\n * @see {@link transitionElementNow}\n *\n * @category CSS: Altering\n */\nexport const displayElementNow = (element: Element) =>\n  transitionElementNow(element, MC.PREFIX_UNDISPLAY, MC.PREFIX_DISPLAY);\n\n/**\n * Like {@link displayElementNow} except it will {@link waitForMutateTime}, and\n * optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const displayElement = (element: Element, delay = 0) =>\n  transitionElement(element, MC.PREFIX_UNDISPLAY, MC.PREFIX_DISPLAY, delay);\n\n/**\n * The opposite of {@link displayElementNow}.\n *\n * @see {@link transitionElementNow}\n *\n * @category CSS: Altering\n */\nexport const undisplayElementNow = (element: Element) =>\n  transitionElementNow(element, MC.PREFIX_DISPLAY, MC.PREFIX_UNDISPLAY);\n\n/**\n * Like {@link undisplayElementNow} except it will {@link waitForMutateTime},\n * and optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const undisplayElement = (element: Element, delay = 0) =>\n  transitionElement(element, MC.PREFIX_DISPLAY, MC.PREFIX_UNDISPLAY, delay);\n\n/**\n * Transitions an element from class `lisn-hide` (which makes the element\n * hidden) to `lisn-show` (which shows it). These classes have CSS\n * transitions applied so the element is faded into and out of view.\n *\n * @see {@link transitionElementNow}.\n *\n * @category CSS: Altering\n */\nexport const showElementNow = (element: Element) =>\n  transitionElementNow(element, MC.PREFIX_HIDE, MC.PREFIX_SHOW);\n\n/**\n * Like {@link showElementNow} except it will {@link waitForMutateTime}, and\n * optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const showElement = (element: Element, delay = 0) =>\n  transitionElement(element, MC.PREFIX_HIDE, MC.PREFIX_SHOW, delay);\n\n/**\n * The opposite of {@link showElementNow}.\n *\n * @see {@link transitionElementNow}\n *\n * @category CSS: Altering\n */\nexport const hideElementNow = (element: Element) =>\n  transitionElementNow(element, MC.PREFIX_SHOW, MC.PREFIX_HIDE);\n\n/**\n * Like {@link hideElementNow} except it will {@link waitForMutateTime}, and\n * optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const hideElement = (element: Element, delay = 0) =>\n  transitionElement(element, MC.PREFIX_SHOW, MC.PREFIX_HIDE, delay);\n\n/**\n * If {@link isElementUndisplayed}, it will {@link displayElementNow},\n * otherwise it will {@link undisplayElementNow}.\n *\n * @see {@link transitionElementNow}\n *\n * @category CSS: Altering\n */\nexport const toggleDisplayElementNow = (element: Element) =>\n  isElementUndisplayed(element)\n    ? displayElementNow(element)\n    : undisplayElementNow(element);\n\n/**\n * Like {@link toggleDisplayElementNow} except it will {@link waitForMutateTime},\n * and optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const toggleDisplayElement = (element: Element, delay = 0) =>\n  isElementUndisplayed(element)\n    ? displayElement(element, delay)\n    : undisplayElement(element, delay);\n\n/**\n * If {@link isElementHidden}, it will {@link showElementNow}, otherwise\n * {@link hideElementNow}.\n *\n * @see {@link transitionElementNow}\n *\n * @category CSS: Altering\n */\nexport const toggleShowElementNow = (element: Element) =>\n  isElementHidden(element) ? showElementNow(element) : hideElementNow(element);\n\n/**\n * Like {@link toggleShowElementNow} except it will {@link waitForMutateTime}, and\n * optionally a delay.\n *\n * @see {@link transitionElement}\n *\n * @category CSS: Altering (optimized)\n */\nexport const toggleShowElement = (element: Element, delay = 0) =>\n  isElementHidden(element)\n    ? showElement(element, delay)\n    : hideElement(element, delay);\n\n/**\n * Returns true if the element's class list contains `lisn-hide`.\n *\n * @category CSS: Altering (optimized)\n */\nexport const isElementHidden = (element: Element) =>\n  hasClass(element, MC.PREFIX_HIDE);\n\n/**\n * Returns true if the element's class list contains `lisn-undisplay`.\n *\n * @category CSS: Altering (optimized)\n */\nexport const isElementUndisplayed = (element: Element) =>\n  hasClass(element, MC.PREFIX_UNDISPLAY);\n\n/**\n * Returns true if the element's class list contains the given class.\n *\n * @category CSS: Altering (optimized)\n */\nexport const hasClass = (el: Element, className: string) =>\n  MH.classList(el).contains(className);\n\n/**\n * Adds the given classes to the element.\n *\n * @category CSS: Altering\n */\nexport const addClassesNow = (el: Element, ...classNames: string[]) =>\n  MH.classList(el).add(...classNames);\n\n/**\n * Like {@link addClassesNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const addClasses = (el: Element, ...classNames: string[]) =>\n  waitForMutateTime().then(() => addClassesNow(el, ...classNames));\n\n/**\n * Removes the given classes to the element.\n *\n * @category CSS: Altering\n */\nexport const removeClassesNow = (el: Element, ...classNames: string[]) =>\n  MH.classList(el).remove(...classNames);\n\n/**\n * Like {@link removeClassesNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const removeClasses = (el: Element, ...classNames: string[]) =>\n  waitForMutateTime().then(() => removeClassesNow(el, ...classNames));\n\n/**\n * Toggles the given class on the element.\n *\n * @param {} force See {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/toggle | DOMTokenList:toggle}\n *\n * @category CSS: Altering\n */\nexport const toggleClassNow = (\n  el: Element,\n  className: string,\n  force?: boolean,\n) => MH.classList(el).toggle(className, force);\n\n/**\n * Like {@link toggleClassNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const toggleClass = (el: Element, className: string, force?: boolean) =>\n  waitForMutateTime().then(() => toggleClassNow(el, className, force));\n\n// For *Data: to avoid unnecessary type checking that ensures element is\n// HTMLElement or SVGElement, use getAttribute instead of dataset.\n\n/**\n * Returns the value of the given data attribute. The name of the attribute\n * must _not_ start with `data`. It can be in either camelCase or kebab-case,\n * it is converted as needed.\n *\n * @category CSS: Altering (optimized)\n */\nexport const getData = (el: Element, name: string) =>\n  MH.getAttr(el, MH.prefixData(name));\n\n/**\n * Returns the value of the given data attribute as a boolean. Its value is\n * expected to be either blank or \"true\" (which result in `true`), or \"false\"\n * (which results in `false`).\n *\n * The name of the attribute must _not_ start with `data`. It can be in either\n * camelCase or kebab-case, it is converted as needed.\n *\n * @category CSS: Altering (optimized)\n */\nexport const getBoolData = (el: Element, name: string) => {\n  const value = getData(el, name);\n  return value !== null && value !== \"false\";\n};\n\n/**\n * Sets the given data attribute.\n *\n * The name of the attribute must _not_ start with `data`. It can be in either\n * camelCase or kebab-case, it is converted as needed.\n *\n * @category CSS: Altering\n */\nexport const setDataNow = (el: Element, name: string, value: string) =>\n  MH.setAttr(el, MH.prefixData(name), value);\n\n/**\n * Like {@link setDataNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const setData = (el: Element, name: string, value: string) =>\n  waitForMutateTime().then(() => setDataNow(el, name, value));\n\n/**\n * Sets the given data attribute with value \"true\" (default) or \"false\".\n *\n * The name of the attribute must _not_ start with `data`. It can be in either\n * camelCase or kebab-case, it is converted as needed.\n *\n * @category CSS: Altering\n */\nexport const setBoolDataNow = (el: Element, name: string, value = true) =>\n  MH.setAttr(el, MH.prefixData(name), value + \"\");\n\n/**\n * Like {@link setBoolDataNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const setBoolData = (el: Element, name: string, value = true) =>\n  waitForMutateTime().then(() => setBoolDataNow(el, name, value));\n\n/**\n * Sets the given data attribute with value \"false\".\n *\n * The name of the attribute must _not_ start with `data`. It can be in either\n * camelCase or kebab-case, it is converted as needed.\n *\n * @category CSS: Altering\n */\nexport const unsetBoolDataNow = (el: Element, name: string) =>\n  MH.unsetAttr(el, MH.prefixData(name));\n\n/**\n * Like {@link unsetBoolDataNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const unsetBoolData = (el: Element, name: string) =>\n  waitForMutateTime().then(() => unsetBoolDataNow(el, name));\n\n/**\n * Deletes the given data attribute.\n *\n * The name of the attribute must _not_ start with `data`. It can be in either\n * camelCase or kebab-case, it is converted as needed.\n *\n * @category CSS: Altering\n */\nexport const delDataNow = (el: Element, name: string) =>\n  MH.delAttr(el, MH.prefixData(name));\n\n/**\n * Like {@link delDataNow} except it will {@link waitForMutateTime}.\n *\n * @category CSS: Altering (optimized)\n */\nexport const delData = (el: Element, name: string) =>\n  waitForMutateTime().then(() => delDataNow(el, name));\n\n/**\n * Returns the value of the given property from the computed style of the\n * element.\n *\n * @category DOM: Altering\n */\nexport const getComputedStylePropNow = (element: Element, prop: string) =>\n  getComputedStyle(element).getPropertyValue(prop);\n\n/**\n * Like {@link getComputedStylePropNow} except it will {@link waitForMeasureTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const getComputedStyleProp = (element: Element, prop: string) =>\n  waitForMeasureTime().then(() => getComputedStylePropNow(element, prop));\n\n/**\n * Returns the value of the given property from the inline style of the\n * element.\n *\n * @category DOM: Altering\n */\nexport const getStylePropNow = (element: Element, prop: string) =>\n  (element as DOMElement).style?.getPropertyValue(prop);\n\n/**\n * Like {@link getStylePropNow} except it will {@link waitForMeasureTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const getStyleProp = (element: Element, prop: string) =>\n  waitForMeasureTime().then(() => getStylePropNow(element, prop));\n\n/**\n * Sets the given property on the inline style of the element.\n *\n * @category DOM: Altering\n */\nexport const setStylePropNow = (\n  element: Element,\n  prop: string,\n  value: string,\n) => (element as DOMElement).style?.setProperty(prop, value);\n\n/**\n * Like {@link setStylePropNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const setStyleProp = (element: Element, prop: string, value: string) =>\n  waitForMutateTime().then(() => setStylePropNow(element, prop, value));\n\n/**\n * Deletes the given property on the inline style of the element.\n *\n * @category DOM: Altering\n */\nexport const delStylePropNow = (element: Element, prop: string) =>\n  (element as DOMElement).style?.removeProperty(prop);\n\n/**\n * Like {@link delStylePropNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const delStyleProp = (element: Element, prop: string) =>\n  waitForMutateTime().then(() => delStylePropNow(element, prop));\n\n/**\n * In milliseconds.\n *\n * @ignore\n * @internal\n */\nexport const getMaxTransitionDuration = async (element: Element) => {\n  const propVal = await getComputedStyleProp(element, \"transition-duration\");\n\n  return MH.max(\n    ...splitOn(propVal, \",\", true).map((strValue) => {\n      let duration = MH.parseFloat(strValue) || 0;\n\n      if (strValue === duration + \"s\") {\n        duration *= 1000;\n      }\n\n      return duration;\n    }),\n  );\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const disableInitialTransition = async (element: Element, delay = 0) => {\n  await addClasses(element, MC.PREFIX_TRANSITION_DISABLE);\n  if (delay) {\n    await waitForDelay(delay);\n  }\n\n  await waitForSubsequentMutateTime();\n  removeClassesNow(element, MC.PREFIX_TRANSITION_DISABLE);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const setHasModal = () => setBoolData(MH.getBody(), PREFIX_HAS_MODAL);\n\n/**\n * @ignore\n * @internal\n */\nexport const delHasModal = () => delData(MH.getBody(), PREFIX_HAS_MODAL);\n\n/**\n * @ignore\n * @internal\n */\nexport const copyStyle = async (\n  fromElement: Element,\n  toElement: Element,\n  includeComputedProps?: string[],\n) => {\n  if (!isDOMElement(fromElement) || !isDOMElement(toElement)) {\n    return;\n  }\n\n  await waitForMeasureTime();\n  const props: Record<string, string> = {};\n\n  if (includeComputedProps) {\n    for (const prop of includeComputedProps) {\n      props[prop] = getComputedStylePropNow(fromElement, prop);\n    }\n  }\n\n  const style = fromElement.style; // only inline styles\n  for (const prop in style) {\n    const value = style.getPropertyValue(prop);\n    if (value) {\n      props[prop] = value;\n    }\n  }\n\n  for (const prop in props) {\n    setStyleProp(toElement, prop, props[prop]);\n  }\n\n  addClasses(toElement, ...MH.classList(fromElement));\n};\n\n/**\n * If the props keys are in camelCase they are converted to kebab-case\n *\n * If a value is null or undefined, the property is deleted.\n *\n * @ignore\n * @internal\n */\nexport const setNumericStyleProps = async (\n  element: Element,\n  props: CssNumericProps,\n  options: {\n    _prefix?: string;\n    _units?: string;\n    _numDecimal?: number;\n    _transformFn?: (prop: string, currVal: number, newVal: number) => number;\n  } = {},\n) => {\n  if (!isDOMElement(element)) {\n    return;\n  }\n\n  const transformFn = options._transformFn;\n\n  const varPrefix = MH.prefixCssJsVar(options?._prefix || \"\");\n  for (const prop in props) {\n    const cssPropSuffix = camelToKebabCase(prop);\n    const varName = `${varPrefix}${cssPropSuffix}`;\n\n    let value: number | null;\n\n    if (!isValidNum(props[prop])) {\n      value = null;\n    } else {\n      value = props[prop];\n      const thisNumDecimal =\n        options?._numDecimal ?? (value > 0 && value < 1 ? 2 : 0);\n\n      if (transformFn) {\n        const currValue = MH.parseFloat(await getStyleProp(element, varName));\n\n        value = transformFn(prop, currValue || 0, value);\n      }\n\n      value = roundNumTo(value, thisNumDecimal);\n    }\n\n    if (value === null) {\n      delStyleProp(element, varName);\n    } else {\n      setStyleProp(element, varName, value + (options?._units || \"\"));\n    }\n  }\n};\n\n/**\n * @ignore\n * @internal\n */\ntype CssNumericProps = Record<string, number | undefined | null>;\n\n// ----------------------------------------\n\ntype CSSTransition = {\n  _cancel: () => undefined;\n  _finish: () => undefined;\n  _isCancelled: () => boolean;\n};\n\nconst PREFIX_HAS_MODAL = MH.prefixName(\"has-modal\");\n\nconst scheduledCSSTransitions = MH.newWeakMap<\n  Element,\n  Record<string, CSSTransition>\n>();\n\nconst cancelCSSTransitions = (element: Element, ...toClasses: string[]) => {\n  const scheduledTransitions = scheduledCSSTransitions.get(element);\n  if (!scheduledTransitions) {\n    return;\n  }\n\n  for (const toCls of toClasses) {\n    const scheduledTransition = scheduledTransitions[toCls];\n    if (scheduledTransition) {\n      scheduledTransition._cancel();\n    }\n  }\n};\n\nconst scheduleCSSTransition = (element: Element, toCls: string) => {\n  let scheduledTransitions = scheduledCSSTransitions.get(element);\n  if (!scheduledTransitions) {\n    scheduledTransitions = {};\n    scheduledCSSTransitions.set(element, scheduledTransitions);\n  }\n\n  let isCancelled = false;\n  scheduledTransitions[toCls] = {\n    _cancel: () => {\n      isCancelled = true;\n      MH.deleteObjKey(scheduledTransitions, toCls);\n    },\n    _finish: () => {\n      MH.deleteObjKey(scheduledTransitions, toCls);\n    },\n    _isCancelled: () => {\n      return isCancelled;\n    },\n  };\n\n  return scheduledTransitions[toCls];\n};\n","/**\n * @module Utils\n *\n * @categoryDescription DOM: Altering\n * These functions alter the DOM tree, but could lead to forced layout if not\n * scheduled using {@link waitForMutateTime}.\n *\n * @categoryDescription DOM: Altering (optimized)\n * These functions alter the DOM tree in an optimized way using\n * {@link waitForMutateTime} and so are asynchronous.\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  hideElement,\n  hasClass,\n  addClassesNow,\n  setDataNow,\n  setBoolData,\n} from \"@lisn/utils/css-alter\";\nimport { waitForMutateTime } from \"@lisn/utils/dom-optimize\";\nimport { isInlineTag } from \"@lisn/utils/dom-query\";\nimport { randId } from \"@lisn/utils/text\";\n\n/**\n * Wraps the element in the given wrapper, or a newly created element if not given.\n *\n * @param {} [options.wrapper]\n *              If it's an element, it is used as the wrapper. If it's a string\n *              tag name, then a new element with this tag is created as the\n *              wrapper. If not given, then `div` is used if the element to be\n *              wrapped has an block-display tag, or otherwise `span` (if the\n *              element to be wrapped has an inline tag name).\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              replacing the element (so as to not trigger relevant callbacks).\n * @returns {} The wrapper element that was either passed in options or created.\n *\n * @category DOM: Altering\n */\nexport const wrapElementNow = (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => {\n  const wrapper = createWrapperFor(element, options?.wrapper);\n\n  if (options?.ignoreMove === true) {\n    ignoreMove(element, {\n      from: MH.parentOf(element),\n      to: wrapper,\n    });\n\n    ignoreMove(wrapper, {\n      to: MH.parentOf(element),\n    });\n  }\n\n  element.replaceWith(wrapper);\n  wrapper.append(element);\n\n  return wrapper;\n};\n\n/**\n * Like {@link wrapElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const wrapElement = async (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => wrapElementNow(element, options));\n\n/**\n * Wraps the element's children in the given wrapper, or a newly created element\n * if not given.\n *\n * @see {@link wrapElementNow}.\n *\n * @category DOM: Altering\n */\nexport const wrapChildrenNow = (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => {\n  const wrapper = createWrapperFor(element, options?.wrapper);\n\n  moveChildrenNow(element, wrapper, { ignoreMove: true });\n  moveElementNow(wrapper, {\n    to: element,\n    ignoreMove: true,\n  });\n\n  return wrapper;\n};\n\n/**\n * Like {@link wrapChildrenNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const wrapChildren = async (\n  element: Element,\n  options?: {\n    wrapper?: HTMLElement | keyof HTMLElementTagNameMap;\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => wrapChildrenNow(element, options));\n\n/**\n * Replace an element with another one.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const replaceElementNow = (\n  element: Element,\n  newElement: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  if (options?.ignoreMove === true) {\n    ignoreMove(\n      // remove element\n      element,\n      { from: MH.parentOf(element) },\n    );\n\n    ignoreMove(\n      // move newElement to element's current parent\n      newElement,\n      { from: MH.parentOf(newElement), to: MH.parentOf(element) },\n    );\n  }\n\n  element.replaceWith(newElement);\n};\n\n/**\n * Like {@link replaceElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const replaceElement = async (\n  element: Element,\n  newElement: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() =>\n    replaceElementNow(element, newElement, options),\n  );\n\n/**\n * Replace an element with another one.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const swapElementsNow = (\n  elementA: Element,\n  elementB: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  const temp = MH.createElement(\"div\");\n  replaceElementNow(elementA, temp, options);\n  replaceElementNow(elementB, elementA, options);\n  replaceElementNow(temp, elementB, options);\n};\n\n/**\n * Like {@link swapElementsNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const swapElements = async (\n  elementA: Element,\n  elementB: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() => swapElementsNow(elementA, elementB, options));\n\n/**\n * Move an element's children to a new element\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              moving the children (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const moveChildrenNow = (\n  oldParent: Element,\n  newParent: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  if (options?.ignoreMove === true) {\n    for (const child of MH.childrenOf(oldParent)) {\n      ignoreMove(child, {\n        from: oldParent,\n        to: newParent,\n      });\n    }\n  }\n\n  newParent.append(...MH.childrenOf(oldParent));\n};\n\n/**\n * Like {@link moveChildrenNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const moveChildren = async (\n  oldParent: Element,\n  newParent: Element,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) =>\n  waitForMutateTime().then(() =>\n    moveChildrenNow(oldParent, newParent, options),\n  );\n\n/**\n * Moves an element to a new position.\n *\n * @param {} [options.to]         The new parent or sibling (depending on\n *                                `options.position`). If not given, the\n *                                element is removed from the DOM.\n * @param {} [options.position]   - append (default): append to `options.to`\n *                                - prepend: prepend to `options.to`\n *                                - before: insert before `options.to`\n *                                - after: insert after `options.to`\n * @param {} [options.ignoreMove] If true, the DOM watcher instances will\n *                                ignore the operation of moving the element\n *                                (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering\n */\nexport const moveElementNow = (\n  element: Element,\n  options?: {\n    to?: Element;\n    position?: \"append\" | \"prepend\" | \"before\" | \"after\";\n    ignoreMove?: boolean;\n  },\n) => {\n  let parentEl = options?.to || null;\n  const position = options?.position || \"append\";\n  if (position === \"before\" || position === \"after\") {\n    parentEl = MH.parentOf(options?.to);\n  }\n\n  if (options?.ignoreMove === true) {\n    ignoreMove(element, {\n      from: MH.parentOf(element),\n      to: parentEl,\n    });\n  }\n\n  if (options?.to) {\n    options.to[position](element);\n  } else {\n    MH.remove(element);\n  }\n};\n\n/**\n * Like {@link moveElementNow} except it will {@link waitForMutateTime}.\n *\n * @category DOM: Altering (optimized)\n */\nexport const moveElement = async (\n  element: Element,\n  options?: {\n    to?: Element;\n    position?: \"append\" | \"prepend\" | \"before\" | \"after\";\n    ignoreMove?: boolean;\n  },\n) => waitForMutateTime().then(() => moveElementNow(element, options));\n\n/**\n * It will {@link hideElement} and then remove it from the DOM.\n *\n * @param {} [options.ignoreMove]\n *              If true, the DOM watcher instances will ignore the operation of\n *              replacing the element (so as to not trigger relevant callbacks).\n *\n * @category DOM: Altering (optimized)\n */\nexport const hideAndRemoveElement = async (\n  element: Element,\n  delay = 0,\n  options?: {\n    ignoreMove?: boolean;\n  },\n) => {\n  await hideElement(element, delay);\n  moveElementNow(element, options);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getOrAssignID = (element: Element, prefix = \"\") => {\n  let domID = element.id;\n  if (!domID) {\n    domID = `${prefix}-${randId()}`;\n    element.id = domID;\n  }\n\n  return domID;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const wrapScrollingContent = async (element: Element) => {\n  await waitForMutateTime();\n\n  let wrapper: HTMLElement;\n  const firstChild = MH.childrenOf(element)[0];\n  if (\n    MH.lengthOf(MH.childrenOf(element)) === 1 &&\n    MH.isHTMLElement(firstChild) &&\n    hasClass(firstChild, PREFIX_CONTENT_WRAPPER)\n  ) {\n    // Another concurrent call has just wrapped it\n    wrapper = firstChild;\n  } else {\n    wrapper = wrapChildrenNow(element, { ignoreMove: true });\n    addClassesNow(wrapper, PREFIX_CONTENT_WRAPPER);\n  }\n\n  return wrapper;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const cloneElement = <E extends Element>(element: E) => {\n  const clone = element.cloneNode(true) as E;\n  setBoolData(clone, MH.prefixName(\"clone\"));\n  return clone;\n};\n\n/**\n * Creates a dummy hidden clone that's got animation and transitions disabled\n * and absolute position, wrapped in a wrapper (of size 0) and inserts it just\n * before the `insertBefore` element (or if not given, the original element),\n * so that the hidden clone overlaps the actual element's regular\n * (pre-transformed) position.\n *\n * It clears the ID of the clone.\n *\n * Returns the clone.\n *\n * @ignore\n * @internal\n */\nexport const insertGhostCloneNow = <E extends Element>(\n  element: E,\n  insertBefore: Element | null = null,\n) => {\n  const clone = cloneElement(element);\n  clone.id = \"\";\n\n  addClassesNow(\n    clone,\n    MC.PREFIX_GHOST,\n    MC.PREFIX_TRANSITION_DISABLE,\n    MC.PREFIX_ANIMATE_DISABLE,\n  );\n\n  const wrapper = wrapElementNow(clone);\n  addClassesNow(wrapper, MC.PREFIX_WRAPPER);\n\n  moveElementNow(wrapper, {\n    to: insertBefore || element,\n    position: \"before\",\n    ignoreMove: true,\n  });\n\n  return { _wrapper: wrapper, _clone: clone };\n};\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via DOMWatcher\n */\nexport const insertGhostClone = <E extends Element>(\n  element: E,\n  insertBefore: Element | null = null,\n) => waitForMutateTime().then(() => insertGhostCloneNow(element, insertBefore));\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via DOMWatcher\n */\nexport const ignoreMove = (\n  target: Element,\n  options: { from?: Element | null; to?: Element | null },\n) =>\n  recordsToSkipOnce.set(target, {\n    from: options.from || null,\n    to: options.to || null,\n  });\n\n/**\n * @ignore\n * @internal\n */\nexport const getIgnoreMove = (\n  target: Element,\n): { from: Element | null; to: Element | null } | null =>\n  recordsToSkipOnce.get(target) || null;\n\n/**\n * @ignore\n * @internal\n */\nexport const clearIgnoreMove = (target: Element) => {\n  // We should not clear the entry the first time the operation is observed\n  // (when we return true here), because there may be multiple DOMWatcher\n  // instances that will observe it and need to query it. Instead do it shortly.\n  MH.setTimer(() => {\n    MH.deleteKey(recordsToSkipOnce, target);\n  }, 100);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const insertArrow = (\n  target: Element,\n  direction: \"up\" | \"down\" | \"left\" | \"right\",\n  position: \"prepend\" | \"append\" | \"before\" | \"after\" = \"append\",\n  tag = \"span\",\n) => {\n  const arrow = MH.createElement(tag);\n  addClassesNow(arrow, MH.prefixName(MC.S_ARROW));\n  setDataNow(arrow, MH.prefixName(\"direction\"), direction);\n  moveElement(arrow, { to: target, position, ignoreMove: true });\n  return arrow;\n};\n\n// ----------------------------------------\n\nconst PREFIX_CONTENT_WRAPPER = MH.prefixName(\"content-wrapper\");\n\nconst recordsToSkipOnce = MH.newMap<\n  /* target being moved */ Element,\n  { from: Element | null; to: Element | null }\n>();\n\nconst createWrapperFor = (\n  element: Element,\n  wrapper: HTMLElement | keyof HTMLElementTagNameMap | undefined,\n) => {\n  if (MH.isElement(wrapper)) {\n    return wrapper;\n  }\n\n  let tag = wrapper;\n  if (!tag) {\n    if (isInlineTag(MH.tagName(element))) {\n      tag = \"span\";\n    } else {\n      tag = \"div\";\n    }\n  }\n\n  return MH.createElement(tag);\n};\n","/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { NonNullableReturnType } from \"@lisn/globals/types\";\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined`.\n *\n * The Promise is resolved with `checkFn`'s return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @param {} timeout If given, then if no such element is present after this\n *                    many milliseconds, the promise will resolve to `null`.\n *\n * @category DOM: Events\n */\nexport const waitForElement = <\n  F extends () => unknown,\n  T extends number | undefined = undefined,\n>(\n  checkFn: F,\n  timeout?: number,\n) =>\n  MH.newPromise<\n    T extends undefined\n      ? NonNullableReturnType<F>\n      : null | NonNullableReturnType<F>\n  >((resolve) => {\n    const callFn = () => {\n      const result = checkFn();\n      if (!MH.isNullish(result)) {\n        resolve(result as NonNullableReturnType<F>);\n        return true; // done\n      }\n      return false;\n    };\n\n    if (callFn()) {\n      return; // resolved already\n    }\n\n    if (!MH.isNullish(timeout)) {\n      MH.setTimer(() => {\n        resolve(\n          null as T extends undefined\n            ? NonNullableReturnType<F>\n            : null | NonNullableReturnType<F>,\n        );\n        observer.disconnect();\n      }, timeout);\n    }\n\n    const observer = MH.newMutationObserver(() => {\n      if (callFn()) {\n        observer.disconnect();\n      }\n    });\n\n    observer.observe(MH.getDocElement(), {\n      childList: true,\n      subtree: true,\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined` or the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * becomes \"interactive\".\n *\n * It always calls the given `checkFn` first before examining the `readyState`.\n *\n * If the `readyState` became interactive before the element was found, the\n * Promise resolves to `null`. Otherwise the Promise is resolved with `checkFn`'s\n * return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @category DOM: Events\n */\nexport const waitForElementOrInteractive = <F extends () => unknown>(\n  checkFn: F,\n) =>\n  MH.newPromise<NonNullableReturnType<F> | null>((resolve) => {\n    let isInteractive = false;\n    // Check element first, then readyState. The callback to waitForElement is\n    // run synchronously first time, so isInteractive will be false and checkFn\n    // will run.\n    waitForElement(() => isInteractive || checkFn()).then((res) => {\n      if (!isInteractive) {\n        resolve(res as NonNullableReturnType<F>);\n      } // else already resolved to null\n    });\n\n    waitForInteractive().then(() => {\n      isInteractive = true;\n      resolve(null);\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"interactive\" (or if it's already \"interactive\" or \"complete\", the\n * Promise is fulfilled immediately).\n *\n * @category DOM: Events\n */\nexport const waitForInteractive = () =>\n  MH.newPromise<void>((resolve) => {\n    const readyState = MH.getReadyState();\n    if (readyState === INTERACTIVE || readyState === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"DOMContentLoaded\", () => resolve());\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" (or if it's already \"complete\", the Promise is fulfilled\n * immediately).\n *\n * @category DOM: Events\n */\nexport const waitForComplete = () =>\n  MH.newPromise<void>((resolve) => {\n    if (MH.getReadyState() === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"readystatechange\", () => {\n      if (MH.getReadyState() === COMPLETE) {\n        resolve();\n      }\n    });\n  });\n\n/**\n * Returns a Promise that is resolved either when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" or the `readyState` is \"interactive\" and at least\n * {@link settings.pageLoadTimeout} milliseconds have passed (if > 0) since it\n * became \"interactive\".\n *\n * @category DOM: Events\n */\nexport const waitForPageReady = () =>\n  MH.newPromise<void>((resolve) => {\n    if (pageIsReady) {\n      resolve();\n      return;\n    }\n\n    return waitForInteractive().then(() => {\n      // Setup a listener for the complete state but wait at most\n      // <pageLoadTimeout> (if specified)\n      let timer: ReturnType<typeof setTimeout> | null = null;\n\n      const dispatchReady = () => {\n        pageIsReady = true;\n        if (timer) {\n          MH.clearTimer(timer);\n          timer = null;\n        }\n        resolve();\n      };\n\n      if (settings.pageLoadTimeout > 0) {\n        timer = MH.setTimer(() => {\n          dispatchReady();\n        }, settings.pageLoadTimeout);\n      }\n\n      waitForComplete().then(dispatchReady);\n    });\n  });\n\n/**\n * Returns true if the page is \"ready\". See {@link waitForPageReady}.\n *\n * @category DOM: Events\n */\nexport const isPageReady = () => pageIsReady;\n\n// --------------------\n\nconst COMPLETE = \"complete\";\nconst INTERACTIVE = \"interactive\";\n\nlet pageIsReady = false;\n\nif (!MH.hasDOM()) {\n  pageIsReady = true;\n} else {\n  waitForPageReady(); // ensure pageIsReady is set even if waitForPageReady is not called\n}\n","/**\n * @module Modules/XMap\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { MapBase } from \"@lisn/globals/types\";\n\nexport type DefaultValueGetter<K, V> = (key: K) => V;\nexport type IteratorCallback<K, V> = (\n  value: V,\n  key: K,\n  map: XMap<K, V>,\n) => void;\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newXMap = <K, V>(getDefaultV: DefaultValueGetter<K, V>) =>\n  new XMap(getDefaultV);\n\n/**\n * For minification optimization. Exposed through {@link XMap.newXMapGetter}.\n *\n * @ignore\n * @internal\n */\nexport const newXMapGetter =\n  <K, V>(getDefaultV: DefaultValueGetter<K, V>) =>\n  () =>\n    newXMap(getDefaultV);\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newXWeakMap = <K extends WeakKey, V>(\n  getDefaultV: DefaultValueGetter<K, V>,\n) => new XWeakMap(getDefaultV);\n\n/**\n * For minification optimization. Exposed through {@link XMap.newXWeakMapGetter}.\n *\n * @ignore\n * @internal\n */\nexport const newXWeakMapGetter =\n  <K extends WeakKey, V>(getDefaultV: DefaultValueGetter<K, V>) =>\n  () =>\n    newXWeakMap(getDefaultV);\n\nexport abstract class XMapBase<K, V> {\n  /**\n   * Returns the value at the given key in the {@link XMap} or {@link XWeakMap}.\n   */\n  readonly get: (key: K) => V | undefined;\n\n  /**\n   * Like {@link get} except that if the key is not found in the map, then it\n   * will set and return a default value by calling `getDefaultV` passed to the\n   * constructor.\n   */\n  readonly sGet: (key: K) => V;\n\n  /**\n   * Sets a value at the given key in the {@link XMap} or {@link XWeakMap}.\n   */\n  readonly set: (key: K, value: V) => void;\n\n  /**\n   * Deletes a value at the given key in the {@link XMap} or {@link XWeakMap}.\n   */\n  readonly delete: (key: K) => void;\n\n  /**\n   * Deletes empty keys in the {@link XMap} or {@link XWeakMap} starting at the\n   * final nested path and checking the level above after deletion.\n   *\n   * A key is considered empty if it's value is undefined or it's an empty Map,\n   * Set, Array, etc (anything with size or length property equal to 0).\n   */\n  readonly prune: (sk: K, ...rest: unknown[]) => void;\n\n  /**\n   * Returns true if the {@link XMap} or {@link XWeakMap} contains the given key.\n   */\n  readonly has: (key: K) => boolean;\n\n  protected constructor(\n    root: MapBase<K, V>,\n    getDefaultV: DefaultValueGetter<K, V>,\n  ) {\n    this.get = (key) => root.get(key);\n    this.set = (key, value) => root.set(key, value);\n    this.delete = (key) => MH.deleteKey(root, key);\n    this.has = (key) => root.has(key);\n\n    this.sGet = (key) => {\n      let result = root.get(key);\n      if (result === undefined) {\n        result = getDefaultV(key);\n        root.set(key, result);\n      }\n      return result;\n    };\n\n    this.prune = (sk, ...rest) => {\n      const value = root.get(sk);\n      if (value instanceof XMapBase && MH.lengthOf(rest)) {\n        value.prune(rest[0], ...rest.slice(1));\n      }\n\n      if (\n        value === undefined ||\n        (MH.isIterableObject(value) &&\n          !(\n            (\"size\" in value && value.size) ||\n            (\"length\" in value && value.length)\n          ))\n      ) {\n        MH.deleteKey(root, sk);\n      }\n    };\n  }\n}\n\n/**\n * {@link XMap} is like\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map},\n * except that it supports automatically creating missing entries with\n * {@link sGet} according to a default value getter function.\n *\n * @typeParam K  The type of the keys the map holds.\n * @typeParam V  The type of the values the map holds.\n */\nexport class XMap<K, V> extends XMapBase<K, V> implements Iterable<[K, V]> {\n  /**\n   * Returns the number of entries in the {@link XMap}.\n   */\n  readonly size!: number;\n\n  /**\n   * Deletes all entries in the {@link XMap}.\n   */\n  readonly clear: () => void;\n\n  /**\n   * Returns an iterator over the {@link XMap} entries.\n   */\n  readonly entries: () => MapIterator<[K, V]>;\n\n  /**\n   * Returns an iterator over the {@link XMap} keys.\n   */\n  readonly keys: () => MapIterator<K>;\n\n  /**\n   * Returns an iterator over the {@link XMap} values.\n   */\n  readonly values: () => MapIterator<V>;\n\n  readonly [Symbol.iterator]!: () => IterableIterator<[K, V]>;\n\n  /**\n   * Returns a function that when called returns a new {@link XMap}.\n   *\n   * You can pass this to the constructor of an {@link XMap} or an\n   * {@link XWeakMap}, whose values are {@link XMap}s.\n   */\n  static readonly newXMapGetter = newXMapGetter;\n\n  /**\n   * @param {} getDefaultV  This function is called each time\n   *                        {@link sGet} is called with a non-existent\n   *                        key and must return a value that is then set for\n   *                        that key and returned.\n   */\n  constructor(getDefaultV: DefaultValueGetter<K, V>) {\n    const root = MH.newMap<K, V>();\n    super(root, getDefaultV);\n\n    MH.defineProperty(this, \"size\", { get: () => root.size });\n    this.clear = () => root.clear();\n    this.entries = () => root.entries();\n    this.keys = () => root.keys();\n    this.values = () => root.values();\n    this[MC.SYMBOL.iterator] = () => root[MC.SYMBOL.iterator]();\n  }\n}\n\n/**\n * {@link XWeakMap} is like\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap | WeakMap},\n * except that it supports automatically creating missing entries with\n * with {@link sGet} according to a default value getter function.\n *\n * @typeParam K  The type of the keys the map holds.\n * @typeParam V  The type of the values the map holds.\n */\nexport class XWeakMap<K extends WeakKey, V> extends XMapBase<K, V> {\n  /**\n   * Returns a function that when called returns a new {@link XWeakMap}.\n   *\n   * You can pass this to the constructor of an {@link XMap} or an\n   * {@link XWeakMap}, whose values are {@link XWeakMap}s.\n   */\n  static readonly newXWeakMapGetter = newXWeakMapGetter;\n\n  /**\n   * @param {} getDefaultV  This function is called each time\n   *                        {@link sGet} is called with a non-existent\n   *                        key and must return a value that is then set for\n   *                        that key and returned.\n   */\n  constructor(getDefaultV: DefaultValueGetter<K, V>) {\n    const root = MH.newWeakMap<K, V>();\n    super(root, getDefaultV);\n  }\n}\n","/**\n * @module Watchers/DOMWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  MutationCategory,\n  CommaSeparatedStr,\n  AtLeastOne,\n} from \"@lisn/globals/types\";\n\nimport { DOM_CATEGORIES_SPACE } from \"@lisn/utils/dom\";\nimport {\n  getIgnoreMove,\n  clearIgnoreMove,\n  ignoreMove,\n} from \"@lisn/utils/dom-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { logError } from \"@lisn/utils/log\";\nimport { omitKeys } from \"@lisn/utils/misc\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap } from \"@lisn/modules/x-map\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link DOMWatcher} listens for changes do the DOM tree. It's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * It manages registered callbacks globally and reuses MutationObservers for\n * more efficient performance.\n *\n * Each instance of DOMWatcher manages up to two MutationObservers: one\n * for `childList` changes and one for attribute changes, and it disconnects\n * them when there are no active callbacks for the relevant type.\n *\n * `characterData` and changes to base\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Node | Node}s\n * (non-{@link https://developer.mozilla.org/en-US/docs/Web/API/Element | Element})\n * are not supported.\n */\nexport class DOMWatcher {\n  /**\n   * Call the given handler whenever there's a matching mutation within this\n   * DOMWatcher's {@link DOMWatcherConfig.root | root}.\n   *\n   * If {@link OnMutationOptions.skipInitial | options.skipInitial} is `false`\n   * (default), _and_ {@link OnMutationOptions.selector | options.selector} is\n   * given, _and_ {@link OnMutationOptions.categories | options.categories}\n   * includes \"added\", the handler is also called (almost) immediately with all\n   * existing elements matching the selector under this DOMWatcher's\n   * {@link DOMWatcherConfig.root | root}.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times, even if\n   * the options differ. If the handler has already been added, it is removed\n   * and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are not valid.\n   */\n  readonly onMutation: (\n    handler: OnMutationHandler,\n    options?: OnMutationOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offMutation: (handler: OnMutationHandler) => void;\n\n  /**\n   * Ignore an upcoming moving/adding/removing of an element.\n   *\n   * The operation must complete within the next cycle, by the time\n   * MutationObserver calls us.\n   *\n   * Use this to prevent this instance of DOMWatcher from calling any callbacks\n   * that listen for relevant changes as a result of this operation, to prevent\n   * loops for example.\n   *\n   * **IMPORTANT:**\n   *\n   * Ignoring moving of an element from a parent _inside_ this DOMWatcher's\n   * root to another parent that's _outside_ the root, will work as expected,\n   * even though the \"adding to the new parent\" mutation will not be observed.\n   * This is because the element's current parent at the time of the mutation\n   * callback can be examined.\n   *\n   * However if you want to ignore moving of an element _from a parent outside\n   * this DOMWatcher's root_ you need to specify from: null since the \"removal\n   * from the old parent\" mutation would not be observed and there's no way to\n   * examine it's previous parent at the time the \"adding to the new parent\"\n   * mutation is observed.\n   *\n   * For this reason, setting `options.from` to be an element that's not under\n   * the root is internally treated the same as `options.from: null`.\n   */\n  readonly ignoreMove: (target: Element, options: MoveOptions) => void;\n\n  /**\n   * Creates a new instance of DOMWatcher with the given\n   * {@link DOMWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: DOMWatcherConfig = {}) {\n    return new DOMWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of DOMWatcher with the given\n   * {@link DOMWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: DOMWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    const root = myConfig._root === MH.getBody() ? null : myConfig._root;\n    let instance = instances.get(root)?.get(configStrKey);\n    if (!instance) {\n      instance = new DOMWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: DOMWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"DOMWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"DOMWatcher\", logAtCreation: config })\n      : null;\n\n    const buffer = newXMap<Element, MutationOperationInternal>((t) => ({\n      _target: t,\n      _categoryBitmask: 0,\n      _attributes: MH.newSet(),\n      _addedTo: null,\n      _removedFrom: null,\n    }));\n\n    const allCallbacks = MH.newMap<\n      OnMutationHandler,\n      {\n        _callback: OnMutationCallback;\n        _options: OnMutationOptionsInternal;\n      }\n    >();\n\n    // ----------\n\n    let timer: ReturnType<typeof setTimeout> | null = null;\n    const mutationHandler = (records: MutationRecord[]) => {\n      debug: logger?.debug9(`Got ${records.length} new records`, records);\n\n      for (const record of records) {\n        const target = MH.targetOf(record);\n        const recType = record.type;\n\n        /* istanbul ignore next */\n        if (!MH.isElement(target)) {\n          continue;\n        }\n\n        if (recType === MC.S_CHILD_LIST) {\n          for (const child of record.addedNodes) {\n            if (MH.isElement(child)) {\n              const operation = buffer.sGet(child);\n              operation._addedTo = target;\n              operation._categoryBitmask |= ADDED_BIT;\n            }\n          }\n\n          for (const child of record.removedNodes) {\n            if (MH.isElement(child)) {\n              const operation = buffer.sGet(child);\n              operation._removedFrom = target;\n              operation._categoryBitmask |= REMOVED_BIT;\n            }\n          }\n\n          //\n        } else if (recType === MC.S_ATTRIBUTES && record.attributeName) {\n          const operation = buffer.sGet(target);\n          operation._attributes.add(record.attributeName);\n          operation._categoryBitmask |= ATTRIBUTE_BIT;\n        }\n      }\n\n      // Schedule flushing of the buffer asynchronously so that we can combine\n      // the records from the two MutationObservers.\n      if (!timer && MH.sizeOf(buffer)) {\n        timer = MH.setTimer(() => {\n          debug: logger?.debug9(`Processing ${buffer.size} operations`);\n          for (const operation of buffer.values()) {\n            if (shouldSkipOperation(operation)) {\n              debug: logger?.debug10(\"Skipping operation\", operation);\n            } else {\n              processOperation(operation);\n            }\n          }\n\n          buffer.clear();\n          timer = null;\n        }, 0);\n      }\n    };\n\n    const observers: Record<MutationType, MyObserver> = {\n      [MC.S_CHILD_LIST]: {\n        _observer: MH.newMutationObserver(mutationHandler),\n        _isActive: false,\n      },\n      [MC.S_ATTRIBUTES]: {\n        _observer: MH.newMutationObserver(mutationHandler),\n        _isActive: false,\n      },\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnMutationHandler,\n      options: OnMutationOptionsInternal,\n    ): OnMutationCallback => {\n      MH.remove(allCallbacks.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => deleteHandler(handler));\n\n      allCallbacks.set(handler, { _callback: callback, _options: options });\n      return callback;\n    };\n\n    // ----------\n\n    const setupOnMutation = async (\n      handler: OnMutationHandler,\n      userOptions: OnMutationOptions | undefined,\n    ) => {\n      const options = getOptions(userOptions || {});\n      const callback = createCallback(handler, options);\n\n      let root = config._root || MH.getBody();\n      if (!root) {\n        root = await waitForElement(MH.getBody);\n      } else {\n        // So that the call is always async\n        await null;\n      }\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      if (options._categoryBitmask & (ADDED_BIT | REMOVED_BIT)) {\n        activateObserver(root, MC.S_CHILD_LIST);\n      }\n\n      if (options._categoryBitmask & ATTRIBUTE_BIT) {\n        activateObserver(root, MC.S_ATTRIBUTES);\n      }\n\n      if (\n        userOptions?.skipInitial ||\n        !options._selector ||\n        !(options._categoryBitmask & ADDED_BIT)\n      ) {\n        return;\n      }\n\n      // As some of the matching elements that currently exist in the root may\n      // have just been added and therefore in the MutationObserver's queue, to\n      // avoid calling the handler with those entries twice, we empty its queue\n      // now and process it (which would also invoke the newly added callback).\n      // Then we skip any elements returned in querySelectorAll that were in\n      // the queue.\n\n      const childQueue = observers[MC.S_CHILD_LIST]._observer.takeRecords();\n      mutationHandler(childQueue);\n\n      for (const element of [\n        ...MH.querySelectorAll(root, options._selector),\n        ...(root.matches(options._selector) ? [root] : []),\n      ]) {\n        const initOperation: MutationOperationInternal = {\n          _target: element,\n          _categoryBitmask: ADDED_BIT,\n          _attributes: MH.newSet(),\n          _addedTo: MH.parentOf(element),\n          _removedFrom: null,\n        };\n\n        const bufferedOperation = buffer.get(element);\n        const diffOperation = getDiffOperation(\n          initOperation,\n          bufferedOperation,\n        );\n\n        if (diffOperation) {\n          if (shouldSkipOperation(diffOperation)) {\n            debug: logger?.debug10(\"Skipping operation\", diffOperation);\n          } else {\n            debug: logger?.debug5(\"Calling initially with\", diffOperation);\n            await invokeCallback(callback, diffOperation);\n          }\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (handler: OnMutationHandler) => {\n      MH.deleteKey(allCallbacks, handler);\n\n      let activeCategories = 0;\n      for (const entry of allCallbacks.values()) {\n        activeCategories |= entry._options._categoryBitmask;\n      }\n\n      if (!(activeCategories & (ADDED_BIT | REMOVED_BIT))) {\n        deactivateObserver(MC.S_CHILD_LIST);\n      }\n\n      if (!(activeCategories & ATTRIBUTE_BIT)) {\n        deactivateObserver(MC.S_ATTRIBUTES);\n      }\n    };\n\n    // ----------\n\n    const processOperation = (operation: MutationOperationInternal) => {\n      debug: logger?.debug10(\"Processing operation\", operation);\n\n      for (const entry of allCallbacks.values()) {\n        const categoryBitmask = entry._options._categoryBitmask;\n        const target = entry._options._target;\n        const selector = entry._options._selector;\n\n        if (!(operation._categoryBitmask & categoryBitmask)) {\n          debug: logger?.debug10(`Category does not match: ${categoryBitmask}`);\n          continue;\n        }\n\n        const currentTargets = [];\n        if (target) {\n          if (!operation._target.contains(target)) {\n            debug: logger?.debug10(\"Target does not match\", target);\n            continue;\n          }\n\n          currentTargets.push(target);\n        }\n\n        if (selector) {\n          const matches = [...MH.querySelectorAll(operation._target, selector)];\n\n          if (operation._target.matches(selector)) {\n            matches.push(operation._target);\n          }\n\n          if (!MH.lengthOf(matches)) {\n            debug: logger?.debug10(`Selector does not match: ${selector}`);\n            continue;\n          }\n\n          currentTargets.push(...matches);\n        }\n\n        invokeCallback(entry._callback, operation, currentTargets);\n      }\n    };\n\n    // ----------\n\n    const activateObserver = (root: Element, mutationType: MutationType) => {\n      if (!observers[mutationType]._isActive) {\n        debug: logger?.debug3(\n          `Activating mutation observer for '${mutationType}'`,\n        );\n        observers[mutationType]._observer.observe(root, {\n          [mutationType]: true,\n          subtree: config._subtree,\n        });\n        observers[mutationType]._isActive = true;\n      }\n    };\n\n    // ----------\n\n    const deactivateObserver = (mutationType: MutationType) => {\n      if (observers[mutationType]._isActive) {\n        debug: logger?.debug3(\n          `Disconnecting mutation observer for '${mutationType}'`,\n        );\n        observers[mutationType]._observer.disconnect();\n        observers[mutationType]._isActive = false;\n      }\n    };\n\n    // ----------\n\n    const shouldSkipOperation = (\n      operation: MutationOperationInternal,\n    ): boolean => {\n      const target = operation._target;\n      const requestToSkip = getIgnoreMove(target);\n      if (!requestToSkip) {\n        return false;\n      }\n\n      const removedFrom = operation._removedFrom;\n      const addedTo = MH.parentOf(target);\n      const requestFrom = requestToSkip.from;\n      const requestTo = requestToSkip.to;\n\n      const root = config._root || MH.getBody();\n      // If \"from\" is currently outside our root, we may not have seen a\n      // removal operation.\n      if (\n        (removedFrom === requestFrom || !root.contains(requestFrom)) &&\n        addedTo === requestTo\n      ) {\n        clearIgnoreMove(target);\n        return true;\n      }\n\n      return false;\n    };\n\n    // ----------\n\n    this.ignoreMove = ignoreMove;\n\n    // ----------\n\n    this.onMutation = setupOnMutation;\n\n    // ----------\n\n    this.offMutation = (handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type DOMWatcherConfig = {\n  /**\n   * The root element to observe for changes.\n   *\n   * It cannot be overridden on a per-callback basis.\n   *\n   * @defaultValue document.body\n   */\n  root?: Element | null;\n\n  /**\n   * Whether to observe root's subtree for changes or just direct descendants.\n   *\n   * It cannot be overridden on a per-callback basis.\n   *\n   * @defaultValue true\n   */\n  subtree?: boolean;\n};\n\n/**\n * @interface\n */\nexport type OnMutationOptions = {\n  /**\n   * If this is given, then the handler would only be called for operations\n   * where the target is _either_ the given element or an ancestor of it, i.e.\n   * it {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/contains | Node:contains} it.\n   *\n   * @defaultValue undefined\n   */\n  target?: Element;\n\n  /**\n   * If this is given, then the handler would only be called for operations\n   * where the target matches the given selector _or contains an element\n   * matching the given selector_.\n   *\n   * @defaultValue undefined\n   */\n  selector?: string;\n\n  /**\n   * Specifies a list of {@link MutationCategory}s to target for.\n   *\n   * If not given, then the handler is called for any of the supported\n   * mutations.\n   *\n   * It can be a comma-separated list of category names or an array of such\n   * names.\n   *\n   * @defaultValue undefined\n   */\n  categories?: CommaSeparatedStr<MutationCategory> | MutationCategory[];\n\n  /**\n   * Do not call the handler until there's a future matching mutation.\n   *\n   * By default, if `selector` is given, and `categories` includes `added`, we\n   * call the handler (almost) immediately with all elements matching selector\n   * relative to this DOMWatcher's root.\n   *\n   * The initial operation will contain just the element and\n   * `addedTo: <current parent>`.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\nexport type MoveOptions = AtLeastOne<{\n  /**\n   * If to is missing or null, it's a removal operation.\n   */\n  to: Element | null;\n\n  /**\n   * If from is missing or null, it's an insertion operation.\n   */\n  from: Element | null;\n}>;\n\nexport type MutationOperation = {\n  /**\n   * The target that was changed.\n   */\n  target: Element;\n\n  /**\n   * The target that the callback was interested in.\n   *\n   * If `selector` is given as part of {@link OnMutationOptions}, then\n   * `currentTarget` will point to the target that matched the selector\n   * starting at the operation's `target` as the root. If the operation's\n   * `target` contains more than one element matching selector, the callback\n   * will be called once for _each_ matching child.\n   *\n   * If `target` is given as part of {@link OnMutationOptions}, then\n   * `currentTarget` will be that element.\n   */\n  currentTarget: Element;\n\n  /**\n   * The list of attributes that were changed in this round.\n   */\n  attributes: Set<string>;\n\n  /**\n   * The element that the target was added to, i.e. it's new parent. It is null\n   * if the target was not moved to a new element _during this round_. It does\n   * not mean that this is its current parent.\n   */\n  addedTo: Element | null;\n\n  /**\n   * The element that the target was removed from, i.e. it's old parent. It is\n   * null if the target was not removed from a previous element _during this\n   * round_. It does not mean it did not previously have a parent, but that its\n   * removal was not observed.\n   */\n  removedFrom: Element | null;\n};\n\n/**\n * The handler is invoked with one argument:\n *\n * - a {@link MutationOperation} for a set of mutations related to a particular\n *   element\n *\n * The handler could be invoked multiple times in each \"round\" (cycle of event\n * loop) if there are mutation operations for more than one element that match\n * the supplied {@link OnMutationOptions}.\n */\nexport type OnMutationHandlerArgs = [MutationOperation];\nexport type OnMutationCallback = Callback<OnMutationHandlerArgs>;\nexport type OnMutationHandler =\n  | CallbackHandler<OnMutationHandlerArgs>\n  | OnMutationCallback;\n\n// ----------------------------------------\n\ntype DOMWatcherConfigInternal = {\n  _root: Element | null;\n  _subtree: boolean;\n};\n\ntype OnMutationOptionsInternal = {\n  _target: Element | null;\n  _selector: string;\n  _categoryBitmask: number;\n};\n\ntype MyObserver = {\n  _observer: MutationObserver;\n  _isActive: boolean;\n};\n\ntype MutationType = \"childList\" | \"attributes\";\n\ntype MutationOperationInternal = {\n  _target: Element;\n  _attributes: Set<string>;\n  _addedTo: Element | null;\n  _removedFrom: Element | null;\n  _categoryBitmask: number;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<Element | null, Map<string, DOMWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst getConfig = (config: DOMWatcherConfig): DOMWatcherConfigInternal => {\n  return {\n    _root: config.root || null,\n    _subtree: config.subtree ?? true,\n  };\n};\n\nconst CATEGORIES_BITS = DOM_CATEGORIES_SPACE.bit;\nconst ADDED_BIT = CATEGORIES_BITS[MC.S_ADDED];\nconst REMOVED_BIT = CATEGORIES_BITS[MC.S_REMOVED];\nconst ATTRIBUTE_BIT = CATEGORIES_BITS[MC.S_ATTRIBUTE];\n\n// ----------------------------------------\n\nconst getOptions = (options: OnMutationOptions): OnMutationOptionsInternal => {\n  let categoryBitmask = 0;\n  const categories = validateStrList(\n    \"categories\",\n    options.categories,\n    DOM_CATEGORIES_SPACE.has,\n  );\n\n  if (categories) {\n    for (const cat of categories) {\n      categoryBitmask |= CATEGORIES_BITS[cat];\n    }\n  } else {\n    categoryBitmask = DOM_CATEGORIES_SPACE.bitmask; // default: all\n  }\n\n  const selector = options.selector || \"\";\n  if (!MH.isString(selector)) {\n    throw MH.usageError(\"'selector' must be a string\");\n  }\n\n  return {\n    _categoryBitmask: categoryBitmask,\n    _target: options.target || null,\n    _selector: options.selector || \"\",\n  };\n};\n\nconst getDiffOperation = (\n  operationA: MutationOperationInternal,\n  operationB: MutationOperationInternal | undefined,\n): MutationOperationInternal | null => {\n  if (!operationB || operationA._target !== operationB._target) {\n    return operationA;\n  }\n\n  const attributes = MH.newSet<string>();\n  for (const attr of operationA._attributes) {\n    if (!operationB._attributes.has(attr)) {\n      attributes.add(attr);\n    }\n  }\n\n  const categoryBitmask =\n    operationA._categoryBitmask ^ operationB._categoryBitmask;\n\n  const addedTo =\n    operationA._addedTo === operationB._addedTo ? null : operationA._addedTo;\n\n  const removedFrom =\n    operationA._removedFrom === operationB._removedFrom\n      ? null\n      : operationA._removedFrom;\n\n  if (!MH.sizeOf(attributes) && !categoryBitmask && !addedTo && !removedFrom) {\n    return null;\n  }\n\n  return {\n    _target: operationA._target,\n    _categoryBitmask: categoryBitmask,\n    _attributes: attributes,\n    _addedTo: addedTo,\n    _removedFrom: removedFrom,\n  };\n};\n\nconst invokeCallback = (\n  callback: OnMutationCallback,\n  operation: MutationOperationInternal,\n  currentTargets: Element[] = [],\n) => {\n  if (!MH.lengthOf(currentTargets)) {\n    currentTargets = [operation._target];\n  }\n\n  for (const currentTarget of currentTargets) {\n    callback\n      .invoke({\n        target: operation._target,\n        currentTarget,\n        attributes: operation._attributes,\n        addedTo: operation._addedTo,\n        removedFrom: operation._removedFrom,\n      })\n      .catch(logError);\n  }\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  XYDirection,\n  ZDirection,\n  NoDirection,\n  AmbiguousDirection,\n  CommaSeparatedStr,\n  Vector,\n} from \"@lisn/globals/types\";\n\nimport { maxAbs, areParallel } from \"@lisn/utils/math\";\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\n/**\n * Returns the cardinal direction in the XY plane for the larger of the two\n * deltas (horizontal vs vertical).\n *\n * If both deltas are 0, returns \"none\".\n *\n * If both deltas are equal and non-0, returns \"ambiguous\".\n *\n * @category Directions\n */\nexport const getMaxDeltaDirection = (\n  deltaX: number,\n  deltaY: number,\n): XYDirection | NoDirection | AmbiguousDirection => {\n  if (!MH.abs(deltaX) && !MH.abs(deltaY)) {\n    return MC.S_NONE;\n  }\n\n  if (MH.abs(deltaX) === MH.abs(deltaY)) {\n    return MC.S_AMBIGUOUS;\n  }\n\n  if (MH.abs(deltaX) > MH.abs(deltaY)) {\n    return deltaX < 0 ? MC.S_LEFT : MC.S_RIGHT;\n  }\n  return deltaY < 0 ? MC.S_UP : MC.S_DOWN;\n};\n\n/**\n * Returns the approximate direction of the given 2D vector as one of the\n * cardinal (XY plane) ones: \"up\", \"down\", \"left\" or \"right\"; or \"ambiguous\".\n *\n * @param {} angleDiffThreshold  See {@link areParallel} or\n *                               {@link Utils.areAntiParallel | areAntiParallel}.\n *                               This determines whether the inferred direction\n *                               is ambiguous. For it to _not_ be ambiguous it\n *                               must align with one of the four cardinal\n *                               directions to within `angleDiffThreshold`.\n *                               It doesn't make sense for this value to be < 0\n *                               or >= 45 degrees. If it is, it's forced to be\n *                               positive (absolute) and <= 44.99.\n *\n * @category Directions\n */\nexport const getVectorDirection = (\n  vector: Vector,\n  angleDiffThreshold = 0,\n): XYDirection | AmbiguousDirection | NoDirection => {\n  angleDiffThreshold = MH.min(44.99, MH.abs(angleDiffThreshold));\n\n  if (!maxAbs(...vector)) {\n    return MC.S_NONE;\n  } else if (areParallel(vector, [1, 0], angleDiffThreshold)) {\n    return MC.S_RIGHT;\n  } else if (areParallel(vector, [0, 1], angleDiffThreshold)) {\n    return MC.S_DOWN;\n  } else if (areParallel(vector, [-1, 0], angleDiffThreshold)) {\n    return MC.S_LEFT;\n  } else if (areParallel(vector, [0, -1], angleDiffThreshold)) {\n    return MC.S_UP;\n  }\n\n  return MC.S_AMBIGUOUS;\n};\n\n/**\n * Returns the opposite direction to the given direction or null if the given\n * direction has no opposite.\n *\n * @example\n * ```javascript\n * getOppositeDirection(\"up\"); // -> \"down\"\n * getOppositeDirection(\"down\"); // -> \"up\"\n * getOppositeDirection(\"left\"); // -> \"right\"\n * getOppositeDirection(\"right\"); // -> \"left\"\n * getOppositeDirection(\"none\"); // -> null\n * getOppositeDirection(\"ambiguous\"); // -> null\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeDirection = (\n  direction: Direction,\n): Direction | null => {\n  if (!(direction in OPPOSITE_DIRECTIONS)) {\n    throw MH.usageError(\"Invalid 'direction'\");\n  }\n\n  return OPPOSITE_DIRECTIONS[direction];\n};\n\n/**\n * Returns the set of directions which are opposite to the given set of directions.\n *\n * There are two sets of opposite pairs (\"up\"/\"down\" and \"left\"/\"right\") and at\n * least one of the two opposing directions of a pair must be present for the\n * other one to be included. If both directions that constitute a pair of\n * opposites is given, then the other pair is returned instead (minus any that\n * are present in the input). See examples below for clarification.\n *\n * @example\n * ```javascript\n * getOppositeXYDirections(\"up\"); // -> [\"down\"]\n * getOppositeXYDirections(\"left\"); // -> [\"right\"]\n * getOppositeXYDirections(\"up,down\"); // -> [\"left\",\"right\"]\n * getOppositeXYDirections(\"up,left\"); // -> [\"down\",\"right\"]\n * getOppositeXYDirections(\"up,left,right\"); // -> [\"down\"]\n * getOppositeXYDirections(\"none\"); // -> throws\n * getOppositeXYDirections(\"ambiguous\"); // -> throws\n * getOppositeXYDirections(\"in\"); // -> throws\n * ```\n *\n * @category Directions\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid.\n */\nexport const getOppositeXYDirections = (\n  directions: CommaSeparatedStr<XYDirection> | XYDirection[],\n): XYDirection[] => {\n  const directionList = validateStrList(\n    \"directions\",\n    directions,\n    isValidXYDirection,\n  );\n\n  if (!directionList) {\n    throw MH.usageError(\"'directions' is required\");\n  }\n\n  const opposites: XYDirection[] = [];\n  for (const direction of directionList) {\n    const opposite = getOppositeDirection(direction);\n    if (\n      opposite &&\n      isValidXYDirection(opposite) &&\n      !MH.includes(directionList, opposite)\n    ) {\n      opposites.push(opposite);\n    }\n  }\n\n  if (!MH.lengthOf(opposites)) {\n    for (const direction of XY_DIRECTIONS) {\n      if (!MH.includes(directionList, direction)) {\n        opposites.push(direction);\n      }\n    }\n  }\n\n  return opposites;\n};\n\n/**\n * Returns true if the given direction is one of the known XY ones.\n *\n * @category Validation\n */\nexport const isValidXYDirection = (\n  direction: string,\n): direction is XYDirection => MH.includes(XY_DIRECTIONS, direction);\n\n/**\n * Returns true if the given direction is one of the known Z ones.\n *\n * @category Validation\n */\nexport const isValidZDirection = (direction: string): direction is ZDirection =>\n  MH.includes(Z_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string is a valid direction.\n *\n * @category Validation\n */\nexport const isValidDirection = (direction: string): direction is Direction =>\n  MH.includes(DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid directions.\n *\n * @category Validation\n */\nexport const isValidDirectionList = (\n  directions: string | string[],\n): directions is CommaSeparatedStr<Direction> | Direction[] =>\n  isValidStrList(directions, isValidDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const XY_DIRECTIONS = [\n  MC.S_UP,\n  MC.S_DOWN,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const Z_DIRECTIONS = [MC.S_IN, MC.S_OUT] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const SCROLL_DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const DIRECTIONS = [\n  ...XY_DIRECTIONS,\n  ...Z_DIRECTIONS,\n  MC.S_NONE,\n  MC.S_AMBIGUOUS,\n] as const;\n\n// --------------------\n\nconst OPPOSITE_DIRECTIONS = {\n  [MC.S_UP]: MC.S_DOWN,\n  [MC.S_DOWN]: MC.S_UP,\n  [MC.S_LEFT]: MC.S_RIGHT,\n  [MC.S_RIGHT]: MC.S_LEFT,\n  [MC.S_IN]: MC.S_OUT,\n  [MC.S_OUT]: MC.S_IN,\n  [MC.S_NONE]: null,\n  [MC.S_AMBIGUOUS]: null,\n} as const;\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { addClasses, removeClasses } from \"@lisn/utils/css-alter\";\nimport { copyExistingKeys } from \"@lisn/utils/misc\";\n\nimport { XMap, newXMapGetter, newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * Calls the given event listener, which could be a function that's callable\n * directly, or an object that has a `handleEvent` function property.\n *\n * @category Events: Generic\n */\nexport const callEventListener = (\n  handler: EventListenerOrEventListenerObject,\n  event: Event,\n) => {\n  if (MH.isFunction(handler)) {\n    handler.call(event.currentTarget || self, event);\n  } else {\n    handler.handleEvent.call(event.currentTarget || self, event);\n  }\n};\n\n/**\n * Adds an event listener for the given event name to the given target.\n *\n * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener | EventTarget:addEventListener}\n * but it handles `options` object in case the browser does not support those.\n * Does not support the `signal` option unless browser natively supports that.\n *\n * @return {} `true` if successfully added, or `false` if the same handler has\n * already been added by us, or if the handler is not a valid event listener.\n *\n * @category Events: Generic\n */\nexport const addEventListenerTo = (\n  target: EventTarget,\n  eventType: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions = {},\n): boolean => {\n  eventType = transformEventType(eventType);\n  if (getEventHandlerData(target, eventType, handler, options)) {\n    // already added\n    return false;\n  }\n\n  let thirdArg = options;\n  let wrappedHandler = handler;\n\n  // If the user passed an options object but the browser only supports a\n  // boolen for 'useCapture', then handle this.\n  const supports = getBrowserSupport();\n  if (MH.isNonPrimitive(options)) {\n    if (!supports._optionsArg) {\n      thirdArg = options.capture ?? false;\n    }\n\n    if (options.once && !supports._options.once) {\n      // Remove the handler once it's called once\n      wrappedHandler = (event) => {\n        removeEventListenerFrom(target, eventType, handler, options);\n        callEventListener(handler, event);\n      };\n    }\n  }\n\n  setEventHandlerData(target, eventType, handler, options, {\n    _wrappedHandler: wrappedHandler,\n    _thirdArg: thirdArg,\n  });\n\n  target.addEventListener(eventType, wrappedHandler, thirdArg);\n  return true;\n};\n\n/**\n * Removes an event listener that has been added using\n * {@link addEventListenerTo}.\n *\n * **IMPORTANT:** If you have added a listener using the built-in\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener | EventTarget:addEventListener},\n * then you should use\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener | EventTarget:removeEventListener},\n * to remove it, not this function.\n *\n * @return {} `true` if successfully removed, or `false` if the handler has not\n * been added by us.\n *\n * @category Events: Generic\n */\nexport const removeEventListenerFrom = (\n  target: EventTarget,\n  eventType: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions = {},\n) => {\n  eventType = transformEventType(eventType);\n  const data = getEventHandlerData(target, eventType, handler, options);\n\n  if (!data) {\n    return false;\n  }\n\n  target.removeEventListener(eventType, data._wrappedHandler, data._thirdArg);\n  deleteEventHandlerData(target, eventType, handler, options);\n  return true;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const preventSelect = (target: EventTarget) => {\n  addEventListenerTo(target, MC.S_SELECTSTART, MH.preventDefault);\n  if (MH.isElement(target)) {\n    addClasses(target, MC.PREFIX_NO_SELECT);\n  }\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const undoPreventSelect = (target: EventTarget) => {\n  removeEventListenerFrom(target, MC.S_SELECTSTART, MH.preventDefault);\n  if (MH.isElement(target)) {\n    removeClasses(target, MC.PREFIX_NO_SELECT);\n  }\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getBrowserSupport = (): BrowserEventSupport => {\n  if (browserEventSupport) {\n    // already detected\n    return browserEventSupport;\n  }\n\n  const supports = {\n    _pointer: false,\n    _optionsArg: false,\n    _options: {\n      capture: false,\n      passive: false,\n      once: false,\n      signal: false,\n    },\n  };\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#safely_detecting_option_support\n  const optTest = {};\n  let opt: keyof typeof supports._options;\n  for (opt in supports._options) {\n    const thisOpt = opt;\n    MH.defineProperty(optTest, thisOpt, {\n      get: () => {\n        supports._options[thisOpt] = true;\n        if (thisOpt === \"signal\") {\n          return new AbortController().signal;\n        }\n        return false;\n      },\n    });\n  }\n\n  const dummyHandler = () => {}; // TypeScript does not accept null\n  const dummyElement = MH.createElement(\"div\");\n  try {\n    dummyElement.addEventListener(\"testOptionSupport\", dummyHandler, optTest);\n    dummyElement.removeEventListener(\n      \"testOptionSupport\",\n      dummyHandler,\n      optTest,\n    );\n    supports._optionsArg = true;\n  } catch (e__ignored) {\n    //\n  }\n\n  supports._pointer = \"onpointerup\" in dummyElement;\n\n  browserEventSupport = supports;\n  return supports;\n};\n\n// --------------------\n\ntype EventHandlerData = {\n  _wrappedHandler: EventListenerOrEventListenerObject;\n  _thirdArg: boolean | AddEventListenerOptions;\n};\n\nlet browserEventSupport: BrowserEventSupport;\n\nconst registeredEventHandlerData = newXWeakMap<\n  EventTarget,\n  XMap<\n    string, // event type\n    XMap<\n      EventListenerOrEventListenerObject, // user-supplied handler\n      Map<\n        string, // str repr of options\n        EventHandlerData\n      >\n    >\n  >\n>(newXMapGetter(newXMapGetter(() => MH.newMap())));\n\n// detect browser features, see below\ntype BrowserEventSupport = {\n  _pointer: boolean;\n  _optionsArg: boolean;\n  _options: {\n    capture: boolean;\n    passive: boolean;\n    once: boolean;\n    signal: boolean;\n  };\n};\n\nconst getEventOptionsStr = (\n  options: boolean | AddEventListenerOptions,\n): string => {\n  const finalOptions: AddEventListenerOptions = {\n    capture: false,\n    passive: false,\n    once: false,\n  };\n\n  if (options === false || options === true) {\n    finalOptions.capture = options;\n  } else if (MH.isObject(options)) {\n    copyExistingKeys(options, finalOptions);\n  }\n\n  return MH.stringify(finalOptions);\n};\n\nconst getEventHandlerData = (\n  target: EventTarget,\n  eventType: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions,\n) => {\n  const optionsStr = getEventOptionsStr(options);\n  return registeredEventHandlerData\n    .get(target)\n    ?.get(eventType)\n    ?.get(handler)\n    ?.get(optionsStr);\n};\n\nconst deleteEventHandlerData = (\n  target: EventTarget,\n  eventType: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions,\n) => {\n  const optionsStr = getEventOptionsStr(options);\n  MH.deleteKey(\n    registeredEventHandlerData.get(target)?.get(eventType)?.get(handler),\n    optionsStr,\n  );\n  registeredEventHandlerData.prune(target, eventType, handler);\n};\n\nconst setEventHandlerData = (\n  target: EventTarget,\n  eventType: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions,\n  data: EventHandlerData,\n) => {\n  const optionsStr = getEventOptionsStr(options);\n  registeredEventHandlerData\n    .sGet(target)\n    .sGet(eventType)\n    .sGet(handler)\n    .set(optionsStr, data);\n};\n\nconst transformEventType = (eventType: string) => {\n  const supports = getBrowserSupport();\n  if (eventType.startsWith(MC.S_POINTER) && !supports._pointer) {\n    // TODO maybe log a warning message is it's not supported, e.g. there's no\n    // mousecancel\n    return MH.strReplace(eventType, MC.S_POINTER, MC.S_MOUSE);\n  }\n\n  return eventType;\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureDevice, GestureIntent } from \"@lisn/globals/types\";\n\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\n/**\n * `deltaX` and `deltaY` together specify the precise direction in the XY plane\n * of the move if relevant (i.e. other than zoom intent). The direction\n * specifies the effective X (\"left\"/\"right\"), Y (\"up\"/\"down\") or Z (\"in\"/\"out\")\n * direction, or \"none\"/\"ambiguous\".\n *\n * `deltaZ` specifies relative zoom in or out for zoom intents.\n * For zoom in, deltaZ is always > 1, and for zoom out it is < 1.\n * For non-zoom events it is 1.\n *\n * For zoom intents, `direction` would be either in, out or none.\n * For other intents, it would be up, down, left, right, none or ambiguous.\n *\n * For important notes on the delta values see\n * - {@link Utils.getKeyGestureFragment | getKeyGestureFragment}\n * - {@link Utils.getTouchGestureFragment | getTouchGestureFragment}\n * - {@link Utils.getWheelGestureFragment | getWheelGestureFragment}\n *\n * @category Gestures\n */\nexport type GestureFragment = {\n  device: GestureDevice;\n  direction: Direction;\n  intent: GestureIntent;\n  deltaX: number;\n  deltaY: number;\n  deltaZ: number;\n};\n\n/**\n * Returns true if the given string is a valid gesture device.\n *\n * @category Validation\n */\nexport const isValidInputDevice = (device: string): device is GestureDevice =>\n  MH.includes(DEVICES, device);\n\n/**\n * Returns true if the given string is a valid gesture intent.\n *\n * @category Validation\n */\nexport const isValidIntent = (intent: string): intent is GestureIntent =>\n  MH.includes(INTENTS, intent);\n\n/**\n * Returns true if the given string or array is a list of valid gesture\n * devices.\n *\n * @category Validation\n */\nexport const isValidInputDeviceList = (devices: string | string[]) =>\n  isValidStrList(devices, isValidInputDevice, false);\n\n/**\n * Returns true if the given string or array is a list of valid gesture\n * intents.\n *\n * @category Validation\n */\nexport const isValidIntentList = (intents: string | string[]) =>\n  isValidStrList(intents, isValidIntent, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const addDeltaZ = (current: number, increment: number) =>\n  MH.max(MIN_DELTA_Z, current * increment);\n\n/**\n * @ignore\n * @internal\n */\nexport const DEVICES: GestureDevice[] = [\n  MC.S_KEY,\n  MC.S_POINTER,\n  MC.S_TOUCH,\n  MC.S_WHEEL,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const INTENTS: GestureIntent[] = [\n  MC.S_SCROLL,\n  MC.S_ZOOM,\n  MC.S_DRAG,\n  MC.S_UNKNOWN,\n] as const;\n\n// Do not allow zooming out more than this value\nconst MIN_DELTA_Z = 0.1;\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { Direction, GestureIntent } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport { GestureFragment, addDeltaZ } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"keydown\"\n * events will be considered.\n *\n * If there are no \"keydown\" events in the given list of events, returns\n * `false`.\n *\n * The deltas of all events are summed together before determining final delta\n * and direction.\n *\n * If the events are of conflicting types, i.e. some scroll, some zoom, then\n * the intent will be \"unknown\" and the direction will be \"ambiguous\".\n *\n * Otherwise, if the deltas sum up to 0, the direction will be \"none\".\n *\n * **IMPORTANT NOTES ON THE DELTA VALUES**\n *\n * For key gestures the deltas are unreliable. You should not assume they\n * correspond to the would-be scroll or zoom amount that the browser would do.\n * But they can be used to determine relative amounts for animating, etc.\n *\n * Key press events can be divided into 3 categories: that scroll by a \"line\"\n * (e.g. arrow keys), by a \"page\" (e.g. PageUp/PageDown) or by the full content\n * height/width (e.g. Home/End). The actual scroll amount that _would_ result\n * from the event is dependent on the browser, the window size or the element's\n * scroll width/height, so ours can only be a best guess.\n *\n * Since the actual pixel equivalent is browser specific, we use reasonable\n * default values of delta for each of these \"line\", \"page\" or \"content\" modes,\n * similar to what\n * {@link Utils.getWheelGestureFragment | getWheelGestureFragment} does:\n * - For \"line\", then a configurable fixed value is used\n *  ({@link settings.deltaLineHeight}).\n * - For \"page\", then a configurable fixed value is used\n *  ({@link settings.deltaPageHeight}).\n * - For \"content\", the element's scroll height is used if given, otherwise\n *   the viewport height (same as \"page\"). We do not try to get the current\n *   scroll height of the target element, (which would be the best guess value\n *   of `deltaY` in case of Home/End key presses), as that would either involve\n *   an asynchronous action or would result in forced layout. If the caller is\n *   already tracking the scroll height of the target, you can pass this as an\n *   argument. Otherwise, we'll default to using the viewport height, same as\n *   for PageUp/Down.\n *\n * If the key gesture fragment is a result of multiple events that were\n * accumulated, the deltas are summed as usual, e.g. if a \"page\" is equal to 20\n * \"lines\", then pressing PageDown and then 10 times Up, would result in a\n * delta equal to 10 \"lines\" down.\n *\n * For zoom intents, `deltaZ` gives a relative change of scale, whereby each\n * press of + or - steps up by 15% or down by ~13% (`1 / 1.15` to be exact)\n * since the previous one.\n *\n * @param {} [options.angleDiffThreshold]\n *                                  See {@link getVectorDirection}\n * @param {} [options.scrollHeight] Use this as deltaY when Home/End is pressed\n *\n * @return {} `false` if there are no \"keydown\" events in the list, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getKeyGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n    scrollHeight?: number;\n  },\n): GestureFragment | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  const LINE = settings.deltaLineHeight;\n  const PAGE = settings.deltaPageHeight;\n  const CONTENT = options?.scrollHeight ?? PAGE;\n\n  const deltasUp = (amount: number): DeltasArr => [0, -amount, 1];\n  const deltasDown = (amount: number): DeltasArr => [0, amount, 1];\n  const deltasLeft = (amount: number): DeltasArr => [-amount, 0, 1];\n  const deltasRight = (amount: number): DeltasArr => [amount, 0, 1];\n  const deltasIn: DeltasArr = [0, 0, 1.15];\n  const deltasOut: DeltasArr = [0, 0, 1 / 1.15];\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent | null = null;\n  let deltaX = 0,\n    deltaY = 0,\n    deltaZ = 1;\n\n  for (const event of events) {\n    if (!MH.isKeyboardEvent(event) || event.type !== MC.S_KEYDOWN) {\n      continue;\n    }\n\n    const deltasForKey: Record<string, DeltasArr | null> = {\n      [SK_UP]: deltasUp(LINE),\n      [SK_ARROWUP]: deltasUp(LINE),\n      [SK_PAGEUP]: deltasUp(PAGE),\n      Home: deltasUp(CONTENT),\n      [SK_DOWN]: deltasDown(LINE),\n      [SK_ARROWDOWN]: deltasDown(LINE),\n      [SK_PAGEDOWN]: deltasDown(PAGE),\n      End: deltasDown(CONTENT),\n      [SK_LEFT]: deltasLeft(LINE),\n      [SK_ARROWLEFT]: deltasLeft(LINE),\n      [SK_RIGHT]: deltasRight(LINE),\n      [SK_ARROWRIGHT]: deltasRight(LINE),\n      \" \": (event.shiftKey ? deltasUp : deltasDown)(PAGE),\n      \"+\": deltasIn,\n      \"=\": event.ctrlKey ? deltasIn : null,\n      \"-\": deltasOut,\n    };\n\n    const theseDeltas = deltasForKey[event.key] || null;\n    if (!theseDeltas) {\n      // not a relevant key\n      continue;\n    }\n\n    const [thisDeltaX, thisDeltaY, thisDeltaZ] = theseDeltas;\n    const thisIntent = thisDeltaZ !== 1 ? MC.S_ZOOM : MC.S_SCROLL;\n\n    deltaX += thisDeltaX;\n    deltaY += thisDeltaY;\n    deltaZ = addDeltaZ(deltaZ, thisDeltaZ);\n\n    if (!intent) {\n      intent = thisIntent;\n    } else if (intent !== thisIntent) {\n      // mixture of zoom and scroll\n      intent = MC.S_UNKNOWN;\n    }\n  }\n\n  if (!intent) {\n    return false; // no relevant events\n  } else if (intent === MC.S_UNKNOWN) {\n    direction = MC.S_AMBIGUOUS;\n  } else if (intent === MC.S_ZOOM) {\n    direction = deltaZ > 1 ? MC.S_IN : deltaZ < 1 ? MC.S_OUT : MC.S_NONE;\n  } else {\n    direction = getVectorDirection(\n      [deltaX, deltaY],\n      options?.angleDiffThreshold,\n    );\n  }\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_KEY,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n      };\n};\n\n// --------------------\n\ntype DeltasArr = [number, number, number];\n\nconst SK_UP = \"Up\";\nconst SK_DOWN = \"Down\";\nconst SK_LEFT = \"Left\";\nconst SK_RIGHT = \"Right\";\nconst SK_PAGE = \"Page\";\nconst SK_ARROW = \"Arrow\";\nconst SK_PAGEUP = (SK_PAGE + SK_UP) as `${typeof SK_PAGE}${typeof SK_UP}`;\nconst SK_PAGEDOWN = (SK_PAGE + SK_DOWN) as `${typeof SK_PAGE}${typeof SK_DOWN}`;\nconst SK_ARROWUP = (SK_ARROW + SK_UP) as `${typeof SK_ARROW}${typeof SK_UP}`;\nconst SK_ARROWDOWN = (SK_ARROW +\n  SK_DOWN) as `${typeof SK_ARROW}${typeof SK_DOWN}`;\nconst SK_ARROWLEFT = (SK_ARROW +\n  SK_LEFT) as `${typeof SK_ARROW}${typeof SK_LEFT}`;\nconst SK_ARROWRIGHT = (SK_ARROW +\n  SK_RIGHT) as `${typeof SK_ARROW}${typeof SK_RIGHT}`;\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\nimport { getBrowserSupport } from \"@lisn/utils/event\";\nimport { GestureFragment } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. If the browser\n * supports Pointer events, then only \"pointermove\" events will be considered.\n * Otherwise, only \"mousemove\" events will be considered.\n *\n * If there are less than 2 such events in the given list of events, returns\n * `false`.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"pointercancel\" in the list or buttons other than the primary are pressed,\n * returns `null`.\n *\n * Pointer gestures always require the primary button to be pressed and the\n * resulting intent is always \"drag\", and `deltaZ` is always 1.\n *\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}\n *\n * @return {} `false` if there are less than 2 \"pointermove\"/\"mousemove\" events\n * in the list, `null` if the gesture is terminated, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getPointerGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let isCancelled = false;\n  const supports = getBrowserSupport();\n\n  // If the browser supports pointer events, then only take those; otherwise\n  // take the mouse events\n  const pointerEventClass = supports._pointer ? PointerEvent : MouseEvent;\n  const pointerUpType = supports._pointer ? MC.S_POINTERUP : MC.S_MOUSEUP;\n\n  const filteredEvents: MouseEvent[] = MH.filter(\n    events,\n    (event): event is MouseEvent => {\n      const eType = event.type;\n      isCancelled = isCancelled || eType === MC.S_POINTERCANCEL;\n      if (eType !== MC.S_CLICK && MH.isInstanceOf(event, pointerEventClass)) {\n        // Only events where the primary button is pressed (unless it's a\n        // pointerup event, in which case no buttons should be pressed) are\n        // considered, otherwise consider it terminated\n        isCancelled =\n          isCancelled ||\n          (eType === pointerUpType && event.buttons !== 0) ||\n          (eType !== pointerUpType && event.buttons !== 1);\n        // we don't handle touch pointer events\n        return !MH.isTouchPointerEvent(event);\n      }\n      return false;\n    },\n  );\n\n  const numEvents = MH.lengthOf(filteredEvents);\n  if (numEvents < 2) {\n    return false; // no enough events\n  }\n\n  if (isCancelled) {\n    return null; // terminated\n  }\n\n  const firstEvent = filteredEvents[0];\n  const lastEvent = filteredEvents[numEvents - 1];\n  if (MH.getPointerType(firstEvent) !== MH.getPointerType(lastEvent)) {\n    return null; // different devices, consider it terminated\n  }\n\n  const deltaX = lastEvent.clientX - firstEvent.clientX;\n  const deltaY = lastEvent.clientY - firstEvent.clientY;\n  const direction = getVectorDirection(\n    [deltaX, deltaY],\n    options?.angleDiffThreshold,\n  );\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_POINTER,\n        direction,\n        intent: MC.S_DRAG,\n        deltaX,\n        deltaY,\n        deltaZ: 1,\n      };\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureIntent, Vector } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport {\n  maxAbs,\n  havingMaxAbs,\n  distanceBetween,\n  areAntiParallel,\n} from \"@lisn/utils/math\";\nimport { GestureFragment } from \"@lisn/utils/gesture\";\n\nimport { newXMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Gestures\n */\nexport type TouchDiff = {\n  startX: number;\n  startY: number;\n\n  endX: number;\n  endY: number;\n\n  deltaX: number;\n  deltaY: number;\n\n  isSignificant: boolean;\n};\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"touchmove\" events\n * will be considered.\n *\n * If there are less than 2 such events in the given list of events, returns `false`.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"touchcancel\" in the list, returns `null`.\n *\n * Note that by default swipe actions follow the natural direction: swipe up\n * with scroll intent results in direction down and swipe down results in\n * direction up. Drag intent always follows the direction of the gesture.\n *\n * For zoom intents, which necessarily involves exactly two fingers `deltaZ`\n * is based on the relative change in distance between the fingers.\n *\n * @param {} [options.deltaThreshold]\n *                          A change of x or y coordinate less than this is\n *                          considered insignificant, for the purposes of\n *                          determining:\n *                          1) whether the inferred direction is in one of the\n *                             four cardinal ones, or otherwise ambiguous; and\n *                          2) whether more than two fingers have moved and\n *                             therefore whether the direction could be zoom or\n *                             not\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}\n * @param {} [options.reverseScroll]\n *                          If set to `true`, will disable natural scroll\n *                          direction.\n * @param {} [options.dragHoldTime]\n *                          If the user presses and holds for at least the\n *                          given amount of milliseconds before moving the\n *                          finger(s), gestures other than pinch will be\n *                          treated as a drag instead of scroll as long as the\n *                          number of fingers touching the screen is\n *                          `options.dragNumFingers`. Default is 500ms.\n * @param {} [options.dragNumFingers]\n *                          The number of fingers that could be considered a\n *                          drag intent. Default is 1.\n *\n * @return {} `false` if there are less than 2 \"touchmove\" events in the list,\n * `null` if the gesture is terminated, otherwise a {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getTouchGestureFragment = (\n  events: Event[],\n  options?: {\n    deltaThreshold?: number;\n    angleDiffThreshold?: number;\n    reverseScroll?: boolean;\n    dragHoldTime?: number;\n    dragNumFingers?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let moves = getTouchDiff(events, options?.deltaThreshold);\n\n  if (!moves) {\n    return null; // terminated\n  }\n\n  let numMoves = MH.lengthOf(moves);\n\n  const holdTime = getHoldTime(events);\n  const canBeDrag =\n    holdTime >= (options?.dragHoldTime ?? 500) &&\n    numMoves === (options?.dragNumFingers ?? 1);\n  const angleDiffThreshold = options?.angleDiffThreshold;\n\n  let deltaX = havingMaxAbs(...moves.map((m) => m.deltaX));\n  let deltaY = havingMaxAbs(...moves.map((m) => m.deltaY));\n  let deltaZ = 1;\n\n  if (numMoves > 2) {\n    // Take only the significant ones\n    moves = MH.filter(moves, (d) => d.isSignificant);\n    numMoves = MH.lengthOf(moves);\n  }\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent = MC.S_UNKNOWN;\n  if (numMoves === 2) {\n    // Check if it's a zoom\n    const vectorA: Vector = [moves[0].deltaX, moves[0].deltaY];\n    const vectorB: Vector = [moves[1].deltaX, moves[1].deltaY];\n\n    // If either finger is approx stationary, or if they move in opposite directions,\n    // treat it as zoom.\n    if (\n      !havingMaxAbs(...vectorA) || // finger A still\n      !havingMaxAbs(...vectorB) || // finger B still\n      areAntiParallel(vectorA, vectorB, angleDiffThreshold)\n    ) {\n      // It's a pinch motion => zoom\n      const startDistance = distanceBetween(\n        [moves[0].startX, moves[0].startY],\n        [moves[1].startX, moves[1].startY],\n      );\n\n      const endDistance = distanceBetween(\n        [moves[0].endX, moves[0].endY],\n        [moves[1].endX, moves[1].endY],\n      );\n\n      direction = startDistance < endDistance ? MC.S_IN : MC.S_OUT;\n      deltaZ = endDistance / startDistance;\n      deltaX = deltaY = 0;\n      intent = MC.S_ZOOM;\n    }\n  }\n\n  const deltaSign = canBeDrag || options?.reverseScroll ? 1 : -1;\n  // If scrolling, swap the deltas for natural scroll direction.\n  // Add +0 to force -0 to be +0 since jest doesn't think they're equal\n  deltaX = deltaSign * deltaX + 0;\n  deltaY = deltaSign * deltaY + 0;\n\n  if (direction === MC.S_NONE) {\n    // Wasn't a zoom. Check if all moves are aligned.\n    let isFirst = true;\n\n    for (const m of moves) {\n      // There's at least one significant move, assume scroll or drag intent.\n      intent = canBeDrag ? MC.S_DRAG : MC.S_SCROLL;\n\n      const thisDirection = getVectorDirection(\n        [deltaSign * m.deltaX, deltaSign * m.deltaY],\n        angleDiffThreshold,\n      );\n\n      if (thisDirection === MC.S_NONE) {\n        continue;\n      }\n\n      if (isFirst) {\n        direction = thisDirection;\n      } else if (direction !== thisDirection) {\n        direction = MC.S_AMBIGUOUS;\n        break;\n      }\n\n      isFirst = false;\n    }\n  }\n\n  if (direction === MC.S_NONE) {\n    const lastTouchEvent = events.filter(MH.isTouchEvent).slice(-1)[0];\n    // If all fingers have lifted off, consider it terminated, otherwise wait\n    // for more events.\n    return MH.lengthOf(lastTouchEvent?.touches) ? false : null;\n  }\n\n  return {\n    device: MC.S_TOUCH,\n    direction,\n    intent,\n    deltaX,\n    deltaY,\n    deltaZ,\n  };\n};\n\n/**\n * Returns a description of the changes in each finger between the first and\n * the last relevant TouchEvent in the list.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"touchcancel\" in the list, returns `null`.\n *\n * Note that, `deltaX`/`deltaY` are the end X/Y coordinate minus the start X/Y\n * coordinate. For natural scroll direction you should swap their signs.\n *\n * @param {} deltaThreshold If the change of x and y coordinate are both less\n *                          than this, it is marked as not significant.\n *\n * @category Gestures\n */\nexport const getTouchDiff = (\n  events: Event[],\n  deltaThreshold = 0,\n): TouchDiff[] | null => {\n  // Group each touch point of each event by identifier, so that we can get the\n  // start and end coordinate of each finger\n  const groupedTouches = newXMap<number, Touch[]>((): Touch[] => []);\n\n  for (const event of events) {\n    if (!MH.isTouchEvent(event)) {\n      continue;\n    }\n\n    if (event.type === MC.S_TOUCHCANCEL) {\n      return null; // gesture terminated\n    }\n\n    for (const touch of event.touches) {\n      groupedTouches.sGet(touch.identifier).push(touch);\n    }\n  }\n\n  const moves: TouchDiff[] = [];\n\n  for (const touchList of groupedTouches.values()) {\n    const nTouches = MH.lengthOf(touchList);\n    if (nTouches < 2) {\n      // Only one event had that finger in it, so there's no move for it\n      continue;\n    }\n\n    const firstTouch = touchList[0];\n    const lastTouch = touchList[nTouches - 1];\n    const startX = firstTouch.clientX;\n    const startY = firstTouch.clientY;\n\n    const endX = lastTouch.clientX;\n    const endY = lastTouch.clientY;\n\n    const deltaX = endX - startX;\n    const deltaY = endY - startY;\n\n    const isSignificant = maxAbs(deltaX, deltaY) >= deltaThreshold;\n\n    // Consider it a move in one of the 4 cardinal ones\n    moves.push({\n      startX,\n      startY,\n      endX,\n      endY,\n      deltaX,\n      deltaY,\n      isSignificant,\n    });\n  }\n\n  return moves;\n};\n\n// --------------------\n\nconst getHoldTime = (events: Event[]) => {\n  const firstStart = events.findIndex((e) => e.type === MC.S_TOUCHSTART);\n  const firstMove = events.findIndex((e) => e.type === MC.S_TOUCHMOVE);\n  if (firstStart < 0 || firstMove < 1) {\n    return 0;\n  }\n\n  return events[firstMove].timeStamp - events[firstStart].timeStamp;\n};\n","/**\n * @module\n * @ignore\n * @internal\n *\n * FULL CREDIT FOR THIS GOES TO\n * https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n *\n * ADAPTED FROM THE ABOVE SOURCE\n *\n * ORIGINAL COPYRIGHT IN FILE PRESERVED:\n *\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * ORIGINAL LICENSE\n *\n * BSD License\n *\n * For FixedDataTable software\n *\n * Copyright (c) 2015, Facebook, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name Facebook nor the names of its contributors may be used to\n *    endorse or promote products derived from this software without specific\n *    prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { settings } from \"@lisn/globals/settings\";\n\n/**\n * ORIGINAL DEVELOPER COMMENT PRESERVED\n *\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n */\nexport const normalizeWheel = (event: LegacyWheelEvent): WheelData => {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = event.deltaX,\n    pixelY = event.deltaY;\n\n  const LINE = settings.deltaLineHeight;\n\n  // Legacy\n  if (event.detail !== undefined) {\n    spinY = event.detail;\n  }\n  if (event.wheelDelta !== undefined) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if (event.wheelDeltaY !== undefined) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if (event.wheelDeltaX !== undefined) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // delta in LINE units\n      pixelX *= LINE;\n      pixelY *= LINE;\n    } else {\n      // delta in PAGE units\n      pixelX *= settings.deltaPageWidth;\n      pixelY *= settings.deltaPageHeight;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return { spinX, spinY, pixelX, pixelY };\n};\n\nexport type WheelData = {\n  spinX: number;\n  spinY: number;\n  pixelX: number;\n  pixelY: number;\n};\n\n// --------------------\n\ntype LegacyWheelEvent = WheelEvent & {\n  wheelDelta?: number;\n  wheelDeltaX?: number;\n  wheelDeltaY?: number;\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureIntent } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport { havingMaxAbs } from \"@lisn/utils/math\";\nimport { normalizeWheel } from \"@lisn/utils/normalize-wheel\";\n\nimport { GestureFragment, addDeltaZ } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"wheel\" events\n * will be considered.\n *\n * If there are no \"wheel\" events in the given list of events, returns `false`.\n *\n * The deltas of all events are summed together before determining final delta\n * and direction.\n *\n * If the events are of conflicting types, i.e. some scroll, some zoom, then\n * the intent will be \"unknown\" and the direction will be \"ambiguous\".\n *\n * If the deltas sum up to 0, the direction will be \"none\".\n *\n * **IMPORTANT NOTES ON THE DELTA VALUES**\n *\n * For wheel gestures the deltas are _highly_ unreliable, especially when\n * zooming (Control + wheel or pinching trackpad). You should not assume they\n * correspond to the would-be scroll or zoom amount that the browser would do.\n * But they can be used to determine relative amounts for animating, etc.\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"line\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaLineHeight | settings.deltaLineHeight}).\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"page\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaPageWidth | settings.deltaPageWidth} and\n * ({@link Settings.settings.deltaPageHeight | settings.deltaPageHeight}).\n *\n * For zoom intents `deltaZ` is based on what the browser reports as the\n * `deltaY`, which in most browsers roughly corresponds to a percentage zoom\n * factor.\n *\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}.\n *                                        Default is 5.\n *\n * @return {} `false` if there are no \"wheel\" events in the list, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getWheelGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent | null = null;\n  let deltaX = 0,\n    deltaY = 0,\n    deltaZ = 1;\n\n  for (const event of events) {\n    if (!MH.isWheelEvent(event) || event.type !== MC.S_WHEEL) {\n      continue;\n    }\n\n    const data = normalizeWheel(event);\n    let thisIntent: GestureIntent = MC.S_SCROLL;\n    let thisDeltaX = data.pixelX;\n    let thisDeltaY = data.pixelY;\n    let thisDeltaZ = 1;\n    const maxDelta = havingMaxAbs(thisDeltaX, thisDeltaY);\n\n    if (event.ctrlKey && !thisDeltaX) {\n      // Browsers report negative deltaY for zoom in, so swap sign\n      let percentage = -maxDelta;\n      // If it's more than 50, assume it's a mouse wheel => delta is roughly\n      // multiple of 10%. Otherwise a trackpad => delta is roughly multiple of 1%\n      if (MH.abs(percentage) >= 50) {\n        percentage /= 10;\n      }\n\n      thisDeltaZ = 1 + percentage / 100;\n\n      thisDeltaX = thisDeltaY = 0;\n      thisIntent = MC.S_ZOOM;\n    } else if (event.shiftKey && !thisDeltaX) {\n      // Holding Shift while turning wheel or swiping trackpad in vertically\n      // results in sideways scroll.\n      thisDeltaX = thisDeltaY;\n      thisDeltaY = 0;\n    }\n\n    deltaX += thisDeltaX;\n    deltaY += thisDeltaY;\n    deltaZ = addDeltaZ(deltaZ, thisDeltaZ);\n\n    if (!thisIntent) {\n      // not a relevant key\n    } else if (!intent) {\n      intent = thisIntent;\n    } else if (intent !== thisIntent) {\n      // mixture of zoom and scroll\n      intent = MC.S_UNKNOWN;\n    }\n  }\n\n  if (!intent) {\n    return false; // no relevant events\n  } else if (intent === MC.S_UNKNOWN) {\n    direction = MC.S_AMBIGUOUS;\n  } else if (intent === MC.S_ZOOM) {\n    direction = deltaZ > 1 ? MC.S_IN : deltaZ < 1 ? MC.S_OUT : MC.S_NONE;\n  } else {\n    direction = getVectorDirection(\n      [deltaX, deltaY],\n      options?.angleDiffThreshold,\n    );\n  }\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_WHEEL,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n      };\n};\n","/**\n * @module Watchers/GestureWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  GestureIntent,\n  GestureDevice,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport {\n  addClasses,\n  removeClasses,\n  setNumericStyleProps,\n} from \"@lisn/utils/css-alter\";\nimport { isValidDirection } from \"@lisn/utils/directions\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport { addDeltaZ } from \"@lisn/utils/gesture\";\n\nimport {\n  isValidInputDevice,\n  isValidIntent,\n  GestureFragment,\n  DEVICES,\n  INTENTS,\n} from \"@lisn/utils/gesture\";\nimport { getKeyGestureFragment } from \"@lisn/utils/gesture-key\";\nimport { getPointerGestureFragment } from \"@lisn/utils/gesture-pointer\";\nimport { getTouchGestureFragment } from \"@lisn/utils/gesture-touch\";\nimport { getWheelGestureFragment } from \"@lisn/utils/gesture-wheel\";\nimport { logError } from \"@lisn/utils/log\";\nimport {\n  maxAbs,\n  toNonNegNum,\n  toPosNum,\n  toNumWithBounds,\n} from \"@lisn/utils/math\";\nimport { randId, objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { LoggerInterface } from \"@lisn/debug/types\";\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link GestureWatcher} listens for user gestures resulting from wheel,\n * pointer, touch or key input events.\n *\n * It supports scroll, zoom or drag type gestures.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class GestureWatcher {\n  /**\n   * Call the given handler whenever the user performs a gesture on the target\n   * matching the given options.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, either using {@link onGesture} or\n   * {@link trackGesture}, then it will be removed and re-added with the\n   * current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onGesture: (\n    target: EventTarget,\n    handler: OnGestureHandler,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offGesture: (target: EventTarget, handler: OnGestureHandler) => void;\n\n  /**\n   * This is the same as {@link onGesture} except that if `handler` is not\n   * given, then it defaults to an internal handler that updates a set of CSS\n   * variables on the target's style:\n   *\n   *   - `--lisn-js--<Intent>-delta-x`\n   *   - `--lisn-js--<Intent>-delta-y`\n   *   - `--lisn-js--<Intent>-delta-z`\n   *\n   * where and `<Intent>` is one of {@link GestureIntent} and the delta X, Y\n   * and Z are the _total summed up_ `deltaX`, `deltaY` and `deltaZ` since the\n   * callback was added, summed over all devices used (key, touch, etc).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackGesture} or using\n   * {@link onGesture}, then it will be removed and re-added with the current\n   * options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackGesture}.\n   */\n  readonly noTrackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n  ) => void;\n\n  /**\n   * Creates a new instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: GestureWatcherConfig = {}) {\n    return new GestureWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: GestureWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new GestureWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: GestureWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"GestureWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"GestureWatcher\", logAtCreation: config })\n      : null;\n\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<\n        OnGestureHandler,\n        {\n          _callback: OnGestureCallback;\n          _wrapper: OnGestureHandlerWrapper;\n          _options: OnGestureOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    // For each target and event type, add only 1 global listener that will then\n    // manage the event queues and callbacks.\n    const allListeners = newXWeakMap<\n      EventTarget,\n      Map<GestureDevice, DeviceListeners>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ): OnGestureCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler for\", options);\n      const { _callback, _wrapper } = getCallbackAndWrapper(\n        handler,\n        options,\n        logger,\n      );\n\n      _callback.onRemove(() => deleteHandler(target, handler, options));\n\n      allCallbacks.sGet(target).set(handler, {\n        _callback,\n        _wrapper,\n        _options: options,\n      });\n\n      return _callback;\n    };\n\n    // ----------\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnGesture = async (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      userOptions: OnGestureOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions || {});\n      createCallback(target, handler, options);\n\n      for (const device of options._devices || DEVICES) {\n        let listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          debug: logger?.debug4(\n            `Listeners already added for ${device}`,\n            target,\n            options,\n          );\n        } else {\n          debug: logger?.debug4(\n            `Adding listeners for ${device}`,\n            target,\n            options,\n          );\n\n          listeners = setupListeners(target, device, options);\n          allListeners.sGet(target).set(device, listeners);\n        }\n\n        listeners._nCallbacks++;\n        if (options._preventDefault) {\n          listeners._nPreventDefault++;\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ) => {\n      MH.deleteKey(allCallbacks.get(target), handler);\n      allCallbacks.prune(target);\n\n      for (const device of options._devices || DEVICES) {\n        const listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          listeners._nCallbacks--;\n          if (options._preventDefault) {\n            listeners._nPreventDefault--;\n          }\n\n          if (!listeners._nCallbacks) {\n            debug: logger?.debug4(\n              `No more callbacks for target and device ${device}; removing listeners`,\n              target,\n            );\n\n            MH.deleteKey(allListeners.get(target), device);\n            listeners._remove();\n          }\n        }\n      }\n    };\n\n    // ----------\n\n    const invokeCallbacks = (\n      target: EventTarget,\n      device: GestureDevice,\n      event: Event,\n    ): boolean /* true if terminated */ => {\n      const preventDefault =\n        (allListeners.get(target)?.get(device)?._nPreventDefault || 0) > 0;\n\n      let isTerminated = false;\n      for (const { _wrapper } of allCallbacks.get(target)?.values() || []) {\n        isTerminated =\n          _wrapper(target, device, event, preventDefault) || isTerminated;\n      }\n\n      return isTerminated;\n    };\n\n    // ----------\n\n    const setupListeners = (\n      target: EventTarget,\n      device: GestureDevice,\n      options: OnGestureOptionsInternal,\n    ): DeviceListeners => {\n      const intents = options._intents;\n      let hasAddedTabIndex = false;\n      let hasPreventedSelect = false;\n\n      if (\n        device === MC.S_KEY &&\n        MH.isElement(target) &&\n        !MH.getTabIndex(target)\n      ) {\n        hasAddedTabIndex = true;\n        // enable element to receive keydown events\n        MH.setTabIndex(target);\n      } else if (MH.isElement(target) && device === MC.S_TOUCH) {\n        if (options._preventDefault) {\n          addClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n        }\n\n        if (!intents || MH.includes(intents, MC.S_DRAG)) {\n          hasPreventedSelect = true;\n          preventSelect(target);\n        }\n      }\n\n      const addOrRemoveListeners = (\n        action: \"add\" | \"remove\",\n        listener: EventListener,\n        eventTypes: readonly (keyof GlobalEventHandlersEventMap)[],\n      ) => {\n        const method =\n          action === \"add\" ? addEventListenerTo : removeEventListenerFrom;\n        for (const eventType of eventTypes) {\n          debug: logger?.debug8(`${action} listener for ${eventType}`, target);\n          method(target, eventType, listener, {\n            passive: false,\n            capture: true,\n          });\n        }\n      };\n\n      const addInitialListener = () =>\n        addOrRemoveListeners(\"add\", initialListener, initiatingEvents[device]);\n\n      const removeInitialListener = () =>\n        addOrRemoveListeners(\n          \"remove\",\n          initialListener,\n          initiatingEvents[device],\n        );\n\n      const addOngoingListener = () =>\n        addOrRemoveListeners(\"add\", processEvent, ongoingEvents[device]);\n\n      const removeOngoingListener = () =>\n        addOrRemoveListeners(\"remove\", processEvent, ongoingEvents[device]);\n\n      const initialListener = (event: Event) => {\n        processEvent(event);\n        removeInitialListener();\n        addOngoingListener();\n      };\n\n      const processEvent = (event: Event) => {\n        const isTerminated = invokeCallbacks(target, device, event);\n        if (isTerminated) {\n          removeOngoingListener();\n          addInitialListener();\n        }\n      };\n\n      addInitialListener();\n\n      return {\n        _nCallbacks: 0,\n        _nPreventDefault: 0,\n        _remove: () => {\n          if (MH.isElement(target)) {\n            if (hasAddedTabIndex) {\n              MH.unsetTabIndex(target);\n            }\n\n            removeClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n\n            if (hasPreventedSelect) {\n              undoPreventSelect(target);\n            }\n          }\n\n          removeOngoingListener();\n          removeInitialListener();\n        },\n      };\n    };\n\n    // ----------\n\n    this.trackGesture = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n        // initial values\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, {\n            intent,\n            totalDeltaX: 0,\n            totalDeltaY: 0,\n            totalDeltaZ: 1,\n          });\n        }\n      }\n\n      return setupOnGesture(element, handler, options);\n    };\n\n    // ----------\n\n    this.noTrackGesture = (element, handler?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n\n        // delete the properties\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, { intent });\n        }\n      }\n\n      this.offGesture(element, handler);\n    };\n\n    // ----------\n\n    this.onGesture = setupOnGesture;\n\n    // ----------\n\n    this.offGesture = (target, handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type GestureWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnGestureOptions.preventDefault | preventDefault} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.debounceWindow | debounceWindow} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 150\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.deltaThreshold | deltaThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 5\n   */\n  deltaThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.angleDiffThreshold | angleDiffThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * It does not make much sense to set this to 0.\n   *\n   * The value is in _degrees_, not radians.\n   *\n   * @defaultValue 35\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.naturalTouchScroll | naturalTouchScroll} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragHoldTime | touchDragHoldTime} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 500\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragNumFingers | touchDragNumFingers} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 1\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * @interface\n */\nexport type OnGestureOptions = {\n  /**\n   * One or more device types to listen for. If not specified, then all devices\n   * are enabled.\n   *\n   * It can be a comma-separated list of {@link GestureDevice}s or an array of\n   * such devices.\n   *\n   * @defaultValue undefined\n   */\n  devices?: CommaSeparatedStr<GestureDevice> | GestureDevice[];\n\n  /**\n   * If given, callback will only be called if the gesture's direction is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link Direction}s or an array of such\n   * directions.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<Direction> | Direction[];\n\n  /**\n   * If given, callback will only be called if the gesture's intent is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link GestureIntent}s or an\n   * array of such intents.\n   *\n   * @defaultValue undefined\n   */\n  intents?: CommaSeparatedStr<GestureIntent> | GestureIntent[];\n\n  /**\n   * Set minimum total delta X. Further reductions in delta X below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaX?: number;\n\n  /**\n   * Set maximum total delta X. Further increase in delta X above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaX?: number;\n\n  /**\n   * Set minimum total delta Y. Further reductions in delta Y below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaY?: number;\n\n  /**\n   * Set maximum total delta Y. Further increase in delta Y above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaY?: number;\n\n  /**\n   * Set minimum total delta Z. Further reductions in delta Z below this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and can be less than 1 but\n   * must be > 0.1 which is a hard minimum.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaZ?: number;\n\n  /**\n   * Set maximum total delta Z. Further increase in delta Z above this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and must be positive.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaZ?: number;\n\n  /**\n   * If true, the events of the gesture, e.g. relevant key presses or touch\n   * moves, etc, will have their default action prevented.\n   *\n   * **IMPORTANT:** For pointer gestures, then pointer/mouse down and click\n   * will be prevented.\n   *\n   * @defaultValue {@link GestureWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If given, callback will be called at most once every `debounceWindow`\n   * milliseconds.\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n\n  /**\n   * Callback will only be called when the gesture's accumulated delta, since\n   * the last time callback was called, exceeds `deltaThreshold`.\n   *\n   * At least one of the three deltas (X, Y or Z) must exceed this number (in\n   * absolute value). Note that when comparing `deltaZ`, it is multiplied by\n   * 100 since it represents fractions of 1 (100%). So supplying\n   * `deltaThreshold` of 10 means is equivalent to the following condition:\n   *\n   * ```\n   * abs(deltaX) >= 10 || abs(deltaY) >= 10 ||  abs(1 - deltaZ) >= 0.1\n   * ```\n   *\n   * Accumulation of the delta ends if the gesture is terminated, for example,\n   * in case of touch gestures, by a \"touchcancel\" event of by the final finger\n   * lifting off..\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.deltaThreshold}\n   */\n  deltaThreshold?: number;\n\n  /**\n   * See {@link Utils.getVectorDirection | getVectorDirection}.\n   *\n   * @defaultValue {@link GestureWatcherConfig.angleDiffThreshold}\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * Whether touch scroll gestures follow the natural direction: swipe up\n   * with scroll intent results in direction down and swipe down results in\n   * direction up.\n   *\n   * @defaultValue {@link GestureWatcherConfig.naturalTouchScroll}\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * If the user presses and holds on a touchscreen for at least the given\n   * amount of milliseconds before moving the finger(s), touch gestures other\n   * than pinch will be treated as a drag intent instead of scroll as long as\n   * the number of fingers touching the screen is {@link touchDragNumFingers}.\n   *\n   * Set to 0 in order to treat _all_ non-pinch touch gestures as drag.\n   *\n   * Set to a negative number in order to treat _all_ non-pinch touch gestures\n   * as scroll.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The number of fingers that could be considered a drag intent for touch\n   * gestures.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link GestureWatcher.onGesture}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link GestureData} that describes the gesture's progression since the\n *   last time the callback was called and since the callback was added.\n */\nexport type OnGestureHandlerArgs = [EventTarget, GestureData, Event[]];\nexport type OnGestureCallback = Callback<OnGestureHandlerArgs>;\nexport type OnGestureHandler =\n  | CallbackHandler<OnGestureHandlerArgs>\n  | OnGestureCallback;\n\nexport type GestureData = {\n  device: GestureDevice;\n  direction: Direction;\n  intent: GestureIntent;\n\n  /**\n   * Delta in the horizontal direction since the start of the gesture.\n   */\n  deltaX: number;\n\n  /**\n   * Delta in the vertical direction since the start of the gesture.\n   */\n  deltaY: number;\n\n  /**\n   * Relative fractional zoom in or out for zoom intents since the start of\n   * the gesture.\n   *\n   * For zoom in, `deltaZ` is always > 1, and for zoom out it is < 1.\n   *\n   * For non-zoom gestures it is 1.\n   */\n  deltaZ: number;\n\n  /**\n   * The time in milliseconds it took for the gesture. This will be the\n   * difference in timestamps between the first and last event that composed\n   * the gesture. For key and wheel gestures this could be 0, since 1 event is\n   * sufficient for them.\n   */\n  time: number;\n\n  /**\n   * Delta in the horizontal direction since the callback was added.\n   */\n  totalDeltaX: number;\n\n  /**\n   * Delta in the vertical direction since the callback was added.\n   */\n  totalDeltaY: number;\n\n  /**\n   * Percentage (relative) zoom in or out for zoom intents since the callback\n   * was added.\n   */\n  totalDeltaZ: number;\n};\n\n// ----------------------------------------\n\ntype GestureWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureOptionsInternal = {\n  _devices: GestureDevice[] | null;\n  _directions: Direction[] | null;\n  _intents: GestureIntent[] | null;\n  _minTotalDeltaX: number | null;\n  _maxTotalDeltaX: number | null;\n  _minTotalDeltaY: number | null;\n  _maxTotalDeltaY: number | null;\n  _minTotalDeltaZ: number | null;\n  _maxTotalDeltaZ: number | null;\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureHandlerWrapper = (\n  _target: EventTarget,\n  _device: GestureDevice,\n  _event: Event,\n  _preventDefault: boolean,\n) => boolean;\n\n// Specific to a combination of target + device\ntype DeviceListeners = {\n  _nCallbacks: number; // total number of callbacks\n  _nPreventDefault: number; // total number wanting to prevent default action\n  _remove: () => void;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, GestureWatcher>();\n\nconst getConfig = (\n  config: GestureWatcherConfig,\n): GestureWatcherConfigInternal => {\n  return {\n    _preventDefault: config.preventDefault ?? true,\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 150),\n    _deltaThreshold: toNonNegNum(config.deltaThreshold, 5),\n    _angleDiffThreshold: toPosNum(config.angleDiffThreshold, 35),\n    _naturalTouchScroll: config.naturalTouchScroll ?? true,\n    _touchDragHoldTime: config.touchDragHoldTime ?? 500,\n    _touchDragNumFingers: config.touchDragNumFingers ?? 1,\n  };\n};\n\nconst initiatingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform it into mousedown\n  //\n  // We need to listen for click, since that occurs after a pointerup (i.e.\n  // after a gesure is terminated and the ongoing listeners removed), but it\n  // needs to have its default action prevented.\n  pointer: [MC.S_POINTERDOWN, MC.S_CLICK],\n  touch: [MC.S_TOUCHSTART],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst ongoingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  pointer: [\n    // If the browser doesn't support point events, then\n    // addEventListenerTo will transform them into mouse*\n    MC.S_POINTERDOWN,\n    MC.S_POINTERUP, // would terminate\n    MC.S_POINTERMOVE,\n    MC.S_POINTERCANCEL, // would terminate\n    MC.S_CLICK, // would terminate; can be default-prevented\n  ],\n  touch: [MC.S_TOUCHSTART, MC.S_TOUCHEND, MC.S_TOUCHMOVE, MC.S_TOUCHCANCEL],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst fragmentGetters: {\n  [D in GestureDevice]: (\n    events: Event[],\n    options: {\n      deltaThreshold?: number;\n      angleDiffThreshold?: number;\n      reverseScroll?: boolean;\n      dragHoldTime?: number;\n      dragNumFingers?: number;\n    },\n  ) => GestureFragment | null | false;\n} = {\n  [MC.S_KEY]: getKeyGestureFragment,\n  [MC.S_POINTER]: getPointerGestureFragment,\n  [MC.S_TOUCH]: getTouchGestureFragment,\n  [MC.S_WHEEL]: getWheelGestureFragment,\n};\n\nconst getOptions = (\n  config: GestureWatcherConfigInternal,\n  options: OnGestureOptions,\n): OnGestureOptionsInternal => {\n  const debounceWindow = toNonNegNum(\n    options[MC.S_DEBOUNCE_WINDOW],\n    config._debounceWindow, // watcher is never debounced, so apply default here\n  );\n  const deltaThreshold = toNonNegNum(\n    options.deltaThreshold,\n    config._deltaThreshold,\n  );\n\n  return {\n    _devices:\n      validateStrList(\"devices\", options.devices, isValidInputDevice) || null,\n    _directions:\n      validateStrList(\"directions\", options.directions, isValidDirection) ||\n      null,\n    _intents:\n      validateStrList(\"intents\", options.intents, isValidIntent) || null,\n    _minTotalDeltaX: options.minTotalDeltaX ?? null,\n    _maxTotalDeltaX: options.maxTotalDeltaX ?? null,\n    _minTotalDeltaY: options.minTotalDeltaY ?? null,\n    _maxTotalDeltaY: options.maxTotalDeltaY ?? null,\n    _minTotalDeltaZ: options.minTotalDeltaZ ?? null,\n    _maxTotalDeltaZ: options.maxTotalDeltaZ ?? null,\n    _preventDefault: options.preventDefault ?? config._preventDefault,\n    _debounceWindow: debounceWindow,\n    _deltaThreshold: deltaThreshold,\n    _angleDiffThreshold: toNonNegNum(\n      options.angleDiffThreshold,\n      config._angleDiffThreshold,\n    ),\n    _naturalTouchScroll:\n      options.naturalTouchScroll ?? config._naturalTouchScroll,\n    _touchDragHoldTime: options.touchDragHoldTime ?? config._touchDragHoldTime,\n    _touchDragNumFingers:\n      options.touchDragNumFingers ?? config._touchDragNumFingers,\n  };\n};\n\n// Since each callback needs to accumulate events during its debounce window\n// and until its threshold is exceeded, we use a wrapper around the\n// user-supplied handler to do that.\nconst getCallbackAndWrapper = (\n  handler: OnGestureHandler,\n  options: OnGestureOptionsInternal,\n  logger: LoggerInterface | null,\n): { _callback: OnGestureCallback; _wrapper: OnGestureHandlerWrapper } => {\n  let totalDeltaX = 0,\n    totalDeltaY = 0,\n    totalDeltaZ = 1;\n  // When there's a pointer down, drag then pointerup, since we prevent\n  // pointerdown default action, this results in a click event shortly\n  // afterwards even when there's been a movement of the mouse. We detect that\n  // and prevent this click.\n  let preventNextClick = false;\n\n  const directions = options._directions;\n  const intents = options._intents;\n  const minTotalDeltaX = options._minTotalDeltaX;\n  const maxTotalDeltaX = options._maxTotalDeltaX;\n  const minTotalDeltaY = options._minTotalDeltaY;\n  const maxTotalDeltaY = options._maxTotalDeltaY;\n  const minTotalDeltaZ = options._minTotalDeltaZ;\n  const maxTotalDeltaZ = options._maxTotalDeltaZ;\n  const deltaThreshold = options._deltaThreshold;\n  const angleDiffThreshold = options._angleDiffThreshold;\n  const reverseScroll = !options._naturalTouchScroll;\n  const dragHoldTime = options._touchDragHoldTime;\n  const dragNumFingers = options._touchDragNumFingers;\n\n  // The event queue is cleared when the threshold is exceeded AND the debounce\n  // window has passed. It's not necessary for the actual handler to be called\n  // then (e.g. if the direction or intent doesn't match, it won't be).\n  const eventQueue: Event[] = [];\n  const id = randId();\n\n  // Since handler could be a function or a callback (not callable), we wrap it\n  // so that in case it's already a callback, its removal will result in\n  // deleteHandler getting called. It is not debounced itself, instead there's\n  // a debounced wrapper that invokes it.\n  const callback = wrapCallback(handler);\n\n  // The debounced callback wrapper is what is debounced.\n  // It accumulates total deltas and checks if the conditions (of threshold,\n  // direction and intent) are satisfied before calling the real handler.\n  //\n  // Most importantly, since it is only called when the debounce window has\n  // expired it can clear the event queue if the threshold is also exceeded.\n  const debouncedWrapper = getDebouncedHandler(\n    options._debounceWindow,\n    (\n      target: EventTarget,\n      fragment: GestureFragment,\n      eventQueueCopy: Event[],\n    ) => {\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      const deltaX = fragment.deltaX;\n      const deltaY = fragment.deltaY;\n      const deltaZ = fragment.deltaZ;\n      const device = fragment.device;\n\n      if (\n        MH.round(maxAbs(deltaX, deltaY, (1 - deltaZ) * 100)) < deltaThreshold\n      ) {\n        debug: logger?.debug7(\n          `[${id}] Delta threshold not exceeded for callback`,\n        );\n        return;\n      }\n\n      debug: logger?.debug9(`[${id}] Done summing events for ${device}`);\n      clearEventQueue(device, eventQueue);\n\n      const newTotalDeltaX = toNumWithBounds(totalDeltaX + deltaX, {\n        min: minTotalDeltaX,\n        max: maxTotalDeltaX,\n      });\n\n      const newTotalDeltaY = toNumWithBounds(totalDeltaY + deltaY, {\n        min: minTotalDeltaY,\n        max: maxTotalDeltaY,\n      });\n\n      const newTotalDeltaZ = toNumWithBounds(addDeltaZ(totalDeltaZ, deltaZ), {\n        min: minTotalDeltaZ,\n        max: maxTotalDeltaZ,\n      });\n\n      if (\n        newTotalDeltaX === totalDeltaX &&\n        newTotalDeltaY === totalDeltaY &&\n        newTotalDeltaZ === totalDeltaZ\n      ) {\n        return;\n      }\n\n      totalDeltaX = newTotalDeltaX;\n      totalDeltaY = newTotalDeltaY;\n      totalDeltaZ = newTotalDeltaZ;\n\n      const direction = fragment.direction;\n      const intent = fragment.intent;\n      const time =\n        eventQueueCopy[MH.lengthOf(eventQueueCopy) - 1]?.timeStamp -\n          eventQueueCopy[0]?.timeStamp || 0;\n\n      const data = {\n        device,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n        time,\n        totalDeltaX,\n        totalDeltaY,\n        totalDeltaZ,\n      };\n\n      if (\n        direction !== MC.S_NONE &&\n        (!directions || MH.includes(directions, direction)) &&\n        (!intents || MH.includes(intents, intent))\n      ) {\n        callback.invoke(target, data, eventQueueCopy).catch(logError);\n      } else {\n        debug: logger?.debug7(\n          `[${id}] Directions or intents not matching for callback`,\n        );\n      }\n    },\n  );\n\n  // This wrapper is NOT debounced and adds the events to the queue, prevents\n  // default action if needed, and indicates whether the gesture is terminated.\n  const wrapper = (\n    target: EventTarget,\n    device: GestureDevice,\n    event: Event,\n    preventDefault: boolean,\n  ) => {\n    eventQueue.push(event);\n\n    const fragment = fragmentGetters[device](eventQueue, {\n      angleDiffThreshold,\n      deltaThreshold,\n      reverseScroll,\n      dragHoldTime,\n      dragNumFingers,\n    });\n\n    debug: logger?.debug8(\n      `[${id}] Got fragment for ${device} (${event.type})`,\n      fragment,\n      [...eventQueue].map((e) => e.type),\n    );\n\n    if (preventDefault) {\n      preventDefaultActionFor(\n        event,\n        !!fragment || (event.type === MC.S_CLICK && preventNextClick),\n      );\n    }\n\n    if (fragment === false) {\n      // not enough events in the queue, pass\n      debug: logger?.debug9(`[${id}] Not enough events for gesture ${device}`);\n      return false;\n    } else if (fragment === null) {\n      // consider the gesture terminated\n      clearEventQueue(device, eventQueue);\n      debug: logger?.debug9(`[${id}] Gesture for ${device} terminated`);\n      return true;\n    }\n\n    if (device === MC.S_POINTER) {\n      // If we're here, there's been a drag, expect a click immediately\n      // afterwards and prevent default action.\n      preventNextClick = true;\n      MH.setTimer(() => {\n        preventNextClick = false;\n      }, 10);\n    }\n\n    debouncedWrapper(\n      target,\n      fragment,\n      [...eventQueue], // copy\n    );\n\n    return false;\n  };\n\n  return { _callback: callback, _wrapper: wrapper };\n};\n\nconst clearEventQueue = (device: GestureDevice, queue: Event[]) => {\n  const keepLastEvent = device === MC.S_POINTER || device === MC.S_TOUCH;\n  queue.splice(0, MH.lengthOf(queue) - (keepLastEvent ? 1 : 0));\n};\n\nconst preventDefaultActionFor = (event: Event, isActualGesture: boolean) => {\n  const target = event.currentTarget;\n  const eventType = event.type;\n  const isPointerDown =\n    eventType === MC.S_POINTERDOWN || eventType === MC.S_MOUSEDOWN;\n\n  if (\n    eventType === MC.S_TOUCHMOVE ||\n    eventType === MC.S_WHEEL ||\n    ((eventType === MC.S_CLICK || eventType === MC.S_KEYDOWN) &&\n      isActualGesture) ||\n    (isPointerDown && (event as MouseEvent).buttons === 1)\n  ) {\n    MH.preventDefault(event);\n\n    if (isPointerDown && MH.isHTMLElement(target)) {\n      // Otherwise capturing key events won't work\n      target.focus({ preventScroll: true });\n    }\n  }\n};\n\nconst setGestureCssProps = (\n  target: EventTarget,\n  data: Partial<GestureData>,\n) => {\n  const intent = data.intent;\n\n  if (!MH.isElement(target) || !intent || intent === MC.S_UNKNOWN) {\n    return;\n  }\n\n  const prefix = `${intent}-`;\n\n  if (intent === MC.S_ZOOM) {\n    setNumericStyleProps(\n      target,\n      {\n        deltaZ: data.totalDeltaZ,\n      },\n      {\n        _prefix: prefix,\n        _numDecimal: 2,\n      },\n    ); // don't await here\n  } else {\n    setNumericStyleProps(\n      target,\n      {\n        deltaX: data.totalDeltaX,\n        deltaY: data.totalDeltaY,\n      },\n      {\n        _prefix: prefix,\n      },\n    ); // don't await here\n  }\n};\n","/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  DeviceSpec,\n  Device,\n  AspectRatioSpec,\n  AspectRatio,\n} from \"@lisn/globals/types\";\n\nimport { sortedKeysByVal } from \"@lisn/utils/math\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  BitSpace,\n  newBitSpaces,\n  createBitSpace,\n} from \"@lisn/modules/bit-spaces\";\n\n/**\n * Returns true if the given string is a valid device name.\n *\n * @category Validation\n */\nexport const isValidDevice = (device: string): device is Device =>\n  ORDERED_DEVICES.has(device);\n\n/**\n * Returns true if the given string is a valid aspect ratio name.\n *\n * @category Validation\n */\nexport const isValidAspectRatio = (\n  aspectRatio: string,\n): aspectRatio is AspectRatio => ORDERED_ASPECTR.has(aspectRatio);\n\n/**\n * Returns true if the given string is a valid device specification (including\n * `\"min <Device>\"`, etc).\n *\n * Returns false for \"\", although if you passed \"\" in\n * {@link Watchers/LayoutWatcher.OnLayoutOptions | OnLayoutOptions} it would\n * accept it as specifying _all_ devices.\n *\n * @category Validation\n */\nexport const isValidDeviceList = (\n  device: string | string[],\n): device is DeviceSpec | Device[] =>\n  isValidForType(S_DEVICES, device, ORDERED_DEVICES);\n\n/**\n * Returns true if the given string is a valid aspect ratio specification\n * (including `\"min <AspectRatio>\"`, etc).\n *\n * Returns false for \"\", although if you passed \"\" in\n * {@link Watchers/LayoutWatcher.OnLayoutOptions | OnLayoutOptions} it would\n * accept it as specifying _all_ aspect ratios.\n *\n * @category Validation\n */\nexport const isValidAspectRatioList = (\n  aspectR: string | string[],\n): aspectR is AspectRatioSpec | AspectRatio[] =>\n  isValidForType(S_ASPECTRS_CAMEL, aspectR, ORDERED_ASPECTR);\n\n/**\n * Returns a list of {@link Device}s that are not covered by the given device\n * specification. See\n * {@link Watchers/LayoutWatcher.OnLayoutOptions | OnLayoutOptions} for accepted\n * formats.\n *\n * Returns an empty for \"\" or for a specification that includes all devices.\n *\n * @category Layout\n */\nexport const getOtherDevices = (device: DeviceSpec | Device[]): Device[] =>\n  getOtherLayouts(S_DEVICES, device, ORDERED_DEVICES);\n\n/**\n * Returns a list of {@link AspectRatio}s that are not covered by the given\n * aspect ratio specification. See\n * {@link Watchers/LayoutWatcher.OnLayoutOptions | OnLayoutOptions} for accepted\n * formats.\n *\n * Returns an empty for \"\" or for a specification that includes all aspect\n * ratios.\n *\n * @category Layout\n */\nexport const getOtherAspectRatios = (\n  aspectR: AspectRatioSpec | AspectRatio[],\n): AspectRatio[] => getOtherLayouts(S_ASPECTRS_CAMEL, aspectR, ORDERED_ASPECTR);\n\n/**\n * @ignore\n * @internal\n */\nexport const getLayoutBitmask = (options?: {\n  devices?: DeviceSpec | Device[];\n  aspectRatios?: AspectRatioSpec | AspectRatio[];\n}): number => {\n  let layoutBitmask =\n    getBitmaskFromSpec(S_DEVICES, options?.devices, ORDERED_DEVICES) |\n    getBitmaskFromSpec(\n      S_ASPECTRS_CAMEL,\n      options?.aspectRatios,\n      ORDERED_ASPECTR,\n    );\n\n  if (!layoutBitmask) {\n    layoutBitmask = ORDERED_DEVICES.bitmask | ORDERED_ASPECTR.bitmask; // default: all\n  }\n\n  return layoutBitmask;\n};\n\n// In ascending order by width.\nconst ORDERED_DEVICE_NAMES = sortedKeysByVal(settings.deviceBreakpoints);\nconst ORDERED_ASPECTR_NAMES = sortedKeysByVal(settings.aspectRatioBreakpoints);\n\nconst bitSpaces = newBitSpaces();\n\n/**\n * @ignore\n * @internal\n */\nexport const ORDERED_DEVICES = createBitSpace(\n  bitSpaces,\n  ...ORDERED_DEVICE_NAMES,\n);\n\n/**\n * @ignore\n * @internal\n */\nexport const ORDERED_ASPECTR = createBitSpace(\n  bitSpaces,\n  ...ORDERED_ASPECTR_NAMES,\n);\n\n/**\n * @ignore\n * @internal\n */\nexport const NUM_LAYOUTS =\n  MH.lengthOf(ORDERED_DEVICE_NAMES) + MH.lengthOf(ORDERED_ASPECTR_NAMES);\n\n// --------------------\n\nconst S_DEVICES = \"devices\";\nconst S_ASPECTRS_CAMEL = \"aspectRatios\";\n\nconst LAYOUT_RANGE_REGEX = RegExp(\n  \"^ *(\" +\n    \"(?<layoutA>[a-z-]+) +to +(?<layoutB>[a-z-]+)|\" +\n    \"min +(?<minLayout>[a-z-]+)|\" +\n    \"max +(?<maxLayout>[a-z-]+)\" +\n    \") *$\",\n);\n\nconst getLayoutsFromBitmask = <T extends Device | AspectRatio>(\n  keyName: string,\n  bitmask: number,\n  bitSpace: BitSpace<T>,\n): T[] => {\n  const layouts: T[] = [];\n  for (let bit = bitSpace.start; bit <= bitSpace.end; bit++) {\n    const value = 1 << bit;\n    if (bitmask & value) {\n      const name = bitSpace.nameOf(value);\n      if (name) {\n        layouts.push(name);\n      }\n    }\n  }\n\n  return layouts;\n};\n\nconst getOtherLayouts = <T extends Device | AspectRatio>(\n  keyName: string,\n  spec: string | string[],\n  bitSpace: BitSpace<T>,\n): T[] => {\n  const bitmask = getBitmaskFromSpec(keyName, spec, bitSpace);\n  if (!bitmask) {\n    return [];\n  }\n\n  const oppositeBitmask = bitSpace.bitmask & ~bitmask;\n  return getLayoutsFromBitmask(keyName, oppositeBitmask, bitSpace);\n};\n\nconst isValidForType = <T extends Device | AspectRatio>(\n  keyName: string,\n  spec: string | string[],\n  bitSpace: BitSpace<T>,\n): boolean => {\n  try {\n    const bitmask = getBitmaskFromSpec(keyName, spec, bitSpace);\n    return bitmask !== 0;\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\nconst getBitmaskFromSpec = <T extends Device | AspectRatio>(\n  keyName: string,\n  spec: string | string[] | undefined | null,\n  bitSpace: BitSpace<T>,\n): number => {\n  if (MH.isEmpty(spec)) {\n    return 0;\n  }\n  const singleKeyName = keyName.slice(0, -1);\n\n  if (MH.isString(spec)) {\n    const rangeMatch = spec.match(LAYOUT_RANGE_REGEX);\n    if (rangeMatch) {\n      /* istanbul ignore next */ // shouldn't happen\n      if (!rangeMatch.groups) {\n        throw MH.bugError(\"Layout regex has no named groups\");\n      }\n\n      const minLayout =\n        rangeMatch.groups.layoutA || rangeMatch.groups.minLayout;\n      const maxLayout =\n        rangeMatch.groups.layoutB || rangeMatch.groups.maxLayout;\n\n      if (minLayout !== undefined && !bitSpace.has(minLayout)) {\n        throw MH.usageError(`Unknown ${singleKeyName} '${minLayout}'`);\n      }\n\n      if (maxLayout !== undefined && !bitSpace.has(maxLayout)) {\n        throw MH.usageError(`Unknown ${singleKeyName} '${maxLayout}'`);\n      }\n\n      return bitSpace.bitmaskFor(minLayout, maxLayout);\n    }\n  }\n\n  let bitmask = 0;\n  const layouts = validateStrList(keyName, spec, bitSpace.has);\n  if (layouts) {\n    for (const lt of layouts) {\n      bitmask |= bitSpace.bit[lt];\n    }\n  }\n\n  return bitmask;\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  ScrollDirection,\n  ScrollTarget,\n  TargetCoordinates,\n  CoordinateOffset,\n  ScrollPosition,\n  Offset,\n} from \"@lisn/globals/types\";\n\nimport { getComputedStylePropNow } from \"@lisn/utils/css-alter\";\nimport { SCROLL_DIRECTIONS } from \"@lisn/utils/directions\";\nimport {\n  waitForInteractive,\n  waitForElementOrInteractive,\n} from \"@lisn/utils/dom-events\";\nimport {\n  waitForMeasureTime,\n  waitForMutateTime,\n} from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { maxAbs, easeInOutQuad } from \"@lisn/utils/math\";\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\nimport { newXMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Scrolling\n */\nexport type ScrollAction = {\n  cancel: () => boolean;\n\n  /**\n   * Will reject if the scroll is cancelled.\n   */\n  waitFor: () => Promise<ScrollPosition>;\n};\n\n/**\n * @category Scrolling\n * @interface\n */\nexport type ScrollToOptions = {\n  /**\n   * The element that should be scrolled.\n   *\n   * @defaultValue If `document.body` is scrollable, will use that; otherwise `document.scrollingElement`\n   */\n  scrollable?: Element;\n\n  /**\n   * Offset the target coordinates by the given amount(s).\n   *\n   * E.g. if the final target coordinates are computed to be\n   * `{top: 100, left: 0}` and you specify offset as `{top: 10, left: 20}`, it\n   * will scroll to  `{top: 110, left: 20}`.\n   *\n   * @defaultValue undefined\n   */\n  offset?: CoordinateOffset;\n\n  // TODO maybe support fixed velocity as an alternative to fixed duration?\n  /**\n   * The duration of the scroll animation. If not given, it is instant.\n   *\n   * @defaultValue 0\n   */\n  duration?: number;\n\n  /**\n   * Whether another request to us to scroll the same target can interrupt this\n   * scroll before it finishes.\n   *\n   * @defaultValue false\n   */\n  weCanInterrupt?: boolean;\n\n  /**\n   * Whether a user attempt to scroll the target can interrupt this before it\n   * finishes.\n   *\n   * @defaultValue false\n   */\n  userCanInterrupt?: boolean;\n\n  /**\n   * If the scrolling element is already at the given coordinates (or strictly\n   * speaking we allow for 5 pixels difference), then if `altTarget` is given,\n   * this will become the target to scroll to.\n   *\n   * @defaultValue undefined\n   */\n  altTarget?: TargetCoordinates | Element | string;\n\n  /**\n   * Offset the target coordinates by the given amount(s) when `altTarget` is used.\n   *\n   * See {@link ScrollToOptions.offset}.\n   *\n   * @defaultValue undefined\n   */\n  altOffset?: CoordinateOffset;\n};\n\n// ----------\n\n/**\n * Returns true if the given element is scrollable in the given direction, or\n * in either direction (if `axis` is not given).\n *\n * **IMPORTANT:** If you enable `active` then be aware that:\n * 1. It may attempt to scroll the target in order to determine whether it's\n *    scrollable in a more reliable way than the default method of comparing\n *    clientWidth/Height to scrollWidth/Height. If there is currently any\n *    ongoing scroll on the target, this will stop it, so never use that inside\n *    scroll-triggered handlers.\n * 2. If the layout has been invalidated and not yet recalculated,\n *    this will cause a forced layout, so always {@link waitForMeasureTime}\n *    before calling this function when possible.\n *\n * @param {} [options.axis]    One of \"x\" or \"y\" for horizontal or vertical\n *                             scroll respectively. If not given, it checks\n *                             both.\n * @param {} [options.active]  If true, then if the target's current scroll\n *                             offset is 0, it will attempt to scroll it rather\n *                             than looking at the clientWidth/Height to\n *                             scrollWidth/Height. This is more reliable but can\n *                             cause issues, see note above.\n * @param {} [options.noCache] By default the result of a check is cached for\n *                             1s and if there's already a cached result for\n *                             this element, it is returns. Set this to true to\n *                             disable checking the cache and also saving the\n *                             result into the cache.\n *\n * @category Scrolling\n */\nexport const isScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n): boolean => {\n  const { axis, active, noCache } = options || {};\n  if (!axis) {\n    return (\n      isScrollable(element, { axis: \"y\", active, noCache }) ||\n      isScrollable(element, { axis: \"x\", active, noCache })\n    );\n  }\n\n  if (!noCache) {\n    const cachedResult = isScrollableCache.get(element)?.get(axis);\n    if (!MH.isNullish(cachedResult)) {\n      return cachedResult;\n    }\n  }\n\n  const offset = axis === \"x\" ? \"Left\" : \"Top\";\n  let result = false;\n  let doCache = !noCache;\n\n  if (element[`scroll${offset}`]) {\n    result = true;\n  } else if (active) {\n    // Use scrollTo with explicit behavior set to instant instead of setting\n    // the scrollTop/Left properties since the latter doesn't work with\n    // scroll-behavior smooth.\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 1 });\n    const canScroll = element[`scroll${offset}`] > 0;\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 0 });\n    result = canScroll;\n  } else {\n    const dimension = axis === \"x\" ? \"Width\" : \"Height\";\n    result = element[`scroll${dimension}`] > element[`client${dimension}`];\n    // No need to cache a passive check.\n    doCache = false;\n  }\n\n  if (doCache) {\n    isScrollableCache.sGet(element).set(axis, result);\n    MH.setTimer(() => {\n      MH.deleteKey(isScrollableCache.get(element), axis);\n      isScrollableCache.prune(element);\n    }, IS_SCROLLABLE_CACHE_TIMEOUT);\n  }\n\n  return result;\n};\n\n/**\n * Returns the closest scrollable ancestor of the given element, _not including\n * it_.\n *\n * @param {} options See {@link isScrollable}\n *\n * @return {} `null` if no scrollable ancestors are found.\n *\n * @category Scrolling\n */\nexport const getClosestScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n) => {\n  // Walk up the tree, starting at the element in question but excluding it.\n  let ancestor: Element | null | undefined = element;\n  while ((ancestor = MH.parentOf(ancestor))) {\n    if (isScrollable(ancestor, options)) {\n      return ancestor;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Returns the current {@link ScrollAction} if any.\n *\n * @category Scrolling\n */\nexport const getCurrentScrollAction = (\n  scrollable?: Element,\n): ScrollAction | null => {\n  scrollable = toScrollableOrDefault(scrollable);\n  const action = currentScrollAction.get(scrollable);\n  if (action) {\n    return MH.copyObject(action);\n  }\n  return null;\n};\n\n/**\n * Scrolls the given scrollable element to the given `to` target.\n *\n * Returns `null` if there's an ongoing scroll that is not cancellable.\n *\n * Note that if `to` is an element or a selector, then it _must_ be a\n * descendant of the scrollable element.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *               If the target coordinates are invalid.\n *\n * @param {} to  If this is an element, then its top-left position is used as\n *               the target coordinates. If it is a string, then it is treated\n *               as a selector for an element using `querySelector`.\n *\n * @return {} `null` if there's an ongoing scroll that is not cancellable,\n * otherwise a {@link ScrollAction}.\n *\n * @category Scrolling\n */\nexport const scrollTo = (\n  to: TargetCoordinates | Element | string,\n  userOptions?: ScrollToOptions,\n): ScrollAction | null => {\n  const options = getOptions(to, userOptions);\n  const scrollable = options._scrollable;\n\n  // cancel current scroll action if any\n  const currentScroll = currentScrollAction.get(scrollable);\n  if (currentScroll) {\n    if (!currentScroll.cancel()) {\n      // current scroll action is not cancellable by us\n      return null;\n    }\n  }\n\n  let isCancelled = false;\n\n  const cancelFn = options._weCanInterrupt\n    ? () => (isCancelled = true)\n    : () => false;\n\n  const scrollEvents = [\"touchmove\", \"wheel\"]; // don't bother with keyboard\n  let preventScrollHandler: EventListener | null = null;\n\n  if (options._userCanInterrupt) {\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(\n        scrollable,\n        eventType,\n        () => {\n          isCancelled = true;\n        },\n        { once: true },\n      );\n    }\n  } else {\n    preventScrollHandler = MH.preventDefault;\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(scrollable, eventType, preventScrollHandler, {\n        passive: false,\n      });\n    }\n  }\n\n  const promise = initiateScroll(options, () => isCancelled);\n\n  const thisScrollAction: ScrollAction = {\n    waitFor: () => promise,\n    cancel: cancelFn,\n  };\n\n  const cleanup = () => {\n    if (currentScrollAction.get(scrollable) === thisScrollAction) {\n      MH.deleteKey(currentScrollAction, scrollable);\n    }\n\n    if (preventScrollHandler) {\n      for (const eventType of scrollEvents) {\n        removeEventListenerFrom(scrollable, eventType, preventScrollHandler, {\n          passive: false,\n        });\n      }\n    }\n  };\n\n  thisScrollAction.waitFor().then(cleanup).catch(cleanup);\n\n  currentScrollAction.set(scrollable, thisScrollAction);\n  return thisScrollAction;\n};\n\n/**\n * Returns true if the given string is a valid scroll direction.\n *\n * @category Validation\n */\nexport const isValidScrollDirection = (\n  direction: string,\n): direction is ScrollDirection => MH.includes(SCROLL_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid scroll\n * directions.\n *\n * @category Validation\n */\nexport const isValidScrollDirectionList = (directions: string | string[]) =>\n  isValidStrList(directions, isValidScrollDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const mapScrollable = (original: Element, actualScrollable: Element) =>\n  mappedScrollables.set(original, actualScrollable);\n\n/**\n * @ignore\n * @internal\n */\nexport const unmapScrollable = (original: Element) =>\n  MH.deleteKey(mappedScrollables, original);\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientWidthNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetWidth -\n      getBorderWidth(element, MC.S_LEFT) -\n      getBorderWidth(element, MC.S_RIGHT)\n    : element[MC.S_CLIENT_WIDTH];\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientHeightNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetHeight -\n      getBorderWidth(element, MC.S_TOP) -\n      getBorderWidth(element, MC.S_BOTTOM)\n    : element[MC.S_CLIENT_HEIGHT];\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainContentElement = (): HTMLElement | null =>\n  mainContentElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainContentElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainContentElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainScrollableElement = (): HTMLElement | null =>\n  mainScrollableElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainScrollableElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainScrollableElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getDefaultScrollingElement = () => {\n  const body = MH.getBody();\n  return isScrollable(body) ? body : MH.getDocScrollingElement() || body;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetScrollableElement = (\n  target: ScrollTarget | null | undefined,\n): Element | null => toScrollableOrMain(target, tryGetMainScrollableElement);\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchScrollableElement = async (\n  target: ScrollTarget | null | undefined,\n): Promise<Element> => toScrollableOrMain(target, fetchMainScrollableElement);\n\n// ----------------------------------------\n\ntype ScrollToOptionsInternal = {\n  _target: TargetCoordinates;\n  _offset: CoordinateOffset | null;\n  _altTarget: TargetCoordinates | null;\n  _altOffset: CoordinateOffset | null;\n  _scrollable: Element;\n  _duration: number;\n  _weCanInterrupt: boolean;\n  _userCanInterrupt: boolean;\n};\n\nconst IS_SCROLLABLE_CACHE_TIMEOUT = 1000;\n\nconst isScrollableCache = newXMap<Element, Map<\"x\" | \"y\", boolean>>(() =>\n  MH.newMap(),\n);\n\nconst mappedScrollables = MH.newMap<Element, Element>();\n\nconst currentScrollAction = MH.newMap<Element, ScrollAction>();\n\nconst DIFF_THRESHOLD = 5;\nconst arePositionsDifferent = (start: ScrollPosition, end: ScrollPosition) =>\n  maxAbs(start.top - end.top, start.left - end.left) >= DIFF_THRESHOLD;\n\nconst toScrollableOrMain = <R>(\n  target: ScrollTarget | null | undefined,\n  getMain: () => R,\n): Element | R => {\n  if (MH.isElement(target)) {\n    return mappedScrollables.get(target) || target;\n  }\n\n  if (!target || target === MH.getWindow() || target === MH.getDoc()) {\n    return getMain();\n  }\n\n  throw MH.usageError(\"Unsupported scroll target\");\n};\n\nconst toScrollableOrDefault = (scrollable: Element | undefined): Element =>\n  scrollable ?? getDefaultScrollingElement();\n\nconst getOptions = (\n  to: TargetCoordinates | Element | string,\n  options: ScrollToOptions | undefined,\n): ScrollToOptionsInternal => {\n  const scrollable = toScrollableOrDefault(options?.scrollable);\n  const target = getTargetCoordinates(scrollable, to);\n  const altTarget = options?.altTarget\n    ? getTargetCoordinates(scrollable, options?.altTarget)\n    : null;\n\n  return {\n    _target: target,\n    _offset: options?.offset || null,\n    _altTarget: altTarget,\n    _altOffset: options?.altOffset || null,\n    _scrollable: scrollable,\n    _duration: options?.duration || 0,\n    _weCanInterrupt: options?.weCanInterrupt ?? false,\n    _userCanInterrupt: options?.userCanInterrupt ?? false,\n  };\n};\n\nconst getTargetCoordinates = (\n  scrollable: Element,\n  target: TargetCoordinates | Element | string,\n): TargetCoordinates => {\n  const docScrollingElement = MH.getDocScrollingElement();\n\n  if (MH.isElement(target)) {\n    if (scrollable === target || !scrollable.contains(target)) {\n      throw MH.usageError(\"Target must be a descendant of the scrollable one\");\n    }\n\n    return {\n      top: () =>\n        scrollable[MC.S_SCROLL_TOP] +\n        MH.getBoundingClientRect(target).top -\n        (scrollable === docScrollingElement\n          ? 0\n          : MH.getBoundingClientRect(scrollable).top),\n      left: () =>\n        scrollable[MC.S_SCROLL_LEFT] +\n        MH.getBoundingClientRect(target).left -\n        (scrollable === docScrollingElement\n          ? 0\n          : MH.getBoundingClientRect(scrollable).left),\n    };\n  }\n\n  if (MH.isString(target)) {\n    const targetEl = MH.docQuerySelector(target);\n    if (!targetEl) {\n      throw MH.usageError(`No match for '${target}'`);\n    }\n\n    return getTargetCoordinates(scrollable, targetEl);\n  }\n\n  if (!MH.isObject(target) || !(\"top\" in target || \"left\" in target)) {\n    throw MH.usageError(\"Invalid coordinates\");\n  }\n\n  return target;\n};\n\nconst getStartEndPosition = async (\n  options: ScrollToOptionsInternal,\n): Promise<{ start: ScrollPosition; end: ScrollPosition }> => {\n  await waitForMeasureTime();\n\n  const applyOffset = (\n    position: ScrollPosition,\n    offset: CoordinateOffset | null,\n  ) => {\n    position.top += offset?.top || 0;\n    position.left += offset?.left || 0;\n  };\n\n  const scrollable = options._scrollable;\n  const start = {\n    top: scrollable[MC.S_SCROLL_TOP],\n    left: scrollable[MC.S_SCROLL_LEFT],\n  };\n\n  let end = getEndPosition(scrollable, start, options._target);\n  applyOffset(end, options._offset);\n\n  if (!arePositionsDifferent(start, end) && options._altTarget) {\n    end = getEndPosition(scrollable, start, options._altTarget);\n    applyOffset(end, options._altOffset);\n  }\n\n  return { start, end };\n};\n\n// must be called in \"measure time\"\nconst getEndPosition = (\n  scrollable: Element,\n  startPosition: ScrollPosition,\n  targetCoordinates: TargetCoordinates,\n): ScrollPosition => {\n  // by default no change in scroll top or left\n  const endPosition = MH.copyObject(startPosition);\n\n  if (!MH.isNullish(targetCoordinates?.top)) {\n    if (MH.isFunction(targetCoordinates.top)) {\n      endPosition.top = targetCoordinates.top(scrollable);\n    } else {\n      endPosition.top = targetCoordinates.top;\n    }\n  }\n\n  if (!MH.isNullish(targetCoordinates?.left)) {\n    if (MH.isFunction(targetCoordinates.left)) {\n      endPosition.left = targetCoordinates.left(scrollable);\n    } else {\n      endPosition.left = targetCoordinates.left;\n    }\n  }\n\n  // Set boundaries\n  const scrollH = scrollable[MC.S_SCROLL_HEIGHT];\n  const scrollW = scrollable[MC.S_SCROLL_WIDTH];\n  const clientH = getClientHeightNow(scrollable);\n  const clientW = getClientWidthNow(scrollable);\n  endPosition.top = MH.min(scrollH - clientH, endPosition.top);\n  endPosition.top = MH.max(0, endPosition.top);\n\n  endPosition.left = MH.min(scrollW - clientW, endPosition.left);\n  endPosition.left = MH.max(0, endPosition.left);\n\n  return endPosition;\n};\n\nconst initiateScroll = async (\n  options: ScrollToOptionsInternal,\n  isCancelled: () => boolean,\n) => {\n  const position = await getStartEndPosition(options);\n  const duration = options._duration;\n  const scrollable = options._scrollable;\n\n  let startTime: number, previousTimeStamp: number;\n  let currentPosition: ScrollPosition = position.start;\n\n  const step = async () => {\n    await waitForMutateTime(); // effectively next animation frame\n    // Element.scrollTo equates to a measurement and needs to run after\n    // painting to avoid forced layout.\n    await waitForMeasureTime();\n    const timeStamp = MH.timeNow();\n\n    if (isCancelled()) {\n      // Reject the promise\n      throw currentPosition;\n    }\n\n    if (!startTime) {\n      // If it's very close to the target, no need to scroll smoothly\n      if (\n        duration === 0 ||\n        !arePositionsDifferent(currentPosition, position.end)\n      ) {\n        MH.elScrollTo(scrollable, position.end);\n        return position.end;\n      }\n\n      startTime = timeStamp;\n    }\n\n    if (startTime !== timeStamp && previousTimeStamp !== timeStamp) {\n      const elapsed = timeStamp - startTime;\n      const progress = easeInOutQuad(MH.min(1, elapsed / duration));\n\n      currentPosition = {\n        top:\n          position.start.top +\n          (position.end.top - position.start.top) * progress,\n        left:\n          position.start.left +\n          (position.end.left - position.start.left) * progress,\n      };\n\n      MH.elScrollTo(scrollable, currentPosition);\n\n      if (progress === 1) {\n        return currentPosition;\n      }\n    }\n\n    previousTimeStamp = timeStamp;\n    return step();\n  };\n\n  return step();\n};\n\nconst isScrollableBodyInQuirks = (element: Element): element is HTMLElement =>\n  element === MH.getBody() && MH.getDocScrollingElement() === null;\n\n// must be called in \"measure time\"\nconst getBorderWidth = (element: Element, side: Offset) =>\n  MH.ceil(MH.parseFloat(getComputedStylePropNow(element, `border-${side}`)));\n\n// ------------------------------\n\nlet mainContentElement: HTMLElement;\nlet mainScrollableElement: HTMLElement;\n\nlet initPromise: Promise<void> | null = null;\nconst init = (): Promise<void> => {\n  if (!initPromise) {\n    initPromise = (async () => {\n      const mainScrollableElementSelector =\n        settings.mainScrollableElementSelector;\n\n      const contentElement = await waitForElementOrInteractive(() => {\n        return mainScrollableElementSelector\n          ? MH.docQuerySelector(mainScrollableElementSelector)\n          : MH.getBody(); // default if no selector\n      });\n\n      // defaults\n      mainScrollableElement = getDefaultScrollingElement();\n      mainContentElement = MH.getBody();\n\n      if (!contentElement) {\n        logError(\n          MH.usageError(\n            `No match for '${mainScrollableElementSelector}'. ` +\n              \"Scroll tracking/capturing may not work as intended.\",\n          ),\n        );\n      } else if (!MH.isHTMLElement(contentElement)) {\n        logWarn(\"mainScrollableElementSelector should point to an HTMLElement\");\n      } else if (contentElement !== mainContentElement) {\n        mainScrollableElement = mainContentElement = contentElement;\n      }\n    })();\n  }\n\n  return initPromise;\n};\n\n// Try to find the main scrollable/content elements asap so that tryGetMain*\n// can return them if called before fetchMain*\nif (MH.hasDOM()) {\n  waitForInteractive().then(init);\n}\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  addClasses,\n  addClassesNow,\n  setDataNow,\n  setStylePropNow,\n} from \"@lisn/utils/css-alter\";\nimport { moveElement, wrapScrollingContent } from \"@lisn/utils/dom-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { waitForMutateTime } from \"@lisn/utils/dom-optimize\";\nimport { logWarn } from \"@lisn/utils/log\";\nimport { camelToKebabCase, objToStrKey } from \"@lisn/utils/text\";\nimport {\n  isScrollable,\n  tryGetMainContentElement,\n  fetchMainContentElement,\n} from \"@lisn/utils/scroll\";\n\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Overlays\n * @interface\n */\nexport type OverlayOptions = {\n  /**\n   * The parent element to insert the overlay into.\n   *\n   * If not given, then:\n   * - if the overlay is to have a `position: fixed`, then `document.body` is used\n   * - otherwise,\n   *   {@link Watchers/ScrollWatcher.ScrollWatcher.fetchMainContentElement | ScrollWatcher.fetchMainContentElement} is\n   *   used\n   */\n  parent?: HTMLElement;\n\n  /**\n   * If set, then it will be assigned as the DOM element ID for the new\n   * overlay.\n   *\n   * Furthermore, the new overlay will be created and will not be saved for\n   * future reuse.\n   *\n   * By default, if `id` is not given, the overlay will be saved, and if\n   * {@link createOverlay} is called again with the same `style`, `data` and\n   * parent, the previous overlay is returned.\n   */\n  id?: string;\n\n  /**\n   * Every entry in this object will be set on the `style` of the new overlay.\n   *\n   * **IMPORTANT:** By default overlays are positioned absolutely, so if you need\n   * another positioning, override this here by setting a `position` key in\n   * `style`. If position is either \"absolute\" (by default or explicitly set) or\n   * \"fixed\", and none of `top` or `bottom` is given, `top: 0` is set; and\n   * similarly, if none of `left` or `right` is given, `left: 0` is set.\n   */\n  style?: Record<string, string>;\n\n  /**\n   * Every entry in this object will be set as a data attribute on the new\n   * overlay.\n   *\n   * Keys can be either kebab-case or camelCase (they will be converted if\n   * needed). Do _not_ include the \"data-\" prefix which will be added\n   * automatically. E.g. both \"foo-bar\" and \"fooBar\" will result in\n   * \"data-foo-bar\" being set.\n   */\n  data?: Record<string, string>;\n};\n\n/**\n * Returns an existing overlay for this specification. If the overlay was just\n * created it may not yet be attached to the DOM.\n *\n * @category Overlays\n */\nexport const getOverlay = (userOptions?: OverlayOptions) => {\n  const options = tryGetOverlayOptions(userOptions);\n  if (!options) {\n    return null;\n  }\n\n  return overlays.get(options._parent)?.get(options._overlayKey) || null;\n};\n\n/**\n * Creates a new overlay, and inserts it into the DOM as soon as\n * {@link waitForMutateTime} resolves, or returns an already existing matching\n * overlay.\n *\n * **Note** that if {@link OverlayOptions.id} is set, a new overlay will\n * _always_ be created.\n *\n * @category Overlays\n */\nexport const createOverlay = async (userOptions?: OverlayOptions) => {\n  const options = await fetchOverlayOptions(userOptions);\n  const canReuse = !options._id;\n\n  if (canReuse) {\n    const existingOverlay = overlays\n      .get(options._parent)\n      ?.get(options._overlayKey);\n\n    if (existingOverlay) {\n      if (!MH.parentOf(existingOverlay)) {\n        // not yet inserted into the DOM, so wait until it is\n        await waitForMutateTime();\n      }\n      return existingOverlay;\n    }\n  }\n\n  // Create a new one\n  const overlay = createOnlyOverlay(options);\n  if (canReuse) {\n    // Save it now before awating, so that concurrent requests to create the\n    // same one use it\n    overlays.sGet(options._parent).set(options._overlayKey, overlay);\n  } else {\n    overlay.id = options._id;\n  }\n\n  const isPercentageHOffset = MH.includes(\n    (options._style.left || \"\") + (options._style.right || \"\"),\n    \"%\",\n  );\n\n  const isPercentageVOffset = MH.includes(\n    (options._style.top || \"\") + (options._style.bottom || \"\"),\n    \"%\",\n  );\n\n  let needsContentWrapping = false;\n  let parentEl = options._parent;\n  if (isPercentageHOffset || isPercentageVOffset) {\n    needsContentWrapping =\n      (isPercentageHOffset && isScrollable(parentEl, { axis: \"x\" })) ||\n      (isPercentageVOffset && isScrollable(parentEl, { axis: \"y\" }));\n  }\n\n  if (needsContentWrapping) {\n    if (settings.contentWrappingAllowed) {\n      parentEl = await wrapScrollingContent(parentEl);\n    } else {\n      logWarn(\n        \"Percentage offset view trigger with scrolling root requires contentWrappingAllowed\",\n      );\n    }\n  }\n\n  if (options._style.position === MC.S_ABSOLUTE) {\n    // Ensure parent has non-static positioning\n    addClasses(parentEl, MH.prefixName(\"overlay-container\"));\n  }\n\n  await moveElement(overlay, { to: parentEl });\n\n  return overlay;\n};\n\n// ----------------------------------------\n\ntype OverlayOptionsInternal = {\n  _parent: HTMLElement;\n  _id: string;\n  _style: Record<string, string>;\n  _data: Record<string, string>;\n  _overlayKey: string;\n};\n\nconst overlays = newXWeakMap<HTMLElement, Map<string, HTMLElement>>(() =>\n  MH.newMap(),\n);\n\nconst tryGetOverlayOptions = (\n  userOptions: OverlayOptions | undefined,\n): OverlayOptionsInternal | null => {\n  const style = getCssProperties(userOptions?.style);\n  const data = userOptions?.data ?? {};\n  const parentEl = tryGetParent(userOptions?.parent, style.position);\n  if (!parentEl) {\n    return null;\n  }\n\n  return {\n    _parent: parentEl,\n    _id: userOptions?.id ?? \"\",\n    _style: style,\n    _data: data,\n    _overlayKey: getOverlayKey(style, data),\n  };\n};\n\nconst fetchOverlayOptions = async (\n  userOptions: OverlayOptions | undefined,\n): Promise<OverlayOptionsInternal> => {\n  const style = getCssProperties(userOptions?.style);\n  const data = userOptions?.data ?? {};\n  const parentEl = await fetchParent(userOptions?.parent, style.position);\n\n  return {\n    _parent: parentEl,\n    _id: userOptions?.id ?? \"\",\n    _style: style,\n    _data: data,\n    _overlayKey: getOverlayKey(style, data),\n  };\n};\n\nconst getOverlayKey = (\n  style: Record<string, string>,\n  data: Record<string, string>,\n) => objToStrKey(style) + \"|\" + objToStrKey(data);\n\nconst getCssProperties = (style: Record<string, string> | undefined) => {\n  const finalCssProperties: Record<string, string> = MH.merge(\n    { position: MC.S_ABSOLUTE }, // default\n    style,\n  );\n\n  if (\n    finalCssProperties.position === MC.S_ABSOLUTE ||\n    finalCssProperties.position === MC.S_FIXED\n  ) {\n    if (\n      MH.isEmpty(finalCssProperties.top) &&\n      MH.isEmpty(finalCssProperties.bottom)\n    ) {\n      finalCssProperties.top = \"0px\";\n    }\n\n    if (\n      MH.isEmpty(finalCssProperties.left) &&\n      MH.isEmpty(finalCssProperties.right)\n    ) {\n      finalCssProperties.left = \"0px\";\n    }\n  }\n\n  return finalCssProperties;\n};\n\nconst tryGetParent = (\n  userSuppliedParent: HTMLElement | undefined | null,\n  position: string,\n) =>\n  userSuppliedParent ??\n  (position === MC.S_FIXED ? MH.getBody() : tryGetMainContentElement());\n\nconst fetchParent = async (\n  userSuppliedParent: HTMLElement | undefined | null,\n  position: string,\n) =>\n  userSuppliedParent ??\n  (position === MC.S_FIXED\n    ? await waitForElement(MH.getBody)\n    : await fetchMainContentElement());\n\nconst createOnlyOverlay = (options: OverlayOptionsInternal) => {\n  const overlay = MH.createElement(\"div\");\n\n  addClassesNow(overlay, MH.prefixName(\"overlay\"));\n\n  const data = options._data;\n  for (const attr of MH.keysOf(data)) {\n    setDataNow(overlay, camelToKebabCase(attr), data[attr]);\n  }\n\n  const style = options._style;\n  for (const prop of MH.keysOf(style)) {\n    setStylePropNow(overlay, prop, style[prop]);\n  }\n\n  return overlay;\n};\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Box, Dimension, Size } from \"@lisn/globals/types\";\n\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { createOverlay } from \"@lisn/utils/overlays\";\n\n/**\n * Returns the content box size of the given\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry | ResizeObserverEntry}.\n *\n * @category Size measurements\n */\nexport const getEntryContentBox = (entry: ResizeObserverEntry): Size => {\n  const size = entry.contentBoxSize;\n\n  if (size) {\n    return getSizeFromInlineBlock(size);\n  }\n\n  const rect = entry.contentRect;\n  return { [MC.S_WIDTH]: rect[MC.S_WIDTH], [MC.S_HEIGHT]: rect[MC.S_HEIGHT] };\n};\n\n/**\n * Returns the border box size of the given\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry | ResizeObserverEntry}.\n *\n * @param {} fallbackToContent If the entry does not contain border box\n *                             measurements (depending on browser), then fall\n *                             back to using the content box size. Otherwise\n *                             (by default) will return `NaN` values for width\n *                             and height.\n *\n * @category Size measurements\n */\nexport const getEntryBorderBox = (\n  entry: ResizeObserverEntry,\n  fallbackToContent = false,\n): Size => {\n  const size = entry.borderBoxSize;\n\n  if (size) {\n    return getSizeFromInlineBlock(size);\n  } else if (fallbackToContent) {\n    return getEntryContentBox(entry);\n  }\n\n  return { [MC.S_WIDTH]: NaN, [MC.S_HEIGHT]: NaN };\n};\n\n/**\n * Returns true if the given string is a valid box type.\n *\n * @category Validation\n */\nexport const isValidBox = (box: string): box is Box =>\n  MH.includes(ALL_BOXES, box);\n\n/**\n * Returns true if the given string is a valid dimension.\n *\n * @category Validation\n */\nexport const isValidDimension = (dimension: string): dimension is Dimension =>\n  MH.includes(ALL_DIMENSIONS, dimension);\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetViewportOverlay = (): HTMLElement | null =>\n  viewportOverlay ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via SizeWatcher\n */\nexport const fetchViewportOverlay = async (): Promise<HTMLElement> => {\n  await init();\n\n  return viewportOverlay;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchViewportSize = async (realtime = false) => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const root = MH.hasDOM()\n    ? (MH.getDocScrollingElement() ?? MH.getBody())\n    : null;\n\n  return {\n    [MC.S_WIDTH]: root?.clientWidth || 0,\n    [MC.S_HEIGHT]: root?.clientHeight || 0,\n  };\n};\n\n// ----------------------------------------\n\nconst S_INLINE_SIZE = \"inlineSize\";\nconst S_BLOCK_SIZE = \"blockSize\";\n\nconst ALL_BOXES: Box[] = [\"content\", \"border\"] as const;\nconst ALL_DIMENSIONS: Dimension[] = [MC.S_WIDTH, MC.S_HEIGHT] as const;\n\nconst getSizeFromInlineBlock = (\n  size: ResizeObserverSize | ReadonlyArray<ResizeObserverSize>,\n): Size => {\n  /* istanbul ignore else */\n  if (MH.isIterableObject(size)) {\n    return {\n      [MC.S_WIDTH]: size[0][S_INLINE_SIZE],\n      [MC.S_HEIGHT]: size[0][S_BLOCK_SIZE],\n    };\n  }\n  return {\n    // in some browsers inlineSize and blockSize are scalars and nor Arrays\n    [MC.S_WIDTH]: (size as { [S_INLINE_SIZE]: number })[S_INLINE_SIZE],\n    [MC.S_HEIGHT]: (size as { [S_BLOCK_SIZE]: number })[S_BLOCK_SIZE],\n  };\n};\n\n// ------------------------------\n\nlet viewportOverlay: HTMLElement;\nlet initPromise: Promise<void> | null = null;\nconst init = (): Promise<void> => {\n  if (!initPromise) {\n    initPromise = (async () => {\n      viewportOverlay = await createOverlay({\n        id: MH.prefixName(\"vp-ovrl\"),\n        style: {\n          position: \"fixed\",\n          [MC.S_WIDTH]: \"100vw\",\n          [MC.S_HEIGHT]: \"100vh\",\n        },\n      });\n    })();\n  }\n\n  return initPromise;\n};\n","/**\n * @module Modules/XResizeObserver\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { logWarn, logError } from \"@lisn/utils/log\";\n\nimport debug from \"@lisn/debug/debug\";\n\nexport type XResizeObserverCallback = (\n  entries: ResizeObserverEntry[],\n  observer: XResizeObserver,\n) => void;\n\n/**\n * {@link XResizeObserver} is an extension of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver | ResizeObserver}\n * - observes both border box and content box size changes\n * - can skip the initial callback that happens shortly after setting up via\n *   {@link observeLater}\n * - can debounce the callback\n */\nexport class XResizeObserver {\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe | ResizeObserver:observe} except it accepts multiple targets.\n   */\n  readonly observe: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link observe} but it ignores the initial almost immediate callback\n   * and only calls the callback on a subsequent resize.\n   *\n   * If the target is already being observed, nothing is done.\n   */\n  readonly observeLater: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/unobserve | ResizeObserver:unobserve} except it accepts multiple targets.\n   */\n  readonly unobserve: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/disconnect | ResizeObserver:disconnect}.\n   */\n  readonly disconnect: () => void;\n\n  /**\n   * @param {} debounceWindow Debounce the handler so that it's called at most\n   *                          every `debounceWindow` ms.\n   */\n  constructor(callback: XResizeObserverCallback, debounceWindow?: number) {\n    const logger = debug ? new debug.Logger({ name: \"XResizeObserver\" }) : null;\n\n    // Keep the latest ResizeObserverEntry for each target during the\n    // debounceWindow. Short-lived, so ok to use a Map.\n    const buffer = MH.newMap<Element, ResizeObserverEntry>();\n\n    // Since internally we have two observers, one for border box, one for\n    // content box, we will get called initially twice for a target. So we keep\n    // a counter of 1 or 2 for how many more calls to ignore.\n    const targetsToSkip = MH.newWeakMap<Element, 1 | 2>();\n\n    let observedTargets = MH.newWeakSet<Element>();\n\n    debounceWindow = debounceWindow || 0;\n\n    let timer: ReturnType<typeof setTimeout> | null = null;\n    const resizeHandler = (entries: ResizeObserverEntry[]) => {\n      // Override entries for previous targets, but keep entries whose targets\n      // were not resized in this round\n      for (const entry of entries) {\n        const target = MH.targetOf(entry);\n        const skipNum = targetsToSkip.get(target);\n        if (skipNum !== undefined) {\n          if (skipNum === 2) {\n            // expect one more call\n            targetsToSkip.set(target, 1);\n          } else {\n            // done\n            /* istanbul ignore next */\n            if (skipNum !== 1) {\n              logError(MH.bugError(`# targetsToSkip is ${skipNum}`));\n            }\n            MH.deleteKey(targetsToSkip, target);\n          }\n\n          continue;\n        }\n\n        buffer.set(target, entry);\n      }\n\n      debug: logger?.debug9(\n        `Got ${entries.length} new entries. ` +\n          `Have ${buffer.size} unique-target entries`,\n        entries,\n      );\n\n      if (!timer && MH.sizeOf(buffer)) {\n        timer = MH.setTimer(() => {\n          if (MH.sizeOf(buffer)) {\n            callback(MH.arrayFrom(buffer.values()), this);\n            buffer.clear();\n          }\n\n          timer = null;\n        }, debounceWindow);\n      }\n    };\n\n    const borderObserver = MH.newResizeObserver(resizeHandler);\n    const contentObserver = MH.newResizeObserver(resizeHandler);\n    if (!borderObserver || !contentObserver) {\n      logWarn(\n        \"This browser does not support ResizeObserver. Some features won't work.\",\n      );\n    }\n\n    const observeTarget = (target: Element) => {\n      observedTargets.add(target);\n      borderObserver?.observe(target, { box: \"border-box\" });\n      contentObserver?.observe(target);\n    };\n\n    // --------------------\n\n    this.observe = (...targets) => {\n      debug: logger?.debug10(\"Observing targets\", targets);\n\n      for (const target of targets) {\n        observeTarget(target);\n      }\n    };\n\n    this.observeLater = (...targets) => {\n      debug: logger?.debug10(\"Observing targets (later)\", targets);\n      for (const target of targets) {\n        // Only skip them if not already observed, otherwise the initial\n        // (almost) immediate callback won't happen anyway.\n        if (observedTargets.has(target)) {\n          continue;\n        }\n\n        targetsToSkip.set(target, 2);\n        observeTarget(target);\n      }\n    };\n\n    this.unobserve = (...targets) => {\n      debug: logger?.debug10(\"Unobserving targets\", targets);\n\n      for (const target of targets) {\n        MH.deleteKey(observedTargets, target);\n        borderObserver?.unobserve(target);\n        contentObserver?.unobserve(target);\n      }\n    };\n\n    this.disconnect = () => {\n      debug: logger?.debug10(\"Disconnecting\");\n      observedTargets = MH.newWeakSet();\n      borderObserver?.disconnect();\n      contentObserver?.disconnect();\n    };\n  }\n}\n","/**\n * @module Watchers/SizeWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Box, Dimension, Size, SizeTarget } from \"@lisn/globals/types\";\n\nimport { setNumericStyleProps } from \"@lisn/utils/css-alter\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum } from \"@lisn/utils/math\";\nimport {\n  isValidBox,\n  isValidDimension,\n  getEntryBorderBox,\n  getEntryContentBox,\n  tryGetViewportOverlay,\n  fetchViewportOverlay,\n} from \"@lisn/utils/size\";\nimport { objToStrKey } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\nimport { XResizeObserver } from \"@lisn/modules/x-resize-observer\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link SizeWatcher} monitors the size of a given target. It's built on top\n * of {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver | ResizeObserver}.\n *\n * It manages registered callbacks globally and reuses ResizeObservers.\n *\n * Each instance of SizeWatcher manages up to two ResizeObservers: one\n * for content-box size changes and one for border-box size changes.\n */\nexport class SizeWatcher {\n  /**\n   * Call the given handler whenever the target's size changes.\n   *\n   * Unless {@link OnResizeOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest size data.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link onResize} or {@link trackSize},\n   * then it will be removed and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or options are invalid.\n   */\n  readonly onResize: (\n    handler: OnResizeHandler,\n    options?: OnResizeOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly offResize: (handler: OnResizeHandler, target?: SizeTarget) => void;\n\n  /**\n   * This is the same as {@link onResize} except that if `handler` is not given,\n   * then it defaults to an  handler that updates a set of CSS variables on the\n   * target's style:\n   *\n   * - If {@link OnResizeOptions.target | options.target} is not given, or is\n   *   `window`, the following CSS variables are set on the root (`html`)\n   *   element and represent the viewport size:\n   *   - `--lisn-js--window-border-width`\n   *   - `--lisn-js--window-border-height`\n   *   - `--lisn-js--window-content-width`\n   *   - `--lisn-js--window-content-height`\n   *\n   * - Otherwise, the following variables are set on the target itself and\n   *   represent its visible size:\n   *   - `--lisn-js--border-width`\n   *   - `--lisn-js--border-height`\n   *   - `--lisn-js--content-width`\n   *   - `--lisn-js--content-height`\n   *\n   * If `target` is `document`, then it will use `document.documentElement`.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link onResize} or {@link trackSize},\n   * then it will be removed and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or options are invalid.\n   */\n  readonly trackSize: (\n    handler?: OnResizeHandler | null,\n    options?: OnResizeOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackSize}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly noTrackSize: (\n    handler?: OnResizeHandler | null,\n    target?: SizeTarget,\n  ) => void;\n\n  /**\n   * Get the size of the given target. It will get the size from a\n   * ResizeObserverEntry and so it's always delayed by one frame at least.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly fetchCurrentSize: (target?: SizeTarget) => Promise<SizeData>;\n\n  /**\n   * Creates a new instance of SizeWatcher with the given\n   * {@link SizeWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: SizeWatcherConfig = {}) {\n    return new SizeWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of SizeWatcher with the given\n   * {@link SizeWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: SizeWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new SizeWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: SizeWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"SizeWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"SizeWatcher\", logAtCreation: config })\n      : null;\n\n    const allSizeData = MH.newWeakMap<Element, SizeData>();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnResizeHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const resizeHandler = (entries: ResizeObserverEntry[]) => {\n      for (const entry of entries) {\n        processEntry(entry);\n      }\n    };\n\n    // Don't debounce the observer, only callbacks.\n    const xObserver = new XResizeObserver(resizeHandler);\n\n    // ----------\n\n    const fetchCurrentSize = async (\n      target: SizeTarget | undefined,\n    ): Promise<SizeData> => {\n      const element = await fetchElement(target);\n      const sizeData = allSizeData.get(element);\n      if (sizeData) {\n        return MH.copyObject(sizeData);\n      }\n\n      return MH.newPromise((resolve) => {\n        // Use a temp ResizeObserver\n        const observer = MH.newResizeObserver((entries) => {\n          const sizeData = getSizeData(entries[0]);\n          observer?.disconnect();\n          resolve(sizeData); // no need to copy or save it\n        });\n\n        if (observer) {\n          observer.observe(element);\n        } else {\n          // Warning would have already been logged by XResizeObserver\n          resolve({\n            border: { [MC.S_WIDTH]: 0, [MC.S_HEIGHT]: 0 },\n            content: { [MC.S_WIDTH]: 0, [MC.S_HEIGHT]: 0 },\n          });\n        }\n      });\n    };\n\n    // ----------\n\n    const fetchOptions = async (\n      options: OnResizeOptions,\n    ): Promise<OnResizeOptionsInternal> => {\n      const box = options.box ?? null;\n      if (box && !isValidBox(box)) {\n        throw MH.usageError(`Unknown box type: '${box}'`);\n      }\n\n      const dimension = options.dimension ?? null;\n      if (dimension && !isValidDimension(dimension)) {\n        throw MH.usageError(`Unknown dimension: '${dimension}'`);\n      }\n\n      return {\n        _element: await fetchElement(MH.targetOf(options)),\n        _box: box,\n        _dimension: dimension,\n        // If threshold is 0, internally treat as 1 (pixel)\n        _threshold:\n          toNonNegNum(options.threshold, config._resizeThreshold) || 1,\n        _debounceWindow:\n          options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n      };\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnResizeHandler,\n      options: OnResizeOptionsInternal,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = { _callback: callback, _options: options };\n      allCallbacks.sGet(element).set(handler, entry);\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnResize = async (\n      handler: OnResizeHandler,\n      userOptions: OnResizeOptions | undefined,\n    ) => {\n      const options = await fetchOptions(userOptions || {});\n      const element = options._element;\n\n      // Don't await for the size data before creating the callback so that\n      // setupOnResize and removeOnResize have the same \"timing\" and therefore\n      // calling onResize and offResize immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options);\n      const callback = entry._callback;\n      const sizeData = await fetchCurrentSize(element);\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = sizeData;\n      allSizeData.set(element, sizeData);\n\n      // Always use observeLater. This is because the initial call to callback\n      // shouldn't be debounced, and so we call it manually here, regardless if\n      // it's a new target or not. Therefore we don't want the observer to also\n      // call it in case it _is_ a new target.\n      // It's ok if already observed, won't do anything.\n      xObserver.observeLater(element);\n\n      if (!userOptions?.skipInitial) {\n        debug: logger?.debug5(\"Calling initially with\", element, sizeData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, sizeData);\n      }\n    };\n\n    // ----------\n\n    const removeOnResize = async (\n      handler: OnResizeHandler,\n      target: SizeTarget | undefined,\n    ) => {\n      const options = await fetchOptions({ target });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setSizeCssProps) {\n          // delete the properties\n          setSizeCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnResizeHandler,\n      options: OnResizeOptionsInternal,\n    ) => {\n      const element = options._element;\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for target; unobserving\",\n          element,\n        );\n        xObserver.unobserve(element);\n        MH.deleteKey(allSizeData, element);\n      }\n    };\n\n    // ----------\n\n    const processEntry = (entry: ResizeObserverEntry) => {\n      // In reality, it can't be just a base Element\n      const element = MH.targetOf(entry);\n\n      const latestData = getSizeData(entry);\n      allSizeData.set(element, latestData);\n\n      debug: logger?.debug9(\"New size data\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        const thresholdsExceeded = hasExceededThreshold(\n          entry._options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\"Threshold not exceeded\");\n          continue;\n        }\n\n        entry._data = latestData;\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentSize = fetchCurrentSize;\n\n    // ----------\n\n    this.trackSize = async (handler?, options?) => {\n      if (!handler) {\n        handler = setSizeCssProps;\n      }\n\n      return setupOnResize(handler, options);\n    };\n\n    // ----------\n\n    this.noTrackSize = (handler?, target?) => {\n      if (!handler) {\n        handler = setSizeCssProps;\n      }\n\n      removeOnResize(handler, target); // no need to await\n    };\n\n    // ----------\n\n    this.onResize = setupOnResize;\n\n    // ----------\n\n    this.offResize = (handler, target?) => {\n      removeOnResize(handler, target); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type SizeWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnResizeOptions.debounceWindow | debounceWindow} in calls to\n   * {@link SizeWatcher.onResize}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnResizeOptions.threshold | threshold} in calls to\n   * {@link SizeWatcher.onResize}.\n   *\n   * @defaultValue 50\n   */\n  resizeThreshold?: number;\n};\n\n/**\n * @interface\n */\nexport type OnResizeOptions = {\n  /**\n   * If it is not given, or is `null` or `window`, then it will track the size\n   * of the viewport (akin to `clientHeight` on `documentElement`).\n   *\n   * If it is `document`, then it will use `document.documentElement`.\n   *\n   * Other values of target must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  target?: SizeTarget;\n\n  /**\n   * Specifies whether to listen for changes in content box size or border box\n   * size.\n   *\n   * If not given, then it listens for changes in either.\n   *\n   * @defaultValue undefined\n   */\n  box?: Box;\n\n  /**\n   * Specifies whether to listen for changes in width or height.\n   *\n   * If not given, then it listens for changes in either.\n   *\n   * @defaultValue undefined\n   */\n  dimension?: Dimension;\n\n  /**\n   * If non-0, the handler will only be called when the target's size in the\n   * observed {@link OnResizeOptions.dimension} and {@link OnResizeOptions.box}\n   * type has changed at least `threshold` pixels since the last time the\n   * handler was called.\n   *\n   * Special case when `threshold` is 0 and at least one of\n   * {@link OnResizeOptions.dimension} or {@link OnResizeOptions.box} is given:\n   * if there's a resize event but the size in the observed dimensions/box\n   * types has not changed, the callback is _not_ called.\n   *\n   * @defaultValue {@link SizeWatcherConfig.resizeThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * @defaultValue {@link SizeWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * The handler is invoked with three arguments:\n *\n * - the element that has been resized: if the target you requested was the\n *   viewport, then this will be a fixed positioned overlay that tracks the\n *   size of the viewport\n * - the {@link SizeData} for the element\n */\nexport type OnResizeHandlerArgs = [Element, SizeData];\nexport type OnResizeCallback = Callback<OnResizeHandlerArgs>;\nexport type OnResizeHandler =\n  | CallbackHandler<OnResizeHandlerArgs>\n  | OnResizeCallback;\n\nexport type SizeData = Record<Box, Size>;\n\n// ----------------------------------------\n\ntype SizeWatcherConfigInternal = {\n  _debounceWindow: number;\n  _resizeThreshold: number;\n};\n\ntype OnResizeOptionsInternal = {\n  _element: Element;\n  _box: Box | null;\n  _dimension: Dimension | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnResizeCallback;\n  _options: OnResizeOptionsInternal;\n  _data?: SizeData;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, SizeWatcher>();\n\nconst getConfig = (config: SizeWatcherConfig): SizeWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _resizeThreshold: toNonNegNum(config.resizeThreshold, 50) || 1,\n  };\n};\n\n// --------------------\n\nconst hasExceededThreshold = (\n  options: OnResizeOptionsInternal,\n  latestData: SizeData,\n  lastThresholdData: SizeData | undefined,\n): boolean => {\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  let box: Box, dim: Dimension;\n  for (box in latestData) {\n    if (options._box && options._box !== box) {\n      continue;\n    }\n\n    for (dim in latestData[box]) {\n      if (options._dimension && options._dimension !== dim) {\n        continue;\n      }\n\n      const diff = MH.abs(latestData[box][dim] - lastThresholdData[box][dim]);\n      if (diff >= options._threshold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst getSizeData = (entry: ResizeObserverEntry): SizeData => {\n  const borderBox = getEntryBorderBox(entry, true);\n  const contentBox = getEntryContentBox(entry);\n\n  return {\n    border: borderBox,\n    content: contentBox,\n  };\n};\n\nconst setSizeCssProps = (\n  element: Element,\n  sizeData: SizeData | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetViewportOverlay()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"window-\";\n  }\n\n  const props = {\n    borderWidth: sizeData?.border[MC.S_WIDTH],\n    borderHeight: sizeData?.border[MC.S_HEIGHT],\n    contentWidth: sizeData?.content[MC.S_WIDTH],\n    contentHeight: sizeData?.content[MC.S_HEIGHT],\n  };\n  setNumericStyleProps(element, props, { _prefix: prefix }); // don't await here\n};\n\nconst fetchElement = async (\n  target: SizeTarget | undefined,\n): Promise<Element> => {\n  if (MH.isElement(target)) {\n    return target;\n  }\n\n  if (!target || target === MH.getWindow()) {\n    return fetchViewportOverlay();\n  }\n\n  if (target === MH.getDoc()) {\n    return MH.getDocElement();\n  }\n\n  throw MH.usageError(\"Unsupported resize target\");\n};\n\nconst invokeCallback = (\n  callback: OnResizeCallback,\n  element: Element,\n  sizeData: SizeData,\n) => callback.invoke(element, MH.copyObject(sizeData)).catch(logError);\n","/**\n * @module Watchers/LayoutWatcher\n */\n\n// NOTES FOR DEVELOPERS\n//\n// For each layout (device or aspect ratio), we create an overlay that has a\n// a width that corresponds to the layout:\n//  - for device layouts, it's a fixed width in pixels, equal to the minimum\n//    width of the device\n//  - for aspect ratio layouts, the overlay has a width that's relative to\n//    the root's height, equal to the minimum width of the aspect ratio\n//\n// Then we observe each overlay with an IntersectionObserver whose root\n// is this Watcher's root and whose root margin is -100% from the left (i.e.\n// right-most edge of the root).\n//\n// If the root is null, i.e. the viewport, the overlays will have a \"fixed\"\n// position and be inserted in document.body. Otherwise, they'll be inserted\n// in the root element with an \"absolute\" position. The root element, if not\n// body must be positioned. It gets a default position of \"relative\" through\n// the class `.lisn-overlay-container`, which Overlays ensures it gets.\n//\n// If using custom root we track its size through SizeWatcher as the\n// aspectRatio overlays are relative to the height, and we can't rely on CSS\n// alone as the root may not have a fixed height through CSS.\n//\n// Whenever any overlay intersects the root, this means that the viewport\n// width is now equal to or narrower than the overlay.\n//\n// ~~~~ The current device or aspect ratio corresponds to the _widest_\n// ~~~~ overlay that does not intersect.\n//\n// For example:\n//\n// | mobile\n// ========| mobile-wide\n// ======================| tablet\n// =========================================| desktop\n//\n// _________________________________| viewport width\n//\n// Here, mobile, mobile-wide and tablet overlays are _not_ intersecting, only\n// desktop intersects. The device layout is therefore tablet.\n//\n// Therefore:\n// - have the layout bit spaces ordered from narrowest layout at lowest bit\n//   to widest layout at hightest bit\n// - keep a running bitmask of which overlays are not intersecting and update\n//   it each time there is an IntersectionObserverEntry.\n// - get the highest device or aspect ratio bit in that bitmask to find out\n//   the widest non-intersecting overlay\n//\n// For simplicity we create overlays also for layouts that have a 0-width.\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  Layout,\n  DeviceSpec,\n  Device,\n  AspectRatioSpec,\n  AspectRatio,\n} from \"@lisn/globals/types\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport {\n  getLayoutBitmask,\n  NUM_LAYOUTS,\n  ORDERED_DEVICES,\n  ORDERED_ASPECTR,\n} from \"@lisn/utils/layout\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { omitKeys, copyExistingKeys } from \"@lisn/utils/misc\";\nimport { createOverlay } from \"@lisn/utils/overlays\";\nimport { objToStrKey } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap } from \"@lisn/modules/x-map\";\n\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link LayoutWatcher} listens for changes in either the width or aspect\n * ratio of the viewport or the given {@link LayoutWatcherConfig.root | root}.\n *\n * It does not track resize events; rather it's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}.\n *\n * It manages registered callbacks globally and reuses IntersectionObservers\n * for more efficient performance.\n */\nexport class LayoutWatcher {\n  /**\n   * Call the given handler whenever the layout changes.\n   *\n   * Unless {@link OnLayoutOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the current layout.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times, even if\n   * the options differ. If the handler has already been added, it is removed\n   * and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onLayout: (\n    handler: OnLayoutHandler,\n    options?: OnLayoutOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offLayout: (handler: OnLayoutHandler) => void;\n\n  /**\n   * Get the current screen layout.\n   */\n  readonly fetchCurrentLayout: () => Promise<LayoutData>;\n\n  /**\n   * Creates a new instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: LayoutWatcherConfig = {}) {\n    return new LayoutWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: LayoutWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    let instance = instances.get(myConfig._root)?.get(configStrKey);\n    if (!instance) {\n      instance = new LayoutWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(myConfig._root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: LayoutWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"LayoutWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"LayoutWatcher\", logAtCreation: config })\n      : null;\n    let nonIntersectingBitmask = 0;\n    let currentLayoutData: LayoutData = {\n      device: null,\n      aspectRatio: null,\n    };\n\n    const allCallbacks = MH.newMap<\n      OnLayoutHandler,\n      {\n        _callback: OnLayoutCallback;\n        _layoutBitmask: number;\n      }\n    >();\n\n    // ----------\n\n    const fetchCurrentLayout = async (): Promise<LayoutData> => {\n      await readyPromise;\n\n      return MH.copyObject(currentLayoutData);\n    };\n\n    // ----------\n\n    const setupOverlays = async () => {\n      const { root, overlays } = await createOverlays(\n        config._root,\n        config._deviceBreakpoints,\n        config._aspectRatioBreakpoints,\n      );\n\n      return MH.newPromise<void>((resolve) => {\n        let isReady = false;\n\n        const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n          const numEntries = MH.lengthOf(entries);\n          debug: logger?.debug9(`Got ${numEntries} new entries`, entries);\n\n          if (!isReady) {\n            /* istanbul ignore next */ // shouldn't happen\n            if (numEntries < NUM_LAYOUTS) {\n              logWarn(\n                MH.bugError(\n                  `Got IntersectionObserver ${numEntries}, ` +\n                    `expected >= ${NUM_LAYOUTS}`,\n                ),\n              );\n            }\n          }\n\n          for (const entry of entries) {\n            nonIntersectingBitmask = getNonIntersecting(\n              nonIntersectingBitmask,\n              entry,\n            );\n          }\n\n          // If this is the initial call from IntersectionObserver, skip callbacks.\n          // Those that have skipInitial: false would be called elsewhere, by\n          // setupOnLayout\n          processLayoutChange(!isReady);\n          isReady = true;\n          resolve(); // ready after IntersectionObserver has called us the 1st time\n        };\n\n        // ----------\n\n        const observeOptions = {\n          root,\n          rootMargin: \"5px 0% 5px -100%\",\n        };\n\n        const observer = MH.newIntersectionObserver(\n          intersectionHandler,\n          observeOptions,\n        );\n\n        for (const triggerOverlay of overlays) {\n          observer.observe(triggerOverlay);\n        }\n      });\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnLayoutHandler,\n      layoutBitmask: number,\n    ): OnLayoutCallback => {\n      MH.remove(allCallbacks.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", layoutBitmask);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        deleteHandler(handler);\n      });\n\n      allCallbacks.set(handler, {\n        _callback: callback,\n        _layoutBitmask: layoutBitmask,\n      });\n      return callback;\n    };\n\n    const setupOnLayout = async (\n      handler: OnLayoutHandler,\n      options: OnLayoutOptions | undefined,\n    ) => {\n      const layoutBitmask = getLayoutBitmask(options);\n      const callback = createCallback(handler, layoutBitmask);\n\n      if (options?.skipInitial) {\n        return;\n      }\n\n      const layoutData = await fetchCurrentLayout();\n\n      if (\n        !callback.isRemoved() &&\n        changeMatches(layoutBitmask, layoutData, null)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", layoutData);\n        await invokeCallback(callback, layoutData);\n      }\n    };\n\n    const deleteHandler = (handler: OnLayoutHandler) => {\n      MH.deleteKey(allCallbacks, handler);\n      // no need to unobserve the overlays\n    };\n\n    const processLayoutChange = (skipCallbacks: boolean) => {\n      const deviceBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_DEVICES.bitmask),\n      );\n\n      const aspectRatioBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_ASPECTR.bitmask),\n      );\n\n      const layoutData: LayoutData = { device: null, aspectRatio: null };\n\n      // -Infinity means all of the overlays are intersecting, which would only\n      // happen if the narrowest overlay is not actually 0-width (which is not the\n      // case by default and against the recommended settings).\n      if (deviceBit !== -MC.INFINITY) {\n        layoutData.device = ORDERED_DEVICES.nameOf(1 << deviceBit);\n      }\n      if (aspectRatioBit !== -MC.INFINITY) {\n        layoutData.aspectRatio = ORDERED_ASPECTR.nameOf(1 << aspectRatioBit);\n      }\n\n      debug: logger?.debug8(\"New layout\", layoutData);\n\n      if (!skipCallbacks) {\n        for (const entry of allCallbacks.values()) {\n          const layoutBitmask = entry._layoutBitmask;\n          if (!changeMatches(layoutBitmask, layoutData, currentLayoutData)) {\n            debug: logger?.debug9(\n              `Layout change does not match bitmask ${layoutBitmask}`,\n            );\n            continue;\n          }\n\n          invokeCallback(entry._callback, layoutData);\n        }\n      }\n\n      currentLayoutData = layoutData;\n    };\n\n    const readyPromise = setupOverlays(); // no need to await\n\n    // ----------\n\n    this.fetchCurrentLayout = fetchCurrentLayout;\n\n    // ----------\n\n    this.onLayout = setupOnLayout;\n\n    // ----------\n\n    this.offLayout = (handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type LayoutWatcherConfig = {\n  /**\n   * The root element whose layout to watch. If not given or `null`, then the\n   * viewport layout is watched.\n   *\n   * @defaultValue null\n   */\n  root?: HTMLElement | null;\n\n  /**\n   * Use custom device breakpoints. Only known device names ({@link Device})\n   * are supported. If any are missing from the given dictionary, the value\n   * from {@link settings.deviceBreakpoints} is used.\n   *\n   * @defaultValue {@link settings.deviceBreakpoints}\n   */\n  deviceBreakpoints?: typeof settings.deviceBreakpoints;\n\n  /**\n   * Use custom aspect ratio breakpoints. Only known aspect ratio names\n   * ({@link AspectRatio}) are supported. If any are missing from the given\n   * dictionary, the value from {@link settings.aspectRatioBreakpoints} is\n   * used.\n   *\n   * @defaultValue {@link settings.aspectRatioBreakpoints}\n   */\n  aspectRatioBreakpoints?: typeof settings.aspectRatioBreakpoints;\n};\n\n/**\n * @interface\n */\nexport type OnLayoutOptions = {\n  /**\n   * Specifies a list of {@link Device}s to target for.\n   *\n   * The handler will only be called if there is a change of device to a device\n   * matching the specification.\n   *\n   * It can be:\n   * - \"min <Device>\": devices at least as wide as `<Device>`\n   * - \"max <Device>\": devices at most as wide as `<Device>`\n   * - \"<DeviceMin> to <DeviceMax>\": devices at least as wide as `<DeviceMin>`\n   *                                 and at most as wide as `<DeviceMax>`\n   * - a comma-separated list of device names\n   * - an array of device names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * Also note that an empty array is treated the same as not given, or `null`.\n   *\n   * @defaultValue undefined\n   */\n  devices?: DeviceSpec | Device[];\n\n  /**\n   * Specifies a list of {@link AspectRatio}s to target for.\n   *\n   * The handler will only be called if there is a change of aspect ratio to\n   * an aspect ratios matching the specification.\n   *\n   * It can be:\n   * - \"min <AspectRatio>\": aspect ratios at least as wide as `<AspectRatio>`\n   * - \"max <AspectRatio>\": aspect ratios at most as wide as `<AspectRatio>`\n   * - \"<AspectRatioMin> to <AspectRatioMax>\": aspect ratios at least as wide\n   *                        as `<AspectRatioMin>` and at most as wide as\n   *                        `<AspectRatioMax>`\n   * - a comma-separated list of aspect ratio names\n   * - an array of aspect ratio names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * @defaultValue undefined\n   */\n  aspectRatios?: AspectRatioSpec | AspectRatio[];\n\n  /**\n   * Do not call the handler until there's a future change of layout.\n   *\n   * By default, we call the handler (almost) immediately with the current\n   * layout data if it matches the given {@link devices} and {@link aspectRatios}.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * The handler is invoked with one argument:\n *\n * - the current {@link LayoutData}\n */\nexport type OnLayoutHandlerArgs = [LayoutData];\nexport type OnLayoutCallback = Callback<OnLayoutHandlerArgs>;\nexport type OnLayoutHandler =\n  | CallbackHandler<OnLayoutHandlerArgs>\n  | OnLayoutCallback;\n\n/**\n * Note that {@link device} or {@link aspectRatio} would only be null if the\n * viewport is narrower than the narrowest device/aspect ratio. This would only\n * happen if the narrowest device/aspect ratio is _not_ 0-width (which is not\n * the case with the default breakpoints and is against the recommendation for\n * setting breakpoints.\n */\nexport type LayoutData = {\n  device: Device | null;\n  aspectRatio: AspectRatio | null;\n};\n\n// ----------------------------------------\n\ntype LayoutWatcherConfigInternal = {\n  _root: HTMLElement | null;\n  _deviceBreakpoints: typeof settings.deviceBreakpoints;\n  _aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<HTMLElement | null, Map<string, LayoutWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst VAR_BORDER_HEIGHT = MH.prefixCssJsVar(\"border-height\");\nconst PREFIX_DEVICE = MH.prefixName(\"device\");\nconst PREFIX_ASPECTR = MH.prefixName(\"aspect-ratio\");\n\nconst getConfig = (\n  config: LayoutWatcherConfig | undefined,\n): LayoutWatcherConfigInternal => {\n  const deviceBreakpoints = MH.copyObject(settings.deviceBreakpoints);\n  if (config?.deviceBreakpoints) {\n    copyExistingKeys(config.deviceBreakpoints, deviceBreakpoints);\n  }\n\n  const aspectRatioBreakpoints = MH.copyObject(settings.aspectRatioBreakpoints);\n\n  if (config?.aspectRatioBreakpoints) {\n    copyExistingKeys(config.aspectRatioBreakpoints, aspectRatioBreakpoints);\n  }\n\n  return {\n    _root: config?.root || null,\n    _deviceBreakpoints: deviceBreakpoints,\n    _aspectRatioBreakpoints: aspectRatioBreakpoints,\n  };\n};\n\n// ----------------------------------------\n\nconst createOverlays = async (\n  root: HTMLElement | null,\n  deviceBreakpoints: typeof settings.deviceBreakpoints,\n  aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints,\n) => {\n  const overlayPromises = [];\n\n  let overlayParent: HTMLElement;\n  if (root) {\n    overlayParent = root;\n  } else {\n    // Since modals remove the scrollbar on the body when active, the width of\n    // the body changes upon open/close of a modal, which would create\n    // glitching if it happens near a device breakpoint. So if the root is the\n    // viewport, we create a fixed positioned container to hold the overlays\n    // and set its width to be 100vw and use that as the root of\n    overlayParent = await createOverlay({\n      style: {\n        position: \"fixed\",\n        [MC.S_WIDTH]: \"100vw\",\n      },\n    });\n  }\n\n  let device: Device;\n  for (device in deviceBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]: deviceBreakpoints[device] + \"px\",\n        },\n        data: {\n          [PREFIX_DEVICE]: device,\n        },\n      }),\n    );\n  }\n\n  const parentHeightCss = root ? `var(${VAR_BORDER_HEIGHT}, 0) * 1px` : \"100vh\";\n  if (root) {\n    SizeWatcher.reuse().trackSize(null, { target: root });\n  }\n\n  let aspectRatio: AspectRatio;\n  for (aspectRatio in aspectRatioBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]:\n            `calc(${aspectRatioBreakpoints[aspectRatio]} ` +\n            `* ${parentHeightCss})`,\n        },\n        data: {\n          [PREFIX_ASPECTR]: aspectRatio,\n        },\n      }),\n    );\n  }\n\n  const overlays = await MH.promiseAll(overlayPromises);\n  return { root: overlayParent, overlays };\n};\n\nconst getOverlayLayout = (overlay: HTMLElement): Layout | null => {\n  const layout =\n    getData(overlay, PREFIX_DEVICE) || getData(overlay, PREFIX_ASPECTR);\n  /* istanbul ignore else */\n  if (layout && (ORDERED_DEVICES.has(layout) || ORDERED_ASPECTR.has(layout))) {\n    return layout;\n  } else {\n    // shouldn't happen\n    logError(MH.bugError(\"No device or aspectRatio data attribute\"));\n    return null;\n  }\n};\n\nconst changeMatches = (\n  layoutBitmask: number,\n  thisLayoutData: LayoutData,\n  prevLayoutData: LayoutData | undefined | null,\n): boolean => {\n  // True if the callback is interested in a change of device and there's a\n  // change of device and the new device is one of the ones it's interested in\n  // (or it's null, i.e. device is undefined).\n  // And the same for aspect ratios.\n\n  if (\n    prevLayoutData?.device !== thisLayoutData.device &&\n    (!thisLayoutData.device ||\n      ORDERED_DEVICES.bit[thisLayoutData.device] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  if (\n    prevLayoutData?.aspectRatio !== thisLayoutData.aspectRatio &&\n    (!thisLayoutData.aspectRatio ||\n      ORDERED_ASPECTR.bit[thisLayoutData.aspectRatio] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getNonIntersecting = (\n  nonIntersectingBitmask: number, // current\n  entry: IntersectionObserverEntry,\n): number => {\n  const target = MH.targetOf(entry);\n  /* istanbul ignore next */ // shouldn't happen\n  if (!MH.isHTMLElement(target)) {\n    logError(\n      MH.bugError(\n        `IntersectionObserver called us with '${MH.typeOrClassOf(target)}'`,\n      ),\n    );\n    return nonIntersectingBitmask;\n  }\n\n  const layout = getOverlayLayout(target);\n  let bit = 0;\n  if (!layout) {\n    // error already logged by getOverlayLayout\n  } else if (ORDERED_DEVICES.has(layout)) {\n    bit = ORDERED_DEVICES.bit[layout];\n  } else if (ORDERED_ASPECTR.has(layout)) {\n    bit = ORDERED_ASPECTR.bit[layout];\n  } else {\n    /* istanbul ignore next */ // shouldn't happen\n    logError(\n      MH.bugError(`Unknown device or aspectRatio data attribute: ${layout}`),\n    );\n  }\n\n  if (entry.isIntersecting) {\n    nonIntersectingBitmask &= ~bit;\n  } else {\n    nonIntersectingBitmask |= bit;\n  }\n\n  return nonIntersectingBitmask;\n};\n\nconst invokeCallback = (callback: OnLayoutCallback, layoutData: LayoutData) =>\n  callback.invoke(MH.copyObject(layoutData)).catch(logError);\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { PointerAction } from \"@lisn/globals/types\";\n\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\n/**\n * Returns true if the given string is a valid pointer action.\n *\n * @category Validation\n */\nexport const isValidPointerAction = (action: string): action is PointerAction =>\n  MH.includes(POINTER_ACTIONS, action);\n\n/**\n * Returns true if the given string or array is a valid list of pointer\n * actions.\n *\n * @category Validation\n */\nexport const isValidPointerActionList = (actions: string | string[]) =>\n  isValidStrList(actions, isValidPointerAction, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const POINTER_ACTIONS: PointerAction[] = [\n  MC.S_CLICK,\n  MC.S_HOVER,\n  MC.S_PRESS,\n] as const;\n","/**\n * @module Watchers/PointerWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { PointerAction, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { isValidPointerAction, POINTER_ACTIONS } from \"@lisn/utils/pointer\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\n/**\n * {@link PointerWatcher} listens for simple pointer actions like clicks, press\n * and hold or hover.\n */\nexport class PointerWatcher {\n  /**\n   * Call the `startHandler` whenever the pointer action begins.\n   * Call the `endHandler` whenever the pointer action ends. If `endHandler` is\n   * not given, it defaults to `startHandler`.\n   *\n   * For an explanation of what \"begins\" and \"ends\" means for each supported\n   * action, see {@link OnPointerOptions.actions}.\n   *\n   * **IMPORTANT:** The same handlers can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, then it will be removed and re-added with the\n   * current options.\n   */\n  readonly onPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n    options?: OnPointerOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes previously added handlers.\n   */\n  readonly offPointer: (\n    target: EventTarget,\n    startHandler: OnPointerHandler,\n    endHandler?: OnPointerHandler,\n  ) => void;\n\n  /**\n   * Creates a new instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: PointerWatcherConfig = {}) {\n    return new PointerWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of PointerWatcher with the given\n   * {@link PointerWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: PointerWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new PointerWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: PointerWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"PointerWatcher.create\");\n    }\n\n    // Keep this watcher super simple. The events we listen for don't fire at a\n    // high rate and it's unlikely for there to be many many callbacks for each\n    // target and event type, so don't bother with using a delegating listener,\n    // etc.\n\n    // Keep a map of callbacks so we can lookup the callback by the handler\n    // (and also to prevent duplicate handler for each target, for consistency\n    // with other watchers).\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<OnPointerHandler, OnPointerCallback>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnPointerHandler,\n    ): OnPointerCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler));\n\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        MH.deleteKey(allCallbacks.get(target), handler);\n      });\n\n      allCallbacks.sGet(target).set(handler, callback);\n      return callback;\n    };\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnPointer = async (\n      target: EventTarget,\n      startHandler: OnPointerHandler,\n      endHandler: OnPointerHandler | undefined,\n      userOptions: OnPointerOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions);\n      const startCallback = createCallback(target, startHandler);\n      const endCallback =\n        endHandler && endHandler !== startHandler\n          ? createCallback(target, endHandler)\n          : startCallback;\n\n      for (const action of options._actions) {\n        listenerSetupFn[action](target, startCallback, endCallback, options);\n      }\n    };\n\n    // ----------\n\n    this.onPointer = setupOnPointer;\n\n    // ----------\n\n    this.offPointer = (target, startHandler, endHandler?) => {\n      const entry = allCallbacks.get(target);\n      MH.remove(entry?.get(startHandler));\n      if (endHandler) {\n        MH.remove(entry?.get(endHandler));\n      }\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type PointerWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventDefault | preventDefault} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue false\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnPointerOptions.preventSelect | preventSelect} in calls to\n   * {@link PointerWatcher.onPointer}.\n   *\n   * @defaultValue true\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * @interface\n */\nexport type OnPointerOptions = {\n  /**\n   * One or more of of \"click\", \"hover\" or \"press\". If not specified, then all\n   * actions are enabled.\n   *\n   * It can be a comma-separated list of {@link PointerAction}s or an array of\n   * such actions.\n   *\n   * For click actions, the start handler is called for every odd number of\n   * clicks (1st, 3rd, 5th, etc), and the end handler is called for every other\n   * click. It functions like a toggle.\n   *\n   * For hover and press actions, the start handler is called when the pointer\n   * enters or presses down on the target respectively, and the end handler is\n   * called when the pointer leaves or comes off the target respectively.\n   *\n   * Note that on touch screens, hover and press actions behave identically.\n   *\n   * @defaultValue undefined\n   */\n  actions?: CommaSeparatedStr<PointerAction> | PointerAction[];\n\n  /**\n   * If true, the events of the pointer actions, e.g. click, will have their\n   * default action prevented.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If true (default), then for press actions (and hover actions on touch\n   * screens) it will prevent starting a text selection.\n   *\n   * @defaultValue {@link PointerWatcherConfig.preventSelect}\n   */\n  preventSelect?: boolean;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link PointerWatcher.onPointer}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link PointerActionData} describing the state of the action.\n */\nexport type OnPointerHandlerArgs = [EventTarget, PointerActionData, Event];\nexport type OnPointerCallback = Callback<OnPointerHandlerArgs>;\nexport type OnPointerHandler =\n  | CallbackHandler<OnPointerHandlerArgs>\n  | OnPointerCallback;\n\nexport type PointerActionData = {\n  action: PointerAction;\n  state: \"ON\" | \"OFF\";\n};\n\n// ----------------------------------------\n\ntype PointerWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\ntype OnPointerOptionsInternal = {\n  _actions: PointerAction[];\n  _preventDefault: boolean;\n  _preventSelect: boolean;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, PointerWatcher>();\n\nconst getConfig = (\n  config: PointerWatcherConfig | undefined,\n): PointerWatcherConfigInternal => {\n  return {\n    _preventDefault: config?.preventDefault ?? false,\n    _preventSelect: config?.preventSelect ?? true,\n  };\n};\n\nconst getOptions = (\n  config: PointerWatcherConfigInternal,\n  options: OnPointerOptions | undefined,\n): OnPointerOptionsInternal => {\n  return {\n    _actions:\n      validateStrList(\"actions\", options?.actions, isValidPointerAction) ||\n      POINTER_ACTIONS,\n    _preventDefault: options?.preventDefault ?? config._preventDefault,\n    _preventSelect: options?.preventSelect ?? config._preventSelect,\n  };\n};\n\nconst setupClickListener = (\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // false if next will start; true if next will end.\n  let toggleState = false;\n\n  const wrapper = (event: Event) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    toggleState = !toggleState;\n\n    const data: PointerActionData = {\n      action: MC.S_CLICK,\n      state: toggleState ? \"ON\" : \"OFF\",\n    };\n\n    invokeCallback(\n      toggleState ? startCallback : endCallback,\n      target,\n      data,\n      event,\n    );\n  };\n\n  addEventListenerTo(target, MC.S_CLICK, wrapper);\n\n  const remove = () => removeEventListenerFrom(target, MC.S_CLICK, wrapper);\n\n  startCallback.onRemove(remove);\n  endCallback.onRemove(remove);\n};\n\nconst setupPointerListeners = (\n  action: typeof MC.S_HOVER | typeof MC.S_PRESS,\n  target: EventTarget,\n  startCallback: OnPointerCallback,\n  endCallback: OnPointerCallback,\n  options: OnPointerOptionsInternal,\n) => {\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform these into mouse*\n  const startEventSuff = action === MC.S_HOVER ? \"enter\" : \"down\";\n  const endEventSuff = action === MC.S_HOVER ? \"leave\" : \"up\";\n  const startEvent = MC.S_POINTER + startEventSuff;\n  const endEvent = MC.S_POINTER + endEventSuff;\n\n  const wrapper = (event: Event, callback: OnPointerCallback) => {\n    if (options._preventDefault) {\n      MH.preventDefault(event);\n    }\n\n    const data: PointerActionData = {\n      action,\n      state:\n        MH.strReplace(event.type, /pointer|mouse/, \"\") === startEventSuff\n          ? \"ON\"\n          : \"OFF\",\n    };\n\n    invokeCallback(callback, target, data, event);\n  };\n  const startListener = (event: Event) => wrapper(event, startCallback);\n  const endListener = (event: Event) => wrapper(event, endCallback);\n\n  addEventListenerTo(target, startEvent, startListener);\n  addEventListenerTo(target, endEvent, endListener);\n\n  // On some touch screen devices pressing and holding will initiate select\n  // and result in touchend, so we prevent text select\n  if (options._preventSelect) {\n    preventSelect(target);\n  }\n\n  startCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, startEvent, startListener);\n  });\n\n  endCallback.onRemove(() => {\n    undoPreventSelect(target);\n    removeEventListenerFrom(target, endEvent, endListener);\n  });\n};\n\nconst listenerSetupFn: {\n  [D in PointerAction]: (\n    target: EventTarget,\n    startCallback: OnPointerCallback,\n    endCallback: OnPointerCallback,\n    options: OnPointerOptionsInternal,\n  ) => void;\n} = {\n  click: setupClickListener,\n  hover: (...args) => setupPointerListeners(MC.S_HOVER, ...args),\n  press: (...args) => setupPointerListeners(MC.S_PRESS, ...args),\n} as const;\n\nconst invokeCallback = (\n  callback: OnPointerCallback,\n  target: EventTarget,\n  actionData: PointerActionData,\n  event: Event,\n) => callback.invoke(target, MH.copyObject(actionData), event).catch(logError);\n","/**\n * @module Watchers/ScrollWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { XYDirection, ScrollDirection, SizeTarget } from \"@lisn/globals/types\";\n\nimport {\n  ScrollTarget,\n  TargetCoordinate,\n  TargetCoordinates,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { getData, setNumericStyleProps } from \"@lisn/utils/css-alter\";\nimport { getMaxDeltaDirection } from \"@lisn/utils/directions\";\nimport { moveElement, wrapScrollingContent } from \"@lisn/utils/dom-alter\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError } from \"@lisn/utils/log\";\nimport { toNonNegNum, maxAbs } from \"@lisn/utils/math\";\nimport {\n  scrollTo,\n  getCurrentScrollAction,\n  getClientWidthNow,\n  getClientHeightNow,\n  tryGetMainScrollableElement,\n  fetchMainContentElement,\n  fetchMainScrollableElement,\n  fetchScrollableElement,\n  isValidScrollDirection,\n  ScrollAction,\n  ScrollToOptions,\n} from \"@lisn/utils/scroll\";\nimport { objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { MutationOperation, DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n// re-export for convenience\nexport type { ScrollAction, ScrollToOptions } from \"@lisn/utils/scroll\";\n\n/**\n * {@link ScrollWatcher} listens for scroll events in any direction.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class ScrollWatcher {\n  /**\n   * Call the given handler whenever the given scrollable is scrolled.\n   *\n   * Unless {@link OnScrollOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the latest scroll data. If a scroll has\n   * not yet been observed on the scrollable and its `scrollTop` and\n   * `scrollLeft` are 0, then the direction is {@link Types.NoDirection} and\n   * the handler is only called if {@link Types.NoDirection} is part of the\n   * supplied {@link OnScrollOptions.directions | options.directions} (or\n   * {@link OnScrollOptions.directions | options.directions} is not given).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking content size changes using\n   * {@link trackScroll}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onScroll: (\n    handler: OnScrollHandler,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly offScroll: (\n    handler: OnScrollHandler,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * This everything that {@link onScroll} does plus more:\n   *\n   * In addition to a scroll event, the handler is also called when either the\n   * offset size or scroll (content) size of the scrollable changes as that\n   * would affect its `scrollTopFraction` and `scrollLeftFraction` and possibly\n   * the `scrollTop` and `scrollLeft` as well.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same scrollable, even if the options differ. If the handler has already\n   * been added for this scrollable, either using {@link trackScroll} or using\n   * {@link onScroll}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates a set of CSS variables on the scrollable element's style:\n   *\n   * - If {@link OnScrollOptions.scrollable | options.scrollable} is not given,\n   *   or is `null`, `window` or `document`, the following CSS variables are\n   *   set on the root (`html`) element and represent the scroll of the\n   *   {@link fetchMainScrollableElement}:\n   *   - `--lisn-js--page-scroll-top`\n   *   - `--lisn-js--page-scroll-top-fraction`\n   *   - `--lisn-js--page-scroll-left`\n   *   - `--lisn-js--page-scroll-left-fraction`\n   *   - `--lisn-js--page-scroll-width`\n   *   - `--lisn-js--page-scroll-height`\n   *\n   * - Otherwise, the following variables are set on the scrollable itself,\n   *   and represent its scroll offset:\n   *   - `--lisn-js--scroll-top`\n   *   - `--lisn-js--scroll-top-fraction`\n   *   - `--lisn-js--scroll-left`\n   *   - `--lisn-js--scroll-left-fraction`\n   *   - `--lisn-js--scroll-width`\n   *   - `--lisn-js--scroll-height`\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackScroll: (\n    handler?: OnScrollHandler | null,\n    options?: OnScrollOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackScroll}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly noTrackScroll: (\n    handler?: OnScrollHandler | null,\n    scrollable?: ScrollTarget,\n  ) => void;\n\n  /**\n   * Get the scroll offset of the given scrollable. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param {} realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                    this only when doing realtime scroll-based animations\n   *                    as it may cause a forced layout.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScroll: (\n    scrollable?: ScrollTarget,\n    realtime?: boolean,\n  ) => Promise<ScrollData>;\n\n  /**\n   * Scrolls the given scrollable element to in the given direction.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the direction or options are invalid.\n   */\n  readonly scroll: (\n    direction: XYDirection,\n    options?: ScrollOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Scrolls the given scrollable element to the given `to` scrollable.\n   *\n   * Returns `null` if there's an ongoing scroll that is not cancellable.\n   *\n   * Note that if `to` is an element or a selector, then it _must_ be a\n   * descendant of the scrollable element.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the \"to\" coordinates or options are invalid.\n   *\n   * @param {} to  If this is an element, then its top-left position is used as\n   *               the target coordinates. If it is a string, then it is treated\n   *               as a selector for an element using `querySelector`.\n   * @param {} [options.scrollable]\n   *               If not given, it defaults to {@link fetchMainScrollableElement}\n   *\n   * @return {} `null` if there's an ongoing scroll that is not cancellable,\n   * otherwise a {@link ScrollAction}.\n   */\n  readonly scrollTo: (\n    to: TargetCoordinates | Element | string,\n    options?: ScrollToOptions,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Returns the current {@link ScrollAction} if any.\n   *\n   * @param {} scrollable\n   *               If not given, it defaults to {@link fetchMainScrollableElement}\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   */\n  readonly fetchCurrentScrollAction: (\n    scrollable?: Element,\n  ) => Promise<ScrollAction | null>;\n\n  /**\n   * Cancels the ongoing scroll that's resulting from smooth scrolling\n   * triggered in the past. Does not interrupt or prevent further scrolling.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the scrollable is invalid.\n   *\n   * @param {} [options.immediate]  If true, then it will not use\n   *                                {@link waitForMeasureTime} or\n   *                                {@link Utils.waitForMutateTime | waitForMutateTime}.\n   *                                Warning: this will likely result in forced layout.\n   */\n  readonly stopUserScrolling: (options?: {\n    scrollable?: ScrollTarget;\n    immediate?: boolean;\n  }) => Promise<void>;\n\n  /**\n   * Returns the element that holds the main page content. By default it's\n   * `document.body` but is overridden by\n   * {@link settings.mainScrollableElementSelector}.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainContentElement(): Promise<HTMLElement> {\n    return fetchMainContentElement();\n  }\n\n  /**\n   * Returns the scrollable element that holds the wrapper around the main page\n   * content. By default it's `document.scrollable` (unless `document.body` is\n   * actually scrollable, in which case it will be used) but it will be\n   * different if {@link settings.mainScrollableElementSelector} is set.\n   *\n   * It will wait for the element to be available if not already.\n   */\n  static fetchMainScrollableElement(): Promise<HTMLElement> {\n    return fetchMainScrollableElement();\n  }\n\n  /**\n   * Creates a new instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ScrollWatcherConfig = {}) {\n    return new ScrollWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of ScrollWatcher with the given\n   * {@link ScrollWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ScrollWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new ScrollWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ScrollWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ScrollWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ScrollWatcher\", logAtCreation: config })\n      : null;\n\n    const allScrollData = MH.newWeakMap<Element, ScrollData>();\n\n    const activeListeners = MH.newWeakMap<\n      ScrollTarget,\n      { _nRealtime: number }\n    >();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<OnScrollHandler, CallbackEntry>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const fetchCurrentScroll = async (\n      element: Element,\n      realtime = false,\n      isScrollEvent = false,\n    ): Promise<ScrollData> => {\n      // The scroll data can change event without a scroll event, e.g. by the\n      // element changing size, so always get the latest here.\n      const previousEventData = allScrollData.get(element);\n      const latestData = await fetchScrollData(\n        element,\n        previousEventData,\n        realtime,\n      );\n\n      // If there hasn't been a scroll event, use the old scroll direction\n      if (!isScrollEvent && previousEventData) {\n        latestData.direction = previousEventData.direction;\n      }\n      return latestData;\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n      trackType: TrackType,\n    ): CallbackEntry => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler, options._debounceWindow);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      const entry = {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      };\n      allCallbacks.sGet(element).set(handler, entry);\n\n      return entry;\n    };\n\n    // ----------\n\n    const setupOnScroll = async (\n      handler: OnScrollHandler,\n      userOptions: OnScrollOptions | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, userOptions || {});\n      const element = options._element;\n\n      // Don't await for the scroll data before creating the callback so that\n      // setupOnScroll and removeOnScroll have the same \"timing\" and therefore\n      // calling onScroll and offScroll immediately without awaiting removes the\n      // callback.\n      const entry = createCallback(handler, options, trackType);\n      const callback = entry._callback;\n\n      const eventTarget = options._eventTarget;\n      const scrollData = await fetchCurrentScroll(\n        element,\n        options._debounceWindow === 0,\n      );\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      entry._data = scrollData;\n      allScrollData.set(element, scrollData);\n\n      if (trackType === TRACK_FULL) {\n        await setupSizeTrack(entry);\n      }\n\n      let listenerOptions = activeListeners.get(eventTarget);\n      if (!listenerOptions) {\n        debug: logger?.debug4(\"Adding scroll listener\", eventTarget);\n        listenerOptions = { _nRealtime: 0 };\n        activeListeners.set(eventTarget, listenerOptions);\n        // Don't debounce the scroll handler, only the callbacks.\n        addEventListenerTo(eventTarget, MC.S_SCROLL, scrollHandler);\n      }\n\n      if (options._debounceWindow === 0) {\n        listenerOptions._nRealtime++;\n      }\n\n      const directions = options._directions;\n      if (\n        !callback.isRemoved() &&\n        !userOptions?.skipInitial &&\n        directionMatches(directions, scrollData.direction)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", element, scrollData);\n        // Use a one-off callback that's not debounced for the initial call.\n        await invokeCallback(wrapCallback(handler), element, scrollData);\n      }\n    };\n\n    // ----------\n\n    const removeOnScroll = async (\n      handler: OnScrollHandler,\n      scrollable: ScrollTarget | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOnScrollOptions(config, { scrollable });\n      const element = options._element;\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setScrollCssProps) {\n          // delete the properties\n          setScrollCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnScrollHandler,\n      options: OnScrollOptionsInternal,\n    ) => {\n      const element = options._element;\n      const eventTarget = options._eventTarget;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      const listenerOptions = activeListeners.get(eventTarget);\n      if (listenerOptions && options._debounceWindow === 0) {\n        listenerOptions._nRealtime--;\n      }\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for scrollable; removing listener\",\n          element,\n        );\n\n        MH.deleteKey(allScrollData, element);\n        removeEventListenerFrom(eventTarget, MC.S_SCROLL, scrollHandler);\n        MH.deleteKey(activeListeners, eventTarget);\n      }\n    };\n\n    // ----------\n\n    const setupSizeTrack = async (entry: CallbackEntry) => {\n      const options = entry._options;\n      const element = options._element;\n      const scrollCallback = entry._callback;\n      debug: logger?.debug8(\"Setting up size tracking\", element);\n\n      const doc = MH.getDoc();\n      const docScrollingElement = MH.getDocScrollingElement();\n\n      const resizeCallback = wrapCallback(async () => {\n        // Get the latest scroll data for the scrollable\n        // Currently, the resize callback is already delayed by a frame due to\n        // the SizeWatcher, so we don't need to treat this as realtime.\n        const latestData = await fetchCurrentScroll(element);\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n        } else if (!scrollCallback.isRemoved()) {\n          await invokeCallback(scrollCallback, element, latestData);\n        }\n      });\n\n      scrollCallback.onRemove(resizeCallback.remove);\n\n      // Don't use default instance as it has a high threshold.\n      const sizeWatcher = SizeWatcher.reuse();\n      const setupOnResize = (target?: SizeTarget) =>\n        sizeWatcher.onResize(resizeCallback, {\n          target,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          // TODO maybe accepts resizeThreshold option\n          threshold: options._threshold,\n        });\n\n      if (element === docScrollingElement) {\n        // In case we're tracking the main document scroll, then we only need to\n        // observe the viewport size and the size of the documentElement (which is\n        // the content size).\n\n        setupOnResize(); // viewport size\n        setupOnResize(doc); // content size\n\n        return;\n      }\n\n      // ResizeObserver only detects changes in offset width/height which is\n      // the visible size of the scrolling element, and that is not affected by the\n      // size of its content.\n      // But we also need to detect changes in the scroll width/height which is\n      // the size of the content.\n      // We also need to keep track of elements being added to the scrollable element.\n\n      const observedElements = MH.newSet<Element>([element]);\n\n      // Observe the scrolling element\n      setupOnResize(element);\n\n      // And also its children (if possible, single wrapper around children\n      const allowedToWrap =\n        settings.contentWrappingAllowed === true &&\n        element !== docScrollingElement &&\n        getData(element, MC.PREFIX_NO_WRAP) === null;\n\n      let wrapper: Element;\n      if (allowedToWrap) {\n        // Wrap the content and observe the wrapper\n        wrapper = await wrapScrollingContent(element);\n        setupOnResize(wrapper);\n        observedElements.add(wrapper);\n\n        //\n      } else {\n        for (const child of MH.childrenOf(element)) {\n          setupOnResize(child);\n          observedElements.add(child);\n        }\n      }\n\n      // Watch for newly added elements\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      const onAddedCallback = wrapCallback((operation: MutationOperation) => {\n        const child = MH.currentTargetOf(operation);\n        // If we've just added the wrapper, it will be in DOMWatcher's queue,\n        // so check.\n        if (child !== wrapper) {\n          if (allowedToWrap) {\n            // Move this child into the wrapper. If this results in change of size\n            // for wrapper, SizeWatcher will call us.\n            moveElement(child, { to: wrapper, ignoreMove: true });\n          } else {\n            // Track the size of this child.\n            // Don't skip initial, call the callback now\n            setupOnResize(child);\n            observedElements.add(child);\n          }\n        }\n      });\n\n      domWatcher.onMutation(onAddedCallback, { categories: [MC.S_ADDED] });\n      resizeCallback.onRemove(onAddedCallback.remove);\n    };\n\n    // ----------\n\n    const scrollHandler = async (event: Event) => {\n      // We cannot use event.currentTarget because scrollHandler is called inside\n      // a setTimeout so by that time, currentTarget is null or something else.\n      //\n      // However, target and currentTarget only differ when the event is in the\n      // bubbling or capturing phase. Because\n      //\n      // - the scroll event only bubbles when fired on document, and (it only\n      //   bubbles up to window)\n      // - and we never attach the listener to the capturing phase\n      // - and we always use document instead of window to listen for scroll on\n      //   document\n      //\n      // then event.target suffices.\n      const scrollable = MH.targetOf(event);\n      /* istanbul ignore next */\n      if (!scrollable || !(MH.isElement(scrollable) || MH.isDoc(scrollable))) {\n        return;\n      }\n\n      const element = await fetchScrollableElement(scrollable);\n      const realtime = (activeListeners.get(scrollable)?._nRealtime || 0) > 0;\n      const latestData = await fetchCurrentScroll(element, realtime, true);\n      allScrollData.set(element, latestData);\n\n      debug: logger?.debug9(\"Scroll event\", element, latestData);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        // Consider the direction since the last scroll event and not the\n        // direction based on the largest delta the last time the callback\n        // was called.\n        const options = entry._options;\n        const thresholdsExceeded = hasExceededThreshold(\n          options,\n          latestData,\n          entry._data,\n        );\n\n        if (!thresholdsExceeded) {\n          debug: logger?.debug9(\n            \"Threshold not exceeded\",\n            options,\n            latestData,\n            entry._data,\n          );\n          continue;\n        }\n\n        // If threshold has been exceeded, always update the latest data for\n        // this callback.\n        entry._data = latestData;\n\n        if (!directionMatches(options._directions, latestData.direction)) {\n          debug: logger?.debug9(\n            \"Direction does not match\",\n            options,\n            latestData,\n          );\n          continue;\n        }\n\n        invokeCallback(entry._callback, element, latestData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentScroll = (scrollable?, realtime?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        fetchCurrentScroll(element, realtime),\n      );\n\n    // ----------\n\n    this.scroll = (direction, options = {}) => {\n      if (!isValidScrollDirection(direction)) {\n        throw MH.usageError(`Unknown scroll direction: '${direction}'`);\n      }\n\n      const isVertical = direction === MC.S_UP || direction === MC.S_DOWN;\n      const sign = direction === MC.S_UP || direction === MC.S_LEFT ? -1 : 1;\n      let targetCoordinate: TargetCoordinate;\n\n      const amount = options.amount ?? 100;\n      const asFractionOf = options.asFractionOf;\n\n      if (asFractionOf === \"visible\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * getClientHeightNow(el)) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * getClientWidthNow(el)) / 100;\n\n        //\n      } else if (asFractionOf === \"content\") {\n        targetCoordinate = isVertical\n          ? (el) =>\n              el[MC.S_SCROLL_TOP] +\n              (sign * amount * el[MC.S_SCROLL_HEIGHT]) / 100\n          : (el) =>\n              el[MC.S_SCROLL_LEFT] +\n              (sign * amount * el[MC.S_SCROLL_WIDTH]) / 100;\n\n        //\n      } else if (asFractionOf !== undefined && asFractionOf !== \"pixel\") {\n        throw MH.usageError(\n          `Unknown 'asFractionOf' keyword: '${asFractionOf}'`,\n        );\n\n        //\n      } else {\n        targetCoordinate = isVertical\n          ? (el) => el[MC.S_SCROLL_TOP] + sign * amount\n          : (el) => el[MC.S_SCROLL_LEFT] + sign * amount;\n      }\n\n      const target = isVertical\n        ? { top: targetCoordinate }\n        : { left: targetCoordinate };\n\n      return this.scrollTo(target, options);\n    };\n\n    // ----------\n\n    this.scrollTo = async (to, options = {}) =>\n      scrollTo(\n        to,\n        MH.merge(\n          { duration: config._scrollDuration }, // default\n          options,\n          {\n            scrollable: await fetchScrollableElement(options.scrollable),\n          }, // override\n        ),\n      );\n\n    // ----------\n\n    this.fetchCurrentScrollAction = (scrollable?) =>\n      fetchScrollableElement(scrollable).then((element) =>\n        getCurrentScrollAction(element),\n      );\n\n    // ----------\n\n    this.stopUserScrolling = async (options = {}) => {\n      const element = await fetchScrollableElement(options.scrollable);\n      const stopScroll = () =>\n        MH.elScrollTo(element, {\n          top: element[MC.S_SCROLL_TOP],\n          left: element[MC.S_SCROLL_LEFT],\n        });\n\n      if (options.immediate) {\n        stopScroll();\n      } else {\n        waitForMeasureTime().then(stopScroll);\n      }\n    };\n\n    // ----------\n\n    this.trackScroll = (handler?, options?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      return setupOnScroll(handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackScroll = (handler?, scrollable?) => {\n      if (!handler) {\n        handler = setScrollCssProps;\n      }\n\n      removeOnScroll(handler, scrollable, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onScroll = (handler, options?) =>\n      setupOnScroll(handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offScroll = (handler, scrollable?) => {\n      removeOnScroll(handler, scrollable, TRACK_REGULAR); // no need to await\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type ScrollWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnScrollOptions.debounceWindow | debounceWindow} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 75\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnScrollOptions.threshold | threshold} in calls to\n   * {@link ScrollWatcher.onScroll}.\n   *\n   * @defaultValue 50\n   */\n  scrollThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link ScrollOptions.duration | duration} in calls to\n   * {@link ScrollWatcher.scroll} and {@link ScrollWatcher.scrollTo}.\n   *\n   * @defaultValue 1000\n   */\n  scrollDuration?: number;\n};\n\n/**\n * @interface\n */\nexport type OnScrollOptions = {\n  /**\n   * If it is not given, or is `null`, `window` or `document`, then it will\n   * track the scroll of the {@link ScrollWatcher.fetchMainScrollableElement}.\n   *\n   * Other values must be an `Element` and are taken literally.\n   *\n   * @defaultValue undefined\n   */\n  scrollable?: ScrollTarget;\n\n  /**\n   * If non-0, the scroll handler will only be called when the scrollable's\n   * scroll offset in the observed direction has changed at least\n   * `scrollThreshold` pixels since the last time the handler was called.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.scrollThreshold}\n   */\n  threshold?: number;\n\n  /**\n   * Specifies a list of {@link ScrollDirection}s to listen for.\n   *\n   * It can be a comma-separated list of direction names or an array of such\n   * names.\n   *\n   * If not given, then it listens for scrolls in any direction, including\n   * {@link Types.NoDirection} and {@link Types.AmbiguousDirection}.\n   *\n   * The {@link Types.NoDirection} occurs when the callback is called initially\n   * (if `skipInitial` is not `true`) and there hasn't yet been a scroll\n   * observed on the scrollable _and_ it's `scrollTop`/`scrollLeft` are 0.\n   *\n   * The {@link Types.AmbiguousDirection} occurs when the user scrolls\n   * diagonally with close to equal deltas in both horizontal and vertical\n   * direction.\n   *\n   * **IMPORTANT:**\n   *\n   * The direction of a scroll event is always based on comparing `deltaX` and\n   * `deltaY` relative to the _last scroll event_ (within the `debounceWindow`,\n   * and not to the scroll data for the last time the callback was called (in\n   * case it was skipped because `threshold` was not exceeded or in case it was\n   * debounced by a larger window than the watcher).\n   *\n   * I.e. if you have both `threshold` and `directions` restricted, or if the\n   * callback has a larger debounce window than the watcher, it is possible for\n   * there to be a change in the relevant `scrollTop`/`scrollLeft` offset that\n   * exceeds the threshold, and for the callback to _not_ be called.\n   *\n   * For a callback to be called, both of these must be true:\n   * - the change in `scrollTop`/`scrollLeft`, _compared to the last time the\n   *   callback was called_ must exceed the {@link threshold}\n   * - the effective scroll direction, _compared to the last scroll event_\n   *   prior to the _watcher's_ debounce window must be one of the given\n   *   {@link directions}.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<ScrollDirection> | ScrollDirection[];\n\n  /**\n   * Do not call the handler until there's a future scroll of the element.\n   *\n   * By default we call the handler (almost) immediately if there's been a\n   * scroll in one of the given directions, or if there has not been a scroll\n   * but directions includes {@link Types.NoDirection}, but you can disable\n   * this initial call here.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n\n  /**\n   * If non-0, the handler will be \"debounced\" so it's called at most\n   * `debounceWindow` milliseconds.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts, but you probably need this when doing\n   * scroll-based animations.\n   *\n   * @defaultValue {@link ScrollWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n};\n\n/**\n * @interface\n */\nexport type ScrollOptions = ScrollToOptions & {\n  /**\n   * How much to scroll in the given direction.\n   *\n   * @defaultValue 100\n   */\n  amount?: number;\n\n  /**\n   * If set to \"pixel\" (default), `amount` is taken as absolute pixels.\n   *\n   * If set to \"visible\", `amount` is taken as percent of the element's visible\n   * size in the scrolling direction (100 means full client width for\n   * horizontal or height for vertical scroll).\n   *\n   * If set to \"content\", `amount` is taken as percent of the element's full\n   * content size in the scrolling direction (100 means full scroll width for\n   * horizontal or height for vertical scroll).\n   *\n   * @defaultValue \"pixel\"\n   */\n  asFractionOf?: \"pixel\" | \"visible\" | \"content\";\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the element that has been resized\n * - the {@link ScrollData} for the element\n */\nexport type OnScrollHandlerArgs = [Element, ScrollData];\nexport type OnScrollCallback = Callback<OnScrollHandlerArgs>;\nexport type OnScrollHandler =\n  | CallbackHandler<OnScrollHandlerArgs>\n  | OnScrollCallback;\n\nexport type ScrollData = {\n  clientWidth: number;\n  clientHeight: number;\n\n  scrollTop: number;\n\n  /**\n   * This is the `scrollTop` relative to the full `scrollHeight` minus the\n   * `clientHeight`, ranging from 0 to 1.\n   */\n  scrollTopFraction: number;\n\n  scrollLeft: number;\n\n  /**\n   * This is the `scrollLeft` relative to the full `scrollWidth` minus the\n   * `clientWidth`, ranging from 0 to 1.\n   */\n  scrollLeftFraction: number;\n\n  scrollWidth: number;\n  scrollHeight: number;\n\n  /**\n   * This is the direction of the last scroll action, i.e. _compared to the\n   * last scroll event_, not necessarily based on the deltas compared to the\n   * last time this callback was called.\n   */\n  direction: ScrollDirection;\n};\n\n// ----------------------------------------\n\ntype ScrollWatcherConfigInternal = {\n  _debounceWindow: number;\n  _scrollThreshold: number;\n  _scrollDuration: number;\n};\n\ntype OnScrollOptionsInternal = {\n  _element: Element;\n  _eventTarget: ScrollTarget;\n  _directions: ScrollDirection[] | null;\n  _threshold: number;\n  _debounceWindow: number;\n};\n\ntype CallbackEntry = {\n  _callback: OnScrollCallback;\n  _trackType: TrackType;\n  _options: OnScrollOptionsInternal;\n  _data?: ScrollData;\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, ScrollWatcher>();\n\nconst getConfig = (\n  config: ScrollWatcherConfig,\n): ScrollWatcherConfigInternal => {\n  return {\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 75),\n    // If threshold is 0, internally treat as 1 (pixel)\n    _scrollThreshold: toNonNegNum(config.scrollThreshold, 50) || 1,\n    _scrollDuration: toNonNegNum(config.scrollDuration, 1000),\n  };\n};\n\nconst TRACK_REGULAR = 1; // only scroll events\nconst TRACK_FULL = 2; // scroll + resizing of content and/or wrapper\n\n// --------------------\n\nconst fetchOnScrollOptions = async (\n  config: ScrollWatcherConfigInternal,\n  options: OnScrollOptions,\n): Promise<OnScrollOptionsInternal> => {\n  const directions =\n    validateStrList(\"directions\", options.directions, isValidScrollDirection) ||\n    null;\n\n  const element = await fetchScrollableElement(options.scrollable);\n\n  return {\n    _element: element,\n    _eventTarget: getEventTarget(element),\n    _directions: directions,\n    // If threshold is 0, internally treat as 1 (pixel)\n    _threshold: toNonNegNum(options.threshold, config._scrollThreshold) || 1,\n    _debounceWindow: options[MC.S_DEBOUNCE_WINDOW] ?? config._debounceWindow,\n  };\n};\n\nconst directionMatches = (\n  userDirections: ScrollDirection[] | null,\n  latestDirection: ScrollDirection,\n) => !userDirections || MH.includes(userDirections, latestDirection);\n\nconst hasExceededThreshold = (\n  options: OnScrollOptionsInternal,\n  latestData: ScrollData,\n  lastThresholdData: ScrollData | undefined,\n): boolean => {\n  const directions = options._directions;\n  const threshold = options._threshold;\n  if (!lastThresholdData) {\n    /* istanbul ignore */\n    return false;\n  }\n\n  const topDiff = maxAbs(\n    latestData[MC.S_SCROLL_TOP] - lastThresholdData[MC.S_SCROLL_TOP],\n    latestData[MC.S_SCROLL_HEIGHT] - lastThresholdData[MC.S_SCROLL_HEIGHT],\n    latestData[MC.S_CLIENT_HEIGHT] - lastThresholdData[MC.S_CLIENT_HEIGHT],\n  );\n\n  const leftDiff = maxAbs(\n    latestData[MC.S_SCROLL_LEFT] - lastThresholdData[MC.S_SCROLL_LEFT],\n    latestData[MC.S_SCROLL_WIDTH] - lastThresholdData[MC.S_SCROLL_WIDTH],\n    latestData[MC.S_CLIENT_WIDTH] - lastThresholdData[MC.S_CLIENT_WIDTH],\n  );\n\n  // If the callback is only interested in up/down, then only check the\n  // scrollTop delta, and similarly for left/right.\n  let checkTop = false,\n    checkLeft = false;\n  if (\n    !directions ||\n    MH.includes(directions, MC.S_NONE) ||\n    MH.includes(directions, MC.S_AMBIGUOUS)\n  ) {\n    checkTop = checkLeft = true;\n  } else {\n    if (\n      MH.includes(directions, MC.S_UP) ||\n      MH.includes(directions, MC.S_DOWN)\n    ) {\n      checkTop = true;\n    }\n    if (\n      MH.includes(directions, MC.S_LEFT) ||\n      MH.includes(directions, MC.S_RIGHT)\n    ) {\n      checkLeft = true;\n    }\n  }\n\n  return (\n    (checkTop && topDiff >= threshold) || (checkLeft && leftDiff >= threshold)\n  );\n};\n\nconst fetchScrollData = async (\n  element: Element,\n  previousEventData: ScrollData | undefined,\n  realtime: boolean,\n): Promise<ScrollData> => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollTop = MH.ceil(element[MC.S_SCROLL_TOP]);\n  const scrollLeft = MH.ceil(element[MC.S_SCROLL_LEFT]);\n  const scrollWidth = element[MC.S_SCROLL_WIDTH];\n  const scrollHeight = element[MC.S_SCROLL_HEIGHT];\n  const clientWidth = getClientWidthNow(element);\n  const clientHeight = getClientHeightNow(element);\n\n  const scrollTopFraction =\n    MH.round(scrollTop) / (scrollHeight - clientHeight || MC.INFINITY);\n  const scrollLeftFraction =\n    MH.round(scrollLeft) / (scrollWidth - clientWidth || MC.INFINITY);\n\n  const prevScrollTop = previousEventData?.scrollTop || 0;\n  const prevScrollLeft = previousEventData?.scrollLeft || 0;\n\n  const direction = getMaxDeltaDirection(\n    scrollLeft - prevScrollLeft,\n    scrollTop - prevScrollTop,\n  );\n\n  return {\n    direction,\n    [MC.S_SCROLL_TOP]: scrollTop,\n    [MC.S_SCROLL_TOP_FRACTION]: scrollTopFraction,\n    [MC.S_SCROLL_LEFT]: scrollLeft,\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollLeftFraction,\n    [MC.S_SCROLL_WIDTH]: scrollWidth,\n    [MC.S_SCROLL_HEIGHT]: scrollHeight,\n    [MC.S_CLIENT_WIDTH]: clientWidth,\n    [MC.S_CLIENT_HEIGHT]: clientHeight,\n  };\n};\n\nconst setScrollCssProps = (\n  element: Element,\n  scrollData: Partial<ScrollData> | undefined | null,\n) => {\n  let prefix = \"\";\n  if (element === tryGetMainScrollableElement()) {\n    // Set the CSS vars on the root element\n    element = MH.getDocElement();\n    prefix = \"page-\";\n  }\n\n  scrollData = scrollData || {};\n  const props = {\n    [MC.S_SCROLL_TOP]: scrollData[MC.S_SCROLL_TOP],\n    [MC.S_SCROLL_TOP_FRACTION]: scrollData[MC.S_SCROLL_TOP_FRACTION],\n    [MC.S_SCROLL_LEFT]: scrollData[MC.S_SCROLL_LEFT],\n    [MC.S_SCROLL_LEFT_FRACTION]: scrollData[MC.S_SCROLL_LEFT_FRACTION],\n    [MC.S_SCROLL_WIDTH]: scrollData[MC.S_SCROLL_WIDTH],\n    [MC.S_SCROLL_HEIGHT]: scrollData[MC.S_SCROLL_HEIGHT],\n  };\n  setNumericStyleProps(element, props, { _prefix: prefix });\n};\n\nconst getEventTarget = (element: Element): ScrollTarget => {\n  if (element === MH.getDocScrollingElement()) {\n    return MH.getDoc();\n  }\n\n  return element;\n};\n\nconst invokeCallback = (\n  callback: OnScrollCallback,\n  element: Element,\n  scrollData: ScrollData,\n) => callback.invoke(element, MH.copyObject(scrollData)).catch(logError);\n","/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { ScrollOffset, View, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\nimport { newBitSpaces, createBitSpace } from \"@lisn/modules/bit-spaces\";\n\n/**\n * Returns true if the given string is a valid {@link ScrollOffset}.\n *\n * @category Validation\n */\nexport const isValidScrollOffset = (offset: string): offset is ScrollOffset =>\n  offset.match(OFFSET_REGEX) !== null;\n\n/**\n * Returns true if the given string is a valid \"view\".\n *\n * @category Validation\n */\nexport const isValidView = (view: string): view is View =>\n  MH.includes(VIEWS, view);\n\n/**\n * Returns true if the given string or array is a list of valid views.\n *\n * @category Validation\n */\nexport const isValidViewList = (views: string | string[]) =>\n  isValidStrList(views, isValidView, false);\n\n/**\n * Returns the views that are opposite to the given set of views.\n *\n * Above and below are opposites, and so are left and right.\n *\n * \"at\" is a special case. It is considered opposite to any view in the sense\n * that if it is not present in `views` it will always be included in the\n * returned array. However it is not \"strongly\" opposite in the sense that it\n * will not cause other views to be included in the result unless it is the\n * only view in `views`. That is, there are two sets of strongly opposite pairs\n * (\"above\"/\"below\" and \"left\"/\"right\") and at least one of the two opposing\n * views of a pair must be present for the other one to be included, _except in\n * the special case of `views` being \"at\"_. See examples below for\n * clarification.\n *\n * **Note** that the order of the returned array is not defined.\n *\n * @example\n * Returns [\"above\", \"below\", \"left\", \"right\"] (not definite order), since\n * \"at\" is the only view present and is opposite to all:\n *\n * ```javascript\n * getOppositeViews(\"at\"); // -> [\"above\", \"below\", \"left\", \"right\"] (not necessarily in this order)\n * ```\n *\n * @example\n * Returns [\"below\"]. \"left\" and \"right\" are NOT included even though \"at\" is\n * given, because at least one of the two opposing views of a pair must be\n * present for the other one to be included (except in the special case of\n * `views` being \"at\").\n *\n * ```javascript\n * getOppositeViews(\"at,above\"); // -> [\"below\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above\"); // -> [\"at\", \"below\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,below\"); // -> [\"at\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,below\"); // -> []\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,right\"); // -> [\"at\", \"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,right\"); // -> [\"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid, including if it's empty \"\".\n *\n * @category Views\n */\nexport const getOppositeViews = (\n  views: CommaSeparatedStr<View> | View[],\n): View[] => {\n  if (!views) {\n    throw MH.usageError(\"'views' cannot be empty\");\n  }\n\n  const bitmask = getViewsBitmask(views);\n  let oppositeBitmask = VIEWS_SPACE.bitmask & ~bitmask; // initial, all not present in bitmask\n\n  // If the given view is \"at\", then include all the other ones.\n  // Otherwise include only the opposite views of those directional\n  // (above/below/left/right) that are present. I.e. if neither left not right\n  // is given, then don't include them\n  if (bitmask !== VIEWS_SPACE.bit.at) {\n    // remove the opposite ones to those not present\n    if (!(bitmask & VIEWS_SPACE.bit.above)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.below;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.below)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.above;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.left)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.right;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.right)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.left;\n    }\n  }\n\n  return getViewsFromBitmask(oppositeBitmask);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getViewsBitmask = (\n  viewsStr: View[] | string | undefined,\n): number => {\n  let viewsBitmask = 0;\n  const views = validateStrList(\"views\", viewsStr, isValidView);\n\n  if (views) {\n    for (const v of views) {\n      if (!isValidView(v)) {\n        throw MH.usageError(`Unknown view '${v}'`);\n      }\n\n      viewsBitmask |= VIEWS_SPACE.bit[v];\n    }\n  } else {\n    viewsBitmask = VIEWS_SPACE.bitmask; // default: all\n  }\n\n  return viewsBitmask;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const parseScrollOffset = (input: string) => {\n  const match = input.match(OFFSET_REGEX);\n  if (!match) {\n    throw MH.usageError(`Invalid offset: '${input}'`);\n  }\n\n  const reference = match.groups?.ref;\n  const value = match.groups?.value;\n  /* istanbul ignore next */ // shouldn't happen\n  if (!reference || !value) {\n    throw MH.bugError(\"Offset regex: blank named groups\");\n  }\n\n  return { reference, value };\n};\n\nconst VIEWS: View[] = [\n  MC.S_AT,\n  MC.S_ABOVE,\n  MC.S_BELOW,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const VIEWS_SPACE = createBitSpace<View>(newBitSpaces(), ...VIEWS);\n\n// --------------------\n\nconst OFFSET_REGEX = RegExp(\"(?<ref>top|bottom|left|right): *(?<value>[^ ].+)\");\n\nconst getViewsFromBitmask = (bitmask: number): View[] => {\n  const views: View[] = [];\n  for (let bit = VIEWS_SPACE.start; bit <= VIEWS_SPACE.end; bit++) {\n    const value = 1 << bit;\n    if (bitmask & value) {\n      const name = VIEWS_SPACE.nameOf(value);\n      if (name) {\n        views.push(name);\n      }\n    }\n  }\n\n  return views;\n};\n","/**\n * @module Modules/XIntersectionObserver\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nexport type XIntersectionObserverCallback = (\n  entries: IntersectionObserverEntry[],\n  observer: XIntersectionObserver,\n) => void;\n\n/**\n * {@link XIntersectionObserver} is an extension of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}\n * with added capabilities:\n * - can skip the initial callback that happens shortly after setting up via\n *   {@link observeLater}\n */\nexport class XIntersectionObserver {\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/root | IntersectionObserver:root}.\n   */\n  readonly root!: Element | Document | null;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin | IntersectionObserver:rootMargin}.\n   */\n  readonly rootMargin!: string;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/thresholds | IntersectionObserver:thresholds}.\n   */\n  readonly thresholds!: number[];\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/observe | IntersectionObserver:observe} except it accepts multiple\n   * targets.\n   */\n  readonly observe: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link observe} but it ignores the initial almost immediate callback\n   * and only calls the callback on a subsequent intersection change.\n   */\n  readonly observeLater: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/unobserve | IntersectionObserver:unobserve} except it accepts multiple\n   * targets.\n   */\n  readonly unobserve: (...targets: Element[]) => void;\n\n  /**\n   * Like {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/disconnect | IntersectionObserver:disconnect}.\n   */\n  readonly disconnect: () => void;\n\n  /**\n   * Like `IntersectionObserver.takeRecords`.\n   */\n  readonly takeRecords: () => void;\n\n  constructor(\n    callback: XIntersectionObserverCallback,\n    observeOptions?: IntersectionObserverInit,\n  ) {\n    let observedTargets = MH.newWeakSet<Element>();\n    const targetsToSkip = MH.newWeakSet<Element>();\n\n    const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n      const selectedEntries = [];\n\n      for (const entry of entries) {\n        if (targetsToSkip.has(MH.targetOf(entry))) {\n          MH.deleteKey(targetsToSkip, MH.targetOf(entry));\n          continue;\n        }\n\n        selectedEntries.push(entry);\n      }\n\n      if (MH.lengthOf(selectedEntries)) {\n        callback(selectedEntries, this);\n      }\n    };\n\n    const observer = MH.newIntersectionObserver(\n      intersectionHandler,\n      observeOptions,\n    );\n\n    MH.defineProperty(this, \"root\", { get: () => observer.root });\n    MH.defineProperty(this, \"rootMargin\", {\n      get: () => observer.rootMargin,\n    });\n    MH.defineProperty(this, \"thresholds\", {\n      get: () => observer.thresholds,\n    });\n\n    this.observe = (...targets) => {\n      for (const target of targets) {\n        observedTargets.add(target);\n        observer.observe(target);\n      }\n    };\n\n    this.observeLater = (...targets) => {\n      for (const target of targets) {\n        // Only skip them if not already observed, otherwise the initial\n        // (almost) immediate callback won't happen anyway.\n        if (observedTargets.has(target)) {\n          continue;\n        }\n\n        targetsToSkip.add(target);\n        this.observe(target);\n      }\n    };\n\n    this.unobserve = (...targets) => {\n      for (const target of targets) {\n        MH.deleteKey(observedTargets, target);\n        observer.unobserve(target);\n      }\n    };\n\n    this.disconnect = () => {\n      observedTargets = MH.newWeakSet();\n      observer.disconnect();\n    };\n\n    this.takeRecords = () => observer.takeRecords();\n  }\n}\n","/**\n * @module Watchers/ViewWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  ViewTarget,\n  View,\n  BoundingRect,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { setNumericStyleProps } from \"@lisn/utils/css-alter\";\nimport { waitForInteractive } from \"@lisn/utils/dom-events\";\nimport {\n  waitForMeasureTime,\n  waitForSubsequentMeasureTime,\n} from \"@lisn/utils/dom-optimize\";\nimport { logError } from \"@lisn/utils/log\";\nimport { omitKeys, compareValuesIn } from \"@lisn/utils/misc\";\nimport { createOverlay, OverlayOptions } from \"@lisn/utils/overlays\";\nimport { getClosestScrollable } from \"@lisn/utils/scroll\";\nimport { fetchViewportSize } from \"@lisn/utils/size\";\nimport { toMargins, objToStrKey } from \"@lisn/utils/text\";\nimport {\n  VIEWS_SPACE,\n  getViewsBitmask,\n  parseScrollOffset,\n} from \"@lisn/utils/views\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap, newXWeakMap } from \"@lisn/modules/x-map\";\nimport { XIntersectionObserver } from \"@lisn/modules/x-intersection-observer\";\n\nimport { DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { ScrollWatcher } from \"@lisn/watchers/scroll-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link ViewWatcher} monitors the position of a given target relative to the\n * given {@link ViewWatcherConfig.root | root} or the viewport.\n *\n * It's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}.\n *\n * It manages registered callbacks globally and reuses IntersectionObservers\n * for more efficient performance.\n */\nexport class ViewWatcher {\n  /**\n   * Call the given handler whenever the {@link ViewWatcherConfig.root | root}'s\n   * view relative to the target position changes, i.e. when the target enters\n   * or leaves the root.\n   *\n   * Unless {@link OnViewOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the current view if it matches this\n   * set of options*.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackView} or using\n   * {@link onView}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking position across root\n   * using {@link trackView}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or the options are invalid.\n   */\n  readonly onView: (\n    target: ViewTarget,\n    handler: OnViewHandler,\n    options?: OnViewOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly offView: (target: ViewTarget, handler: OnViewHandler) => void;\n\n  /**\n   * This does more than just {@link onView}. The difference is that in\n   * addition to a change of {@link View}, such as the target entering or\n   * leaving the ViewWatcher's {@link ViewWatcherConfig.root | root} (by\n   * default the viewport), the handler is also called each time the target's\n   * relative view changes _while inside the root_.\n   *\n   * A change of relative position happens when:\n   * - the target is resized\n   * - the root is resized\n   * - the any of the target's scrollable ancestors is scrolled\n   * - the target's attributes changed that resulted in a change of position\n   *\n   * All of the above are accounted for. Internally it uses\n   * {@link ScrollWatcher}, {@link DOMWatcher} and {@link SizeWatcher} to keep\n   * track of all of this.\n   *\n   * If the target is leaves the ViewWatcher's\n   * {@link ViewWatcherConfig.root | root}, the handler will be called with\n   * the {@link ViewData}, and the above events will stop being tracked until\n   * the target enters the watcher's root again.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackView} or using\n   * {@link onView}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates the following set of CSS variables on the target's style and\n   * represent its relative position:\n   *\n   * - `--lisn-js--r-top`\n   * - `--lisn-js--r-bottom`\n   * - `--lisn-js--r-left`\n   * - `--lisn-js--r-right`\n   * - `--lisn-js--r-width`\n   * - `--lisn-js--r-height`\n   * - `--lisn-js--r-h-middle`\n   * - `--lisn-js--r-v-middle`\n   *\n   * See {@link ViewData.relative} for an explanation of each.\n   *\n   * Note that only Element targets are supported here and not offsets.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or \"views\" are invalid.\n   */\n  readonly trackView: (\n    element: Element,\n    handler?: OnViewHandler | null,\n    options?: TrackViewOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackView}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly noTrackView: (\n    element: Element,\n    handler?: OnViewHandler | null,\n  ) => void;\n\n  /**\n   * Get the current view relative to the target. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param {} realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                    this only when doing realtime scroll-based animations\n   *                    as it may cause a forced layout.\n   */\n  readonly fetchCurrentView: (\n    target: ViewTarget,\n    realtime?: boolean,\n  ) => Promise<ViewData>;\n\n  /**\n   * Creates a new instance of ViewWatcher with the given\n   * {@link ViewWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ViewWatcherConfig = {}) {\n    return new ViewWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing  instance of ViewWatcher with the given\n   * {@link ViewWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ViewWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    let instance = instances.get(myConfig._root)?.get(configStrKey);\n    if (!instance) {\n      instance = new ViewWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(myConfig._root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ViewWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ViewWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ViewWatcher\", logAtCreation: config })\n      : null;\n\n    const allViewData = MH.newWeakMap<Element, ViewData>();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<\n        OnViewHandler,\n        {\n          _callback: OnViewCallback;\n          _trackType: TrackType;\n          _options: OnViewOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n      debug: logger?.debug9(`Got ${entries.length} new entries`, entries);\n\n      for (const entry of entries) {\n        processEntry(entry);\n      }\n    };\n\n    const observeOptions = {\n      root: config._root,\n      threshold: config._threshold,\n      rootMargin: config._rootMargin,\n    };\n\n    const xObserver = new XIntersectionObserver(\n      intersectionHandler,\n      observeOptions,\n    );\n\n    // ----------\n\n    const fetchCurrentView = (\n      element: Element,\n      realtime = false,\n    ): Promise<ViewData> => {\n      const fetchData = async (\n        entryOrElement: IntersectionObserverEntry | Element,\n      ) => {\n        const intersection = await fetchIntersectionData(\n          config,\n          entryOrElement,\n          realtime,\n        );\n        const data = await fetchViewData(intersection, realtime);\n        return data;\n      };\n\n      if (realtime) {\n        return fetchData(element);\n      }\n\n      return MH.newPromise((resolve) => {\n        // Use a temp IntersectionObserver\n        const observer = MH.newIntersectionObserver((entries) => {\n          const promise = fetchData(entries[0]);\n          observer.disconnect();\n          promise.then(resolve);\n        }, observeOptions);\n\n        observer.observe(element);\n      });\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnViewHandler,\n      options: OnViewOptionsInternal,\n      trackType: TrackType,\n    ): OnViewCallback => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      allCallbacks.sGet(element).set(handler, {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      });\n\n      return callback;\n    };\n\n    // ----------\n\n    const setupOnView = async (\n      target: ViewTarget,\n      handler: OnViewHandler,\n      userOptions: (OnViewOptions & TrackViewOptions) | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOptions(config._root, target, userOptions);\n      const element = options._element;\n\n      const callback = createCallback(handler, options, trackType);\n\n      // View watcher should be used before the DOM is loaded since the initial\n      // size of the root may be 0 or close to 0 and would lead to premature\n      // triggering.\n      await waitForInteractive();\n\n      // Initial call doesn't need to be realtime, and best to use an actual\n      // IntersectionObserverEntry for that one.\n      let viewData = await fetchCurrentView(element);\n\n      if (\n        viewData.rootBounds[MC.S_WIDTH] === 0 &&\n        viewData.rootBounds[MC.S_HEIGHT] === 0\n      ) {\n        // Possibly the root is being setup now, wait for one AF\n        debug: logger?.debug5(\n          \"Got zero root size, deferring for a bit\",\n          config._root,\n        );\n        await waitForSubsequentMeasureTime();\n        viewData = await fetchCurrentView(element);\n      }\n\n      if (trackType === TRACK_FULL) {\n        // Detect resize or scroll\n        await setupInviewTrack(options, callback, viewData);\n      }\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      // Always use observeLater to skip the initial call from the\n      // IntersectionObserver, and call callbacks that have skipInitial: false\n      // here. Otherwise, we can't tell from inside the intersectionHandler whether\n      // a callback wants to skip its initial call or not.\n      //\n      // It's ok if already observed, won't do anything.\n      xObserver.observeLater(element);\n\n      if (!userOptions?.skipInitial) {\n        debug: logger?.debug5(\"Calling initially with\", element, viewData);\n        if (viewsToBitmask(viewData.views) & options._viewsBitmask) {\n          await invokeCallback(callback, element, viewData);\n        }\n      }\n    };\n\n    // ----------\n\n    const removeOnView = async (\n      target: ViewTarget,\n      handler: OnViewHandler,\n      trackType: TrackType,\n    ) => {\n      // For time sync, so that if called immediately after onView without\n      // awaiting, it will remove the callback that is about to be added.\n      // But if no such handler has been added we may unnecessarily\n      // create an overlay... TODO\n      const options = await fetchOptions(config._root, target, {});\n      const element = options._element;\n\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setViewCssProps) {\n          // delete the properties\n          setViewCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnViewHandler,\n      options: OnViewOptionsInternal,\n    ) => {\n      const element = options._element;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for target; unobserving\",\n          element,\n        );\n\n        xObserver.unobserve(element);\n        MH.deleteKey(allViewData, element);\n      }\n    };\n\n    // ----------\n\n    const processEntry = async (entry: IntersectionObserverEntry) => {\n      // In reality, it can't be just a base Element\n      const element = MH.targetOf(entry);\n\n      // This doesn't need to be \"realtime\", since IntersectionObserver alone\n      // introduces a delay.\n      const intersection = await fetchIntersectionData(config, entry);\n      const latestData = await fetchViewData(intersection);\n      debug: logger?.debug9(\"Got ViewData\", element, latestData);\n\n      const viewsBitmask = viewsToBitmask(latestData.views);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        if (viewsBitmask & entry._options._viewsBitmask) {\n          invokeCallback(entry._callback, element, latestData);\n        }\n      }\n    };\n\n    // ----------\n\n    const setupInviewTrack = async (\n      options: OnViewOptionsInternal,\n      viewCallback: OnViewCallback,\n      viewData: ViewData,\n    ) => {\n      const element = options._element;\n      debug: logger?.debug8(\n        \"Setting up size, scroll and attribute tracking\",\n        element,\n      );\n\n      const sizeWatcher = SizeWatcher.reuse();\n      const scrollWatcher = ScrollWatcher.reuse();\n      const realtime = options._debounceWindow === 0;\n\n      // Detect when target's class or style attribute change\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      // We need to remove the tracking callback when target leaves view and re-add\n      // it when it enters view. But the OnViewCallback that is associated may have\n      // already been added prior, by calling onView with this handler, so we can't\n      // always wrap around it, in order to detect when it's called with a change\n      // of view. So we setup another OnViewCallback tied to the tracking callback.\n      let isInview = false;\n\n      let removeTrackCallback: (() => void) | null = null;\n\n      // Finds any scrollable ancestors of the element and detect scroll on them.\n      const scrollableAncestors = await fetchScrollableAncestors(\n        element,\n        realtime,\n      );\n      if (viewCallback.isRemoved()) {\n        return;\n      }\n\n      const addTrackCallback = () => {\n        const trackCallback = wrapCallback(async () => {\n          const prevData = allViewData.get(element);\n\n          // Get the latest view data for the target\n          const latestData = await fetchCurrentView(element, realtime);\n          debug: logger?.debug9(\"Got ViewData\", element, latestData);\n\n          const changed = viewChanged(latestData, prevData);\n          if (changed) {\n            // When comparing for changes, we round the numbers to certain number\n            // of decimal places, and allViewData serves as a \"last threshold\"\n            // state, so only update it if there was a significant change.\n            // Otherwise very quick changes in small increments would get\n            // rejected as \"no change\".\n            allViewData.set(element, latestData);\n\n            if (isInview && !viewCallback.isRemoved()) {\n              // Could have been removed during the debounce window\n              await invokeCallback(viewCallback, element, latestData);\n            }\n          } else {\n            debug: logger?.debug9(\"ViewData same as last\");\n          }\n        });\n\n        // TODO Is there a better way to detect when it's moved?\n        viewCallback.onRemove(trackCallback.remove);\n        removeTrackCallback = trackCallback.remove;\n\n        // Detect when target's class or style attribute change\n        domWatcher.onMutation(trackCallback, {\n          categories: [MC.S_ATTRIBUTE],\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when target is resized\n        sizeWatcher.onResize(trackCallback, {\n          target: element,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          threshold: options._resizeThreshold,\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when the root is resized\n        sizeWatcher.onResize(trackCallback, {\n          target: config._root ?? MH.getWindow(),\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          threshold: options._resizeThreshold,\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when the target's scrollable ancestors are scrolled (this\n        // will almost certainly include the main scrollable element).\n        for (const ancestor of scrollableAncestors) {\n          scrollWatcher.onScroll(trackCallback, {\n            scrollable: ancestor,\n            [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n            threshold: options._scrollThreshold,\n            [MC.S_SKIP_INITIAL]: true,\n          });\n        }\n      };\n\n      const enterOrLeaveCallback = createCallback(\n        (target__ignored, viewData) => {\n          if (viewData.views[0] === MC.S_AT) {\n            if (!isInview) {\n              isInview = true;\n              addTrackCallback();\n            }\n          } else if (removeTrackCallback) {\n            isInview = false;\n            removeTrackCallback();\n            removeTrackCallback = null;\n          }\n        },\n        MH.assign(options, {\n          _viewsBitmask: VIEWS_SPACE.bitmask,\n        }),\n        TRACK_REGULAR,\n      );\n\n      viewCallback.onRemove(enterOrLeaveCallback.remove);\n\n      allViewData.set(element, viewData); // to avoid duplicate initial call\n      // Setup the track and the \"inView\" state\n      if (!enterOrLeaveCallback.isRemoved()) {\n        invokeCallback(enterOrLeaveCallback, element, viewData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentView = (target, realtime = false) =>\n      fetchElement(config._root, target).then((element) =>\n        fetchCurrentView(element, realtime),\n      );\n\n    // ----------\n\n    this.trackView = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setViewCssProps;\n      }\n\n      return setupOnView(element, handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackView = (element, handler?) => {\n      if (!handler) {\n        handler = setViewCssProps;\n      }\n\n      removeOnView(element, handler, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onView = (target, handler, options?) =>\n      setupOnView(target, handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offView = (target, handler) =>\n      removeOnView(target, handler, TRACK_REGULAR); // no need to await\n  }\n}\n\n/**\n * @interface\n */\nexport type ViewWatcherConfig = {\n  /**\n   * The root element to use for the IntersectionObserver.\n   *\n   * **NOTE:** If the target you want to observe (via\n   * {@link ViewWatcher.onView}) is inside a scrolling element, then you should\n   * probably set the watcher's root to be that scrolling element or a wrapper\n   * around it. However, even if you don't or can't do that, the watcher will\n   * try to be smart about that, and when the target is no longer intercepting\n   * because it's scrolled outside its scrolling container, and yet its\n   * bounding box is still inside the watcher root (e.g. the viewport) the\n   * watcher will determine the relative view based on the scrolling container\n   * and not the actual watcher root.\n   *\n   * @defaultValue null\n   */\n  root?: Element | null;\n\n  /**\n   * The rootMargin to pass to the IntersectionObserver constructor options.\n   *\n   * @defaultValue \"0px 0px 0px 0px\"\n   */\n  rootMargin?: string;\n\n  /**\n   * The threshold to pass to the IntersectionObserver constructor options.\n   *\n   * @defaultValue 0\n   */\n  threshold?: number | number[];\n};\n\n/**\n * @interface\n */\nexport type OnViewOptions = {\n  /**\n   * Specifies a list of {@link View}s to target for.\n   *\n   * The handler will only be called if there is a change of view relative to\n   * the target that matches the given ones.\n   *\n   * It can be a comma-separated list of \"views\" or an array of such names.\n   *\n   * @defaultValue undefined\n   */\n  views?: CommaSeparatedStr<View> | View[];\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * @interface\n */\nexport type TrackViewOptions = {\n  /**\n   * Use this debounce window for the {@link ScrollWatcher} and\n   * {@link SizeWatcher} involved in the view tracking.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts during scroll, but you probably need this when\n   * doing scroll-based animations.\n   *\n   * @defaultValue undefined // ScrollWatcher and SizeWatcher defaults\n   */\n  debounceWindow?: number;\n\n  /**\n   * Use this resize threshold for the {@link SizeWatcher} involved in the view\n   * tracking.\n   *\n   * @defaultValue undefined // SizeWatcher default\n   */\n  resizeThreshold?: number;\n\n  /**\n   * Use this scroll threshold for the {@link ScrollWatcher} involved in the\n   * view tracking.\n   *\n   * @defaultValue undefined // ScrollWatcher default\n   */\n  scrollThreshold?: number;\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - The element that is the target of the IntersectionObserver. If the call to\n *   {@link ViewWatcher.onView} specified an element as the target, it will be\n *   the same. If it specified an offset, then the element passed to the\n *   callback will be an absolutely positioned trigger overlay that's created\n *   as a result.\n * - the {@link ViewData} for relative to the target\n */\nexport type OnViewHandlerArgs = [Element, ViewData];\nexport type OnViewCallback = Callback<OnViewHandlerArgs>;\nexport type OnViewHandler = CallbackHandler<OnViewHandlerArgs> | OnViewCallback;\n\nexport type ViewData = {\n  isIntersecting: boolean;\n\n  targetBounds: BoundingRect;\n\n  rootBounds: BoundingRect;\n\n  /**\n   * The current view or views of the target. There would be two views given\n   * only if the target is _not_ in view and it's diagonally across from the\n   * root, e.g. both below and to the right.\n   */\n  views: [View, View?];\n\n  /**\n   * This is the target's position relative to the\n   * {@link ViewWatcherConfig.root | root} with values relative to the root\n   * size.\n   *\n   * It is like the {@link targetBounds} except that each quantity is scaled by\n   * the root's width or height, and having two additional computed values.\n   */\n  relative: {\n    x: number;\n    y: number;\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n    width: number;\n    height: number;\n\n    /**\n     * Average of the relative left and right.\n     */\n    hMiddle: number;\n\n    /**\n     * Average of the relative top and bottom.\n     */\n    vMiddle: number;\n  };\n};\n\n// ----------------------------------------\n\ntype ViewWatcherConfigInternal = {\n  _root: Element | null;\n  _rootMargin: string;\n  _threshold: number | number[];\n};\n\ntype OnViewOptionsInternal = {\n  _element: Element;\n  _viewsBitmask: number;\n  _debounceWindow: number | undefined;\n  _resizeThreshold: number | undefined;\n  _scrollThreshold: number | undefined;\n};\n\ntype IntersectionData = {\n  _target: Element;\n  _targetBounds: BoundingRect;\n  _root: Element | null;\n  _rootMargins: [number, number, number, number];\n  _rootBounds: BoundingRect;\n  _isIntersecting: boolean | null; // null means unknown, no IntersectionObserverEntry\n  _isCrossOrigin: boolean | null; // null means unknown, no IntersectionObserverEntry\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<Element | null, Map<string, ViewWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst getConfig = (\n  config: ViewWatcherConfig | undefined,\n): ViewWatcherConfigInternal => {\n  return {\n    _root: config?.root || null,\n    _rootMargin: config?.rootMargin ?? \"0px 0px 0px 0px\",\n    _threshold: config?.threshold || 0,\n  };\n};\n\nconst TRACK_REGULAR = 1; // only entering/leaving root\nconst TRACK_FULL = 2; // entering/leaving + moving across (fine-grained)\n\n// --------------------\n\nconst fetchOptions = async (\n  root: Element | null,\n  target: ViewTarget,\n  options: (OnViewOptions & TrackViewOptions) | undefined,\n): Promise<OnViewOptionsInternal> => {\n  return {\n    _element: await fetchElement(root, target),\n    _viewsBitmask: getViewsBitmask(options?.views),\n    _debounceWindow: options?.debounceWindow,\n    _resizeThreshold: options?.resizeThreshold,\n    _scrollThreshold: options?.scrollThreshold,\n  };\n};\n\nconst fetchScrollableAncestors = async (\n  element: Element,\n  realtime: boolean,\n) => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollableAncestors = [];\n  let ancestor: Element | null | undefined = element;\n  while ((ancestor = getClosestScrollable(ancestor, { active: true }))) {\n    scrollableAncestors.push(ancestor);\n  }\n\n  return scrollableAncestors;\n};\n\nconst viewChanged = (latestData: ViewData, prevData: ViewData | undefined) =>\n  !prevData ||\n  viewsToBitmask(prevData.views) !== viewsToBitmask(latestData.views) ||\n  !compareValuesIn(\n    MH.copyBoundingRectProps(prevData.targetBounds),\n    MH.copyBoundingRectProps(latestData.targetBounds),\n  ) ||\n  !compareValuesIn(prevData.rootBounds, latestData.rootBounds) ||\n  !compareValuesIn(prevData.relative, latestData.relative);\n\nconst viewsToBitmask = (views: [View, View?]) =>\n  VIEWS_SPACE.bit[views[0]] | (views[1] ? VIEWS_SPACE.bit[views[1]] : 0);\n\nconst fetchIntersectionData = async (\n  config: ViewWatcherConfigInternal,\n  entryOrTarget: IntersectionObserverEntry | Element,\n  realtime = false,\n): Promise<IntersectionData> => {\n  const root = config._root;\n  const vpSize = await fetchViewportSize(realtime);\n  const rootMargins = toMargins(config._rootMargin, vpSize);\n\n  let target: Element;\n  let targetBounds: BoundingRect;\n  let rootBounds: BoundingRect | null = null;\n  let isIntersecting: boolean | null = null;\n  let isCrossOrigin: boolean | null = null;\n\n  if (MH.isInstanceOf(entryOrTarget, IntersectionObserverEntry)) {\n    target = entryOrTarget.target;\n    targetBounds = entryOrTarget.boundingClientRect;\n    rootBounds = entryOrTarget.rootBounds;\n    isIntersecting = entryOrTarget.isIntersecting;\n    isCrossOrigin = !entryOrTarget.rootBounds;\n  } else {\n    target = entryOrTarget;\n    targetBounds = await fetchBounds(target, realtime);\n  }\n\n  if (!rootBounds) {\n    rootBounds = await fetchBounds(root, realtime, rootMargins);\n  }\n\n  return {\n    _target: target,\n    _targetBounds: targetBounds,\n    _root: root,\n    _rootMargins: rootMargins,\n    _rootBounds: rootBounds,\n    _isIntersecting: isIntersecting,\n    _isCrossOrigin: isCrossOrigin,\n  };\n};\n\nconst fetchBounds = async (\n  root: Element | null,\n  realtime: boolean,\n  rootMargins?: [number, number, number, number],\n): Promise<BoundingRect> => {\n  let rect: BoundingRect;\n\n  if (root) {\n    if (!realtime) {\n      await waitForMeasureTime();\n    }\n\n    rect = MH.copyBoundingRectProps(MH.getBoundingClientRect(root));\n  } else {\n    const { width, height } = await fetchViewportSize(realtime);\n    rect = {\n      x: 0,\n      left: 0,\n      right: width,\n      width,\n      y: 0,\n      top: 0,\n      bottom: height,\n      height,\n    };\n  }\n\n  if (rootMargins) {\n    rect.x = rect[MC.S_LEFT] -= rootMargins[3];\n    rect[MC.S_RIGHT] += rootMargins[1];\n    rect[MC.S_WIDTH] += rootMargins[1] + rootMargins[3];\n\n    rect.y = rect[MC.S_TOP] -= rootMargins[0];\n    rect[MC.S_BOTTOM] += rootMargins[2];\n    rect[MC.S_HEIGHT] += rootMargins[0] + rootMargins[2];\n  }\n\n  return rect;\n};\n\nconst fetchViewData = async (\n  intersection: IntersectionData,\n  realtime = false,\n): Promise<ViewData> => {\n  const vpSize = await fetchViewportSize(realtime);\n  const vpHeight = vpSize[MC.S_HEIGHT];\n  const vpWidth = vpSize[MC.S_WIDTH];\n\n  const views = await fetchViews(intersection, realtime);\n\n  const relative = MH.merge(\n    { hMiddle: NaN, vMiddle: NaN },\n    MH.copyBoundingRectProps(intersection._targetBounds),\n  );\n\n  relative.y /= vpHeight;\n  relative[MC.S_TOP] /= vpHeight;\n  relative[MC.S_BOTTOM] /= vpHeight;\n  relative[MC.S_HEIGHT] /= vpHeight;\n\n  relative.x /= vpWidth;\n  relative[MC.S_LEFT] /= vpWidth;\n  relative[MC.S_RIGHT] /= vpWidth;\n  relative[MC.S_WIDTH] /= vpWidth;\n\n  relative.hMiddle = (relative[MC.S_LEFT] + relative[MC.S_RIGHT]) / 2;\n  relative.vMiddle = (relative[MC.S_TOP] + relative[MC.S_BOTTOM]) / 2;\n\n  const viewData: ViewData = {\n    isIntersecting: intersection._isIntersecting ?? views[0] === MC.S_AT,\n    targetBounds: intersection._targetBounds,\n    rootBounds: intersection._rootBounds,\n    views,\n    relative,\n  };\n\n  return viewData;\n};\n\nconst fetchViews = async (\n  intersection: IntersectionData,\n  realtime: boolean,\n  useScrollingAncestor?: Element,\n): Promise<[View, View?]> => {\n  if (intersection._isIntersecting) {\n    return [MC.S_AT];\n  }\n\n  let rootBounds: BoundingRect;\n  if (useScrollingAncestor) {\n    rootBounds = await fetchBounds(\n      useScrollingAncestor,\n      realtime,\n      intersection._rootMargins,\n    );\n  } else {\n    rootBounds = intersection._rootBounds;\n  }\n\n  const targetBounds = intersection._targetBounds;\n  const delta = {\n    _left: rootBounds[MC.S_LEFT] - targetBounds[MC.S_LEFT],\n    _right: targetBounds[MC.S_RIGHT] - rootBounds[MC.S_RIGHT],\n    _top: rootBounds[MC.S_TOP] - targetBounds[MC.S_TOP],\n    _bottom: targetBounds[MC.S_BOTTOM] - rootBounds[MC.S_BOTTOM],\n  };\n\n  let xView: View | null = null;\n  let yView: View | null = null;\n  if (delta._left > 0 && delta._right > 0) {\n    // Target is wider than root: use greater delta to determine position.\n    // Remember, the view is the _root_ position relative to target.\n    xView = delta._left > delta._right ? MC.S_RIGHT : MC.S_LEFT;\n  } else if (delta._left > 0) {\n    // Target is to the left of the root\n    xView = MC.S_RIGHT;\n  } else if (delta._right > 0) {\n    // Target is to the right of the root\n    xView = MC.S_LEFT;\n  } // else target is horizontally contained in root, see below\n\n  if (delta._top > 0 && delta._bottom > 0) {\n    // Target is taller than root: use greater delta to determine position.\n    // Remember, the view is the _root_ position relative to target.\n    yView = delta._top > delta._bottom ? MC.S_BELOW : MC.S_ABOVE;\n  } else if (delta._top > 0) {\n    // Target is above the root\n    yView = MC.S_BELOW;\n  } else if (delta._bottom > 0) {\n    // Target is below the root\n    yView = MC.S_ABOVE;\n  } // else target is vertically contained in root, see below\n\n  if (xView && yView) {\n    // diagonally out of vide\n    return [xView, yView];\n  } else if (xView) {\n    // horizontally out of vide\n    return [xView];\n  } else if (yView) {\n    // vertically out of vide\n    return [yView];\n  }\n\n  // The target is contained in the root bounds and yet isIntersecting was\n  // not true. This means that either:\n  //\n  // 1. It may be intersecting, but we didn't get an actual\n  //    IntersectionObserverEntry and we don't know if it's intersecting\n  //    or not\n  // 2. The target is inside a scrolling element that is _not_ being used as\n  //    the observer root, and the target has scrolled out of the scrollable\n  //    bounds but still inside the viewport\n  // 3. We're inside a cross-origin iFrame and the iFrame is partially or\n  //    fully not-intersecting\n\n  if (!intersection._isCrossOrigin) {\n    // This is case 1. or 2. => get the views relative to the closest\n    // scrollable ancestor relative to which it is _not_ intersecting, if\n    // any. If it's nested inside several scrolling elements, we'll end up\n    // looping over each one until we find the one for which the target is\n    // outside its box.\n    //\n    // It is too risky to use active isScrollable check here since we could be\n    // inside an onScroll handler, so just use passive.\n    const scrollingAncestor = getClosestScrollable(\n      useScrollingAncestor ?? intersection._target,\n    );\n\n    if (scrollingAncestor) {\n      return fetchViews(intersection, realtime, scrollingAncestor);\n    }\n  }\n\n  // Either case 3. (cross-origin iframe outside the viewport) or case 1. and\n  // the target is actually intersecting the root. Either way, it's to be\n  // considered in-view of its root.\n  return [MC.S_AT];\n};\n\nconst setViewCssProps = (\n  element: Element,\n  viewData: ViewData | undefined | null,\n) => {\n  const relative: Record<string, number> = viewData?.relative || {};\n  const props = {\n    top: relative.top,\n    bottom: relative.bottom,\n    left: relative.left,\n    right: relative.right,\n    [MC.S_WIDTH]: relative[MC.S_WIDTH],\n    [MC.S_HEIGHT]: relative[MC.S_HEIGHT],\n    hMiddle: relative.hMiddle,\n    vMiddle: relative.vMiddle,\n  };\n  setNumericStyleProps(element, props, { _prefix: \"r-\", _numDecimal: 4 }); // don't await here\n};\n\nconst fetchElement = async (\n  root: Element | null,\n  target: ViewTarget,\n): Promise<Element> => {\n  if (MH.isElement(target)) {\n    return target;\n  } else if (!MH.isString(target)) {\n    throw MH.usageError(\n      \"'target' must be an offset string or an HTMLElement | SVGElement | MathMLElement\",\n    );\n  }\n\n  const overlayOptions = getOverlayOptions(root, target);\n  return await createOverlay(overlayOptions);\n};\n\nconst getOverlayOptions = (\n  root: Element | null,\n  target: string,\n): OverlayOptions => {\n  const { reference, value } = parseScrollOffset(target);\n\n  let ovrDimension: \"width\" | \"height\";\n  if (reference === MC.S_TOP || reference === MC.S_BOTTOM) {\n    ovrDimension = MC.S_WIDTH;\n  } else if (reference === MC.S_LEFT || reference === MC.S_RIGHT) {\n    ovrDimension = MC.S_HEIGHT;\n  } else {\n    throw MH.usageError(`Invalid offset reference: '${reference}'`);\n  }\n\n  return {\n    parent: MH.isHTMLElement(root) ? root : undefined,\n    style: {\n      [reference]: value,\n      [ovrDimension]: \"100%\",\n    },\n  };\n};\n\nconst invokeCallback = (\n  callback: OnViewCallback,\n  element: Element,\n  viewData: ViewData,\n) => callback.invoke(element, MH.copyObject(viewData)).catch(logError);\n","/**\n * @module\n * @ignore\n * @internal\n */\n\nimport { settings } from \"@lisn/globals/settings\";\nsettings.autoWidgets = true;\n\nexport { settings } from \"@lisn/globals/settings\";\nexport * as watchers from \"@lisn/watchers/index\";\n"],"names":["PREFIX","LOG_PREFIX","OBJECT","Object","SYMBOL","Symbol","ARRAY","Array","STRING","String","FUNCTION","Function","MATH","Math","NUMBER","Number","PROMISE","Promise","PI","INFINITY","Infinity","S_ABSOLUTE","S_FIXED","S_WIDTH","S_HEIGHT","S_TOP","S_BOTTOM","S_UP","S_DOWN","S_LEFT","S_RIGHT","S_AT","S_ABOVE","S_BELOW","S_IN","S_OUT","S_NONE","S_AMBIGUOUS","S_ADDED","S_REMOVED","S_ATTRIBUTE","S_KEY","S_MOUSE","S_POINTER","S_TOUCH","S_WHEEL","S_CLICK","S_HOVER","S_PRESS","S_SCROLL","S_ZOOM","S_DRAG","S_UNKNOWN","S_SCROLL_TOP","concat","S_SCROLL_LEFT","S_SCROLL_WIDTH","S_SCROLL_HEIGHT","S_CLIENT_WIDTH","S_CLIENT_HEIGHT","S_SCROLL_TOP_FRACTION","S_SCROLL_LEFT_FRACTION","S_SKIP_INITIAL","S_DEBOUNCE_WINDOW","S_CANCEL","S_KEYDOWN","S_MOUSEUP","S_MOUSEDOWN","S_POINTERUP","S_POINTERDOWN","S_POINTERMOVE","S_POINTERCANCEL","S_TOUCHSTART","S_TOUCHEND","S_TOUCHMOVE","S_TOUCHCANCEL","S_SELECTSTART","S_ATTRIBUTES","S_CHILD_LIST","S_ROLE","ARIA_PREFIX","PREFIX_TRANSITION","PREFIX_TRANSITION_DISABLE","PREFIX_HIDE","PREFIX_SHOW","PREFIX_NO_SELECT","PREFIX_NO_TOUCH_ACTION","PREFIX_NO_WRAP","USER_AGENT","navigator","userAgent","match","LisnError","_Error","_classCallCheck","_callSuper","arguments","_inherits","_createClass","_wrapNativeSuper","Error","LisnUsageError","_LisnError","_this","message","length","undefined","name","LisnBugError","_LisnError2","_this2","root","self","_typeof","global","kebabToCamelCase","str","replace","m","toUpperCase","charAt","camelToKebabCase","toLowerCase","prefixName","MC","prefixCssVar","prefixCssJsVar","prefixData","prefixLisnData","s","timeNow","Date","now","bind","timeSince","startTime","hasDOM","document","getWindow","window","getDoc","getDocElement","documentElement","getDocScrollingElement","scrollingElement","getBody","body","getReadyState","readyState","getPointerType","event","isPointerEvent","pointerType","isMouseEvent","onAnimationFrame","requestAnimationFrame","createElement","tagName","options","createButton","label","tag","btn","setTabIndex","setAttr","isNullish","v","isEmpty","isIterableObject","isNonPrimitive","iterator","isArray","isInstanceOf","isObject","typeOf","isNumber","isString","isLiteralString","isBoolean","isFunction","isDoc","target","MouseEvent","PointerEvent","isTouchPointerEvent","isWheelEvent","WheelEvent","isKeyboardEvent","KeyboardEvent","isTouchEvent","TouchEvent","isNode","Node","isElement","Element","isHTMLElement","HTMLElement","isNodeBAfterA","nodeA","nodeB","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","strReplace","replacement","setTimer","setTimeout","clearTimer","clearTimeout","getBoundingClientRect","el","copyBoundingRectProps","rect","_defineProperty","x","left","right","y","top","bottom","querySelector","selector","querySelectorAll","docQuerySelector","docQuerySelectorAll","getElementById","id","getAttr","getAttribute","value","setAttribute","unsetAttr","delAttr","removeAttribute","includes","arr","startAt","indexOf","filter","array","filterFn","filterBlank","result","lengthOf","sizeOf","obj","_obj$size","size","_obj$length","preventDefault","arrayFrom","from","keysOf","keys","defineProperty","merge","_MC$OBJECT","_len","a","_key","assign","apply","copyObject","promiseResolve","resolve","promiseAll","all","freezeObj","freeze","hasOwnProp","o","prop","prototype","hasOwnProperty","call","preventExtensions","stringify","JSON","floor","ceil","log2","sqrt","max","min","abs","round","pow","parseFloat","isNaN","Class","constructorOf","constructor","typeOrClassOf","_constructorOf","parentOf","element","parentElement","childrenOf","children","targetOf","currentTargetOf","currentTarget","classList","S_TABINDEX","getTabIndex","index","unsetTabIndex","remove","deleteObjKey","key","deleteKey","map","elScrollTo","coords","behavior","scrollTo","elScrollBy","scrollBy","newPromise","executor","newMap","entries","Map","newWeakMap","WeakMap","newSet","values","Set","newWeakSet","WeakSet","newIntersectionObserver","callback","IntersectionObserver","newResizeObserver","ResizeObserver","newMutationObserver","MutationObserver","usageError","msg","bugError","illegalConstructorError","useWhat","CONSOLE","console","consoleDebug","debug","consoleLog","log","consoleInfo","info","consoleWarn","warn","consoleError","error","settings","MH","mainScrollableElementSelector","contentWrappingAllowed","pageLoadTimeout","autoWidgets","scrollbarHideNative","scrollbarOnMobile","scrollbarPositionH","scrollbarPositionV","scrollbarAutoHide","scrollbarClickScroll","scrollbarDragScroll","scrollbarUseHandle","sameHeightDiffTolerance","sameHeightResizeThreshold","sameHeightDebounceWindow","sameHeightMinGap","sameHeightMaxFreeR","sameHeightMaxWidthR","deviceBreakpoints","mobile","tablet","desktop","aspectRatioBreakpoints","tall","square","wide","lightThemeClassName","darkThemeClassName","deltaLineHeight","deltaPageWidth","deltaPageHeight","verbosityLevel","remoteLoggerURL","remoteLoggerOnMobileOnly","roundNumTo","numDecimal","multiplicationFactor","isValidNum","isFinite","toNum","defaultValue","numValue","toNonNegNum","toPosNum","toNumWithBounds","limits","_limits$min","_limits$max","_ref","maxAbs","_toConsumableArray","havingMaxAbs","_len3","_key3","sort","b","hAngle","normalizeAngle","atan2","degToRad","areParallel","vA","vB","angleDiffThreshold","angleA","angleB","areAntiParallel","distanceBetween","ptA","ptB","easeInOutQuad","sortedKeysByVal","descending","getBitmask","start","end","copyExistingKeys","fromObj","toObj","omitKeys","keysToRm","res","compareValuesIn","objA","objB","roundTo","valA","valB","formatAsString","maxLen","maybeConvertToString","joinAsString","separator","args","join","splitOn","input","trim","limit","output","addEntry","push","matchIndex","matchLength","_match$index","exec","slice","randId","nChars","segment","random","toString","toMargins","absoluteSize","_parts$","_parts$2","_parts$3","toPxValue","strValue","margin","parts","margins","objToStrKey","flattenForSorting","k","stringifyReplacer","nested","classStr","stack","validateStrList","checkFn","_toArray","toArray","_validateString","typeDescription","BitSpaces","counter","newCounter","create","propNames","newBitSpace","get","_nBits","_bitmask","newBitSpaces","createBitSpace","spaces","_len2","_key2","bitmask","space","bit","has","p","bitmaskFor","pStart","pEnd","thisStart","thisEnd","nameOf","val","_propNames","_iterator","_createForOfIteratorHelper","_step","n","done","enumerable","err","e","f","DOM_CATEGORIES_SPACE","scheduleHighPriorityTask","task","scheduler","postTask","priority","channel","MessageChannel","port1","onmessage","close","port2","postMessage","getDebouncedHandler","debounceWindow","handler","timer","lastArgs","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","stop","waitForDelay","delay","wrapCallback","handlerOrCallback","isRemoved","callablesMap","invoke","wrapper","Callback","onRemove","rmFn","CallbackScheduler","_clear","fn","add","reject","_push","sent","t0","REMOVE","set","queues","flush","_ref2","_callee2","queue","_callee2$","_context2","_running","_task","shift","_x","item","_onRemove","logWarn","isMessageSeen","logError","discardMessages","isSeen","waitForMutateTime","scheduleDOMTask","scheduledDOMMutations","waitForMeasureTime","scheduledDOMMeasurements","waitForSubsequentMutateTime","then","waitForSubsequentMeasureTime","hasScheduledDOMTasks","runAllDOMTasks","runDOMTaskQueue","isInlineTag","inlineTags","isDOMElement","SVGElement","MathMLElement","transitionElementNow","fromCls","toCls","cancelCSSTransitions","didChange","hasClass","removeClassesNow","addClassesNow","transitionElement","thisTransition","transitionDuration","_args","scheduleCSSTransition","_isCancelled","abrupt","_finish","getMaxTransitionDuration","_x2","_x3","hideElement","className","contains","_MH$classList","classNames","addClasses","_MH$classList2","removeClasses","_len4","_key4","getData","setDataNow","getComputedStylePropNow","getComputedStyle","getPropertyValue","getComputedStyleProp","getStylePropNow","_style","style","getStyleProp","setStylePropNow","_style2","setProperty","setStyleProp","delStylePropNow","_style3","removeProperty","delStyleProp","propVal","duration","_x4","_ref3","_callee3","_args3","_callee3$","_context3","disableInitialTransition","_x5","_ref4","_callee4","fromElement","toElement","includeComputedProps","props","_prop","_prop2","_callee4$","_context4","copyStyle","_x6","_x7","_x8","setNumericStyleProps","_ref5","_callee5","transformFn","varPrefix","cssPropSuffix","varName","_options$_numDecimal","thisNumDecimal","currValue","_args5","_callee5$","_context5","_transformFn","_prefix","t1","_numDecimal","t2","t3","_units","_x9","_x10","scheduledCSSTransitions","scheduledTransitions","_len5","toClasses","_key5","_i","_toClasses","scheduledTransition","_cancel","isCancelled","wrapElementNow","createWrapperFor","ignoreMove","to","replaceWith","append","wrapElement","wrapChildrenNow","moveChildrenNow","moveElementNow","wrapChildren","replaceElementNow","newElement","replaceElement","swapElementsNow","elementA","elementB","temp","swapElements","oldParent","newParent","child","moveChildren","_x11","_x12","_x13","parentEl","position","moveElement","_ref6","_callee6","_callee6$","_context6","_x14","_x15","_ref7","_callee7","_args7","_callee7$","_context7","hideAndRemoveElement","_x16","wrapScrollingContent","_ref8","_callee8","firstChild","_callee8$","_context8","PREFIX_CONTENT_WRAPPER","_x17","recordsToSkipOnce","getIgnoreMove","clearIgnoreMove","waitForElement","timeout","callFn","observer","disconnect","observe","childList","subtree","waitForElementOrInteractive","isInteractive","waitForInteractive","INTERACTIVE","COMPLETE","addEventListener","waitForComplete","waitForPageReady","pageIsReady","dispatchReady","newXMap","getDefaultV","XMap","newXMapGetter","newXWeakMap","XWeakMap","newXWeakMapGetter","XMapBase","sGet","prune","sk","rest","_XMapBase","clear","_XMapBase2","DOMWatcher","config","CONSTRUCTOR_KEY","buffer","t","_target","_categoryBitmask","_attributes","_addedTo","_removedFrom","allCallbacks","mutationHandler","records","record","recType","type","_iterator3","addedNodes","_step3","operation","ADDED_BIT","_iterator4","removedNodes","_step4","REMOVED_BIT","attributeName","ATTRIBUTE_BIT","_iterator2","_step2","shouldSkipOperation","processOperation","observers","_observer","_isActive","createCallback","_allCallbacks$get","_callback","deleteHandler","_options","setupOnMutation","userOptions","childQueue","_arr","initOperation","bufferedOperation","diffOperation","getOptions","_root","activateObserver","skipInitial","_selector","takeRecords","matches","getDiffOperation","invokeCallback","activeCategories","_iterator5","_step5","entry","deactivateObserver","_iterator6","_step6","categoryBitmask","currentTargets","mutationType","_subtree","requestToSkip","removedFrom","addedTo","requestFrom","requestTo","onMutation","offMutation","_allCallbacks$get2","getConfig","reuse","_instances$get","myConfig","configStrKey","instance","instances","_config$subtree","CATEGORIES_BITS","categories","_iterator7","_step7","cat","operationA","operationB","attributes","_iterator8","_step8","attr","_iterator9","_step9","getMaxDeltaDirection","deltaX","deltaY","getVectorDirection","vector","isValidDirection","direction","DIRECTIONS","XY_DIRECTIONS","Z_DIRECTIONS","SCROLL_DIRECTIONS","callEventListener","handleEvent","addEventListenerTo","eventType","transformEventType","getEventHandlerData","thirdArg","wrappedHandler","supports","getBrowserSupport","_optionsArg","_options$capture","capture","once","removeEventListenerFrom","setEventHandlerData","_wrappedHandler","_thirdArg","data","removeEventListener","deleteEventHandlerData","preventSelect","undoPreventSelect","browserEventSupport","_pointer","passive","signal","optTest","opt","_loop","thisOpt","AbortController","dummyHandler","dummyElement","e__ignored","registeredEventHandlerData","getEventOptionsStr","finalOptions","_registeredEventHandl","optionsStr","_registeredEventHandl2","startsWith","isValidInputDevice","device","DEVICES","isValidIntent","intent","INTENTS","addDeltaZ","current","increment","MIN_DELTA_Z","getKeyGestureFragment","events","_options$scrollHeight","LINE","PAGE","CONTENT","scrollHeight","deltasUp","amount","deltasDown","deltasLeft","deltasRight","deltasIn","deltasOut","deltaZ","_deltasForKey","deltasForKey","SK_UP","SK_ARROWUP","SK_PAGEUP","SK_DOWN","SK_ARROWDOWN","SK_PAGEDOWN","SK_LEFT","SK_ARROWLEFT","SK_RIGHT","SK_ARROWRIGHT","shiftKey","ctrlKey","theseDeltas","_theseDeltas","_slicedToArray","thisDeltaX","thisDeltaY","thisDeltaZ","thisIntent","SK_PAGE","SK_ARROW","getPointerGestureFragment","pointerEventClass","pointerUpType","filteredEvents","eType","buttons","numEvents","firstEvent","lastEvent","clientX","clientY","getTouchGestureFragment","_options$dragHoldTime","_options$dragNumFinge","moves","getTouchDiff","deltaThreshold","numMoves","holdTime","getHoldTime","canBeDrag","dragHoldTime","dragNumFingers","d","isSignificant","vectorA","vectorB","startDistance","startX","startY","endDistance","endX","endY","deltaSign","reverseScroll","isFirst","thisDirection","lastTouchEvent","touches","groupedTouches","touch","identifier","touchList","nTouches","firstTouch","lastTouch","firstStart","findIndex","firstMove","timeStamp","normalizeWheel","spinX","spinY","pixelX","pixelY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","deltaMode","getWheelGestureFragment","maxDelta","percentage","GestureWatcher","allListeners","_getCallbackAndWrappe","getCallbackAndWrapper","_wrapper","setupOnGesture","_allListeners$get","listeners","_devices","setupListeners","_nCallbacks","_preventDefault","_nPreventDefault","_allListeners$get2","_remove","invokeCallbacks","_allListeners$get3","isTerminated","intents","_intents","hasAddedTabIndex","hasPreventedSelect","addOrRemoveListeners","action","listener","eventTypes","method","addInitialListener","initialListener","initiatingEvents","removeInitialListener","addOngoingListener","processEvent","ongoingEvents","removeOngoingListener","trackGesture","setGestureCssProps","totalDeltaX","totalDeltaY","totalDeltaZ","noTrackGesture","offGesture","onGesture","_allCallbacks$get3","_config$preventDefaul","_config$naturalTouchS","_config$touchDragHold","_config$touchDragNumF","_debounceWindow","_deltaThreshold","_angleDiffThreshold","_naturalTouchScroll","naturalTouchScroll","_touchDragHoldTime","touchDragHoldTime","_touchDragNumFingers","touchDragNumFingers","pointer","wheel","fragmentGetters","_options$minTotalDelt","_options$maxTotalDelt","_options$minTotalDelt2","_options$maxTotalDelt2","_options$minTotalDelt3","_options$maxTotalDelt3","_options$preventDefau","_options$naturalTouch","_options$touchDragHol","_options$touchDragNum","devices","_directions","directions","_minTotalDeltaX","minTotalDeltaX","_maxTotalDeltaX","maxTotalDeltaX","_minTotalDeltaY","minTotalDeltaY","_maxTotalDeltaY","maxTotalDeltaY","_minTotalDeltaZ","minTotalDeltaZ","_maxTotalDeltaZ","maxTotalDeltaZ","logger","preventNextClick","eventQueue","debouncedWrapper","fragment","eventQueueCopy","_eventQueueCopy","_eventQueueCopy$","clearEventQueue","newTotalDeltaX","newTotalDeltaY","newTotalDeltaZ","time","preventDefaultActionFor","keepLastEvent","splice","isActualGesture","isPointerDown","focus","preventScroll","prefix","getLayoutBitmask","layoutBitmask","getBitmaskFromSpec","S_DEVICES","ORDERED_DEVICES","S_ASPECTRS_CAMEL","aspectRatios","ORDERED_ASPECTR","ORDERED_DEVICE_NAMES","ORDERED_ASPECTR_NAMES","bitSpaces","NUM_LAYOUTS","LAYOUT_RANGE_REGEX","RegExp","keyName","spec","bitSpace","singleKeyName","rangeMatch","groups","minLayout","layoutA","maxLayout","layoutB","layouts","lt","isScrollable","axis","active","noCache","_isScrollableCache$ge","cachedResult","isScrollableCache","offset","doCache","canScroll","dimension","IS_SCROLLABLE_CACHE_TIMEOUT","getClosestScrollable","ancestor","getCurrentScrollAction","scrollable","toScrollableOrDefault","currentScrollAction","_scrollable","currentScroll","cancel","cancelFn","_weCanInterrupt","scrollEvents","preventScrollHandler","_userCanInterrupt","promise","initiateScroll","thisScrollAction","waitFor","cleanup","_scrollEvents","isValidScrollDirection","getClientWidthNow","isScrollableBodyInQuirks","offsetWidth","getBorderWidth","getClientHeightNow","offsetHeight","fetchMainContentElement","init","mainContentElement","tryGetMainScrollableElement","mainScrollableElement","fetchMainScrollableElement","getDefaultScrollingElement","fetchScrollableElement","toScrollableOrMain","mappedScrollables","DIFF_THRESHOLD","arePositionsDifferent","getMain","_options$weCanInterru","_options$userCanInter","getTargetCoordinates","altTarget","_offset","_altTarget","_altOffset","altOffset","_duration","weCanInterrupt","userCanInterrupt","docScrollingElement","targetEl","getStartEndPosition","applyOffset","getEndPosition","startPosition","targetCoordinates","endPosition","scrollH","scrollW","clientH","clientW","previousTimeStamp","currentPosition","step","elapsed","progress","side","initPromise","contentElement","createOverlay","canReuse","_overlays$get2","existingOverlay","overlay","isPercentageHOffset","isPercentageVOffset","needsContentWrapping","fetchOverlayOptions","_id","overlays","_parent","_overlayKey","createOnlyOverlay","_userOptions$data2","_userOptions$id2","getCssProperties","fetchParent","parent","_data","getOverlayKey","finalCssProperties","userSuppliedParent","getEntryContentBox","contentBoxSize","getSizeFromInlineBlock","contentRect","getEntryBorderBox","fallbackToContent","borderBoxSize","NaN","isValidBox","box","ALL_BOXES","isValidDimension","ALL_DIMENSIONS","tryGetViewportOverlay","viewportOverlay","fetchViewportOverlay","fetchViewportSize","_MH$getDocScrollingEl","realtime","_args2","clientWidth","clientHeight","S_INLINE_SIZE","S_BLOCK_SIZE","XResizeObserver","targetsToSkip","observedTargets","resizeHandler","skipNum","borderObserver","contentObserver","observeTarget","targets","_targets","observeLater","_i2","_targets2","unobserve","_i3","_targets3","SizeWatcher","allSizeData","processEntry","xObserver","fetchCurrentSize","sizeData","fetchElement","getSizeData","border","content","fetchOptions","_options$box","_options$dimension","_options$MC$S_DEBOUNC","threshold","_resizeThreshold","t4","_element","_box","_dimension","_threshold","setupOnResize","removeOnResize","currEntry","setSizeCssProps","latestData","thresholdsExceeded","hasExceededThreshold","trackSize","noTrackSize","onResize","offResize","resizeThreshold","lastThresholdData","dim","diff","borderBox","contentBox","borderWidth","borderHeight","contentWidth","contentHeight","LayoutWatcher","nonIntersectingBitmask","currentLayoutData","aspectRatio","fetchCurrentLayout","readyPromise","setupOverlays","_yield$createOverlays","createOverlays","_deviceBreakpoints","_aspectRatioBreakpoints","isReady","intersectionHandler","numEntries","getNonIntersecting","processLayoutChange","observeOptions","rootMargin","triggerOverlay","_layoutBitmask","setupOnLayout","layoutData","changeMatches","skipCallbacks","deviceBit","aspectRatioBit","onLayout","offLayout","VAR_BORDER_HEIGHT","PREFIX_DEVICE","PREFIX_ASPECTR","overlayPromises","overlayParent","parentHeightCss","getOverlayLayout","layout","thisLayoutData","prevLayoutData","isIntersecting","isValidPointerAction","POINTER_ACTIONS","PointerWatcher","setupOnPointer","startHandler","endHandler","startCallback","endCallback","_actions","listenerSetupFn","onPointer","offPointer","_config$preventSelect","_preventSelect","_options$preventSelec","actions","setupClickListener","toggleState","state","setupPointerListeners","startEventSuff","endEventSuff","startEvent","endEvent","startListener","endListener","click","hover","press","actionData","ScrollWatcher","allScrollData","activeListeners","fetchCurrentScroll","isScrollEvent","previousEventData","fetchScrollData","trackType","_trackType","setupOnScroll","eventTarget","scrollData","listenerOptions","fetchOnScrollOptions","_eventTarget","TRACK_FULL","setupSizeTrack","_nRealtime","scrollHandler","directionMatches","removeOnScroll","setScrollCssProps","scrollCallback","doc","resizeCallback","sizeWatcher","observedElements","allowedToWrap","domWatcher","onAddedCallback","_activeListeners$get","finish","scroll","_options$amount","isVertical","sign","targetCoordinate","asFractionOf","_scrollDuration","t5","t6","t7","fetchCurrentScrollAction","stopUserScrolling","stopScroll","_args8","immediate","trackScroll","noTrackScroll","onScroll","TRACK_REGULAR","offScroll","_scrollThreshold","scrollThreshold","scrollDuration","_ref9","_callee9","_callee9$","_context9","getEventTarget","userDirections","latestDirection","topDiff","leftDiff","checkTop","checkLeft","_ref10","_callee10","scrollTop","scrollLeft","scrollWidth","scrollTopFraction","scrollLeftFraction","prevScrollTop","prevScrollLeft","_callee10$","_context10","isValidView","view","VIEWS","getViewsBitmask","viewsStr","viewsBitmask","views","VIEWS_SPACE","parseScrollOffset","_match$groups","_match$groups2","OFFSET_REGEX","reference","ref","XIntersectionObserver","selectedEntries","thresholds","ViewWatcher","allViewData","_rootMargin","fetchCurrentView","fetchData","entryOrElement","intersection","fetchIntersectionData","fetchViewData","setupOnView","viewData","rootBounds","setupInviewTrack","viewsToBitmask","_viewsBitmask","removeOnView","setViewCssProps","_entry","viewCallback","scrollWatcher","isInview","removeTrackCallback","scrollableAncestors","addTrackCallback","enterOrLeaveCallback","fetchScrollableAncestors","_config$_root","trackCallback","prevData","changed","viewChanged","target__ignored","trackView","noTrackView","onView","offView","_config$rootMargin","targetBounds","relative","entryOrTarget","vpSize","rootMargins","isCrossOrigin","_args9","IntersectionObserverEntry","boundingClientRect","fetchBounds","_targetBounds","_rootMargins","_rootBounds","_isIntersecting","_isCrossOrigin","_x18","_x19","_yield$fetchViewportS","width","height","_x20","_x21","_x22","_ref11","_callee11","_intersection$_isInte","vpHeight","vpWidth","_args11","_callee11$","_context11","fetchViews","hMiddle","vMiddle","_x23","_ref12","_callee12","useScrollingAncestor","delta","xView","yView","scrollingAncestor","_callee12$","_context12","_left","_right","_top","_bottom","_x24","_x25","_x26","_ref13","_callee13","overlayOptions","_callee13$","_context13","getOverlayOptions","_x27","_x28","_parseScrollOffset","ovrDimension"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQO,IAAMA,MAAM,GAAG,MAAM;AACrB,IAAMC,UAAU,GAAG,WAAW;AAE9B,IAAMC,MAAM,GAAGC,MAAM;AACrB,IAAMC,MAAM,GAAGC,MAAM;AACrB,IAAMC,KAAK,GAAGC,KAAK;AACnB,IAAMC,MAAM,GAAGC,MAAM;AACrB,IAAMC,QAAQ,GAAGC,QAAQ;AACzB,IAAMC,IAAI,GAAGC,IAAI;AACjB,IAAMC,MAAM,GAAGC,MAAM;AACrB,IAAMC,OAAO,GAAGC,OAAO;AAEvB,IAAMC,EAAE,GAAGN,IAAI,CAACM,EAAE;AAClB,IAAMC,QAAQ,GAAGC,QAAQ;AAEzB,IAAMC,UAAU,GAAG,UAAU;AAC7B,IAAMC,OAAO,GAAG,OAAO;AAGvB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,QAAQ,GAAG,QAAQ;AAEzB,IAAMC,KAAK,GAAG,KAAK;AACnB,IAAMC,QAAQ,GAAG,QAAQ;AAEzB,IAAMC,IAAI,GAAG,IAAI;AACjB,IAAMC,MAAM,GAAG,MAAM;AAErB,IAAMC,MAAM,GAAG,MAAM;AACrB,IAAMC,OAAO,GAAG,OAAO;AAEvB,IAAMC,IAAI,GAAG,IAAI;AACjB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,OAAO,GAAG,OAAO;AAEvB,IAAMC,IAAI,GAAG,IAAI;AACjB,IAAMC,KAAK,GAAG,KAAK;AAEnB,IAAMC,MAAM,GAAG,MAAM;AACrB,IAAMC,WAAW,GAAG,WAAW;AAE/B,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,SAAS,GAAG,SAAS;AAC3B,IAAMC,WAAW,GAAG,WAAW;AAE/B,IAAMC,KAAK,GAAG,KAAK;AACnB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,SAAS,GAAG,SAAS;AAC3B,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,OAAO,GAAG,OAAO;AACvB,IAAMC,OAAO,GAAG,OAAO;AAEvB,IAAMC,QAAQ,GAAG,QAAQ;AACzB,IAAMC,MAAM,GAAG,MAAM;AACrB,IAAMC,MAAM,GAAG,MAAM;AACrB,IAAMC,SAAS,GAAG,SAAS;AAE3B,IAAMC,YAAY,GAAA,EAAA,CAAAC,MAAA,CAAML,QAAQ,EAAgC,KAAA,CAAA;AAChE,IAAMM,aAAa,GAAA,EAAA,CAAAD,MAAA,CAAML,QAAQ,EAAkC,MAAA,CAAA;AAEnE,IAAMO,cAAc,GAAA,EAAA,CAAAF,MAAA,CAAML,QAAQ,EAAoC,OAAA,CAAA;AACtE,IAAMQ,eAAe,GAAA,EAAA,CAAAH,MAAA,CACvBL,QAAQ,EAAsC,QAAA,CAAA;AAE5C,IAAMS,cAAc,GAAG,aAAa;AACpC,IAAMC,eAAe,GAAG,cAAc;AAEtC,IAAMC,qBAAqB,GAAA,EAAA,CAAAN,MAAA,CAC7BL,QAAQ,EAAgD,aAAA,CAAA;AACtD,IAAMY,sBAAsB,GAAA,EAAA,CAAAP,MAAA,CAC9BL,QAAQ,EAAkD,cAAA,CAAA;AAIxD,IAAMa,cAAc,GAAG,aAAa;AACpC,IAAMC,iBAAiB,GAAG,gBAAgB;AAG1C,IAAMC,QAAQ,GAAG,QAAQ;AAEzB,IAAMC,SAAS,GAAIxB,KAAK,GAAGb,MAA4C;AAEvE,IAAMsC,SAAS,GAAIxB,OAAO,GAAGf,IAA0C;AACvE,IAAMwC,WAAW,GAAIzB,OAAO,GACjCd,MAA8C;AAGzC,IAAMwC,WAAW,GAAIzB,SAAS,GACnChB,IAA4C;AACvC,IAAM0C,aAAa,GAAI1B,SAAS,GACrCf,MAAgD;AAG3C,IAAM0C,aAAa,GAAA,EAAA,CAAAhB,MAAA,CAAMX,SAAS,EAAmC,MAAA,CAAA;AACrE,IAAM4B,eAAe,GAAI5B,SAAS,GACvCqB,QAAoD;AAE/C,IAAMQ,YAAY,GAAA,EAAA,CAAAlB,MAAA,CAAMV,OAAO,EAAmC,OAAA,CAAA;AAClE,IAAM6B,UAAU,GAAA,EAAA,CAAAnB,MAAA,CAAMV,OAAO,EAA+B,KAAA,CAAA;AAC5D,IAAM8B,WAAW,GAAA,EAAA,CAAApB,MAAA,CAAMV,OAAO,EAAiC,MAAA,CAAA;AAC/D,IAAM+B,aAAa,GAAI/B,OAAO,GACnCoB,QAAkD;AAS7C,IAAMY,aAAa,GAAG,aAAa;AAEnC,IAAMC,YAAY,GAAG,YAAY;AACjC,IAAMC,YAAY,GAAG,WAAW;AAQhC,IAAMC,MAAM,GAAG,MAAM;AAErB,IAAMC,WAAW,GAAG,OAAO;AAK3B,IAAMC,iBAAiB,GAAA,EAAA,CAAA3B,MAAA,CAAMtD,MAAM,EAAa,aAAA,CAAA;AAChD,IAAMkF,yBAAyB,GAAA,EAAA,CAAA5B,MAAA,CAAM2B,iBAAiB,EAAW,WAAA,CAAA;AACjE,IAAME,WAAW,GAAA,EAAA,CAAA7B,MAAA,CAAMtD,MAAM,EAAO,OAAA,CAAA;AACpC,IAAMoF,WAAW,GAAA,EAAA,CAAA9B,MAAA,CAAMtD,MAAM,EAAO,OAAA,CAAA;AAQpC,IAAMqF,gBAAgB,GAAA,EAAA,CAAA/B,MAAA,CAAMtD,MAAM,EAAY,YAAA,CAAA;AAC9C,IAAMsF,sBAAsB,GAAA,EAAA,CAAAhC,MAAA,CAAMtD,MAAM,EAAkB,kBAAA,CAAA;AAC1D,IAAMuF,cAAc,GAAA,EAAA,CAAAjC,MAAA,CAAMtD,MAAM,EAAU,UAAA,CAAA;AAS1C,IAAMwF,UAAU,GACrB,OAAOC,SAAS,KAAK,WAAW,GAAG,EAAE,GAAGA,SAAS,CAACC,SAAS;AAG3DF,UAAU,CAACG,KAAK,CACd,+DACF,CAAC,KAAK;;AC7JcC,IAAAA,SAAS,aAAAC,MAAA,EAAA;AAAA,EAAA,SAAAD,SAAA,GAAA;AAAAE,IAAAA,eAAA,OAAAF,SAAA,CAAA;AAAA,IAAA,OAAAG,UAAA,CAAA,IAAA,EAAAH,SAAA,EAAAI,SAAA,CAAA;AAAA;EAAAC,SAAA,CAAAL,SAAA,EAAAC,MAAA,CAAA;EAAA,OAAAK,YAAA,CAAAN,SAAA,CAAA;AAAA,CAAAO,CAAAA,gBAAA,CAASC,KAAK,CAAA,CAAA;AAKhCC,IAAAA,cAAc,aAAAC,UAAA,EAAA;AACzB,EAAA,SAAAD,iBAA0B;AAAA,IAAA,IAAAE,KAAA;AAAA,IAAA,IAAdC,OAAO,GAAAR,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAAAF,IAAAA,eAAA,OAAAO,cAAA,CAAA;IACtBE,KAAA,GAAAR,UAAA,CAAA,IAAA,EAAAM,cAAA,EAAA,CAAA,EAAA,CAAA/C,MAAA,CAASrD,UAAU,EAAA,oBAAA,CAAA,CAAAqD,MAAA,CAAqBkD,OAAO,CAAA,CAAA,CAAA;IAC/CD,KAAA,CAAKI,IAAI,GAAG,gBAAgB;AAAC,IAAA,OAAAJ,KAAA;AAC/B;EAACN,SAAA,CAAAI,cAAA,EAAAC,UAAA,CAAA;EAAA,OAAAJ,YAAA,CAAAG,cAAA,CAAA;AAAA,CAAA,CAJiCT,SAAS,CAAA;AAUhCgB,IAAAA,YAAY,aAAAC,WAAA,EAAA;AACvB,EAAA,SAAAD,eAA0B;AAAA,IAAA,IAAAE,MAAA;AAAA,IAAA,IAAdN,OAAO,GAAAR,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAAAF,IAAAA,eAAA,OAAAc,YAAA,CAAA;IACtBE,MAAA,GAAAf,UAAA,CAAA,IAAA,EAAAa,YAAA,EAAA,CAAA,EAAA,CAAAtD,MAAA,CAASrD,UAAU,EAAA,wBAAA,CAAA,CAAAqD,MAAA,CAAyBkD,OAAO,CAAA,CAAA,CAAA;IACnDM,MAAA,CAAKH,IAAI,GAAG,cAAc;AAAC,IAAA,OAAAG,MAAA;AAC7B;EAACb,SAAA,CAAAW,YAAA,EAAAC,WAAA,CAAA;EAAA,OAAAX,YAAA,CAAAU,YAAA,CAAA;AAAA,CAAA,CAJ+BhB,SAAS,CAAA;;ACD3C,IAAMmB,IAAI,GACP,CAAOC,OAAAA,IAAI,iCAAAC,OAAA,CAAJD,IAAI,CAAK,MAAA,QAAQ,IAAIA,IAAI,CAACA,IAAI,KAAKA,IAAI,IAAIA,IAAI,IACtD,QAAOE,MAAM,KAAA,WAAA,GAAA,WAAA,GAAAD,OAAA,CAANC,MAAM,MAAI,QAAQ,IAAIA,MAAM,CAACA,MAAM,KAAKA,MAAM,IAAIA,MAAO,IACjEvG,QAAQ,CAAC,aAAa,CAAC,EAAE,IACzB,EAAE;AAEG,IAAMwG,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIC,GAAW,EAAA;AAAA,EAAA,OAC1CA,GAAG,CAACC,OAAO,CAAC,KAAK,EAAE,UAACC,CAAC,EAAA;IAAA,OAAKC,WAAW,CAACD,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC;GAAC,CAAA;AAAA,CAAA;AAE9C,IAAMC,kBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIL,GAAW,EAAA;AAAA,EAAA,OAC1CA,GAAG,CACAC,OAAO,CAAC,aAAa,EAAE,UAACC,CAAC,EAAA;AAAA,IAAA,OAAK,GAAG,GAAGI,WAAW,CAACJ,CAAC,CAAC;AAAA,GAAA,CAAC,CACnDD,OAAO,CAAC,QAAQ,EAAE,UAACC,CAAC,EAAA;AAAA,IAAA,OAAK,GAAG,GAAGI,WAAW,CAACJ,CAAC,CAAC;GAAC,CAAA;AAAA,CAAA;AAE5C,IAAMK,UAAU,GAAG,SAAbA,UAAUA,CAAIhB,IAAY,EAAA;EAAA,OAAArD,EAAAA,CAAAA,MAAA,CAAQsE,MAAS,EAAAtE,GAAAA,CAAAA,CAAAA,MAAA,CAAIqD,IAAI,CAAA;AAAA,CAAE;AAE3D,IAAMkB,YAAY,GAAG,SAAfA,YAAYA,CAAIlB,IAAY,EAAA;AAAA,EAAA,OAAK,IAAI,GAAGgB,UAAU,CAAChB,IAAI,CAAC;AAAA,CAAA;AAE9D,IAAMmB,cAAc,GAAG,SAAjBA,cAAcA,CAAInB,IAAY,EAAA;AAAA,EAAA,OAAKkB,YAAY,CAAC,MAAM,GAAGlB,IAAI,CAAC;AAAA,CAAA;AAEpE,IAAMoB,UAAU,GAAG,SAAbA,UAAUA,CAAIpB,IAAY,EAAA;AAAA,EAAA,OAAA,OAAA,CAAArD,MAAA,CAAamE,kBAAgB,CAACd,IAAI,CAAC,CAAA;AAAA,CAAE;AAErE,IAAMqB,cAAc,GAAG,SAAjBA,cAAcA,CAAIrB,IAAY,EAAA;AAAA,EAAA,OAAKoB,UAAU,CAACJ,UAAU,CAAChB,IAAI,CAAC,CAAC;AAAA,CAAA;AAErE,IAAMe,WAAW,GAAG,SAAdA,WAAWA,CAAIO,CAAS,EAAA;AAAA,EAAA,OAAKA,CAAC,CAACP,WAAW,EAAE;AAAA,CAAA;AAElD,IAAMH,WAAW,GAAG,SAAdA,WAAWA,CAAIU,CAAS,EAAA;AAAA,EAAA,OAAKA,CAAC,CAACV,WAAW,EAAE;AAAA,CAAA;AAElD,IAAMW,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACC,IAAI,CAACF,IAAI,CAAC;AAEnC,IAAMG,SAAS,GAAG,SAAZA,SAASA,CAAIC,SAAiB,EAAA;AAAA,EAAA,OAAKL,OAAO,EAAE,GAAGK,SAAS;AAAA,CAAA;AAE9D,IAAMC,MAAM,GAAG,SAATA,MAAMA,GAAA;EAAA,OAAS,OAAOC,QAAQ,KAAK,WAAW;AAAA,CAAA;AAEpD,IAAMC,SAAS,GAAG,SAAZA,SAASA,GAAA;AAAA,EAAA,OAASC,MAAM;AAAA,CAAA;AAE9B,IAAMC,MAAM,GAAG,SAATA,MAAMA,GAAA;AAAA,EAAA,OAASH,QAAQ;AAAA,CAAA;AAE7B,IAAMI,aAAa,GAAG,SAAhBA,aAAaA,GAAA;AAAA,EAAA,OAASD,MAAM,EAAE,CAACE,eAAe;AAAA,CAAA;AAEpD,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAsBA,GAAA;AAAA,EAAA,OACjCH,MAAM,EAAE,CAACI,gBAAgB;AAAA,CAAsB;AAE1C,IAAMC,OAAO,GAAG,SAAVA,OAAOA,GAAA;AAAA,EAAA,OAASL,MAAM,EAAE,CAACM,IAAI;AAAA,CAAA;AAEnC,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,GAAA;AAAA,EAAA,OAASP,MAAM,EAAE,CAACQ,UAAU;AAAA,CAAA;AAE/C,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,KAAY,EAAA;AAAA,EAAA,OACzCC,cAAc,CAACD,KAAK,CAAC,GACjBA,KAAK,CAACE,WAAW,GACjBC,YAAY,CAACH,KAAK,CAAC,GACjB,OAAO,GACP,IAAI;AAAA,CAAA;AAEL,IAAMI,gBAAgB,GAAGlB,MAAM,EAAE,GACpCzB,IAAI,CAAC4C,qBAAqB,CAACtB,IAAI,CAACtB,IAAI,CAAC,GACrC,YAAM,EAAE;AAEL,IAAM6C,aAAa,GAAG,SAAhBA,aAAaA,CACxBC,OAAe,EACfC,OAAgC,EAAA;EAAA,OAC7BlB,MAAM,EAAE,CAACgB,aAAa,CAACC,OAAO,EAAEC,OAAO,CAAC;AAAA,CAAA;AAEtC,IAAMC,YAAY,GAAG,SAAfA,YAAYA,GAAmC;AAAA,EAAA,IAA/BC,KAAK,GAAAhE,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAAA,EAAA,IAAEiE,GAAG,GAAAjE,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,QAAQ;AACrD,EAAA,IAAMkE,GAAG,GAAGN,aAAa,CAACK,GAAG,CAAC;EAC9BE,WAAW,CAACD,GAAG,CAAC;EAChBE,OAAO,CAACF,GAAG,EAAEtC,MAAS,EAAE,QAAQ,CAAC;EACjCwC,OAAO,CAACF,GAAG,EAAEtC,WAAc,GAAG,OAAO,EAAEoC,KAAK,CAAC;AAC7C,EAAA,OAAOE,GAAG;AACZ,CAAC;AAEM,IAAMG,SAAS,GAAG,SAAZA,SAASA,CAAIC,CAAU,EAAA;AAAA,EAAA,OAClCA,CAAC,KAAK5D,SAAS,IAAI4D,CAAC,KAAK,IAAI;AAAA,CAAA;AAExB,IAAMC,OAAO,GAAG,SAAVA,OAAOA,CAAID,CAAU,EAAA;AAAA,EAAA,OAChCD,SAAS,CAACC,CAAC,CAAC,IAAIA,CAAC,KAAK,EAAE;AAAA,CAAA;AAEnB,IAAME,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIF,CAAU,EAAA;EAAA,OACzCG,cAAc,CAACH,CAAC,CAAC,IAAI1C,MAAS,CAAC8C,QAAQ,IAAIJ,CAAC;AAAA,CAAA;AAEvC,IAAMK,OAAO,GAAG,SAAVA,OAAOA,CAAIL,CAAU,EAAA;AAAA,EAAA,OAAKM,YAAY,CAACN,CAAC,EAAE1C,KAAQ,CAAC;AAAA,CAAA;AAEzD,IAAMiD,QAAQ,GAAG,SAAXA,QAAQA,CAAIP,CAAU,EAAA;AAAA,EAAA,OAAKM,YAAY,CAACN,CAAC,EAAE1C,MAAS,CAAC;AAAA,CAAA;AAE3D,IAAM6C,cAAc,GAAG,SAAjBA,cAAcA,CAAIH,CAAU,EAAA;EAAA,OACvCA,CAAC,KAAK,IAAI,IAAIQ,MAAM,CAACR,CAAC,CAAC,KAAK,QAAQ;AAAA,CAAA;AAG/B,IAAMS,QAAQ,GAAG,SAAXA,QAAQA,CAAIT,CAAU,EAAA;AAAA,EAAA,OAAkBQ,MAAM,CAACR,CAAC,CAAC,KAAK,QAAQ;AAAA,CAAA;AAGpE,IAAMU,QAAQ,GAAG,SAAXA,QAAQA,CAAIV,CAAU,EAAA;AAAA,EAAA,OACjCQ,MAAM,CAACR,CAAC,CAAC,KAAK,QAAQ,IAAIM,YAAY,CAACN,CAAC,EAAE1C,MAAS,CAAC;AAAA,CAAA;AAE/C,IAAMqD,eAAe,GAAG,SAAlBA,eAAeA,CAAIX,CAAU,EAAA;AAAA,EAAA,OACxCQ,MAAM,CAACR,CAAC,CAAC,KAAK,QAAQ;AAAA,CAAA;AAEjB,IAAMY,SAAS,GAAG,SAAZA,SAASA,CAAIZ,CAAU,EAAA;AAAA,EAAA,OAAmBQ,MAAM,CAACR,CAAC,CAAC,KAAK,SAAS;AAAA,CAAA;AAGvE,IAAMa,UAAU,GAAG,SAAbA,UAAUA,CAAIb,CAAU,EAAA;AAAA,EAAA,OACnCQ,MAAM,CAACR,CAAC,CAAC,KAAK,UAAU,IAAIM,YAAY,CAACN,CAAC,EAAE1C,QAAW,CAAC;AAAA,CAAA;AAEnD,IAAMwD,KAAK,GAAG,SAARA,KAAKA,CAAIC,MAAe,EAAA;AAAA,EAAA,OACnCA,MAAM,KAAKzC,MAAM,EAAE;AAAA,CAAA;AAEd,IAAMa,YAAY,GAAG,SAAfA,YAAYA,CAAIH,KAAY,EAAA;AAAA,EAAA,OACvCsB,YAAY,CAACtB,KAAK,EAAEgC,UAAU,CAAC;AAAA,CAAA;AAE1B,IAAM/B,cAAc,GAAG,SAAjBA,cAAcA,CAAID,KAAY,EAAA;AAAA,EAAA,OACzCsB,YAAY,CAACtB,KAAK,EAAEiC,YAAY,CAAC;AAAA,CAAA;AAE5B,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAIlC,KAAY,EAAA;AAAA,EAAA,OAC9CC,cAAc,CAACD,KAAK,CAAC,IAAID,cAAc,CAACC,KAAK,CAAC,KAAK1B,OAAU;AAAA,CAAA;AAExD,IAAM6D,YAAY,GAAG,SAAfA,YAAYA,CAAInC,KAAY,EAAA;AAAA,EAAA,OACvCsB,YAAY,CAACtB,KAAK,EAAEoC,UAAU,CAAC;AAAA,CAAA;AAE1B,IAAMC,eAAe,GAAG,SAAlBA,eAAeA,CAAIrC,KAAY,EAAA;AAAA,EAAA,OAC1CsB,YAAY,CAACtB,KAAK,EAAEsC,aAAa,CAAC;AAAA,CAAA;AAE7B,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAIvC,KAAY,EAAA;AAAA,EAAA,OACvCsB,YAAY,CAACtB,KAAK,EAAEwC,UAAU,CAAC;AAAA,CAAA;AAE1B,IAAMC,MAAM,GAAG,SAATA,MAAMA,CAAIV,MAAe,EAAA;AAAA,EAAA,OAAKT,YAAY,CAACS,MAAM,EAAEW,IAAI,CAAC;AAAA,CAAA;AAE9D,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAIZ,MAAe,EAAA;AAAA,EAAA,OAAKT,YAAY,CAACS,MAAM,EAAEa,OAAO,CAAC;AAAA,CAAA;AAEpE,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAId,MAAe,EAAA;AAAA,EAAA,OAC3CT,YAAY,CAACS,MAAM,EAAEe,WAAW,CAAC;AAAA,CAAA;AAE5B,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,KAAW,EAAEC,KAAW,EAAA;AAAA,EAAA,OACpD,CAACD,KAAK,CAACE,uBAAuB,CAACD,KAAK,CAAC,GAAGP,IAAI,CAACS,2BAA2B,MACxE,CAAC;AAAA,CAAA;AAEI,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CACrBzE,CAAS,EACTtC,KAAsB,EACtBgH,WAAmB,EAAA;AAAA,EAAA,OAChB1E,CAAC,CAACZ,OAAO,CAAC1B,KAAK,EAAEgH,WAAW,CAAC;AAAA,CAAA;AAE3B,IAAMC,QAAQ,GAAG7F,IAAI,CAAC8F,UAAU,CAACxE,IAAI,CAACtB,IAAI,CAAC;AAE3C,IAAM+F,UAAU,GAAG/F,IAAI,CAACgG,YAAY,CAAC1E,IAAI,CAACtB,IAAI,CAAC;AAE/C,IAAMiG,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAIC,EAAW,EAAA;AAAA,EAAA,OAC/CA,EAAE,CAACD,qBAAqB,EAAE;AAAA,CAAA;AAIrB,IAAME,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAIC,IAAkB,EAAmB;EACzE,OAAAC,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;IACEC,CAAC,EAAEF,IAAI,CAACE,CAAC;IACTC,IAAI,EAAEH,IAAI,CAACG,IAAI;IACfC,KAAK,EAAEJ,IAAI,CAACI;AAAK,GAAA,EAChB3F,OAAU,EAAGuF,IAAI,CAACvF,OAAU,CAAC,CAAA,EAAA,GAAA,EAC3BuF,IAAI,CAACK,CAAC,CACJL,EAAAA,KAAAA,EAAAA,IAAI,CAACM,GAAG,CACLN,EAAAA,QAAAA,EAAAA,IAAI,CAACO,MAAM,GAClB9F,QAAW,EAAGuF,IAAI,CAACvF,QAAW,CAAC,CAAA;AAEpC,CAAC;AAEM,IAAM+F,aAAa,GAAG,SAAhBA,aAAaA,CAAI5G,IAAwB,EAAE6G,QAAgB,EAAA;AAAA,EAAA,OACtE7G,IAAI,CAAC4G,aAAa,CAACC,QAAQ,CAAC;AAAA,CAAA;AAEvB,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAI9G,IAAwB,EAAE6G,QAAgB,EAAA;AAAA,EAAA,OACzE7G,IAAI,CAAC8G,gBAAgB,CAACD,QAAQ,CAAC;AAAA,CAAA;AAE1B,IAAME,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIF,QAAgB,EAAA;AAAA,EAAA,OAC/CD,aAAa,CAAC/E,MAAM,EAAE,EAAEgF,QAAQ,CAAC;AAAA,CAAA;AAE5B,IAAMG,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAIH,QAAgB,EAAA;AAAA,EAAA,OAClDC,gBAAgB,CAACjF,MAAM,EAAE,EAAEgF,QAAQ,CAAC;AAAA,CAAA;AAE/B,IAAMI,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,EAAU,EAAA;AAAA,EAAA,OAAKrF,MAAM,EAAE,CAACoF,cAAc,CAACC,EAAE,CAAC;AAAA,CAAA;AAElE,IAAMC,OAAO,GAAG,SAAVA,OAAOA,CAAIjB,EAAW,EAAEtG,IAAY,EAAA;AAAA,EAAA,OAAKsG,EAAE,CAACkB,YAAY,CAACxH,IAAI,CAAC;AAAA,CAAA;AAEpE,IAAMyD,OAAO,GAAG,SAAVA,OAAOA,CAAI6C,EAAW,EAAEtG,IAAY,EAAA;AAAA,EAAA,IAAEyH,KAAK,GAAApI,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,MAAM;AAAA,EAAA,OAC/DiH,EAAE,CAACoB,YAAY,CAAC1H,IAAI,EAAEyH,KAAK,CAAC;AAAA,CAAA;AAEvB,IAAME,SAAS,GAAG,SAAZA,SAASA,CAAIrB,EAAW,EAAEtG,IAAY,EAAA;AAAA,EAAA,OACjDsG,EAAE,CAACoB,YAAY,CAAC1H,IAAI,EAAE,OAAO,CAAC;AAAA,CAAA;AAEzB,IAAM4H,OAAO,GAAG,SAAVA,OAAOA,CAAItB,EAAW,EAAEtG,IAAY,EAAA;AAAA,EAAA,OAAKsG,EAAE,CAACuB,eAAe,CAAC7H,IAAI,CAAC;AAAA,CAAA;AAEvE,IAAM8H,QAAQ,GAAG,SAAXA,QAAQA,CACnBC,GAAgC,EAChCpE,CAAU,EACVqE,OAAgB,EAAA;EAAA,OACZD,GAAG,CAACE,OAAO,CAA8CtE,CAAC,EAAEqE,OAAO,CAAC,IAAI,CAAC;AAAA,CAAA;AAExE,IAAME,MAAM,GAAG,SAATA,MAAMA,CAKjBC,KAAQ,EACRC,QAAW,EAAA;AAAA,EAAA,OACRD,KAAK,CAACD,MAAM,CAACE,QAAQ,CAAC;AAAA,CAAmC;AAEvD,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CACtBF,KAA2B,EACxB;EACH,IAAMG,MAAM,GAAGH,KAAK,GAChBD,MAAM,CAACC,KAAK,EAAE,UAACxE,CAAC,EAAA;AAAA,IAAA,OAAkC,CAACC,OAAO,CAACD,CAAC,CAAC;AAAA,GAAA,CAAC,GAC9D5D,SAAS;AAEb,EAAA,OAAOwI,QAAQ,CAACD,MAAM,CAAC,GAAGA,MAAM,GAAGvI,SAAS;AAC9C,CAAC;AAEM,IAAMyI,MAAM,GAAG,SAATA,MAAMA,CAAIC,GAAwC,EAAA;AAAA,EAAA,IAAAC,SAAA;AAAA,EAAA,OAAA,CAAAA,SAAA,GAC7DD,GAAG,KAAA,IAAA,IAAHA,GAAG,KAAHA,MAAAA,GAAAA,MAAAA,GAAAA,GAAG,CAAEE,IAAI,MAAAD,IAAAA,IAAAA,SAAA,KAAAA,MAAAA,GAAAA,SAAA,GAAI,CAAC;AAAA,CAAA;AAET,IAAMH,QAAQ,GAAG,SAAXA,QAAQA,CAAIE,GAA0C,EAAA;AAAA,EAAA,IAAAG,WAAA;AAAA,EAAA,OAAA,CAAAA,WAAA,GACjEH,GAAG,KAAA,IAAA,IAAHA,GAAG,KAAHA,MAAAA,GAAAA,MAAAA,GAAAA,GAAG,CAAE3I,MAAM,MAAA8I,IAAAA,IAAAA,WAAA,KAAAA,MAAAA,GAAAA,WAAA,GAAI,CAAC;AAAA,CAAA;AAEX,IAAM1F,OAAO,GAAG,SAAVA,OAAOA,CAAIoD,EAAW,EAAA;EAAA,OAAKA,EAAE,CAACpD,OAAO;AAAA,CAAA;AAE3C,IAAM2F,cAAc,GAAG,SAAjBA,cAAcA,CAAIlG,KAAY,EAAA;AAAA,EAAA,OAAKA,KAAK,CAACkG,cAAc,EAAE;AAAA,CAAA;AAE/D,IAAMC,SAAS,GAAG7H,KAAQ,CAAC8H,IAAI,CAACrH,IAAI,CAACT,KAAQ,CAAC;AAE9C,IAAM+H,MAAM,GAAG,SAATA,MAAMA,CACjBP,GAAM,EAAA;AAAA,EAAA,OACsBxH,MAAS,CAACgI,IAAI,CAACR,GAAG,CAAC;AAAA,CAAA;AAE1C,IAAMS,cAAc,GAAGjI,MAAS,CAACiI,cAAc,CAACxH,IAAI,CAACT,MAAS,CAAC;AAG/D,IAAMkI,KAAK,GAAG,SAARA,KAAKA,GAEb;AAAA,EAAA,IAAAC,UAAA;AAAA,EAAA,KAAA,IAAAC,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EADAwJ,CAAC,GAAA1P,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAADD,IAAAA,CAAC,CAAAC,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAEJ,EAAA,OAAO,CAAAH,UAAA,GAAAnI,MAAS,EAACuI,MAAM,CAAAC,KAAA,CAAAL,UAAA,GAAC,EAAE,EAAAzM,MAAA,CAAK2M,CAAC,CAAC,CAAA;AACnC,CAAC;AAEM,IAAMI,UAAU,GAAG,SAAbA,UAAUA,CAAsBjB,GAAM,EAAA;EAAA,OAAKU,KAAK,CAACV,GAAG,CAAC;AAAA,CAAA;AAE3D,IAAMkB,cAAc,GAAG1I,OAAU,CAAC2I,OAAO,CAAClI,IAAI,CAACT,OAAU,CAAC;AAE1D,IAAM4I,UAAU,GAAG5I,OAAU,CAAC6I,GAAG,CAACpI,IAAI,CAACT,OAAU,CAAC;AAElD,IAAMuI,MAAM,GAAGvI,MAAS,CAACuI,MAAM,CAAC9H,IAAI,CAACT,MAAS,CAAC;AAE/C,IAAM8I,SAAS,GAAG9I,MAAS,CAAC+I,MAAM,CAACtI,IAAI,CAACT,MAAS,CAAC;AAElD,IAAMgJ,UAAU,GAAG,SAAbA,UAAUA,CAAIC,CAAS,EAAEC,IAAqB,EAAA;AAAA,EAAA,OACzDlJ,MAAS,CAACmJ,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,CAAC,EAAEC,IAAI,CAAC;AAAA,CAAA;AAE3C,IAAMI,iBAAiB,GAAGtJ,MAAS,CAACsJ,iBAAiB,CAAC7I,IAAI,CAACT,MAAS,CAAC;AAErE,IAAMuJ,SAAS,GAAGC,IAAI,CAACD,SAAS,CAAC9I,IAAI,CAAC+I,IAAI,CAAC;AAE3C,IAAMC,KAAK,GAAGzJ,IAAO,CAACyJ,KAAK,CAAChJ,IAAI,CAACT,IAAO,CAAC;AAEzC,IAAM0J,IAAI,GAAG1J,IAAO,CAAC0J,IAAI,CAACjJ,IAAI,CAACT,IAAO,CAAC;AAEvC,IAAM2J,IAAI,GAAG3J,IAAO,CAAC2J,IAAI,CAAClJ,IAAI,CAACT,IAAO,CAAC;AAEvC,IAAM4J,IAAI,GAAG5J,IAAO,CAAC4J,IAAI,CAACnJ,IAAI,CAACT,IAAO,CAAC;AAEvC,IAAM6J,GAAG,GAAG7J,IAAO,CAAC6J,GAAG,CAACpJ,IAAI,CAACT,IAAO,CAAC;AAErC,IAAM8J,GAAG,GAAG9J,IAAO,CAAC8J,GAAG,CAACrJ,IAAI,CAACT,IAAO,CAAC;AAErC,IAAM+J,GAAG,GAAG/J,IAAO,CAAC+J,GAAG,CAACtJ,IAAI,CAACT,IAAO,CAAC;AAErC,IAAMgK,KAAK,GAAGhK,IAAO,CAACgK,KAAK,CAACvJ,IAAI,CAACT,IAAO,CAAC;AAEzC,IAAMiK,GAAG,GAAGjK,IAAO,CAACiK,GAAG,CAACxJ,IAAI,CAACT,IAAO,CAAC;AAErC,IAAMkK,UAAU,GAAGlK,MAAS,CAACkK,UAAU,CAACzJ,IAAI,CAACT,MAAS,CAAC;AAEvD,IAAMmK,OAAK,GAAGnK,MAAS,CAACmK,KAAK,CAAC1J,IAAI,CAACT,MAAS,CAAC;AAE7C,IAAMgD,YAAY,GAAG,SAAfA,YAAYA,CACvBwD,KAAc,EACd4D,KAAQ,EAAA;EAAA,OACqB5D,KAAK,YAAY4D,KAAK;AAAA,CAAA;AAE9C,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAI7C,GAAW,EAAA;EAAA,OAAKA,GAAG,CAAC8C,WAAW;AAAA,CAAA;AAEtD,IAAMpH,MAAM,GAAG,SAATA,MAAMA,CAAIsE,GAAY,EAAA;EAAA,OAAAnI,OAAA,CAAYmI,GAAG,CAAA;AAAA,CAAA;AAE3C,IAAM+C,aAAa,GAAG,SAAhBA,aAAaA,CAAI/C,GAAY,EAAA;AAAA,EAAA,IAAAgD,cAAA;EAAA,OACxCvH,QAAQ,CAACuE,GAAG,CAAC,IAAAgD,cAAA,GAAGH,aAAa,CAAC7C,GAAG,CAAC,MAAAgD,IAAAA,IAAAA,cAAA,uBAAlBA,cAAA,CAAoBzL,IAAI,GAAGmE,MAAM,CAACsE,GAAG,CAAC;AAAA,CAAA;AAEjD,IAAMiD,QAAQ,GAAG,SAAXA,QAAQA,CAAIC,OAAmC,EAAA;EAAA,OAC1D,CAAAA,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEC,aAAa,KAAI,IAAI;AAAA,CAAA;AAEzB,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIF,OAAmC,EAAA;EAAA,OAC5D,CAAAA,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEG,QAAQ,KAAI,EAAE;AAAA,CAAA;AAElB,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CACnBtD,GAAM,EAAA;AAAA,EAAA,OAENA,GAAG,KAAHA,IAAAA,IAAAA,GAAG,KAAHA,MAAAA,GAAAA,MAAAA,GAAAA,GAAG,CAAE/D,MAAM;AAAA,CAII;AAEV,IAAMsH,eAAe,GAAG,SAAlBA,eAAeA,CAG1BvD,GAAM,EAAA;AAAA,EAAA,OAENA,GAAG,KAAHA,IAAAA,IAAAA,GAAG,KAAHA,MAAAA,GAAAA,MAAAA,GAAAA,GAAG,CAAEwD,aAAa;AAAA,CAIH;AAEV,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAA0C5F,EAAK,EAAA;AAAA,EAAA,OACnEA,EAAE,KAAFA,IAAAA,IAAAA,EAAE,KAAFA,MAAAA,GAAAA,MAAAA,GAAAA,EAAE,CAAE4F,SAAS;AAAA,CAAgD;AAE/D,IAAMC,UAAU,GAAG,UAAU;AACtB,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAI9F,EAAW,EAAA;AAAA,EAAA,OAAKiB,OAAO,CAACjB,EAAE,EAAE6F,UAAU,CAAC;AAAA,CAAA;AAE5D,IAAM3I,WAAW,GAAG,SAAdA,WAAWA,CAAI8C,EAAW,EAAA;AAAA,EAAA,IAAE+F,KAAK,GAAAhN,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,GAAG;AAAA,EAAA,OAClDoE,OAAO,CAAC6C,EAAE,EAAE6F,UAAU,EAAEE,KAAK,CAAC;AAAA,CAAA;AAEzB,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIhG,EAAW,EAAA;AAAA,EAAA,OAAKsB,OAAO,CAACtB,EAAE,EAAE6F,UAAU,CAAC;AAAA,CAAA;AAE9D,IAAMI,MAAM,GAAG,SAATA,MAAMA,CAAI9D,GAA8C,EAAA;EAAA,OACnEA,GAAG,aAAHA,GAAG,KAAA,MAAA,GAAA,MAAA,GAAHA,GAAG,CAAE8D,MAAM,EAAE;AAAA,CAAA;AAER,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAsB/D,GAAM,EAAEgE,GAAY,EAAA;AAAA,EAAA,OACjE,OAAOhE,GAAG,CAACgE,GAAG,CAAC;AAAA,CAAA;AAEV,IAAMC,SAAS,GAAG,SAAZA,SAASA,CACpBC,GAAkD,EAClDF,GAAM,EAAA;EAAA,OACHE,GAAG,aAAHA,GAAG,KAAA,MAAA,GAAA,MAAA,GAAHA,GAAG,CAAQ,QAAA,CAAA,CAACF,GAAG,CAAC;AAAA,CAAA;AAEd,IAAMG,UAAU,GAAG,SAAbA,UAAUA,CACrBtG,EAAW,EACXuG,MAAuC,EAAA;AAAA,EAAA,IACvCC,QAAwB,GAAAzN,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,SAAS;AAAA,EAAA,OACjCiH,EAAE,CAACyG,QAAQ,CAAC5D,KAAK,CAAC;AAAE2D,IAAAA,QAAQ,EAARA;GAAU,EAAED,MAAM,CAAC,CAAC;AAAA,CAAA;AAEtC,IAAMG,UAAU,GAAG,SAAbA,UAAUA,CACrB1G,EAAW,EACXuG,MAAuC,EAAA;AAAA,EAAA,IACvCC,QAAwB,GAAAzN,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,SAAS;AAAA,EAAA,OACjCiH,EAAE,CAAC2G,QAAQ,CAAC9D,KAAK,CAAC;AAAE2D,IAAAA,QAAQ,EAARA;GAAU,EAAED,MAAM,CAAC,CAAC;AAAA,CAAA;AAEtC,IAAMK,UAAU,GAAG,SAAbA,UAAUA,CACrBC,QAIS,EAAA;AAAA,EAAA,OACN,IAAI7S,OAAO,CAAC6S,QAAQ,CAAC;AAAA,CAAA;AAEnB,IAAMC,MAAM,GAAG,SAATA,MAAMA,CAAUC,OAA6C,EAAA;AAAA,EAAA,OACxE,IAAIC,GAAG,CAACD,OAAO,CAAC;AAAA,CAAA;AAEX,IAAME,UAAU,GAAG,SAAbA,UAAUA,CACrBF,OAA6C,EAAA;AAAA,EAAA,OAC1C,IAAIG,OAAO,CAACH,OAAO,CAAC;AAAA,CAAA;AAElB,IAAMI,MAAM,GAAG,SAATA,MAAMA,CAAOC,MAA4B,EAAA;AAAA,EAAA,OAAK,IAAIC,GAAG,CAACD,MAAM,CAAC;AAAA,CAAA;AAEnE,IAAME,UAAU,GAAG,SAAbA,UAAUA,CAAuBF,MAA4B,EAAA;AAAA,EAAA,OACxE,IAAIG,OAAO,CAACH,MAAM,CAAC;AAAA,CAAA;AAEd,IAAMI,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAClCC,QAAsC,EACtC5K,OAAkC,EAAA;AAAA,EAAA,OAC/B,IAAI6K,oBAAoB,CAACD,QAAQ,EAAE5K,OAAO,CAAC;AAAA,CAAA;AAEzC,IAAM8K,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIF,QAAgC,EAAA;EAAA,OAChE,OAAOG,cAAc,KAAK,WAAW,GAAG,IAAI,GAAG,IAAIA,cAAc,CAACH,QAAQ,CAAC;AAAA,CAAA;AAEtE,IAAMI,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAIJ,QAA0B,EAAA;AAAA,EAAA,OAC5D,IAAIK,gBAAgB,CAACL,QAAQ,CAAC;AAAA,CAAA;AAEzB,IAAMM,UAAU,GAAG,SAAbA,UAAUA,CAAIC,GAAW,EAAA;AAAA,EAAA,OAAK,IAAI5O,cAAc,CAAC4O,GAAG,CAAC;AAAA,CAAA;AAE3D,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAID,GAAW,EAAA;AAAA,EAAA,OAAK,IAAIrO,YAAY,CAACqO,GAAG,CAAC;AAAA,CAAA;AAEvD,IAAME,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAIC,OAAe,EAAA;AAAA,EAAA,OACrDJ,UAAU,CAAA1R,2BAAAA,CAAAA,MAAA,CAA6B8R,OAAO,MAAG,CAAC;AAAA,CAAA;AAEpD,IAAMC,OAAO,GAAGC,OAAO;AAChB,IAAMC,YAAY,GAAGF,OAAO,CAACG,KAAK,CAACnN,IAAI,CAACgN,OAAO,CAAC;AAEhD,IAAMI,UAAU,GAAGJ,OAAO,CAACK,GAAG,CAACrN,IAAI,CAACgN,OAAO,CAAC;AAE5C,IAAMM,WAAW,GAAGN,OAAO,CAACO,IAAI,CAACvN,IAAI,CAACgN,OAAO,CAAC;AAE9C,IAAMQ,WAAW,GAAGR,OAAO,CAACS,IAAI,CAACzN,IAAI,CAACgN,OAAO,CAAC;AAE9C,IAAMU,YAAY,GAAGV,OAAO,CAACW,KAAK,CAAC3N,IAAI,CAACgN,OAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICpY1CY,QAAQ,GAAGC,iBAAoB,CAAC;AAiB3CC,EAAAA,6BAA6B,EAAE,IAAqB;AA+DpDC,EAAAA,sBAAsB,EAAE,IAAI;AAgB5BC,EAAAA,eAAe,EAAE,IAAI;AAiBrBC,EAAAA,WAAW,EAAE,KAAK;AASlBC,EAAAA,mBAAmB,EAAE,IAAI;AASzBC,EAAAA,iBAAiB,EAAE,KAAK;AASxBC,EAAAA,kBAAkB,EAAE,QAAQ;AAS5BC,EAAAA,kBAAkB,EAAE,OAAO;EAS3BC,iBAAiB,EAAE,EAAE;AASrBC,EAAAA,oBAAoB,EAAE,IAAI;AAS1BC,EAAAA,mBAAmB,EAAE,IAAI;AASzBC,EAAAA,kBAAkB,EAAE,KAAK;AASzBC,EAAAA,uBAAuB,EAAE,EAAE;AAS3BC,EAAAA,yBAAyB,EAAE,CAAC;AAS5BC,EAAAA,wBAAwB,EAAE,GAAG;AAS7BC,EAAAA,gBAAgB,EAAE,EAAE;AASpBC,EAAAA,kBAAkB,EAAE,GAAG;AASvBC,EAAAA,mBAAmB,EAAE,GAAG;AAexBC,EAAAA,iBAAiB,EAAE;AAOjBC,IAAAA,MAAM,EAAE,CAAC;AAQT,IAAA,aAAa,EAAE,GAAG;AAQlBC,IAAAA,MAAM,EAAE,GAAG;AAOXC,IAAAA,OAAO,EAAE;GACV;AAgBDC,EAAAA,sBAAsB,EAAE;AAOtB,IAAA,WAAW,EAAE,CAAC;IAQdC,IAAI,EAAE,CAAC,GAAG,EAAE;IAQZC,MAAM,EAAE,CAAC,GAAG,CAAC;IAQbC,IAAI,EAAE,CAAC,GAAG,CAAC;IAOX,WAAW,EAAE,EAAE,GAAG;GACnB;AAiBDC,EAAAA,mBAAmB,EAAE,aAAa;AAgBlCC,EAAAA,kBAAkB,EAAE,YAAY;AAYhCC,EAAAA,eAAe,EAAE,EAAE;AAWnBC,EAAAA,cAAc,EAAE,IAAI;AAYpBC,EAAAA,eAAe,EAAE,GAAG;AAWpBC,EAAAA,cAAc,EAAE,CAAC;AAwBjBC,EAAAA,eAAe,EAAE,IAAqB;AAatCC,EAAAA,wBAAwB,EAAE;AAC5B,CAAC;;ACvdM,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIjK,KAAa,EAAqB;AAAA,EAAA,IAAnBkK,UAAU,GAAAtS,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;EACtD,IAAMuS,oBAAoB,GAAGrC,GAAM,CAAC,EAAE,EAAEoC,UAAU,CAAC;EACnD,OAAOpC,KAAQ,CAAC9H,KAAK,GAAGmK,oBAAoB,CAAC,GAAGA,oBAAoB;AACtE,CAAC;AAOM,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIpK,KAAc,EAAA;AAAA,EAAA,OACvC8H,QAAW,CAAC9H,KAAK,CAAC,IAAIxG,MAAS,CAAC6Q,QAAQ,CAACrK,KAAK,CAAC;AAAA,CAAA;AAQ1C,IAAMsK,KAAK,GAAG,SAARA,KAAKA,CAChBtK,KAAc,EAEC;AAAA,EAAA,IADfuK,YAAmB,GAAA3S,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEvB,EAAA,IAAM4S,QAAQ,GAAG1C,eAAkB,CAAC9H,KAAK,CAAC,GAAG8H,UAAa,CAAC9H,KAAK,CAAC,GAAGA,KAAK;EAKzE,OAAOoK,UAAU,CAACI,QAAQ,CAAC,IAAIA,QAAQ,IAAIxK,KAAK,GAAGwK,QAAQ,GAAGD,YAAY;AAC5E,CAAC;AAyBM,IAAME,WAAW,GAAG,SAAdA,WAAWA,CACtBzK,KAAc,EAEC;AAAA,EAAA,IADfuK,YAAmB,GAAA3S,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEvB,EAAA,IAAM4S,QAAQ,GAAGF,KAAK,CAACtK,KAAK,EAAE,IAAI,CAAC;EACnC,OAAOwK,QAAQ,KAAK,IAAI,IAAIA,QAAQ,IAAI,CAAC,GAAGA,QAAQ,GAAGD,YAAY;AACrE,CAAC;AAQM,IAAMG,QAAQ,GAAG,SAAXA,QAAQA,CACnB1K,KAAc,EAEC;AAAA,EAAA,IADfuK,YAAmB,GAAA3S,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEvB,EAAA,IAAM4S,QAAQ,GAAGF,KAAK,CAACtK,KAAK,EAAE,IAAI,CAAC;EACnC,OAAOwK,QAAQ,KAAK,IAAI,IAAIA,QAAQ,GAAG,CAAC,GAAGA,QAAQ,GAAGD,YAAY;AACpE,CAAC;AAiBM,IAAMI,eAAe,GAAG,SAAlBA,eAAeA,CAC1B3K,KAAc,EACd4K,MAA8D,EAC9DL,YAAgB,EACD;EAAA,IAAAM,WAAA,EAAAC,WAAA;AAEf,EAAA,IAAMN,QAAQ,GAAGF,KAAK,CAACtK,KAAK,EAAE,IAAI,CAAC;AACnC,EAAA,IAAMsD,GAAG,GAAAuH,CAAAA,WAAA,GAAGD,MAAM,aAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEtH,GAAG,MAAAuH,IAAAA,IAAAA,WAAA,KAAAA,MAAAA,GAAAA,WAAA,GAAI,IAAI;AAC/B,EAAA,IAAMxH,GAAG,GAAAyH,CAAAA,WAAA,GAAGF,MAAM,aAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEvH,GAAG,MAAAyH,IAAAA,IAAAA,WAAA,KAAAA,MAAAA,GAAAA,WAAA,GAAI,IAAI;AAE/B,EAAA,IAAIjK,MAAkB;AACtB,EAAA,IAAI,CAACuJ,UAAU,CAACI,QAAQ,CAAC,EAAE;AAAA,IAAA,IAAAO,IAAA;AACzBlK,IAAAA,MAAM,GAAgCkK,CAAAA,IAAA,GAAIzH,GAAG,KAAA,IAAA,IAAHA,GAAG,KAAHA,MAAAA,GAAAA,GAAG,GAAID,GAAG,MAAA,IAAA,IAAA0H,IAAA,KAAAA,MAAAA,GAAAA,IAAA,GAAI,CAAE;GAC3D,MAAM,IAAIzH,GAAG,KAAK,IAAI,IAAIkH,QAAQ,GAAGlH,GAAG,EAAE;AACzCzC,IAAAA,MAAM,GAAmCyC,GAAG;GAC7C,MAAM,IAAID,GAAG,KAAK,IAAI,IAAImH,QAAQ,GAAGnH,GAAG,EAAE;AACzCxC,IAAAA,MAAM,GAAmCwC,GAAG;AAC9C,GAAC,MAAM;AACLxC,IAAAA,MAAM,GAAG2J,QAAQ;AACnB;AAEA,EAAA,OAAO3J,MAAM;AACf,CAAC;AASM,IAAMmK,MAAM,GAAG,SAATA,MAAMA,GAAA;AAAA,EAAA,KAAA,IAAApJ,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAO4N,MAAM,GAAA9T,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAANmE,IAAAA,MAAM,CAAAnE,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAAA,EAAA,OAC9BgG,GAAM,CAAA9F,KAAA,CAAN8F,EAAE,EAAAmD,kBAAA,CAAQhF,MAAM,CAACf,GAAG,CAAC,UAAChJ,CAAC,EAAA;AAAA,IAAA,OAAK4L,GAAM,CAAC5L,CAAC,CAAC;AAAA,GAAA,CAAC,CAAC,CAAA;AAAA,CAAA;AAmBlC,IAAMgP,YAAY,GAAG,SAAfA,YAAYA,GAAA;AAAA,EAAA,KAAA,IAAAC,KAAA,GAAAvT,SAAA,CAAAS,MAAA,EAAO4N,MAAM,GAAA9T,IAAAA,KAAA,CAAAgZ,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAANnF,IAAAA,MAAM,CAAAmF,KAAA,CAAAxT,GAAAA,SAAA,CAAAwT,KAAA,CAAA;AAAA;AAAA,EAAA,OACpCtD,QAAW,CAAC7B,MAAM,CAAC,GACfA,MAAM,CAACoF,IAAI,CAAC,UAACxJ,CAAC,EAAEyJ,CAAC,EAAA;AAAA,IAAA,OAAKxD,GAAM,CAACwD,CAAC,CAAC,GAAGxD,GAAM,CAACjG,CAAC,CAAC;AAAA,GAAA,CAAC,CAAC,CAAC,CAAC,GAC/C,CAACrI,QAAW;AAAA,CAAA;AAsBX,IAAM+R,MAAM,GAAG,SAATA,MAAMA,CAAItM,CAAS,EAAEG,CAAS,EAAA;AAAA,EAAA,OACzCoM,cAAc,CAAChS,IAAO,CAACiS,KAAK,CAACrM,CAAC,EAAEH,CAAC,CAAC,CAAC;AAAA,CAAA;AAQ9B,IAAMuM,cAAc,GAAG,SAAjBA,cAAcA,CAAI3J,CAAS,EAAK;EAE3C,OAAOA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAGrI,EAAK,GAAG,CAAC,EAAE;AAC7BqI,IAAAA,CAAC,IAAI,CAACA,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAIrI,EAAK,GAAG,CAAC;AACnC;AAGA,EAAA,OAAOqI,CAAC,GAAGrI,EAAK,GAAGqI,CAAC,GAAGrI,EAAK,GAAG,CAAC,GAAGqI,CAAC;AACtC,CAAC;AAOM,IAAM6J,QAAQ,GAAG,SAAXA,QAAQA,CAAI7J,CAAS,EAAA;AAAA,EAAA,OAAMA,CAAC,GAAGrI,EAAK,GAAI,GAAG;AAAA,CAAA;AAuBjD,IAAMmS,WAAW,GAAG,SAAdA,WAAWA,CAAIC,EAAU,EAAEC,EAAU,EAA6B;AAAA,EAAA,IAA3BC,kBAAkB,GAAAlU,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AACxE,EAAA,IAAMmU,MAAM,GAAGR,MAAM,CAACK,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;AACnC,EAAA,IAAMI,MAAM,GAAGT,MAAM,CAACM,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;AACnCC,EAAAA,kBAAkB,GAAGhE,GAAM,CAAC,KAAK,EAAEA,GAAM,CAACgE,kBAAkB,CAAC,CAAC;AAE9D,EAAA,OACEhE,GAAM,CAAC0D,cAAc,CAACO,MAAM,GAAGC,MAAM,CAAC,CAAC,IAAIN,QAAQ,CAACI,kBAAkB,CAAC;AAE3E,CAAC;AAgBM,IAAMG,eAAe,GAAG,SAAlBA,eAAeA,CAC1BL,EAAU,EACVC,EAAU,EAAA;AAAA,EAAA,IACVC,kBAAkB,GAAAlU,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAAA,EAAA,OACnB+T,WAAW,CAACC,EAAE,EAAE,CAAC,CAACC,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,CAAC,EAAEC,kBAAkB,CAAC;AAAA,CAAA;AAOnD,IAAMI,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,GAAU,EAAEC,GAAU,EAAA;AAAA,EAAA,OACpDtE,IAAO,CAACA,GAAM,CAACqE,GAAG,CAAC,CAAC,CAAC,GAAGC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGtE,GAAM,CAACqE,GAAG,CAAC,CAAC,CAAC,GAAGC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,CAAA;AAuB3D,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIpN,CAAS,EAAA;EAAA,OACrCA,CAAC,GAAG,GAAG,GAAG,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG6I,GAAM,CAAC,EAAE,GAAG7I,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;AAAA,CAAA;AAO9C,IAAMqN,eAAe,GAAG,SAAlBA,eAAeA,CAC1BtL,GAAM,EAEa;AAAA,EAAA,IADnBuL,UAAU,GAAA3U,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAElB,EAAA,IAAI2U,UAAU,EAAE;AACd,IAAA,OAAOzE,MAAS,CAAC9G,GAAG,CAAC,CAACqK,IAAI,CAAC,UAACpM,CAAU,EAAEG,CAAU,EAAA;MAAA,OAAK4B,GAAG,CAAC5B,CAAC,CAAC,GAAG4B,GAAG,CAAC/B,CAAC,CAAC;KAAC,CAAA;AACzE;AAEA,EAAA,OAAO6I,MAAS,CAAC9G,GAAG,CAAC,CAACqK,IAAI,CAAC,UAACpM,CAAU,EAAEG,CAAU,EAAA;IAAA,OAAK4B,GAAG,CAAC/B,CAAC,CAAC,GAAG+B,GAAG,CAAC5B,CAAC,CAAC;GAAC,CAAA;AACzE,CAAC;AAuCM,IAAMoN,WAAU,GAAG,SAAbA,UAAUA,CAAIC,KAAa,EAAEC,GAAW,EAAA;EAAA,OACnDD,KAAK,GAAGC,GAAG,GACPF,WAAU,CAACE,GAAG,EAAED,KAAK,CAAC,GACrB,EAAE,KAAM,EAAE,GAAGC,GAAG,GAAG,CAAC,GAAGD,KAAM,IAAKA,KAAK;AAAA,CAAA;;AC/UvC,IAAME,iBAAgB,GAAG,SAAnBA,gBAAgBA,CAAsBC,OAAU,EAAEC,KAAQ,EAAK;AAC1E,EAAA,KAAK,IAAM7H,GAAG,IAAI6H,KAAK,EAAE;IACvB,IAAI,CAAC/E,UAAa,CAAC+E,KAAK,EAAE7H,GAAG,CAAC,EAAE;AAC9B,MAAA;AACF;IAEA,IAAIA,GAAG,IAAI4H,OAAO,EAAE;AAClB,MAAA,IAAI9E,cAAiB,CAAC8E,OAAO,CAAC5H,GAAG,CAAC,CAAC,IAAI8C,cAAiB,CAAC+E,KAAK,CAAC7H,GAAG,CAAC,CAAC,EAAE;QACpE2H,iBAAgB,CAACC,OAAO,CAAC5H,GAAG,CAAC,EAAE6H,KAAK,CAAC7H,GAAG,CAAC,CAAC;AAC5C,OAAC,MAAM;AACL6H,QAAAA,KAAK,CAAC7H,GAAG,CAAC,GAAG4H,OAAO,CAAC5H,GAAG,CAAC;AAC3B;AACF;AACF;AACF,CAAC;AAKM,IAAM8H,QAAQ,GAAG,SAAXA,QAAQA,CAInB9L,GAAM,EACN+L,QAAW,EACU;EACrB,IAAMC,GAAe,GAAG,EAAE;AAC1B,EAAA,IAAIhI,GAAY;EAEhB,KAAKA,GAAG,IAAIhE,GAAG,EAAE;AACf,IAAA,IAAI,EAAEgE,GAAG,IAAI+H,QAAQ,CAAC,EAAE;AACtBC,MAAAA,GAAG,CAAChI,GAAG,CAAC,GAAGhE,GAAG,CAACgE,GAAG,CAAC;AACrB;AACF;AAEA,EAAA,OAAOgI,GAAG;AACZ,CAAC;AAIM,IAAMC,gBAAe,GAAG,SAAlBA,eAAeA,CAC1BC,IAAO,EACPC,IAAO,EAEJ;AAAA,EAAA,IADHC,OAAO,GAAAxV,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEX,EAAA,KAAK,IAAMoN,GAAG,IAAIkI,IAAI,EAAE;IACtB,IAAI,CAACpF,UAAa,CAACoF,IAAI,EAAElI,GAAG,CAAC,EAAE;AAC7B,MAAA;AACF;AAEA,IAAA,IAAMqI,IAAI,GAAGH,IAAI,CAAClI,GAAG,CAAC;AACtB,IAAA,IAAMsI,IAAI,GAAGH,IAAI,CAACnI,GAAG,CAAC;AAEtB,IAAA,IAAI8C,cAAiB,CAACuF,IAAI,CAAC,IAAIvF,cAAiB,CAACwF,IAAI,CAAC,EAAE;AACtD,MAAA,IAAI,CAACL,gBAAe,CAACI,IAAI,EAAEC,IAAI,CAAC,EAAE;AAChC,QAAA,OAAO,KAAK;AACd;AACF,KAAC,MAAM,IAAIxF,QAAW,CAACuF,IAAI,CAAC,IAAIvF,QAAW,CAACwF,IAAI,CAAC,EAAE;AACjD,MAAA,IAAIrD,UAAU,CAACoD,IAAI,EAAED,OAAO,CAAC,KAAKnD,UAAU,CAACqD,IAAI,EAAEF,OAAO,CAAC,EAAE;AAC3D,QAAA,OAAO,KAAK;AACd;AACF,KAAC,MAAM,IAAIC,IAAI,KAAKC,IAAI,EAAE;AACxB,MAAA,OAAO,KAAK;AACd;AACF;AACA,EAAA,OAAO,IAAI;AACb,CAAC;;ACpDM,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAIvN,KAAc,EAAEwN,MAAe,EAAK;AACjE,EAAA,IAAM3M,MAAM,GAAG4M,qBAAoB,CAACzN,KAAK,EAAE,KAAK,CAAC;AAMjD,EAAA,OAAOa,MAAM;AACf,CAAC;AAYM,IAAM6M,YAAY,GAAG,SAAfA,YAAYA,CAAIC,SAAiB,EAAA;EAAA,KAAA/L,IAAAA,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAKuV,IAAI,OAAAzb,KAAA,CAAAyP,IAAA,GAAAA,CAAAA,GAAAA,IAAA,WAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAJ8L,IAAAA,IAAI,CAAA9L,IAAA,GAAAlK,CAAAA,CAAAA,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAAA,EAAA,OACrD8L,IAAI,CAAC1I,GAAG,CAAC,UAACrD,CAAC,EAAA;IAAA,OAAK0L,cAAc,CAAC1L,CAAC,CAAC;AAAA,GAAA,CAAC,CAACgM,IAAI,CAACF,SAAS,CAAC;AAAA,CAAA;AA6B7C,IAAMG,OAAO,GAAG,SAAVA,OAAOA,CAClBC,KAAa,EACbJ,SAA0B,EAC1BK,IAAc,EACdC,KAAc,EACX;AACH,EAAA,IAAI,CAACF,KAAK,CAACC,IAAI,EAAE,EAAE;AACjB,IAAA,OAAO,EAAE;AACX;EAEAC,KAAK,GAAGA,KAAK,KAALA,IAAAA,IAAAA,KAAK,cAALA,KAAK,GAAI,EAAE;EAEnB,IAAMC,MAAgB,GAAG,EAAE;AAC3B,EAAA,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAItU,CAAS,EAAA;AAAA,IAAA,OAAKqU,MAAM,CAACE,IAAI,CAACJ,IAAI,GAAGnU,CAAC,CAACmU,IAAI,EAAE,GAAGnU,CAAC,CAAC;AAAA,GAAA;EAEhE,OAAOoU,KAAK,EAAE,EAAE;IACd,IAAII,UAAU,GAAG,EAAE;AACjBC,MAAAA,WAAW,GAAG,CAAC;AACjB,IAAA,IAAIxG,eAAkB,CAAC6F,SAAS,CAAC,EAAE;AACjCU,MAAAA,UAAU,GAAGN,KAAK,CAACvN,OAAO,CAACmN,SAAS,CAAC;AACrCW,MAAAA,WAAW,GAAGxG,QAAW,CAAC6F,SAAS,CAAC;AACtC,KAAC,MAAM;AAAA,MAAA,IAAAY,YAAA;AACL,MAAA,IAAMhX,KAAK,GAAGoW,SAAS,CAACa,IAAI,CAACT,KAAK,CAAC;AACnCM,MAAAA,UAAU,IAAAE,YAAA,GAAGhX,KAAK,KAAA,IAAA,IAALA,KAAK,KAALA,MAAAA,GAAAA,MAAAA,GAAAA,KAAK,CAAEqN,KAAK,cAAA2J,YAAA,KAAA,MAAA,GAAAA,YAAA,GAAI,EAAE;AAC/BD,MAAAA,WAAW,GAAG/W,KAAK,GAAGuQ,QAAW,CAACvQ,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AACjD;IAEA,IAAI8W,UAAU,GAAG,CAAC,EAAE;AAClB,MAAA;AACF;IAEAF,QAAQ,CAACJ,KAAK,CAACU,KAAK,CAAC,CAAC,EAAEJ,UAAU,CAAC,CAAC;IACpCN,KAAK,GAAGA,KAAK,CAACU,KAAK,CAACJ,UAAU,GAAGC,WAAW,CAAC;AAC/C;EAEAH,QAAQ,CAACJ,KAAK,CAAC;AACf,EAAA,OAAOG,MAAM;AACf,CAAC;AAkBM,IAAM7U,gBAAgB,GAAGyO,kBAAmB;AAW5C,IAAM4G,MAAM,GAAG,SAATA,MAAMA,GAAmB;AAAA,EAAA,IAAfC,MAAM,GAAA/W,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAC/B,EAAA,IAAMgX,OAAO,GAAG,SAAVA,OAAOA,GAAA;IAAA,OACX9G,KAAQ,CAAC,MAAM,GAAGtO,IAAO,CAACqV,MAAM,EAAE,GAAG,MAAM,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;AAAA,GAAA;EAE3D,IAAIjV,CAAC,GAAG,EAAE;EACV,OAAOiO,QAAW,CAACjO,CAAC,CAAC,GAAG8U,MAAM,EAAE;IAC9B9U,CAAC,IAAI+U,OAAO,EAAE;AAChB;AACA,EAAA,OAAO/U,CAAC,CAAC4U,KAAK,CAAC,CAAC,EAAEE,MAAM,CAAC;AAC3B,CAAC;AAqBM,IAAMI,SAAS,GAAG,SAAZA,SAASA,CAAI/O,KAAa,EAAEgP,YAAkB,EAAK;AAAA,EAAA,IAAAC,OAAA,EAAAC,QAAA,EAAAnE,IAAA,EAAAoE,QAAA;EAC9D,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAIC,QAA4B,EAAEzK,KAAa,EAAK;IACjE,IAAI0K,MAAM,GAAGxH,UAAa,CAACuH,QAAQ,IAAI,EAAE,CAAC,IAAI,CAAC;AAE/C,IAAA,IAAIA,QAAQ,KAAKC,MAAM,GAAG,GAAG,EAAE;AAC7BA,MAAAA,MAAM,IACJ1K,KAAK,GAAG,CAAC,GAAGoK,YAAY,CAACxV,QAAW,CAAC,GAAGwV,YAAY,CAACxV,OAAU,CAAC;AACpE;AAEA,IAAA,OAAO8V,MAAM;GACd;EAED,IAAMC,KAAK,GAAGzB,OAAO,CAAC9N,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC;AACvC,EAAA,IAAMwP,OAAyC,GAAG,CAEhDJ,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAEtBH,SAAS,EAAAH,OAAA,GAACM,KAAK,CAAC,CAAC,CAAC,MAAA,IAAA,IAAAN,OAAA,KAAAA,MAAAA,GAAAA,OAAA,GAAIM,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAElCH,SAAS,CAAAF,CAAAA,QAAA,GAACK,KAAK,CAAC,CAAC,CAAC,MAAA,IAAA,IAAAL,QAAA,KAAA,MAAA,GAAAA,QAAA,GAAIK,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAElCH,SAAS,EAAArE,IAAA,GAAA,CAAAoE,QAAA,GAACI,KAAK,CAAC,CAAC,CAAC,MAAAJ,IAAAA,IAAAA,QAAA,cAAAA,QAAA,GAAII,KAAK,CAAC,CAAC,CAAC,MAAAxE,IAAAA,IAAAA,IAAA,cAAAA,IAAA,GAAIwE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAC/C;AAED,EAAA,OAAOC,OAAO;AAChB,CAAC;AAMM,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAIzO,GAAc,EAAA;EAAA,OACxC8G,SAAY,CAAC4H,kBAAiB,CAAC1O,GAAG,CAAC,CAAC;AAAA,CAAA;AAItC,IAAM0O,kBAAiB,GAAG,SAApBA,iBAAiBA,CAAI1O,GAAc,EAAgB;EACvD,IAAMN,KAAK,GAAGoH,OAAU,CAAC9G,GAAG,CAAC,GACzBA,GAAG,GACH8G,MAAS,CAAC9G,GAAG,CAAC,CACXqK,IAAI,EAAE,CACNnG,GAAG,CAAC,UAACyK,CAAC,EAAA;IAAA,OAAK3O,GAAG,CAAC2O,CAAC,CAAC;GAAC,CAAA;AAEzB,EAAA,OAAOjP,KAAK,CAACwE,GAAG,CAAC,UAAClF,KAAK,EAAK;IAC1B,IACE8H,OAAU,CAAC9H,KAAK,CAAC,IAChB8H,cAAiB,CAAC9H,KAAK,CAAC,IAAI8H,aAAgB,CAAC9H,KAAK,CAAC,KAAKxG,MAAU,EACnE;MACA,OAAOkW,kBAAiB,CAAC1P,KAAK,CAAC;AACjC;AACA,IAAA,OAAOA,KAAK;AACd,GAAC,CAAC;AACJ,CAAC;AAED,IAAM4P,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAI5K,GAAW,EAAEhF,KAAc,EAAA;EAAA,OACpDgF,GAAG,GAAGyI,qBAAoB,CAACzN,KAAK,EAAE,IAAI,CAAC,GAAGA,KAAK;AAAA,CAAA;AAEjD,IAAMyN,qBAAoB,GAAG,SAAvBA,oBAAoBA,CACxBzN,KAAQ,EACR6P,MAAS,EACiC;EAC1C,IAAIhP,MAAkB,GAAG,EAAE;AAE3B,EAAA,IAAIiH,SAAY,CAAC9H,KAAK,CAAC,EAAE;AACvB,IAAA,IAAM8P,QAAQ,GAAGhI,SAAY,CAAC9H,KAAK,CAAC,CAAC8O,QAAQ,EAAE,CAACd,IAAI,EAAE;AAEtDnN,IAAAA,MAAM,GAAGb,KAAK,CAACH,EAAE,GACb,GAAG,GAAGG,KAAK,CAACH,EAAE,GAAA3K,GAAAA,CAAAA,MAAA,CACV4S,OAAU,CAAC9H,KAAK,CAAC,CAAA9K,CAAAA,MAAA,CAAG4a,QAAQ,GAAG,UAAU,GAAGA,QAAQ,GAAG,GAAG,GAAG,EAAE,EAAG,GAAA,CAAA;GAG3E,MAAM,IAAIhI,YAAe,CAAC9H,KAAK,EAAEhI,KAAK,CAAC,EAAE;AAExC,IAAA,IAAI,OAAO,IAAIgI,KAAK,IAAI8H,QAAW,CAAC9H,KAAK,CAAC+P,KAAK,CAAC,EAAE;MAChDlP,MAAM,GAAGb,KAAK,CAAC+P,KAAK;AACtB,KAAC,MAAM;AACLlP,MAAAA,MAAM,aAAA3L,MAAA,CAAa8K,KAAK,CAAC5H,OAAO,CAAE;AACpC;GAGD,MAAM,IAAI0P,OAAU,CAAC9H,KAAK,CAAC,EAAE;IAC5Ba,MAAM,GACJ,GAAG,GACHb,KAAK,CACFkF,GAAG,CAAC,UAAChJ,CAAC,EAAA;AAAA,MAAA,OACL4L,QAAW,CAAC5L,CAAC,CAAC,GAAG4L,SAAY,CAAC5L,CAAC,CAAC,GAAGuR,qBAAoB,CAACvR,CAAC,EAAE,KAAK,CAAC;AAAA,KACnE,CAAC,CACA2R,IAAI,CAAC,GAAG,CAAC,GACZ,GAAG;GAGN,MAAM,IAAI/F,gBAAmB,CAAC9H,KAAK,CAAC,EAAE;IACrCa,MAAM,GACJiH,aAAgB,CAAC9H,KAAK,CAAC,GACvB,GAAG,GACHyN,qBAAoB,CAAC3F,SAAY,CAAC9H,KAAK,CAAC,EAAE,KAAK,CAAC,GAChD,GAAG;GAGN,MAAM,IAAI8H,cAAiB,CAAC9H,KAAK,CAAC,EAAE;AACnCa,IAAAA,MAAM,GAAGgP,MAAM,GAAG7P,KAAK,GAAG8H,SAAY,CAAC9H,KAAK,EAAE4P,iBAAiB,CAAC;AAGlE,GAAC,MAAM;IAEL/O,MAAM,GAAGgP,MAAM,GAAG7P,KAAK,GAAGxG,MAAS,CAACwG,KAAK,CAAC;AAC5C;AAEA,EAAA,OAAOa,MAAM;AACf,CAAC;;AChOM,IAAMmP,eAAe,GAAG,SAAlBA,eAAeA,CAC1BhL,GAAW,EACXhF,KAAc,EACdiQ,OAAuC,EAAA;AAAA,EAAA,IAAAC,QAAA;AAAA,EAAA,OAEvCpI,WAAc,EAAAoI,QAAA,GACZC,OAAO,CAACnQ,KAAK,CAAC,MAAA,IAAA,IAAAkQ,QAAA,KAAdA,MAAAA,GAAAA,MAAAA,GAAAA,QAAA,CAAgBhL,GAAG,CAAC,UAAChJ,CAAC,EAAA;IAAA,OACpBkU,eAAe,CAACpL,GAAG,EAAE9I,CAAC,EAAE+T,OAAO,EAAE,4BAA4B,CAAC;AAAA,GAChE,CACF,CAAC;AAAA,CAAA;AAwIH,IAAME,OAAO,GAAG,SAAVA,OAAOA,CAAInQ,KAAc,EAA4B;AACzD,EAAA,IAAIa,MAAwB;AAC5B,EAAA,IAAIiH,OAAU,CAAC9H,KAAK,CAAC,EAAE;AACrBa,IAAAA,MAAM,GAAGb,KAAK;GACf,MAAM,IAAI8H,gBAAmB,CAAC9H,KAAK,CAAC,EAAE;AACrCa,IAAAA,MAAM,GAAGiH,SAAY,CAAC9H,KAAK,CAAC;GAC7B,MAAM,IAAI8H,eAAkB,CAAC9H,KAAK,CAAC,EAAE;AACpCa,IAAAA,MAAM,GAAGiN,OAAO,CAAC9N,KAAK,EAAE,GAAG,CAAC;GAC7B,MAAM,IAAI,CAAC8H,SAAY,CAAC9H,KAAK,CAAC,EAAE;IAC/Ba,MAAM,GAAG,CAACb,KAAK,CAAC;AAClB,GAAC,MAAM;AACLa,IAAAA,MAAM,GAAG,IAAI;AACf;EAEA,OAAOA,MAAM,GACTiH,WAAc,CAACjH,MAAM,CAACqE,GAAG,CAAC,UAAChJ,CAAC,EAAA;AAAA,IAAA,OAAM4L,eAAkB,CAAC5L,CAAC,CAAC,GAAGA,CAAC,CAAC8R,IAAI,EAAE,GAAG9R,CAAC;GAAC,CAAC,CAAC,GACzE5D,SAAS;AACf,CAAC;AAsCD,IAAM8X,eAAe,GAAG,SAAlBA,eAAeA,CACnBpL,GAAW,EACXhF,KAAc,EACdiQ,OAAuC,EACvCI,eAAwB,EAC+C;AACvE,EAAA,IAAIvI,SAAY,CAAC9H,KAAK,CAAC,EAAE;AACvB,IAAA;AACF;AAEA,EAAA,IAAI,CAAC8H,eAAkB,CAAC9H,KAAK,CAAC,EAAE;AAC9B,IAAA,MAAM8H,UAAa,KAAA5S,MAAA,CAAK8P,GAAG,EAAA9P,YAAAA,CAAAA,CAAAA,MAAA,CAAamb,eAAe,CAAc,CAAE,CAAC;GACzE,MAAM,IAAIJ,OAAO,IAAI,CAACA,OAAO,CAACjQ,KAAK,CAAC,EAAE;IACrC,MAAM8H,UAAa,CAAA,qBAAA,CAAA5S,MAAA,CAAuB8P,GAAG,MAAG,CAAC;AACnD;AAEA,EAAA,OAAOhF,KAAK;AACd,CAAC;;ACzJD,IAAasQ,SAAS,GAAAxY,YAAA,CAuEpB,SAAAwY,YAAc;AAAA5Y,EAAAA,eAAA,OAAA4Y,SAAA,CAAA;AACZ,EAAA,IAAMC,OAAO,GAAGC,UAAU,EAAE;EAE5B,IAAI,CAACC,MAAM,GAAG,YAAA;AAAA,IAAA,KAAA,IAAA7O,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAIqY,SAAS,GAAAve,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAT4O,MAAAA,SAAS,CAAA5O,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAAA,IAAA,OAAK6O,WAAW,CAACJ,OAAO,EAAEG,SAAS,CAAC;AAAA,GAAA;AAC/D5I,EAAAA,cAAiB,CAAC,IAAI,EAAE,OAAO,EAAE;IAAE8I,GAAG,EAAE,SAALA,GAAGA,GAAA;MAAA,OAAQL,OAAO,CAACM,MAAM;AAAA;AAAC,GAAC,CAAC;AAC/D/I,EAAAA,cAAiB,CAAC,IAAI,EAAE,SAAS,EAAE;IAAE8I,GAAG,EAAE,SAALA,GAAGA,GAAA;MAAA,OAAQL,OAAO,CAACO,QAAQ;AAAA;AAAC,GAAC,CAAC;AACrE,CAAC,CAAA;AASI,IAAMC,YAAY,GAAG,SAAfA,YAAYA,GAAA;EAAA,OAAS,IAAIT,SAAS,EAAE;AAAA,CAAA;AAQ1C,IAAMU,cAAc,GAAG,SAAjBA,cAAcA,CACzBC,MAAiB,EAAA;EAAA,KAAAC,IAAAA,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EACdqY,SAAS,OAAAve,KAAA,CAAA+e,KAAA,GAAAA,CAAAA,GAAAA,KAAA,WAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAATT,IAAAA,SAAS,CAAAS,KAAA,GAAAvZ,CAAAA,CAAAA,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;EAAA,OACIF,MAAM,CAACR,MAAM,CAAAzO,KAAA,CAAbiP,MAAM,EAAWP,SAAS,CAAC;AAAA,CAAA;AAS7C,IAAMF,UAAU,GAAG,SAAbA,UAAUA,GAAA;EAAA,OAAsB;AACpCK,IAAAA,MAAM,EAAE,CAAC;AACTC,IAAAA,QAAQ,EAAE;GACX;AAAA,CAAC;AAEF,IAAMH,WAAW,GAAG,SAAdA,WAAWA,CACfJ,OAAmB,EACnBG,SAAuB,EACP;AAChB,EAAA,IAAMjE,KAAK,GAAG8D,OAAO,CAACM,MAAM;EAC5B,IAAMnE,GAAG,GAAGD,KAAK,GAAG3E,QAAW,CAAC4I,SAAS,CAAC,GAAG,CAAC;EAC9C,IAAIhE,GAAG,IAAI,EAAE,EAAE;AACb,IAAA,MAAM5E,UAAa,CAAC,oBAAoB,CAAC;AAC3C;AAEA,EAAA,IAAMsJ,OAAO,GAAG5E,WAAU,CAACC,KAAK,EAAEC,GAAG,CAAC;AACtC,EAAA,IAAM2E,KAAkB,GAAG;IACzBC,GAAG,EAAE,EAAE;AACP7E,IAAAA,KAAK,EAALA,KAAK;AACLC,IAAAA,GAAG,EAAHA,GAAG;AACH0E,IAAAA,OAAO,EAAPA,OAAO;AAEPG,IAAAA,GAAG,EAAE,SAALA,GAAGA,CAAGC,CAAC,EAAA;MAAA,OACL1J,QAAW,CAAC0J,CAAC,CAAC,IACdA,CAAC,IAAIH,KAAK,CAACC,GAAG,IACdxJ,QAAW,CAAEuJ,KAAK,CAACC,GAAG,CAA6BE,CAAC,CAAC,CAAC;AAAA,KAAA;AAExDC,IAAAA,UAAU,EAAE,SAAZA,UAAUA,CAAGC,MAAM,EAAEC,IAAI,EAAK;AAC5B,MAAA,IACG,CAAC7J,OAAU,CAAC4J,MAAM,CAAC,IAAI,CAACL,KAAK,CAACE,GAAG,CAACG,MAAM,CAAC,IACzC,CAAC5J,OAAU,CAAC6J,IAAI,CAAC,IAAI,CAACN,KAAK,CAACE,GAAG,CAACI,IAAI,CAAE,EACvC;AACA,QAAA,OAAO,CAAC;AACV;MAEA,IAAMC,SAAS,GAAG,CAAC9J,OAAU,CAAC4J,MAAM,CAAC,GACjC5J,IAAO,CAACuJ,KAAK,CAACC,GAAG,CAACI,MAAM,CAAC,CAAC,GAC1BjF,KAAK;MACT,IAAMoF,OAAO,GAAG,CAAC/J,OAAU,CAAC6J,IAAI,CAAC,GAAG7J,IAAO,CAACuJ,KAAK,CAACC,GAAG,CAACK,IAAI,CAAC,CAAC,GAAGjF,GAAG;AAElE,MAAA,OAAOF,WAAU,CAACoF,SAAS,EAAEC,OAAO,CAAC;KACtC;AAEDC,IAAAA,MAAM,EAAE,SAARA,MAAMA,CAAGC,GAAG,EAAA;AAAA,MAAA,IAAAC,UAAA;AAAA,MAAA,OAAA,CAAAA,UAAA,GAAKtB,SAAS,CAAC5I,IAAO,CAACiK,GAAG,CAAC,GAAGtF,KAAK,CAAC,MAAA,IAAA,IAAAuF,UAAA,KAAAA,MAAAA,GAAAA,UAAA,GAAI,IAAI;AAAA;GAC1C;AAAC,EAAA,IAAAC,SAAA,GAAAC,0BAAA,CAEExB,SAAS,CAAA;IAAAyB,KAAA;AAAA,EAAA,IAAA;IAA5B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA8B;AAAA,MAAA,IAAnB9Z,IAAI,GAAA4Z,KAAA,CAAAnS,KAAA;MACb8H,cAAiB,CAACuJ,KAAK,CAACC,GAAG,EAAE/Y,IAAI,EAAE;AACjCyH,QAAAA,KAAK,EAAE,CAAC,IAAIuQ,OAAO,CAACM,MAAM,EAAE;AAC5ByB,QAAAA,UAAU,EAAE;AACd,OAAC,CAAC;AACJ;AAAC,GAAA,CAAA,OAAAC,GAAA,EAAA;IAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAN,IAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;EAEDlC,OAAO,CAACO,QAAQ,IAAIM,OAAO;AAE3B,EAAA,OAAOC,KAAK;AACd,CAAC;;AC3PM,IAAMqB,oBAAoB,GAAG1B,cAAc,CAChDD,YAAY,EAAE,EACdvX,OAAU,EACVA,SAAY,EACZA,WACF,CAAC;;ACKM,IAAMmZ,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAIC,IAAgB,EAAK;AAC5D,EAAA,IAAI,OAAOC,SAAS,KAAK,WAAW,EAAE;AACpCA,IAAAA,SAAS,CAACC,QAAQ,CAACF,IAAI,EAAE;AACvBG,MAAAA,QAAQ,EAAE;AACZ,KAAC,CAAC;AACJ,GAAC,MAAM;AAEL,IAAA,IAAMC,OAAO,GAAG,IAAIC,cAAc,EAAE;AACpCD,IAAAA,OAAO,CAACE,KAAK,CAACC,SAAS,GAAG,YAAM;AAC9BH,MAAAA,OAAO,CAACE,KAAK,CAACE,KAAK,EAAE;AACrBR,MAAAA,IAAI,EAAE;KACP;AACDI,IAAAA,OAAO,CAACK,KAAK,CAACC,WAAW,CAAC,EAAE,CAAC;AAC/B;AACF,CAAC;AAQM,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAC9BC,cAAsB,EACtBC,OAAgC,EAC7B;EACH,IAAI,CAACD,cAAc,EAAE;AACnB,IAAA,OAAOC,OAAO;AAChB;EAEA,IAAIC,KAA2C,GAAG,IAAI;AACtD,EAAA,IAAIC,QAAc;AAElB,EAAA,OAAO,YAAmB;AAAA,IAAA,KAAA,IAAA/R,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAfuV,IAAI,GAAAzb,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAJ8L,MAAAA,IAAI,CAAA9L,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AACb6R,IAAAA,QAAQ,GAAG/F,IAAI;IAEf,IAAI8F,KAAK,KAAK,IAAI,EAAE;AAClBA,MAAAA,KAAK,GAAG5L,QAAW,CAAA8L,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAC,SAAAC,OAAA,GAAA;AAAA,QAAA,OAAAF,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA,OACZX,OAAO,CAAAzR,KAAA,SAAAiJ,kBAAA,CAAI0I,QAAQ,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;AAC1BD,cAAAA,KAAK,GAAG,IAAI;AAAC,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAQ,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OACd,CAAA,CAAA,EAAEP,cAAc,CAAC;AACpB;GACD;AACH,CAAC;AAQM,IAAMc,YAAY,GAAG,SAAfA,YAAYA,CAAIC,KAAc,EAAA;AAAA,EAAA,OACzCzM,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B2F,IAAAA,QAAW,CAAC3F,OAAO,EAAEoS,KAAK,CAAC;AAC7B,GAAC,CAAC;AAAA,CAAA;;ACpEG,IAAMC,aAAY,GAAG,SAAfA,YAAYA,CACvBC,iBAAyD,EAEtC;AAAA,EAAA,IADnBjB,cAAc,GAAA5b,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAElB,EAAA,IAAMmF,YAAU,GAAG+K,UAAa,CAAC2M,iBAAiB,CAAC;AACnD,EAAA,IAAIC,SAAS,GAAG,SAAZA,SAASA,GAAA;AAAA,IAAA,OAAS,KAAK;AAAA,GAAA;AAE3B,EAAA,IAAI3X,YAAU,EAAE;AAEd,IAAA,IAAMuJ,QAAQ,GAAGqO,YAAY,CAAC/D,GAAG,CAAC6D,iBAAiB,CAAC;AACpD,IAAA,IAAInO,QAAQ,EAAE;MACZ,OAAOkO,aAAY,CAAClO,QAAQ,CAAC;AAC/B;AACF,GAAC,MAAM;IACLoO,SAAS,GAAGD,iBAAiB,CAACC,SAAS;AACzC;AAEA,EAAA,IAAMjB,OAA8B,GAAG1W,YAAU,GAC7C0X,iBAAiB,GACjB,YAAA;IAAA,OAAmBA,iBAAiB,CAACG,MAAM,CAAA5S,KAAA,CAAxByS,iBAAiB,EAAA7c,SAAe,CAAC;AAAA,GAAA;EAExD,IAAMid,OAAO,GAAG,IAAIC,QAAQ,CAC1BvB,mBAAmB,CAACC,cAAc,EAAE,YAAmB;AACrD,IAAA,IAAI,CAACkB,SAAS,EAAE,EAAE;AAChB,MAAA,OAAOjB,OAAO,CAAAzR,KAAA,CAAA,MAAA,EAAApK,SAAQ,CAAC;AACzB;AACF,GAAC,CACH,CAAC;EAED,IAAI,CAACmF,YAAU,EAAE;AACf0X,IAAAA,iBAAiB,CAACM,QAAQ,CAACF,OAAO,CAAC/P,MAAM,CAAC;AAC5C;AAEA,EAAA,OAAO+P,OAAO;AAChB,CAAC;AAaD,IAAaC,QAAQ,GAAAhd,YAAA,CAqFnB,SAAAgd,QAAAA,CAAYrB,OAA8B,EAAE;AAAA,EAAA,IAAAtb,KAAA,GAAA,IAAA;AAAAT,EAAAA,eAAA,OAAAod,QAAA,CAAA;EAK1C,IAAIJ,SAAS,GAAG,KAAK;AACrB,EAAA,IAAM7U,EAAE,GAAGrG,MAAS,EAAE;AAEtB,EAAA,IAAMub,QAAQ,GAAGjN,MAAS,EAAc;EAExC,IAAI,CAAC4M,SAAS,GAAG,YAAA;AAAA,IAAA,OAAMA,SAAS;AAAA,GAAA;EAEhC,IAAI,CAAC5P,MAAM,GAAG,YAAM;IAElB,IAAI,CAAC4P,SAAS,EAAE;AACdA,MAAAA,SAAS,GAAG,IAAI;AAAC,MAAA,IAAAzC,SAAA,GAAAC,0BAAA,CAEE6C,QAAQ,CAAA;QAAA5C,KAAA;AAAA,MAAA,IAAA;QAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,UAAA,IAAlB2C,IAAI,GAAA7C,KAAA,CAAAnS,KAAA;AACbgV,UAAAA,IAAI,EAAE;AACR;AAAC,OAAA,CAAA,OAAAzC,GAAA,EAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAN,QAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAEDwC,MAAAA,iBAAiB,CAACC,MAAM,CAACrV,EAAE,CAAC;AAC9B;GACD;AAED,EAAA,IAAI,CAACkV,QAAQ,GAAG,UAACI,EAAE,EAAA;AAAA,IAAA,OAAKJ,QAAQ,CAACK,GAAG,CAACD,EAAE,CAAC;AAAA,GAAA;EAExC,IAAI,CAACP,MAAM,GAAG,YAAA;AAAA,IAAA,KAAA,IAAAhT,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAIuV,IAAI,GAAAzb,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAJ8L,MAAAA,IAAI,CAAA9L,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;IAAA,OACpBgG,UAAa,CAAC,UAAC3F,OAAO,EAAEkT,MAAM,EAAK;AAEjC,MAAA,IAAIX,SAAS,EAAE;AACbW,QAAAA,MAAM,CAACvN,UAAa,CAAC,2BAA2B,CAAC,CAAC;AAClD,QAAA;AACF;AAEAmN,MAAAA,iBAAiB,CAACK,KAAK,CACrBzV,EAAE,EAAA+T,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CACF,SAAAC,OAAA,GAAA;AAAA,QAAA,IAAAlT,MAAA;AAAA,QAAA,OAAAgT,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAC,IAAA,GAAA,CAAA;AAAAD,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA,OAGmBX,OAAO,CAAAzR,KAAA,CAAA,MAAA,EAAI4L,IAAI,CAAC;AAAA,YAAA,KAAA,CAAA;cAA/B/M,MAAM,GAAAqT,QAAA,CAAAqB,IAAA;AAAArB,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAC,IAAA,GAAA,CAAA;cAAAD,QAAA,CAAAsB,EAAA,GAAAtB,QAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA;AAENmB,cAAAA,MAAM,CAAAnB,QAAA,CAAAsB,EAAI,CAAC;AAAC,YAAA,KAAA,CAAA;AAGd,cAAA,IAAI3U,MAAM,KAAKiU,QAAQ,CAACW,MAAM,EAAE;gBAC9Btd,KAAI,CAAC2M,MAAM,EAAE;AACf;AAEA3C,cAAAA,OAAO,EAAE;AAAC,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA+R,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,EAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA;OACX,CAAA,CAAA,EACDsB,MACF,CAAC;AACH,KAAC,CAAC;AAAA,GAAA;EAEJV,YAAY,CAACe,GAAG,CAAC,IAAI,CAACd,MAAM,EAAE,IAAI,CAAC;AACrC,CAAC,CAAA;AA7IkB5V,eAAA,CAAR8V,QAAQ,EAMmBtb,MAAAA,EAAAA,MAAS,CAC7C,MACF,CAAC,CAAA;AAAAwF,eAAA,CARU8V,QAAQ,EAeqBtb,QAAAA,EAAAA,MAAS,CAC/C,QACF,CAAC,CAAA;AAAAwF,eAAA,CAjBU8V,QAAQ,EAAA,MAAA,EA+EIN,aAAY,CAAA;AA4ErC,IAAMG,YAAY,GAAG7M,UAAa,EAA8B;AAEhE,IAAMmN,iBAAiB,GAAI,YAAM;AAC/B,EAAA,IAAMU,MAAM,GAAG7N,MAAS,EAAwC;AAEhE,EAAA,IAAM8N,KAAK,GAAA,YAAA;IAAA,IAAAC,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAgC,QAAAA,CAAOC,KAAmC,EAAA;AAAA,MAAA,OAAAlC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,QAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,UAAA,KAAA,CAAA;AAAA6B,YAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,YAAA,OAGhD,IAAI;AAAA,UAAA,KAAA,CAAA;AAAA,YAAA,IAAA,CACHtM,QAAW,CAACiO,KAAK,CAAC,EAAA;AAAAE,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,cAAA;AAAA;AAEvB2B,YAAAA,KAAK,CAAC,CAAC,CAAC,CAACG,QAAQ,GAAG,IAAI;AAACD,YAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,YAAA,OACnB2B,KAAK,CAAC,CAAC,CAAC,CAACI,KAAK,EAAE;AAAA,UAAA,KAAA,CAAA;YAGtBJ,KAAK,CAACK,KAAK,EAAE;AAACH,YAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA,UAAA,KAAA,CAAA;AAAA,UAAA,KAAA,KAAA;YAAA,OAAA6B,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,OAAA,EAAAyB,QAAA,CAAA;KAEjB,CAAA,CAAA;IAAA,OAZKF,SAAAA,KAAKA,CAAAS,EAAA,EAAA;AAAA,MAAA,OAAAR,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,KAAA;GAYV,EAAA;EAED,OAAO;AACLsd,IAAAA,MAAM,EAAE,SAARA,MAAMA,CAAGrV,EAAU,EAAK;AACtB,MAAA,IAAMkW,KAAK,GAAGJ,MAAM,CAAC/E,GAAG,CAAC/Q,EAAE,CAAC;AAC5B,MAAA,IAAIkW,KAAK,EAAE;AACT,QAAA,IAAIO,IAA4C;AAChD,QAAA,OAAQA,IAAI,GAAGP,KAAK,CAACK,KAAK,EAAE,EAAG;AAC7B,UAAA,IAAI,CAACE,IAAI,CAACJ,QAAQ,EAAE;AAClBI,YAAAA,IAAI,CAACC,SAAS,CAACzB,QAAQ,CAACW,MAAM,CAAC;AACjC;AACF;AAEA3N,QAAAA,SAAY,CAAC6N,MAAM,EAAE9V,EAAE,CAAC;AAC1B;KACD;IAEDyV,KAAK,EAAE,SAAPA,KAAKA,CAAGzV,EAAU,EAAE+S,IAA2B,EAAEmC,QAAoB,EAAK;AACxE,MAAA,IAAIgB,KAAK,GAAGJ,MAAM,CAAC/E,GAAG,CAAC/Q,EAAE,CAAC;MAC1B,IAAI,CAACkW,KAAK,EAAE;AACVA,QAAAA,KAAK,GAAG,EAAE;AACVJ,QAAAA,MAAM,CAACD,GAAG,CAAC7V,EAAE,EAAEkW,KAAK,CAAC;AACvB;MAEAA,KAAK,CAAC3H,IAAI,CAAC;AAAE+H,QAAAA,KAAK,EAAEvD,IAAI;AAAE2D,QAAAA,SAAS,EAAExB,QAAQ;AAAEmB,QAAAA,QAAQ,EAAE;AAAM,OAAC,CAAC;MACjE,IAAIpO,QAAW,CAACiO,KAAK,CAAC,KAAK,CAAC,EAAE;QAC5BH,KAAK,CAACG,KAAK,CAAC;AACd;AACF;GACD;AACH,CAAC,EAAG;;ACvPG,IAAMS,OAAoB,GAAG,SAAvBA,OAAoBA,GAAgB;AAAA,EAAA,KAAA,IAAAtF,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EAATuV,IAAI,GAAAzb,IAAAA,KAAA,CAAA+e,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAJvD,IAAAA,IAAI,CAAAuD,KAAA,CAAAvZ,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;AAC1C,EAAA,IAAI,CAACsF,aAAa,CAAC7I,IAAI,CAAC,EAAE;AACxB9F,IAAAA,WAAc,CAAA9F,KAAA,CAAd8F,EAAE,EAAA,CAAatO,UAAa,CAAA,CAAAtE,MAAA,CAAK0Y,IAAI,CAAC,CAAA;AACxC;AACF,CAAC;AAQM,IAAM8I,QAAqB,GAAG,SAAxBA,QAAqBA,GAAgB;AAAA,EAAA,KAAA,IAAAvL,KAAA,GAAAvT,SAAA,CAAAS,MAAA,EAATuV,IAAI,GAAAzb,IAAAA,KAAA,CAAAgZ,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAJwC,IAAAA,IAAI,CAAAxC,KAAA,CAAAxT,GAAAA,SAAA,CAAAwT,KAAA,CAAA;AAAA;EAC3C,IACE,CAACtD,QAAW,CAAC8F,IAAI,CAAC,GAAG,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAKkH,QAAQ,CAACW,MAAM,KACrD,CAACgB,aAAa,CAAC7I,IAAI,CAAC,EACpB;AACA9F,IAAAA,YAAe,CAAA9F,KAAA,CAAf8F,EAAE,EAAA,CAActO,UAAa,CAAA,CAAAtE,MAAA,CAAK0Y,IAAI,CAAC,CAAA;AACzC;AACF,CAAC;AAED,IAAM+I,eAAe,GAAG7O,MAAS,EAAU;AAC3C,IAAM2O,aAAa,GAAG,SAAhBA,aAAaA,CAAI7I,IAAe,EAAK;AACzC,EAAA,IAAM/G,GAAG,GAAG6G,YAAY,CAAA1L,KAAA,CAAA,MAAA,EAAA,CAAC,GAAG,CAAA,CAAA9M,MAAA,CAAA+V,kBAAA,CAAK2C,IAAI,CAAC,CAAA,CAAA;AACtC,EAAA,IAAMgJ,MAAM,GAAGD,eAAe,CAACpF,GAAG,CAAC1K,GAAG,CAAC;AACvC8P,EAAAA,eAAe,CAACvB,GAAG,CAACvO,GAAG,CAAC;AACxB,EAAA,OAAO+P,MAAM;AACf,CAAC;;ACnBM,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,GAAA;AAAA,EAAA,OAC5B/O,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B2U,IAAAA,eAAe,CAACC,qBAAqB,EAAE5U,OAAO,CAAC;AACjD,GAAC,CAAC;AAAA,CAAA;AAQG,IAAM6U,kBAAkB,GAAG,SAArBA,kBAAkBA,GAAA;AAAA,EAAA,OAC7BlP,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B2U,IAAAA,eAAe,CAACG,wBAAwB,EAAE9U,OAAO,CAAC;AACpD,GAAC,CAAC;AAAA,CAAA;AAQG,IAAM+U,2BAA2B,GAAG,SAA9BA,2BAA2BA,GAAA;AAAA,EAAA,OACtCL,iBAAiB,EAAE,CAACM,IAAI,CAACH,kBAAkB,CAAC,CAACG,IAAI,CAACN,iBAAiB,CAAC;AAAA,CAAA;AAQ/D,IAAMO,4BAA4B,GAAG,SAA/BA,4BAA4BA,GAAA;AAAA,EAAA,OACvCJ,kBAAkB,EAAE,CAACG,IAAI,CAACN,iBAAiB,CAAC,CAACM,IAAI,CAACH,kBAAkB,CAAC;AAAA,CAAA;AAOvE,IAAMC,wBAAsC,GAAG,EAAE;AACjD,IAAMF,qBAAmC,GAAG,EAAE;AAC9C,IAAIM,oBAAoB,GAAG,KAAK;AAEhC,IAAMP,eAAe,GAAG,SAAlBA,eAAeA,CAAIf,KAAmB,EAAE5T,OAAqB,EAAK;AACtE4T,EAAAA,KAAK,CAAC3H,IAAI,CAACjM,OAAO,CAAC;EACnB,IAAI,CAACkV,oBAAoB,EAAE;AACzBA,IAAAA,oBAAoB,GAAG,IAAI;AAC3BvP,IAAAA,gBAAmB,CAACwP,eAAc,CAAC;AACrC;AACF,CAAC;AAED,IAAMA,eAAc,GAAA,YAAA;EAAA,IAAAvM,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAgC,QAAA,GAAA;AAAA,IAAA,OAAAjC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CAOdtM,QAAW,CAACiP,qBAAqB,CAAC,EAAA;AAAAd,YAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UACvCmD,eAAe,CAACR,qBAAqB,CAAC;AAACd,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,UAAA,OAEjC,IAAI;AAAA,QAAA,KAAA,CAAA;AAAA6B,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,UAAA;AAAA,QAAA,KAAA,CAAA;UASZzB,wBAAwB,CAAAiB,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAAC,OAAA,GAAA;AAAA,YAAA,OAAAF,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,cAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,gBAAA,KAAA,CAAA;AAAA,kBAAA,IAAA,CAChBtM,QAAW,CAACmP,wBAAwB,CAAC,EAAA;AAAA/C,oBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,oBAAA;AAAA;kBAC1CmD,eAAe,CAACN,wBAAwB,CAAC;AAAC/C,kBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,kBAAA,OAEpC,IAAI;AAAA,gBAAA,KAAA,CAAA;AAAAF,kBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,kBAAA;AAAA,gBAAA,KAAA,CAAA;AAGZ,kBAAA,IAAItM,QAAW,CAACiP,qBAAqB,CAAC,EAAE;AAEtCjP,oBAAAA,gBAAmB,CAACwP,eAAc,CAAC;AACrC,mBAAC,MAAM;AACLD,oBAAAA,oBAAoB,GAAG,KAAK;AAC9B;AAAC,gBAAA,KAAA,CAAA;AAAA,gBAAA,KAAA,KAAA;kBAAA,OAAAnD,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,aAAA,EAAAN,OAAA,CAAA;AAAA,WACF,CAAC,CAAA,CAAA;AAAC,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAkC,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;GACJ,CAAA,CAAA;AAAA,EAAA,OAAA,SAjCKwB,cAAcA,GAAA;AAAA,IAAA,OAAAvM,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAiCnB,EAAA;AAED,IAAM2f,eAAe,GAAG,SAAlBA,eAAeA,CAAIxB,KAAmB,EAAK;AAC/C,EAAA,IAAI5T,OAAiC;AACrC,EAAA,OAAQA,OAAO,GAAG4T,KAAK,CAACK,KAAK,EAAE,EAAG;IAChC,IAAI;AACFjU,MAAAA,OAAO,EAAE;KACV,CAAC,OAAOoQ,GAAG,EAA6B;MACvCmE,QAAQ,CAACnE,GAAG,CAAC;AACf;AACF;AACF,CAAC;;ACtGM,IAAMiF,WAAW,GAAG,SAAdA,WAAWA,CAAI/b,OAAe,EAAA;EAAA,OACzCgc,UAAU,CAAClG,GAAG,CAAC9V,OAAO,CAACnC,WAAW,EAAE,CAAC;AAAA,CAAA;AAOhC,IAAMoe,YAAY,GAAG,SAAfA,YAAYA,CAAIza,MAAe,EAAA;AAAA,EAAA,OAC1C6K,aAAgB,CAAC7K,MAAM,CAAC,IACxB6K,YAAe,CAAC7K,MAAM,EAAE0a,UAAU,CAAC,IAClC,OAAOC,aAAa,KAAK,WAAW,IACnC9P,YAAe,CAAC7K,MAAM,EAAE2a,aAAa,CAAE;AAAA,CAAA;AAI3C,IAAMH,UAAU,GAAG3P,MAAS,CAAC,CAC3B,GAAG,EACH,MAAM,EACN,SAAS,EACT,GAAG,EACH,KAAK,EACL,KAAK,EACL,KAAK,EACL,QAAQ,EACR,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,IAAI,EACJ,GAAG,EACH,KAAK,EACL,OAAO,EACP,KAAK,EACL,OAAO,EACP,MAAM,EACN,KAAK,EACL,QAAQ,EACR,QAAQ,EACR,GAAG,EACH,IAAI,EACJ,IAAI,EACJ,MAAM,EACN,GAAG,EACH,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,OAAO,EACP,MAAM,EACN,QAAQ,EACR,KAAK,EACL,KAAK,EACL,UAAU,EACV,MAAM,EACN,IAAI,EACJ,GAAG,EACH,KAAK,CACN,CAAC;;AC5CK,IAAM+P,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAC/B3T,OAAgB,EAChB4T,OAAe,EACfC,KAAa,EACV;AACHC,EAAAA,oBAAoB,CAAC9T,OAAO,EAAE4T,OAAO,EAAEC,KAAK,CAAC;EAG7C,IAAIE,SAAS,GAAG,KAAK;AACrB,EAAA,IAAIC,QAAQ,CAAChU,OAAO,EAAE4T,OAAO,CAAC,EAAE;AAC9BG,IAAAA,SAAS,GAAG,IAAI;AAChBE,IAAAA,gBAAgB,CAACjU,OAAO,EAAE4T,OAAO,CAAC;AACpC;AAEA,EAAA,IAAI,CAACI,QAAQ,CAAChU,OAAO,EAAE6T,KAAK,CAAC,EAAE;AAC7BK,IAAAA,aAAa,CAAClU,OAAO,EAAE6T,KAAK,CAAC;AAC7BE,IAAAA,SAAS,GAAG,IAAI;AAClB;AAEA,EAAA,OAAOA,SAAS;AAClB,CAAC;AAgDM,IAAMI,iBAAiB,GAAA,YAAA;AAAA,EAAA,IAAAtN,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAC,OAC/B7P,CAAAA,OAAgB,EAChB4T,OAAe,EACfC,KAAa,EAAA;AAAA,IAAA,IAAAxD,KAAA;MAAA+D,cAAA;MAAAL,SAAA;MAAAM,kBAAA;AAAAC,MAAAA,KAAA,GAAA5gB,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,QAAA,KAAA,CAAA;UACbG,KAAK,GAAAiE,KAAA,CAAAngB,MAAA,GAAA,CAAA,IAAAmgB,KAAA,CAAA,CAAA,CAAA,KAAAlgB,SAAA,GAAAkgB,KAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEHF,UAAAA,cAAc,GAAGG,qBAAqB,CAACvU,OAAO,EAAE6T,KAAK,CAAC;AAAA,UAAA,IAAA,CAExDxD,KAAK,EAAA;AAAAL,YAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;UAAA,OACDE,YAAY,CAACC,KAAK,CAAC;AAAA,QAAA,KAAA,CAAA;AAAAL,UAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;UAAA,OAGrByC,iBAAiB,EAAE;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CACrByB,cAAc,CAACI,YAAY,EAAE,EAAA;AAAAxE,YAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAExB,KAAK,CAAA;AAAA,QAAA,KAAA,CAAA;UAGRV,SAAS,GAAGJ,oBAAoB,CAAC3T,OAAO,EAAE4T,OAAO,EAAEC,KAAK,CAAC;UAC/DO,cAAc,CAACM,OAAO,EAAE;AAAC,UAAA,IAEpBX,SAAS,EAAA;AAAA/D,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,EACL,KAAK,CAAA;AAAA,QAAA,KAAA,EAAA;AAAAzE,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;UAAA,OAKmByE,wBAAwB,CAAC3U,OAAO,CAAC;AAAA,QAAA,KAAA,EAAA;UAA5DqU,kBAAkB,GAAArE,QAAA,CAAAqB,IAAA;AAAA,UAAA,IAAA,CACpBgD,kBAAkB,EAAA;AAAArE,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;UAAA,OACdE,YAAY,CAACiE,kBAAkB,CAAC;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,OAAArE,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAGjC,IAAI,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAzE,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAN,OAAA,CAAA;GACZ,CAAA,CAAA;AAAA,EAAA,OAAA,SAjCYsE,iBAAiBA,CAAAhC,EAAA,EAAAyC,GAAA,EAAAC,GAAA,EAAA;AAAA,IAAA,OAAAhO,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAiC7B,EAAA;AA0FM,IAAMohB,WAAW,GAAG,SAAdA,WAAWA,CAAI9U,OAAgB,EAAA;AAAA,EAAA,IAAEqQ,KAAK,GAAA3c,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAAA,EAAA,OACrDygB,iBAAiB,CAACnU,OAAO,EAAE1K,WAAc,EAAEA,WAAc,EAAE+a,KAAK,CAAC;AAAA,CAAA;AAyE5D,IAAM2D,QAAQ,GAAG,SAAXA,QAAQA,CAAIrZ,EAAW,EAAEoa,SAAiB,EAAA;EAAA,OACrDnR,SAAY,CAACjJ,EAAE,CAAC,CAACqa,QAAQ,CAACD,SAAS,CAAC;AAAA,CAAA;AAO/B,IAAMb,aAAa,GAAG,SAAhBA,aAAaA,CAAIvZ,EAAW,EAAA;AAAA,EAAA,IAAAsa,aAAA;EAAA,KAAAvX,IAAAA,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAK+gB,UAAU,OAAAjnB,KAAA,CAAAyP,IAAA,GAAAA,CAAAA,GAAAA,IAAA,WAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAVsX,IAAAA,UAAU,CAAAtX,IAAA,GAAAlK,CAAAA,CAAAA,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAAA,EAAA,OACtD,CAAAqX,aAAA,GAAArR,SAAY,CAACjJ,EAAE,CAAC,EAACuW,GAAG,CAAApT,KAAA,CAAAmX,aAAA,EAAIC,UAAU,CAAC;AAAA,CAAA;AAO9B,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIxa,EAAW,EAAA;EAAA,KAAAqS,IAAAA,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EAAK+gB,UAAU,OAAAjnB,KAAA,CAAA+e,KAAA,GAAAA,CAAAA,GAAAA,KAAA,WAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAViI,IAAAA,UAAU,CAAAjI,KAAA,GAAAvZ,CAAAA,CAAAA,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;AAAA,EAAA,OACnD0F,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;IAAA,OAAMiB,aAAa,CAAApW,KAAA,CAAA,MAAA,EAAA,CAACnD,EAAE,CAAA3J,CAAAA,MAAA,CAAKkkB,UAAU,CAAC,CAAA;GAAC,CAAA;AAAA,CAAA;AAO3D,IAAMjB,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAItZ,EAAW,EAAA;AAAA,EAAA,IAAAya,cAAA;EAAA,KAAAnO,IAAAA,KAAA,GAAAvT,SAAA,CAAAS,MAAA,EAAK+gB,UAAU,OAAAjnB,KAAA,CAAAgZ,KAAA,GAAAA,CAAAA,GAAAA,KAAA,WAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAVgO,IAAAA,UAAU,CAAAhO,KAAA,GAAAxT,CAAAA,CAAAA,GAAAA,SAAA,CAAAwT,KAAA,CAAA;AAAA;AAAA,EAAA,OACzD,CAAAkO,cAAA,GAAAxR,SAAY,CAACjJ,EAAE,CAAC,EAACiG,MAAM,CAAA9C,KAAA,CAAAsX,cAAA,EAAIF,UAAU,CAAC;AAAA,CAAA;AAOjC,IAAMG,aAAa,GAAG,SAAhBA,aAAaA,CAAI1a,EAAW,EAAA;EAAA,KAAA2a,IAAAA,KAAA,GAAA5hB,SAAA,CAAAS,MAAA,EAAK+gB,UAAU,OAAAjnB,KAAA,CAAAqnB,KAAA,GAAAA,CAAAA,GAAAA,KAAA,WAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAVL,IAAAA,UAAU,CAAAK,KAAA,GAAA7hB,CAAAA,CAAAA,GAAAA,SAAA,CAAA6hB,KAAA,CAAA;AAAA;AAAA,EAAA,OACtD5C,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;IAAA,OAAMgB,gBAAgB,CAAAnW,KAAA,CAAA,MAAA,EAAA,CAACnD,EAAE,CAAA3J,CAAAA,MAAA,CAAKkkB,UAAU,CAAC,CAAA;GAAC,CAAA;AAAA,CAAA;AAiC9D,IAAMM,OAAO,GAAG,SAAVA,OAAOA,CAAI7a,EAAW,EAAEtG,IAAY,EAAA;AAAA,EAAA,OAC/CuP,OAAU,CAACjJ,EAAE,EAAEiJ,UAAa,CAACvP,IAAI,CAAC,CAAC;AAAA,CAAA;AAyB9B,IAAMohB,UAAU,GAAG,SAAbA,UAAUA,CAAI9a,EAAW,EAAEtG,IAAY,EAAEyH,KAAa,EAAA;AAAA,EAAA,OACjE8H,OAAU,CAACjJ,EAAE,EAAEiJ,UAAa,CAACvP,IAAI,CAAC,EAAEyH,KAAK,CAAC;AAAA,CAAA;AAyErC,IAAM4Z,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAI1V,OAAgB,EAAExB,IAAY,EAAA;EAAA,OACpEmX,gBAAgB,CAAC3V,OAAO,CAAC,CAAC4V,gBAAgB,CAACpX,IAAI,CAAC;AAAA,CAAA;AAO3C,IAAMqX,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAI7V,OAAgB,EAAExB,IAAY,EAAA;AAAA,EAAA,OACjEsU,kBAAkB,EAAE,CAACG,IAAI,CAAC,YAAA;AAAA,IAAA,OAAMyC,uBAAuB,CAAC1V,OAAO,EAAExB,IAAI,CAAC;GAAC,CAAA;AAAA,CAAA;AAQlE,IAAMsX,eAAe,GAAG,SAAlBA,eAAeA,CAAI9V,OAAgB,EAAExB,IAAY,EAAA;AAAA,EAAA,IAAAuX,MAAA;AAAA,EAAA,OAAA,CAAAA,MAAA,GAC3D/V,OAAO,CAAgBgW,KAAK,MAAA,IAAA,IAAAD,MAAA,KAAA,MAAA,GAAA,MAAA,GAA7BA,MAAA,CAA+BH,gBAAgB,CAACpX,IAAI,CAAC;AAAA,CAAA;AAOhD,IAAMyX,YAAY,GAAG,SAAfA,YAAYA,CAAIjW,OAAgB,EAAExB,IAAY,EAAA;AAAA,EAAA,OACzDsU,kBAAkB,EAAE,CAACG,IAAI,CAAC,YAAA;AAAA,IAAA,OAAM6C,eAAe,CAAC9V,OAAO,EAAExB,IAAI,CAAC;GAAC,CAAA;AAAA,CAAA;AAO1D,IAAM0X,eAAe,GAAG,SAAlBA,eAAeA,CAC1BlW,OAAgB,EAChBxB,IAAY,EACZ1C,KAAa,EAAA;AAAA,EAAA,IAAAqa,OAAA;AAAA,EAAA,OAAA,CAAAA,OAAA,GACTnW,OAAO,CAAgBgW,KAAK,MAAAG,IAAAA,IAAAA,OAAA,KAA7BA,MAAAA,GAAAA,MAAAA,GAAAA,OAAA,CAA+BC,WAAW,CAAC5X,IAAI,EAAE1C,KAAK,CAAC;AAAA,CAAA;AAOrD,IAAMua,YAAY,GAAG,SAAfA,YAAYA,CAAIrW,OAAgB,EAAExB,IAAY,EAAE1C,KAAa,EAAA;AAAA,EAAA,OACxE6W,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,IAAA,OAAMiD,eAAe,CAAClW,OAAO,EAAExB,IAAI,EAAE1C,KAAK,CAAC;GAAC,CAAA;AAAA,CAAA;AAOhE,IAAMwa,eAAe,GAAG,SAAlBA,eAAeA,CAAItW,OAAgB,EAAExB,IAAY,EAAA;AAAA,EAAA,IAAA+X,OAAA;AAAA,EAAA,OAAA,CAAAA,OAAA,GAC3DvW,OAAO,CAAgBgW,KAAK,MAAA,IAAA,IAAAO,OAAA,KAAA,MAAA,GAAA,MAAA,GAA7BA,OAAA,CAA+BC,cAAc,CAAChY,IAAI,CAAC;AAAA,CAAA;AAO9C,IAAMiY,YAAY,GAAG,SAAfA,YAAYA,CAAIzW,OAAgB,EAAExB,IAAY,EAAA;AAAA,EAAA,OACzDmU,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,IAAA,OAAMqD,eAAe,CAACtW,OAAO,EAAExB,IAAI,CAAC;GAAC,CAAA;AAAA,CAAA;AAQzD,IAAMmW,wBAAwB,GAAA,YAAA;EAAA,IAAAhD,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAgC,QAAAA,CAAO5R,OAAgB,EAAA;AAAA,IAAA,IAAA0W,OAAA;AAAA,IAAA,OAAA/G,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA6B,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,UAAA,OACvC2F,oBAAoB,CAAC7V,OAAO,EAAE,qBAAqB,CAAC;AAAA,QAAA,KAAA,CAAA;UAApE0W,OAAO,GAAA3E,SAAA,CAAAV,IAAA;UAAA,OAAAU,SAAA,CAAA0C,MAAA,CAEN7Q,QAAAA,EAAAA,GAAM,CAAA9F,KAAA,CAAN8F,EAAE,EAAAmD,kBAAA,CACJ6C,OAAO,CAAC8M,OAAO,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC1V,GAAG,CAAC,UAACmK,QAAQ,EAAK;YAC/C,IAAIwL,QAAQ,GAAG/S,UAAa,CAACuH,QAAQ,CAAC,IAAI,CAAC;AAE3C,YAAA,IAAIA,QAAQ,KAAKwL,QAAQ,GAAG,GAAG,EAAE;AAC/BA,cAAAA,QAAQ,IAAI,IAAI;AAClB;AAEA,YAAA,OAAOA,QAAQ;WAChB,CAAC,CACJ,CAAC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA5E,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;GACF,CAAA,CAAA;EAAA,OAdY+C,SAAAA,wBAAwBA,CAAAiC,GAAA,EAAA;AAAA,IAAA,OAAAjF,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAcpC,EAAA;CAMoC,YAAA;EAAA,IAAAmjB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAkH,QAAAA,CAAO9W,OAAgB,EAAA;AAAA,IAAA,IAAAqQ,KAAA;AAAA0G,MAAAA,MAAA,GAAArjB,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,QAAA,KAAA,CAAA;UAAEG,KAAK,GAAA0G,MAAA,CAAA5iB,MAAA,GAAA,CAAA,IAAA4iB,MAAA,CAAA,CAAA,CAAA,KAAA3iB,SAAA,GAAA2iB,MAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAAAE,UAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,UAAA,OAClEiF,UAAU,CAACnV,OAAO,EAAE1K,yBAA4B,CAAC;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CACnD+a,KAAK,EAAA;AAAA4G,YAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA+G,UAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;UAAA,OACDE,YAAY,CAACC,KAAK,CAAC;AAAA,QAAA,KAAA,CAAA;AAAA4G,UAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;UAAA,OAGrB8C,2BAA2B,EAAE;AAAA,QAAA,KAAA,CAAA;AACnCiB,UAAAA,gBAAgB,CAACjU,OAAO,EAAE1K,yBAA4B,CAAC;AAAC,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA2hB,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2G,QAAA,CAAA;GACzD,CAAA,CAAA;EAAA,OARYI,SAAAA,wBAAwBA,CAAAC,GAAA,EAAA;AAAA,IAAA,OAAAN,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAQpC;CAkBqB,YAAA;AAAA,EAAA,IAAA0jB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAyH,QACvBC,CAAAA,WAAoB,EACpBC,SAAkB,EAClBC,oBAA+B,EAAA;AAAA,IAAA,IAAAC,KAAA,EAAA1J,SAAA,EAAAE,KAAA,EAAAzP,IAAA,EAAAwX,KAAA,EAAA0B,KAAA,EAAA5b,KAAA,EAAA6b,MAAA;AAAA,IAAA,OAAAhI,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,IAE3B,EAAA,CAACsD,YAAY,CAAC8D,WAAW,CAAC,IAAI,CAAC9D,YAAY,CAAC+D,SAAS,CAAC,CAAA,EAAA;AAAAM,YAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UAAA,OAAA2H,SAAA,CAAApD,MAAA,CAAA,QAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAAoD,UAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;UAAA,OAIpD4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;UACpB2E,KAA6B,GAAG,EAAE;AAExC,UAAA,IAAID,oBAAoB,EAAE;YAAAzJ,SAAA,GAAAC,0BAAA,CACLwJ,oBAAoB,CAAA;AAAA,YAAA,IAAA;cAAvC,KAAAzJ,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAyC;gBAA9B3P,IAAI,GAAAyP,KAAA,CAAAnS,KAAA;gBACb2b,KAAK,CAACjZ,IAAI,CAAC,GAAGkX,uBAAuB,CAAC4B,WAAW,EAAE9Y,IAAI,CAAC;AAC1D;AAAC,aAAA,CAAA,OAAA6P,GAAA,EAAA;cAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,aAAA,SAAA;AAAAN,cAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH;UAEMyH,KAAK,GAAGsB,WAAW,CAACtB,KAAK;UAC/B,KAAWxX,KAAI,IAAIwX,KAAK,EAAE;AAClBla,YAAAA,KAAK,GAAGka,KAAK,CAACJ,gBAAgB,CAACpX,KAAI,CAAC;AAC1C,YAAA,IAAI1C,KAAK,EAAE;AACT2b,cAAAA,KAAK,CAACjZ,KAAI,CAAC,GAAG1C,KAAK;AACrB;AACF;UAEA,KAAW0C,MAAI,IAAIiZ,KAAK,EAAE;YACxBpB,YAAY,CAACkB,SAAS,EAAE/Y,MAAI,EAAEiZ,KAAK,CAACjZ,MAAI,CAAC,CAAC;AAC5C;AAEA2W,UAAAA,UAAU,CAAArX,KAAA,CAACyZ,MAAAA,EAAAA,CAAAA,SAAS,EAAAvmB,MAAA,CAAA+V,kBAAA,CAAKnD,SAAY,CAAC0T,WAAW,CAAC,CAAC,CAAA,CAAA;AAAC,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAO,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAkH,QAAA,CAAA;GACrD,CAAA,CAAA;AAAA,EAAA,OAAA,SA/BYS,SAASA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAA;AAAA,IAAA,OAAAb,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EA+BrB;AAUM,IAAMwkB,oBAAoB,GAAA,YAAA;AAAA,EAAA,IAAAC,KAAA,GAAAzI,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAwI,QAAAA,CAClCpY,OAAgB,EAChByX,KAAsB,EAAA;AAAA,IAAA,IAAAjgB,OAAA;MAAA6gB,WAAA;MAAAC,SAAA;MAAA9Z,IAAA;MAAA+Z,aAAA;MAAAC,OAAA;MAAA1c,KAAA;MAAA2c,oBAAA;MAAAC,cAAA;MAAAC,SAAA;AAAAC,MAAAA,MAAA,GAAAllB,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,QAAA,KAAA,CAAA;AACtB1Y,UAAAA,OAKC,GAAAohB,MAAA,CAAAzkB,MAAA,GAAAykB,CAAAA,IAAAA,MAAA,CAAAxkB,CAAAA,CAAAA,KAAAA,SAAA,GAAAwkB,MAAA,CAAG,CAAA,CAAA,GAAA,EAAE;UAAA,IAEDpF,YAAY,CAACxT,OAAO,CAAC,EAAA;AAAA8Y,YAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UAAA,OAAA4I,SAAA,CAAArE,MAAA,CAAA,QAAA,CAAA;AAAA,QAAA,KAAA,CAAA;UAIpB4D,WAAW,GAAG7gB,OAAO,CAACuhB,YAAY;AAElCT,UAAAA,SAAS,GAAG1U,cAAiB,CAAC,CAAApM,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEwhB,OAAO,KAAI,EAAE,CAAC;AAAAF,UAAAA,SAAA,CAAAxH,EAAA,GAAA3B,mBAAA,EAAArS,CAAAA,IAAA,CACxCma,KAAK,CAAA;AAAA,QAAA,KAAA,CAAA;UAAA,IAAAqB,CAAAA,SAAA,CAAAG,EAAA,GAAAH,SAAA,CAAAxH,EAAA,IAAAnD,IAAA,EAAA;AAAA2K,YAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAb1R,UAAAA,IAAI,GAAAsa,SAAA,CAAAG,EAAA,CAAAnd,KAAA;AACPyc,UAAAA,aAAa,GAAGpjB,gBAAgB,CAACqJ,IAAI,CAAC;AACtCga,UAAAA,OAAO,MAAAxnB,MAAA,CAAMsnB,SAAS,CAAAtnB,CAAAA,MAAA,CAAGunB,aAAa,CAAA;UAExCzc,KAAoB,GAAA,MAAA;AAAA,UAAA,IAEnBoK,UAAU,CAACuR,KAAK,CAACjZ,IAAI,CAAC,CAAC,EAAA;AAAAsa,YAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAC1BpU,UAAAA,KAAK,GAAG,IAAI;AAACgd,UAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,EAAA;AAEbpU,UAAAA,KAAK,GAAG2b,KAAK,CAACjZ,IAAI,CAAC;UACbka,cAAc,GAAA,CAAAD,oBAAA,GAClBjhB,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAE0hB,WAAW,MAAAT,IAAAA,IAAAA,oBAAA,cAAAA,oBAAA,GAAK3c,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;AAAA,UAAA,IAAA,CAErDuc,WAAW,EAAA;AAAAS,YAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UAAA4I,SAAA,CAAAK,EAAA,GACKvV,EAAE;AAAAkV,UAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,UAAA,OAAkB+F,YAAY,CAACjW,OAAO,EAAEwY,OAAO,CAAC;AAAA,QAAA,KAAA,EAAA;AAAAM,UAAAA,SAAA,CAAAM,EAAA,GAAAN,SAAA,CAAAzH,IAAA;AAA9DsH,UAAAA,SAAS,GAAAG,SAAA,CAAAK,EAAA,CAAM3Z,UAAU,CAAAb,IAAA,CAAAma,SAAA,CAAAK,EAAA,EAAAL,SAAA,CAAAM,EAAA,CAAA;UAE/Btd,KAAK,GAAGuc,WAAW,CAAC7Z,IAAI,EAAEma,SAAS,IAAI,CAAC,EAAE7c,KAAK,CAAC;AAAC,QAAA,KAAA,EAAA;AAGnDA,UAAAA,KAAK,GAAGiK,UAAU,CAACjK,KAAK,EAAE4c,cAAc,CAAC;AAAC,QAAA,KAAA,EAAA;UAG5C,IAAI5c,KAAK,KAAK,IAAI,EAAE;AAClB2a,YAAAA,YAAY,CAACzW,OAAO,EAAEwY,OAAO,CAAC;AAChC,WAAC,MAAM;AACLnC,YAAAA,YAAY,CAACrW,OAAO,EAAEwY,OAAO,EAAE1c,KAAK,IAAI,CAAAtE,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAE6hB,MAAM,KAAI,EAAE,CAAC,CAAC;AACjE;AAACP,UAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;AAAA,UAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA4I,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAiI,QAAA,CAAA;GAEJ,CAAA,CAAA;AAAA,EAAA,OAAA,SA7CYF,oBAAoBA,CAAAoB,GAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAApB,KAAA,CAAAra,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CA6ChC,EAAA;AAkBD,IAAM8lB,uBAAuB,GAAG5V,UAAa,EAG1C;AAEH,IAAMkQ,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAI9T,OAAgB,EAA6B;AACzE,EAAA,IAAMyZ,oBAAoB,GAAGD,uBAAuB,CAAC9M,GAAG,CAAC1M,OAAO,CAAC;EACjE,IAAI,CAACyZ,oBAAoB,EAAE;AACzB,IAAA;AACF;EAAC,KAAAC,IAAAA,KAAA,GAAAhmB,SAAA,CAAAS,MAAA,EAJgDwlB,SAAS,OAAA1rB,KAAA,CAAAyrB,KAAA,GAAAA,CAAAA,GAAAA,KAAA,WAAAE,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA,EAAA,EAAA;AAATD,IAAAA,SAAS,CAAAC,KAAA,GAAAlmB,CAAAA,CAAAA,GAAAA,SAAA,CAAAkmB,KAAA,CAAA;AAAA;AAM1D,EAAA,KAAA,IAAAC,EAAA,GAAA,CAAA,EAAAC,UAAA,GAAoBH,SAAS,EAAAE,EAAA,GAAAC,UAAA,CAAA3lB,MAAA,EAAA0lB,EAAA,EAAE,EAAA;AAA1B,IAAA,IAAMhG,KAAK,GAAAiG,UAAA,CAAAD,EAAA,CAAA;AACd,IAAA,IAAME,mBAAmB,GAAGN,oBAAoB,CAAC5F,KAAK,CAAC;AACvD,IAAA,IAAIkG,mBAAmB,EAAE;MACvBA,mBAAmB,CAACC,OAAO,EAAE;AAC/B;AACF;AACF,CAAC;AAED,IAAMzF,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAIvU,OAAgB,EAAE6T,KAAa,EAAK;AACjE,EAAA,IAAI4F,oBAAoB,GAAGD,uBAAuB,CAAC9M,GAAG,CAAC1M,OAAO,CAAC;EAC/D,IAAI,CAACyZ,oBAAoB,EAAE;IACzBA,oBAAoB,GAAG,EAAE;AACzBD,IAAAA,uBAAuB,CAAChI,GAAG,CAACxR,OAAO,EAAEyZ,oBAAoB,CAAC;AAC5D;EAEA,IAAIQ,WAAW,GAAG,KAAK;EACvBR,oBAAoB,CAAC5F,KAAK,CAAC,GAAG;AAC5BmG,IAAAA,OAAO,EAAE,SAATA,OAAOA,GAAQ;AACbC,MAAAA,WAAW,GAAG,IAAI;AAClBrW,MAAAA,YAAe,CAAC6V,oBAAoB,EAAE5F,KAAK,CAAC;KAC7C;AACDa,IAAAA,OAAO,EAAE,SAATA,OAAOA,GAAQ;AACb9Q,MAAAA,YAAe,CAAC6V,oBAAoB,EAAE5F,KAAK,CAAC;KAC7C;AACDW,IAAAA,YAAY,EAAE,SAAdA,YAAYA,GAAQ;AAClB,MAAA,OAAOyF,WAAW;AACpB;GACD;EAED,OAAOR,oBAAoB,CAAC5F,KAAK,CAAC;AACpC,CAAC;;ACtrBM,IAAMqG,cAAc,GAAG,SAAjBA,cAAcA,CACzBla,OAAgB,EAChBxI,OAGC,EACE;AACH,EAAA,IAAMmZ,OAAO,GAAGwJ,gBAAgB,CAACna,OAAO,EAAExI,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEmZ,OAAO,CAAC;EAE3D,IAAI,CAAAnZ,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE4iB,UAAU,MAAK,IAAI,EAAE;IAChCA,UAAU,CAACpa,OAAO,EAAE;AAClB5C,MAAAA,IAAI,EAAEwG,QAAW,CAAC5D,OAAO,CAAC;AAC1Bqa,MAAAA,EAAE,EAAE1J;AACN,KAAC,CAAC;IAEFyJ,UAAU,CAACzJ,OAAO,EAAE;AAClB0J,MAAAA,EAAE,EAAEzW,QAAW,CAAC5D,OAAO;AACzB,KAAC,CAAC;AACJ;AAEAA,EAAAA,OAAO,CAACsa,WAAW,CAAC3J,OAAO,CAAC;AAC5BA,EAAAA,OAAO,CAAC4J,MAAM,CAACva,OAAO,CAAC;AAEvB,EAAA,OAAO2Q,OAAO;AAChB,CAAC;CAOuB,YAAA;AAAA,EAAA,IAAA9J,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAC,OAAAA,CACzB7P,OAAgB,EAChBxI,OAGC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,EACE9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OAAMiH,cAAc,CAACla,OAAO,EAAExI,OAAO,CAAC;WAAC,CAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAwY,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAN,OAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SANxD2K,WAAWA,CAAArI,EAAA,EAAAyC,GAAA,EAAA;AAAA,IAAA,OAAA/N,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAM6C;AAU9D,IAAM+mB,eAAe,GAAG,SAAlBA,eAAeA,CAC1Bza,OAAgB,EAChBxI,OAGC,EACE;AACH,EAAA,IAAMmZ,OAAO,GAAGwJ,gBAAgB,CAACna,OAAO,EAAExI,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEmZ,OAAO,CAAC;AAE3D+J,EAAAA,eAAe,CAAC1a,OAAO,EAAE2Q,OAAO,EAAE;AAAEyJ,IAAAA,UAAU,EAAE;AAAK,GAAC,CAAC;EACvDO,cAAc,CAAChK,OAAO,EAAE;AACtB0J,IAAAA,EAAE,EAAEra,OAAO;AACXoa,IAAAA,UAAU,EAAE;AACd,GAAC,CAAC;AAEF,EAAA,OAAOzJ,OAAO;AAChB,CAAC;CAOwB,YAAA;AAAA,EAAA,IAAAgB,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAgC,QAAAA,CAC1B5R,OAAgB,EAChBxI,OAGC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAA6B,SAAA,CAAA0C,MAAA,CAAA,QAAA,EACE9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OAAMwH,eAAe,CAACza,OAAO,EAAExI,OAAO,CAAC;WAAC,CAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAua,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SANzDgJ,YAAYA,CAAA/F,GAAA,EAAA+B,GAAA,EAAA;AAAA,IAAA,OAAAjF,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAM6C;AAW/D,IAAMmnB,iBAAiB,GAAG,SAApBA,iBAAiBA,CAC5B7a,OAAgB,EAChB8a,UAAmB,EACnBtjB,OAEC,EACE;EACH,IAAI,CAAAA,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE4iB,UAAU,MAAK,IAAI,EAAE;IAChCA,UAAU,CAERpa,OAAO,EACP;AAAE5C,MAAAA,IAAI,EAAEwG,QAAW,CAAC5D,OAAO;AAAE,KAC/B,CAAC;IAEDoa,UAAU,CAERU,UAAU,EACV;AAAE1d,MAAAA,IAAI,EAAEwG,QAAW,CAACkX,UAAU,CAAC;AAAET,MAAAA,EAAE,EAAEzW,QAAW,CAAC5D,OAAO;AAAE,KAC5D,CAAC;AACH;AAEAA,EAAAA,OAAO,CAACsa,WAAW,CAACQ,UAAU,CAAC;AACjC,CAAC;CAO0B,YAAA;AAAA,EAAA,IAAAjE,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAkH,QAC5B9W,CAAAA,OAAgB,EAChB8a,UAAmB,EACnBtjB,OAEC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAA+G,SAAA,CAAAxC,MAAA,CAAA,QAAA,EAED9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OACvB4H,iBAAiB,CAAC7a,OAAO,EAAE8a,UAAU,EAAEtjB,OAAO,CAAC;AAAA,WACjD,CAAC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAyf,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2G,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SATUiE,cAAcA,CAAA5D,GAAA,EAAAY,GAAA,EAAAC,GAAA,EAAA;AAAA,IAAA,OAAAnB,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EASxB;AAWI,IAAMsnB,eAAe,GAAG,SAAlBA,eAAeA,CAC1BC,QAAiB,EACjBC,QAAiB,EACjB1jB,OAEC,EACE;AACH,EAAA,IAAM2jB,IAAI,GAAGvX,aAAgB,CAAC,KAAK,CAAC;AACpCiX,EAAAA,iBAAiB,CAACI,QAAQ,EAAEE,IAAI,EAAE3jB,OAAO,CAAC;AAC1CqjB,EAAAA,iBAAiB,CAACK,QAAQ,EAAED,QAAQ,EAAEzjB,OAAO,CAAC;AAC9CqjB,EAAAA,iBAAiB,CAACM,IAAI,EAAED,QAAQ,EAAE1jB,OAAO,CAAC;AAC5C,CAAC;CAOwB,YAAA;AAAA,EAAA,IAAA4f,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAyH,QAC1B4D,CAAAA,QAAiB,EACjBC,QAAiB,EACjB1jB,OAEC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAA2H,SAAA,CAAApD,MAAA,CAAA,QAAA,EAED9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OAAM+H,eAAe,CAACC,QAAQ,EAAEC,QAAQ,EAAE1jB,OAAO,CAAC;WAAC,CAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAqgB,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAkH,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SAPjE+D,YAAYA,CAAAnD,GAAA,EAAAqB,GAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAnC,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAOqD;AAWvE,IAAMgnB,eAAe,GAAG,SAAlBA,eAAeA,CAC1BW,SAAkB,EAClBC,SAAkB,EAClB9jB,OAEC,EACE;EACH,IAAI,CAAAA,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE4iB,UAAU,MAAK,IAAI,EAAE;IAAA,IAAArM,SAAA,GAAAC,0BAAA,CACZpK,UAAa,CAACyX,SAAS,CAAC,CAAA;MAAApN,KAAA;AAAA,IAAA,IAAA;MAA5C,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA8C;AAAA,QAAA,IAAnCoN,KAAK,GAAAtN,KAAA,CAAAnS,KAAA;QACdse,UAAU,CAACmB,KAAK,EAAE;AAChBne,UAAAA,IAAI,EAAEie,SAAS;AACfhB,UAAAA,EAAE,EAAEiB;AACN,SAAC,CAAC;AACJ;AAAC,KAAA,CAAA,OAAAjN,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH;AAEA+M,EAAAA,SAAS,CAACf,MAAM,CAAAzc,KAAA,CAAhBwd,SAAS,EAAAvU,kBAAA,CAAWnD,UAAa,CAACyX,SAAS,CAAC,CAAC,CAAA;AAC/C,CAAC;CAOwB,YAAA;AAAA,EAAA,IAAAlD,KAAA,GAAAzI,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAwI,QAC1BiD,CAAAA,SAAkB,EAClBC,SAAkB,EAClB9jB,OAEC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAA4I,SAAA,CAAArE,MAAA,CAAA,QAAA,EAED9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OACvByH,eAAe,CAACW,SAAS,EAAEC,SAAS,EAAE9jB,OAAO,CAAC;AAAA,WAChD,CAAC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAshB,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAiI,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SATUoD,YAAYA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAxD,KAAA,CAAAra,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAStB;AAkBI,IAAMinB,cAAc,GAAG,SAAjBA,cAAcA,CACzB3a,OAAgB,EAChBxI,OAIC,EACE;EACH,IAAIokB,QAAQ,GAAG,CAAApkB,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE6iB,EAAE,KAAI,IAAI;EAClC,IAAMwB,QAAQ,GAAG,CAAArkB,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEqkB,QAAQ,KAAI,QAAQ;AAC9C,EAAA,IAAIA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,OAAO,EAAE;AACjDD,IAAAA,QAAQ,GAAGhY,QAAW,CAACpM,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAE6iB,EAAE,CAAC;AACrC;EAEA,IAAI,CAAA7iB,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE4iB,UAAU,MAAK,IAAI,EAAE;IAChCA,UAAU,CAACpa,OAAO,EAAE;AAClB5C,MAAAA,IAAI,EAAEwG,QAAW,CAAC5D,OAAO,CAAC;AAC1Bqa,MAAAA,EAAE,EAAEuB;AACN,KAAC,CAAC;AACJ;AAEA,EAAA,IAAIpkB,OAAO,KAAPA,IAAAA,IAAAA,OAAO,eAAPA,OAAO,CAAE6iB,EAAE,EAAE;AACf7iB,IAAAA,OAAO,CAAC6iB,EAAE,CAACwB,QAAQ,CAAC,CAAC7b,OAAO,CAAC;AAC/B,GAAC,MAAM;AACL4D,IAAAA,MAAS,CAAC5D,OAAO,CAAC;AACpB;AACF,CAAC;AAOM,IAAM8b,WAAW,GAAA,YAAA;AAAA,EAAA,IAAAC,KAAA,GAAArM,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAoM,QAAAA,CACzBhc,OAAgB,EAChBxI,OAIC,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAmM,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAjM,IAAA,GAAAiM,SAAA,CAAAhM,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,QAAA,EACE9B,iBAAiB,EAAE,CAACM,IAAI,CAAC,YAAA;AAAA,YAAA,OAAM0H,cAAc,CAAC3a,OAAO,EAAExI,OAAO,CAAC;WAAC,CAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA0kB,SAAA,CAAA/L,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA6L,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;AAAA,EAAA,OAAA,SAPxDF,WAAWA,CAAAK,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAL,KAAA,CAAAje,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAO6C,EAAA;CAWpC,YAAA;EAAA,IAAA2oB,KAAA,GAAA3M,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAA0M,QAAAA,CAClCtc,OAAgB,EAAA;AAAA,IAAA,IAAAqQ,KAAA;MAAA7Y,OAAA;AAAA+kB,MAAAA,MAAA,GAAA7oB,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA0M,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAxM,IAAA,GAAAwM,SAAA,CAAAvM,IAAA;AAAA,QAAA,KAAA,CAAA;UAChBG,KAAK,GAAAkM,MAAA,CAAApoB,MAAA,GAAA,CAAA,IAAAooB,MAAA,CAAA,CAAA,CAAA,KAAAnoB,SAAA,GAAAmoB,MAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AACT/kB,UAAAA,OAEC,GAAA+kB,MAAA,CAAApoB,MAAA,GAAAooB,CAAAA,GAAAA,MAAA,MAAAnoB,SAAA;AAAAqoB,UAAAA,SAAA,CAAAvM,IAAA,GAAA,CAAA;AAAA,UAAA,OAEK4E,WAAW,CAAC9U,OAAO,EAAEqQ,KAAK,CAAC;AAAA,QAAA,KAAA,CAAA;AACjCsK,UAAAA,cAAc,CAAC3a,OAAO,EAAExI,OAAO,CAAC;AAAC,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAilB,SAAA,CAAAtM,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAmM,QAAA,CAAA;GAClC,CAAA,CAAA;EAAA,OATYI,SAAAA,oBAAoBA,CAAAC,IAAA,EAAA;AAAA,IAAA,OAAAN,KAAA,CAAAve,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,EAShC;AAoBM,IAAMkpB,oBAAoB,GAAA,YAAA;EAAA,IAAAC,KAAA,GAAAnN,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAkN,QAAAA,CAAO9c,OAAgB,EAAA;IAAA,IAAA2Q,OAAA,EAAAoM,UAAA;AAAA,IAAA,OAAApN,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkN,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhN,IAAA,GAAAgN,SAAA,CAAA/M,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA+M,UAAAA,SAAA,CAAA/M,IAAA,GAAA,CAAA;UAAA,OACnDyC,iBAAiB,EAAE;AAAA,QAAA,KAAA,CAAA;UAGnBoK,UAAU,GAAGnZ,UAAa,CAAC5D,OAAO,CAAC,CAAC,CAAC,CAAC;UAC5C,IACE4D,QAAW,CAACA,UAAa,CAAC5D,OAAO,CAAC,CAAC,KAAK,CAAC,IACzC4D,aAAgB,CAACmZ,UAAU,CAAC,IAC5B/I,QAAQ,CAAC+I,UAAU,EAAEG,sBAAsB,CAAC,EAC5C;AAEAvM,YAAAA,OAAO,GAAGoM,UAAU;AACtB,WAAC,MAAM;AACLpM,YAAAA,OAAO,GAAG8J,eAAe,CAACza,OAAO,EAAE;AAAEoa,cAAiB,CAAC,CAAC;AACxDlG,YAAAA,aAAa,CAACvD,OAAO,EAAEuM,sBAAsB,CAAC;AAChD;AAAC,UAAA,OAAAD,SAAA,CAAAxI,MAAA,CAAA,QAAA,EAEM9D,OAAO,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAsM,SAAA,CAAA9M,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2M,QAAA,CAAA;GACf,CAAA,CAAA;EAAA,OAlBYF,SAAAA,oBAAoBA,CAAAO,IAAA,EAAA;AAAA,IAAA,OAAAN,KAAA,CAAA/e,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAkBhC,EAAA;AAqEM,IAAM0mB,UAAU,GAAG,SAAbA,UAAUA,CACrBrhB,MAAe,EACfvB,OAAuD,EAAA;AAAA,EAAA,OAEvD4lB,iBAAiB,CAAC5L,GAAG,CAACzY,MAAM,EAAE;AAC5BqE,IAAAA,IAAI,EAAE5F,OAAO,CAAC4F,IAAI,IAAI,IAAI;AAC1Bid,IAAAA,EAAE,EAAE7iB,OAAO,CAAC6iB,EAAE,IAAI;AACpB,GAAC,CAAC;AAAA,CAAA;AAMG,IAAMgD,aAAa,GAAG,SAAhBA,aAAaA,CACxBtkB,MAAe,EAAA;AAAA,EAAA,OAEfqkB,iBAAiB,CAAC1Q,GAAG,CAAC3T,MAAM,CAAC,IAAI,IAAI;AAAA,CAAA;AAMhC,IAAMukB,eAAe,GAAG,SAAlBA,eAAeA,CAAIvkB,MAAe,EAAK;EAIlD6K,QAAW,CAAC,YAAM;AAChBA,IAAAA,SAAY,CAACwZ,iBAAiB,EAAErkB,MAAM,CAAC;GACxC,EAAE,GAAG,CAAC;AACT,CAAC;AAqBD,IAAMmkB,sBAAsB,GAAGtZ,UAAa,CAAC,iBAAiB,CAAC;AAE/D,IAAMwZ,iBAAiB,GAAGxZ,MAAS,EAGhC;AAEH,IAAMuW,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpBna,OAAgB,EAChB2Q,OAA8D,EAC3D;AACH,EAAA,IAAI/M,SAAY,CAAC+M,OAAO,CAAC,EAAE;AACzB,IAAA,OAAOA,OAAO;AAChB;EAEA,IAAIhZ,GAAG,GAAGgZ,OAAO;EACjB,IAAI,CAAChZ,GAAG,EAAE;IACR,IAAI2b,WAAW,CAAC1P,OAAU,CAAC5D,OAAO,CAAC,CAAC,EAAE;AACpCrI,MAAAA,GAAG,GAAG,MAAM;AACd,KAAC,MAAM;AACLA,MAAAA,GAAG,GAAG,KAAK;AACb;AACF;AAEA,EAAA,OAAOiM,aAAgB,CAACjM,GAAG,CAAC;AAC9B,CAAC;;ACleM,IAAM4lB,cAAc,GAAG,SAAjBA,cAAcA,CAIzBxR,OAAU,EACVyR,OAAgB,EAAA;AAAA,EAAA,OAEhB5Z,UAAa,CAIX,UAAC3F,OAAO,EAAK;AACb,IAAA,IAAMwf,MAAM,GAAG,SAATA,MAAMA,GAAS;AACnB,MAAA,IAAM9gB,MAAM,GAAGoP,OAAO,EAAE;AACxB,MAAA,IAAI,CAACnI,SAAY,CAACjH,MAAM,CAAC,EAAE;QACzBsB,OAAO,CAACtB,MAAkC,CAAC;AAC3C,QAAA,OAAO,IAAI;AACb;AACA,MAAA,OAAO,KAAK;KACb;IAED,IAAI8gB,MAAM,EAAE,EAAE;AACZ,MAAA;AACF;AAEA,IAAA,IAAI,CAAC7Z,SAAY,CAAC4Z,OAAO,CAAC,EAAE;MAC1B5Z,QAAW,CAAC,YAAM;QAChB3F,OAAO,CACL,IAGF,CAAC;QACDyf,QAAQ,CAACC,UAAU,EAAE;OACtB,EAAEH,OAAO,CAAC;AACb;AAEA,IAAA,IAAME,QAAQ,GAAG9Z,mBAAsB,CAAC,YAAM;MAC5C,IAAI6Z,MAAM,EAAE,EAAE;QACZC,QAAQ,CAACC,UAAU,EAAE;AACvB;AACF,KAAC,CAAC;IAEFD,QAAQ,CAACE,OAAO,CAACha,aAAgB,EAAE,EAAE;AACnCia,MAAAA,SAAS,EAAE,IAAI;AACfC,MAAAA,OAAO,EAAE;AACX,KAAC,CAAC;AACJ,GAAC,CAAC;AAAA,CAAA;AAoBG,IAAMC,2BAA2B,GAAG,SAA9BA,2BAA2BA,CACtChS,OAAU,EAAA;AAAA,EAAA,OAEVnI,UAAa,CAAkC,UAAC3F,OAAO,EAAK;IAC1D,IAAI+f,aAAa,GAAG,KAAK;AAIzBT,IAAAA,cAAc,CAAC,YAAA;AAAA,MAAA,OAAMS,aAAa,IAAIjS,OAAO,EAAE;AAAA,KAAA,CAAC,CAACkH,IAAI,CAAC,UAACnK,GAAG,EAAK;MAC7D,IAAI,CAACkV,aAAa,EAAE;QAClB/f,OAAO,CAAC6K,GAA+B,CAAC;AAC1C;AACF,KAAC,CAAC;AAEFmV,IAAAA,kBAAkB,EAAE,CAAChL,IAAI,CAAC,YAAM;AAC9B+K,MAAAA,aAAa,GAAG,IAAI;MACpB/f,OAAO,CAAC,IAAI,CAAC;AACf,KAAC,CAAC;AACJ,GAAC,CAAC;AAAA,CAAA;AAUG,IAAMggB,kBAAkB,GAAG,SAArBA,kBAAkBA,GAAA;AAAA,EAAA,OAC7Bra,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B,IAAA,IAAMnH,UAAU,GAAG8M,aAAgB,EAAE;AACrC,IAAA,IAAI9M,UAAU,KAAKonB,WAAW,IAAIpnB,UAAU,KAAKqnB,QAAQ,EAAE;AACzDlgB,MAAAA,OAAO,EAAE;AACT,MAAA;AACF;IAEA2F,MAAS,EAAE,CAACwa,gBAAgB,CAAC,kBAAkB,EAAE,YAAA;MAAA,OAAMngB,OAAO,EAAE;KAAC,CAAA;AACnE,GAAC,CAAC;AAAA,CAAA;AAUG,IAAMogB,eAAe,GAAG,SAAlBA,eAAeA,GAAA;AAAA,EAAA,OAC1Bza,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B,IAAA,IAAI2F,aAAgB,EAAE,KAAKua,QAAQ,EAAE;AACnClgB,MAAAA,OAAO,EAAE;AACT,MAAA;AACF;IAEA2F,MAAS,EAAE,CAACwa,gBAAgB,CAAC,kBAAkB,EAAE,YAAM;AACrD,MAAA,IAAIxa,aAAgB,EAAE,KAAKua,QAAQ,EAAE;AACnClgB,QAAAA,OAAO,EAAE;AACX;AACF,KAAC,CAAC;AACJ,GAAC,CAAC;AAAA,CAAA;AAWG,IAAMqgB,gBAAgB,GAAG,SAAnBA,gBAAgBA,GAAA;AAAA,EAAA,OAC3B1a,UAAa,CAAO,UAAC3F,OAAO,EAAK;AAC/B,IAAA,IAAIsgB,WAAW,EAAE;AACftgB,MAAAA,OAAO,EAAE;AACT,MAAA;AACF;AAEA,IAAA,OAAOggB,kBAAkB,EAAE,CAAChL,IAAI,CAAC,YAAM;MAGrC,IAAIzD,KAA2C,GAAG,IAAI;AAEtD,MAAA,IAAMgP,aAAa,GAAG,SAAhBA,aAAaA,GAAS;AAC1BD,QAAAA,WAAW,GAAG,IAAI;AAClB,QAAA,IAAI/O,KAAK,EAAE;AACT5L,UAAAA,UAAa,CAAC4L,KAAK,CAAC;AACpBA,UAAAA,KAAK,GAAG,IAAI;AACd;AACAvR,QAAAA,OAAO,EAAE;OACV;AAED,MAAA,IAAI0F,QAAQ,CAACI,eAAe,GAAG,CAAC,EAAE;AAChCyL,QAAAA,KAAK,GAAG5L,QAAW,CAAC,YAAM;AACxB4a,UAAAA,aAAa,EAAE;AACjB,SAAC,EAAE7a,QAAQ,CAACI,eAAe,CAAC;AAC9B;AAEAsa,MAAAA,eAAe,EAAE,CAACpL,IAAI,CAACuL,aAAa,CAAC;AACvC,KAAC,CAAC;AACJ,GAAC,CAAC;AAAA,CAAA;AAWJ,IAAML,QAAQ,GAAG,UAAU;AAC3B,IAAMD,WAAW,GAAG,aAAa;AAEjC,IAAIK,WAAW,GAAG,KAAK;AAEvB,IAAI,CAAC3a,MAAS,EAAE,EAAE;AAChB2a,EAAAA,WAAW,GAAG,IAAI;AACpB,CAAC,MAAM;AACLD,EAAAA,gBAAgB,EAAE;AACpB;;AC5LO,IAAMG,OAAO,GAAG,SAAVA,OAAOA,CAAUC,WAAqC,EAAA;AAAA,EAAA,OACjE,IAAIC,IAAI,CAACD,WAAW,CAAC;AAAA,CAAA;AAQhB,IAAME,aAAa,GACxB,SADWA,aAAaA,CACjBF,WAAqC,EAAA;EAAA,OAC5C,YAAA;IAAA,OACED,OAAO,CAACC,WAAW,CAAC;AAAA,GAAA;AAAA,CAAA;AAQjB,IAAMG,WAAW,GAAG,SAAdA,WAAWA,CACtBH,WAAqC,EAAA;AAAA,EAAA,OAClC,IAAII,QAAQ,CAACJ,WAAW,CAAC;AAAA,CAAA;AAQvB,IAAMK,iBAAiB,GAC5B,SADWA,iBAAiBA,CACLL,WAAqC,EAAA;EAAA,OAC5D,YAAA;IAAA,OACEG,WAAW,CAACH,WAAW,CAAC;AAAA,GAAA;AAAA,CAAA;AAENM,IAAAA,QAAQ,GAAAprB,YAAA,CAqC5B,SAAAorB,QACEvqB,CAAAA,IAAmB,EACnBiqB,WAAqC,EACrC;AAAAlrB,EAAAA,eAAA,OAAAwrB,QAAA,CAAA;AACA,EAAA,IAAI,CAACtS,GAAG,GAAG,UAAC5L,GAAG,EAAA;AAAA,IAAA,OAAKrM,IAAI,CAACiY,GAAG,CAAC5L,GAAG,CAAC;AAAA,GAAA;AACjC,EAAA,IAAI,CAAC0Q,GAAG,GAAG,UAAC1Q,GAAG,EAAEhF,KAAK,EAAA;AAAA,IAAA,OAAKrH,IAAI,CAAC+c,GAAG,CAAC1Q,GAAG,EAAEhF,KAAK,CAAC;AAAA,GAAA;EAC/C,IAAI,CAAA,QAAA,CAAO,GAAG,UAACgF,GAAG,EAAA;AAAA,IAAA,OAAK8C,SAAY,CAACnP,IAAI,EAAEqM,GAAG,CAAC;AAAA,GAAA;AAC9C,EAAA,IAAI,CAACuM,GAAG,GAAG,UAACvM,GAAG,EAAA;AAAA,IAAA,OAAKrM,IAAI,CAAC4Y,GAAG,CAACvM,GAAG,CAAC;AAAA,GAAA;AAEjC,EAAA,IAAI,CAACme,IAAI,GAAG,UAACne,GAAG,EAAK;AACnB,IAAA,IAAInE,MAAM,GAAGlI,IAAI,CAACiY,GAAG,CAAC5L,GAAG,CAAC;IAC1B,IAAInE,MAAM,KAAKvI,SAAS,EAAE;AACxBuI,MAAAA,MAAM,GAAG+hB,WAAW,CAAC5d,GAAG,CAAC;AACzBrM,MAAAA,IAAI,CAAC+c,GAAG,CAAC1Q,GAAG,EAAEnE,MAAM,CAAC;AACvB;AACA,IAAA,OAAOA,MAAM;GACd;AAED,EAAA,IAAI,CAACuiB,KAAK,GAAG,UAACC,EAAE,EAAc;AAC5B,IAAA,IAAMrjB,KAAK,GAAGrH,IAAI,CAACiY,GAAG,CAACyS,EAAE,CAAC;IAAC,KAAAzhB,IAAAA,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EADRirB,IAAI,OAAAnxB,KAAA,CAAAyP,IAAA,GAAAA,CAAAA,GAAAA,IAAA,WAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAJwhB,MAAAA,IAAI,CAAAxhB,IAAA,GAAAlK,CAAAA,CAAAA,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;IAEvB,IAAI9B,KAAK,YAAYkjB,QAAQ,IAAIpb,QAAW,CAACwb,IAAI,CAAC,EAAE;MAClDtjB,KAAK,CAACojB,KAAK,CAAAphB,KAAA,CAAXhC,KAAK,EAAA,CAAOsjB,IAAI,CAAC,CAAC,CAAC,EAAApuB,MAAA,CAAA+V,kBAAA,CAAKqY,IAAI,CAAC7U,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA,CAAA;AACxC;AAEA,IAAA,IACEzO,KAAK,KAAK1H,SAAS,IAClBwP,gBAAmB,CAAC9H,KAAK,CAAC,IACzB,EACG,MAAM,IAAIA,KAAK,IAAIA,KAAK,CAACkB,IAAI,IAC7B,QAAQ,IAAIlB,KAAK,IAAIA,KAAK,CAAC3H,MAAO,CACnC,EACJ;AACAyP,MAAAA,SAAY,CAACnP,IAAI,EAAE0qB,EAAE,CAAC;AACxB;GACD;AACH,CAAC,CAAA;AAYUR,IAAAA,IAAI,aAAAU,SAAA,EAAA;EA0Cf,SAAAV,IAAAA,CAAYD,WAAqC,EAAE;AAAA,IAAA,IAAAzqB,KAAA;AAAAT,IAAAA,eAAA,OAAAmrB,IAAA,CAAA;AACjD,IAAA,IAAMlqB,IAAI,GAAGmP,MAAS,EAAQ;AAC9B3P,IAAAA,KAAA,GAAAR,UAAA,CAAA,IAAA,EAAAkrB,IAAA,EAAMlqB,CAAAA,IAAI,EAAEiqB,WAAW,CAAA,CAAA;AAEvB9a,IAAAA,cAAiB,CAAA3P,KAAA,EAAO,MAAM,EAAE;MAAEyY,GAAG,EAAE,SAALA,GAAGA,GAAA;QAAA,OAAQjY,IAAI,CAACuI,IAAI;AAAA;AAAC,KAAC,CAAC;IACzD/I,KAAA,CAAKqrB,KAAK,GAAG,YAAA;AAAA,MAAA,OAAM7qB,IAAI,CAAC6qB,KAAK,EAAE;AAAA,KAAA;IAC/BrrB,KAAA,CAAKyN,OAAO,GAAG,YAAA;AAAA,MAAA,OAAMjN,IAAI,CAACiN,OAAO,EAAE;AAAA,KAAA;IACnCzN,KAAA,CAAKqJ,IAAI,GAAG,YAAA;AAAA,MAAA,OAAM7I,IAAI,CAAC6I,IAAI,EAAE;AAAA,KAAA;IAC7BrJ,KAAA,CAAK8N,MAAM,GAAG,YAAA;AAAA,MAAA,OAAMtN,IAAI,CAACsN,MAAM,EAAE;AAAA,KAAA;AACjC9N,IAAAA,KAAA,CAAKqB,MAAS,CAAC8C,QAAQ,CAAC,GAAG,YAAA;MAAA,OAAM3D,IAAI,CAACa,MAAS,CAAC8C,QAAQ,CAAC,EAAE;AAAA,KAAA;AAAC,IAAA,OAAAnE,KAAA;AAC9D;EAACN,SAAA,CAAAgrB,IAAA,EAAAU,SAAA,CAAA;EAAA,OAAAzrB,YAAA,CAAA+qB,IAAA,CAAA;AAAA,CAAA,CApD6BK,QAAQ,CAAA;AAqDvClkB,eAAA,CArDY6jB,IAAI,EAAA,eAAA,EAkCiBC,aAAa,CAAA;AA8BlCE,IAAAA,QAAQ,aAAAS,UAAA,EAAA;EAenB,SAAAT,QAAAA,CAAYJ,WAAqC,EAAE;AAAAlrB,IAAAA,eAAA,OAAAsrB,QAAA,CAAA;AACjD,IAAA,IAAMrqB,IAAI,GAAGmP,UAAa,EAAQ;AAAC,IAAA,OAAAnQ,UAAA,CAAAqrB,IAAAA,EAAAA,QAAA,EAC7BrqB,CAAAA,IAAI,EAAEiqB,WAAW,CAAA,CAAA;AACzB;EAAC/qB,SAAA,CAAAmrB,QAAA,EAAAS,UAAA,CAAA;EAAA,OAAA3rB,YAAA,CAAAkrB,QAAA,CAAA;AAAA,CAAA,CAlBiDE,QAAQ,CAAA;AAmB3DlkB,eAAA,CAnBYgkB,QAAQ,EAAA,mBAAA,EAOiBC,iBAAiB,CAAA;;AClKvD,IAAaS,UAAU,GAAA,YAAA;AAuFrB,EAAA,SAAAA,UACEC,CAAAA,MAAgC,EAChC3e,GAA2B,EAC3B;AAAAtN,IAAAA,eAAA,OAAAgsB,UAAA,CAAA;IACA,IAAI1e,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,mBAAmB,CAAC;AACvD;AAMA,IAAA,IAAM+b,MAAM,GAAGlB,OAAO,CAAqC,UAACmB,CAAC,EAAA;MAAA,OAAM;AACjEC,QAAAA,OAAO,EAAED,CAAC;AACVE,QAAAA,gBAAgB,EAAE,CAAC;AACnBC,QAAAA,WAAW,EAAEnc,MAAS,EAAE;AACxBoc,QAAAA,QAAQ,EAAE,IAAI;AACdC,QAAAA,YAAY,EAAE;OACf;AAAA,KAAC,CAAC;AAEH,IAAA,IAAMC,YAAY,GAAGtc,MAAS,EAM3B;IAIH,IAAI4L,KAA2C,GAAG,IAAI;AACtD,IAAA,IAAM2Q,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,OAAyB,EAAK;AACe,MAAA,IAAArS,SAAA,GAAAC,0BAAA,CAE/CoS,OAAO,CAAA;QAAAnS,KAAA;AAAA,MAAA,IAAA;QAA5B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA8B;AAAA,UAAA,IAAnBkS,MAAM,GAAApS,KAAA,CAAAnS,KAAA;AACf,UAAA,IAAM/C,MAAM,GAAG6K,QAAW,CAACyc,MAAM,CAAC;AAClC,UAAA,IAAMC,OAAO,GAAGD,MAAM,CAACE,IAAI;AAG3B,UAAA,IAAI,CAAC3c,SAAY,CAAC7K,MAAM,CAAC,EAAE;AACzB,YAAA;AACF;AAEA,UAAA,IAAIunB,OAAO,KAAKhrB,YAAe,EAAE;AAAA,YAAA,IAAAkrB,UAAA,GAAAxS,0BAAA,CACXqS,MAAM,CAACI,UAAU,CAAA;cAAAC,MAAA;AAAA,YAAA,IAAA;cAArC,KAAAF,UAAA,CAAA7qB,CAAA,EAAA+qB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAAtS,CAAA,EAAAC,EAAAA,IAAA,GAAuC;AAAA,gBAAA,IAA5BoN,KAAK,GAAAmF,MAAA,CAAA5kB,KAAA;AACd,gBAAA,IAAI8H,SAAY,CAAC2X,KAAK,CAAC,EAAE;AACvB,kBAAA,IAAMoF,SAAS,GAAGhB,MAAM,CAACV,IAAI,CAAC1D,KAAK,CAAC;kBACpCoF,SAAS,CAACX,QAAQ,GAAGjnB,MAAM;kBAC3B4nB,SAAS,CAACb,gBAAgB,IAAIc,SAAS;AACzC;AACF;AAAC,aAAA,CAAA,OAAAvS,GAAA,EAAA;cAAAmS,UAAA,CAAAlS,CAAA,CAAAD,GAAA,CAAA;AAAA,aAAA,SAAA;AAAAmS,cAAAA,UAAA,CAAAjS,CAAA,EAAA;AAAA;AAAA,YAAA,IAAAsS,UAAA,GAAA7S,0BAAA,CAEmBqS,MAAM,CAACS,YAAY,CAAA;cAAAC,MAAA;AAAA,YAAA,IAAA;cAAvC,KAAAF,UAAA,CAAAlrB,CAAA,EAAAorB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAA3S,CAAA,EAAAC,EAAAA,IAAA,GAAyC;AAAA,gBAAA,IAA9BoN,MAAK,GAAAwF,MAAA,CAAAjlB,KAAA;AACd,gBAAA,IAAI8H,SAAY,CAAC2X,MAAK,CAAC,EAAE;AACvB,kBAAA,IAAMoF,UAAS,GAAGhB,MAAM,CAACV,IAAI,CAAC1D,MAAK,CAAC;kBACpCoF,UAAS,CAACV,YAAY,GAAGlnB,MAAM;kBAC/B4nB,UAAS,CAACb,gBAAgB,IAAIkB,WAAW;AAC3C;AACF;AAAC,aAAA,CAAA,OAAA3S,GAAA,EAAA;cAAAwS,UAAA,CAAAvS,CAAA,CAAAD,GAAA,CAAA;AAAA,aAAA,SAAA;AAAAwS,cAAAA,UAAA,CAAAtS,CAAA,EAAA;AAAA;WAGF,MAAM,IAAI+R,OAAO,KAAKhrB,YAAe,IAAI+qB,MAAM,CAACY,aAAa,EAAE;AAC9D,YAAA,IAAMN,WAAS,GAAGhB,MAAM,CAACV,IAAI,CAAClmB,MAAM,CAAC;YACrC4nB,WAAS,CAACZ,WAAW,CAAC7O,GAAG,CAACmP,MAAM,CAACY,aAAa,CAAC;YAC/CN,WAAS,CAACb,gBAAgB,IAAIoB,aAAa;AAC7C;AACF;AAAC,OAAA,CAAA,OAAA7S,GAAA,EAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAN,QAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;MAID,IAAI,CAACiB,KAAK,IAAI5L,MAAS,CAAC+b,MAAM,CAAC,EAAE;AAC/BnQ,QAAAA,KAAK,GAAG5L,QAAW,CAAC,YAAM;UACsC,IAAAud,UAAA,GAAAnT,0BAAA,CACtC2R,MAAM,CAAC5d,MAAM,EAAE,CAAA;YAAAqf,MAAA;AAAA,UAAA,IAAA;YAAvC,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAAyC;AAAA,cAAA,IAA9BwS,SAAS,GAAAS,MAAA,CAAAtlB,KAAA;AAClB,cAAA,IAAIulB,mBAAmB,CAACV,SAAS,CAAC,EAAE;AAEpC,eAAC,MAAM;gBACLW,gBAAgB,CAACX,SAAS,CAAC;AAC7B;AACF;AAAC,WAAA,CAAA,OAAAtS,GAAA,EAAA;YAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,WAAA,SAAA;AAAA8S,YAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;UAEDoR,MAAM,CAACL,KAAK,EAAE;AACd9P,UAAAA,KAAK,GAAG,IAAI;SACb,EAAE,CAAC,CAAC;AACP;KACD;IAED,IAAM+R,SAA2C,GAAAzmB,eAAA,CAAAA,eAAA,CAC9CxF,EAAAA,EAAAA,YAAe,EAAG;AACjBksB,MAAAA,SAAS,EAAE5d,mBAAsB,CAACuc,eAAe,CAAC;AAClDsB,MAAAA,SAAS,EAAE;AACb,KAAC,CACAnsB,EAAAA,YAAe,EAAG;AACjBksB,MAAAA,SAAS,EAAE5d,mBAAsB,CAACuc,eAAe,CAAC;AAClDsB,MAAAA,SAAS,EAAE;AACb,KAAC,CACF;IAID,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAClBnS,OAA0B,EAC1B/X,OAAkC,EACX;AAAA,MAAA,IAAAmqB,iBAAA;AACvB/d,MAAAA,MAAS,CAAA,CAAA+d,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,uBAAzBA,iBAAA,CAA2BC,SAAS,CAAC;AAG/C,MAAA,IAAMxf,QAAQ,GAAGkO,aAAY,CAACf,OAAO,CAAC;MACtCnN,QAAQ,CAACyO,QAAQ,CAAC,YAAA;QAAA,OAAMgR,aAAa,CAACtS,OAAO,CAAC;OAAC,CAAA;AAE/C2Q,MAAAA,YAAY,CAAC1O,GAAG,CAACjC,OAAO,EAAE;AAAEqS,QAAAA,SAAS,EAAExf,QAAQ;AAAE0f,QAAAA,QAAQ,EAAEtqB;AAAQ,OAAC,CAAC;AACrE,MAAA,OAAO4K,QAAQ;KAChB;AAID,IAAA,IAAM2f,eAAe,GAAA,YAAA;AAAA,MAAA,IAAAlb,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAC,OAAAA,CACtBN,OAA0B,EAC1ByS,WAA0C,EAAA;AAAA,QAAA,IAAAxqB,OAAA,EAAA4K,QAAA,EAAA3N,IAAA,EAAAwtB,UAAA,EAAApI,EAAA,EAAAqI,IAAA,EAAAliB,OAAA,EAAAmiB,aAAA,EAAAC,iBAAA,EAAAC,aAAA;AAAA,QAAA,OAAA1S,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAEpC1Y,cAAAA,OAAO,GAAG8qB,YAAU,CAACN,WAAW,IAAI,EAAE,CAAC;AACvC5f,cAAAA,QAAQ,GAAGsf,cAAc,CAACnS,OAAO,EAAE/X,OAAO,CAAC;cAE7C/C,IAAI,GAAGgrB,MAAM,CAAC8C,KAAK,IAAI3e,OAAU,EAAE;AAAA,cAAA,IAClCnP,IAAI,EAAA;AAAAub,gBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;AAAAF,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA,OACMqN,cAAc,CAAC3Z,OAAU,CAAC;AAAA,YAAA,KAAA,CAAA;cAAvCnP,IAAI,GAAAub,QAAA,CAAAqB,IAAA;AAAArB,cAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,cAAA,OAGE,IAAI;AAAA,YAAA,KAAA,EAAA;AAAA,cAAA,IAAA,CAGR9N,QAAQ,CAACoO,SAAS,EAAE,EAAA;AAAAR,gBAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAIxB,IAAIjd,OAAO,CAACsoB,gBAAgB,IAAIc,SAAS,GAAGI,WAAW,CAAC,EAAE;AACxDwB,gBAAAA,gBAAgB,CAAC/tB,IAAI,EAAEa,YAAe,CAAC;AACzC;AAEA,cAAA,IAAIkC,OAAO,CAACsoB,gBAAgB,GAAGoB,aAAa,EAAE;AAC5CsB,gBAAAA,gBAAgB,CAAC/tB,IAAI,EAAEa,YAAe,CAAC;AACzC;AAAC,cAAA,IAAA,EAGC0sB,WAAW,KAAXA,IAAAA,IAAAA,WAAW,eAAXA,WAAW,CAAES,WAAW,IACxB,CAACjrB,OAAO,CAACkrB,SAAS,IAClB,EAAElrB,OAAO,CAACsoB,gBAAgB,GAAGc,SAAS,CAAC,CAAA,EAAA;AAAA5Q,gBAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAYnCwN,cAAAA,UAAU,GAAGV,SAAS,CAACjsB,YAAe,CAAC,CAACksB,SAAS,CAACmB,WAAW,EAAE;cACrExC,eAAe,CAAC8B,UAAU,CAAC;AAACpI,cAAAA,EAAA,GAAAqI,CAAAA,EAAAA,IAAA,GAAAlxB,EAAAA,CAAAA,MAAA,CAAA+V,kBAAA,CAGvBnD,gBAAmB,CAACnP,IAAI,EAAE+C,OAAO,CAACkrB,SAAS,CAAC,CAAA,EAAA3b,kBAAA,CAC3CtS,IAAI,CAACmuB,OAAO,CAACprB,OAAO,CAACkrB,SAAS,CAAC,GAAG,CAACjuB,IAAI,CAAC,GAAG,EAAE,CAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAAA,cAAA,IAAA,EAAAolB,EAAA,GAAAqI,IAAA,CAAA/tB,MAAA,CAAA,EAAA;AAAA6b,gBAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAFxClQ,OAAO,GAAAkiB,IAAA,CAAArI,EAAA,CAAA;AAIVsI,cAAAA,aAAwC,GAAG;AAC/CtC,gBAAAA,OAAO,EAAE7f,OAAO;AAChB8f,gBAAAA,gBAAgB,EAAEc,SAAS;AAC3Bb,gBAAAA,WAAW,EAAEnc,MAAS,EAAE;AACxBoc,gBAAAA,QAAQ,EAAEpc,QAAW,CAAC5D,OAAO,CAAC;AAC9BigB,gBAAAA,YAAY,EAAE;eACf;AAEKmC,cAAAA,iBAAiB,GAAGzC,MAAM,CAACjT,GAAG,CAAC1M,OAAO,CAAC;AACvCqiB,cAAAA,aAAa,GAAGQ,gBAAgB,CACpCV,aAAa,EACbC,iBACF,CAAC;AAAA,cAAA,IAAA,CAEGC,aAAa,EAAA;AAAArS,gBAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,IACXmR,CAAAA,mBAAmB,CAACgB,aAAa,CAAC,EAAA;AAAArS,gBAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AACwBF,cAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,EAAA;AAEGF,cAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,cAAA,OACzD4S,gBAAc,CAAC1gB,QAAQ,EAAEigB,aAAa,CAAC;AAAA,YAAA,KAAA,EAAA;cAAAxI,EAAA,EAAA;AAAA7J,cAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAF,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OAIpD,CAAA,CAAA;AAAA,MAAA,OAAA,SAxEKkS,eAAeA,CAAA5P,EAAA,EAAAyC,GAAA,EAAA;AAAA,QAAA,OAAA/N,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAwEpB,EAAA;AAID,IAAA,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CAAItS,OAA0B,EAAK;AACpD3L,MAAAA,SAAY,CAACsc,YAAY,EAAE3Q,OAAO,CAAC;MAEnC,IAAIwT,gBAAgB,GAAG,CAAC;MAAC,IAAAC,UAAA,GAAAhV,0BAAA,CACLkS,YAAY,CAACne,MAAM,EAAE,CAAA;QAAAkhB,MAAA;AAAA,MAAA,IAAA;QAAzC,KAAAD,UAAA,CAAArtB,CAAA,EAAAstB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAA9U,CAAA,EAAAC,EAAAA,IAAA,GAA2C;AAAA,UAAA,IAAhC+U,KAAK,GAAAD,MAAA,CAAAnnB,KAAA;AACdinB,UAAAA,gBAAgB,IAAIG,KAAK,CAACpB,QAAQ,CAAChC,gBAAgB;AACrD;AAAC,OAAA,CAAA,OAAAzR,GAAA,EAAA;QAAA2U,UAAA,CAAA1U,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAA2U,QAAAA,UAAA,CAAAzU,CAAA,EAAA;AAAA;MAED,IAAI,EAAEwU,gBAAgB,IAAInC,SAAS,GAAGI,WAAW,CAAC,CAAC,EAAE;AACnDmC,QAAAA,kBAAkB,CAAC7tB,YAAe,CAAC;AACrC;AAEA,MAAA,IAAI,EAAEytB,gBAAgB,GAAG7B,aAAa,CAAC,EAAE;AACvCiC,QAAAA,kBAAkB,CAAC7tB,YAAe,CAAC;AACrC;KACD;AAID,IAAA,IAAMgsB,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIX,SAAoC,EAAK;MACP,IAAAyC,UAAA,GAAApV,0BAAA,CAEtCkS,YAAY,CAACne,MAAM,EAAE,CAAA;QAAAshB,MAAA;AAAA,MAAA,IAAA;QAAzC,KAAAD,UAAA,CAAAztB,CAAA,EAAA0tB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAlV,CAAA,EAAAC,EAAAA,IAAA,GAA2C;AAAA,UAAA,IAAhC+U,KAAK,GAAAG,MAAA,CAAAvnB,KAAA;AACd,UAAA,IAAMwnB,eAAe,GAAGJ,KAAK,CAACpB,QAAQ,CAAChC,gBAAgB;AACvD,UAAA,IAAM/mB,MAAM,GAAGmqB,KAAK,CAACpB,QAAQ,CAACjC,OAAO;AACrC,UAAA,IAAMvkB,QAAQ,GAAG4nB,KAAK,CAACpB,QAAQ,CAACY,SAAS;AAEzC,UAAA,IAAI,EAAE/B,SAAS,CAACb,gBAAgB,GAAGwD,eAAe,CAAC,EAAE;AAEnD,YAAA;AACF;UAEA,IAAMC,cAAc,GAAG,EAAE;AACzB,UAAA,IAAIxqB,MAAM,EAAE;YACV,IAAI,CAAC4nB,SAAS,CAACd,OAAO,CAAC7K,QAAQ,CAACjc,MAAM,CAAC,EAAE;AAEvC,cAAA;AACF;AAEAwqB,YAAAA,cAAc,CAACrZ,IAAI,CAACnR,MAAM,CAAC;AAC7B;AAEA,UAAA,IAAIuC,QAAQ,EAAE;AACZ,YAAA,IAAMsnB,OAAO,GAAA7b,kBAAA,CAAOnD,gBAAmB,CAAC+c,SAAS,CAACd,OAAO,EAAEvkB,QAAQ,CAAC,CAAC;YAErE,IAAIqlB,SAAS,CAACd,OAAO,CAAC+C,OAAO,CAACtnB,QAAQ,CAAC,EAAE;AACvCsnB,cAAAA,OAAO,CAAC1Y,IAAI,CAACyW,SAAS,CAACd,OAAO,CAAC;AACjC;AAEA,YAAA,IAAI,CAACjc,QAAW,CAACgf,OAAO,CAAC,EAAE;AAEzB,cAAA;AACF;YAEAW,cAAc,CAACrZ,IAAI,CAAApM,KAAA,CAAnBylB,cAAc,EAAAxc,kBAAA,CAAS6b,OAAO,CAAC,CAAA;AACjC;UAEAE,gBAAc,CAACI,KAAK,CAACtB,SAAS,EAAEjB,SAAS,EAAE4C,cAAc,CAAC;AAC5D;AAAC,OAAA,CAAA,OAAAlV,GAAA,EAAA;QAAA+U,UAAA,CAAA9U,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAA+U,QAAAA,UAAA,CAAA7U,CAAA,EAAA;AAAA;KACF;IAID,IAAMiU,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAI/tB,IAAa,EAAE+uB,YAA0B,EAAK;AACtE,MAAA,IAAI,CAACjC,SAAS,CAACiC,YAAY,CAAC,CAAC/B,SAAS,EAAE;QAItCF,SAAS,CAACiC,YAAY,CAAC,CAAChC,SAAS,CAAC5D,OAAO,CAACnpB,IAAI,EAAAqG,eAAA,CAAAA,eAAA,CAAA,EAAA,EAC3C0oB,YAAY,EAAG,IAAI,cACX/D,MAAM,CAACgE,QAAQ,CACzB,CAAC;AACFlC,QAAAA,SAAS,CAACiC,YAAY,CAAC,CAAC/B,SAAS,GAAG,IAAI;AAC1C;KACD;AAID,IAAA,IAAM0B,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIK,YAA0B,EAAK;AACzD,MAAA,IAAIjC,SAAS,CAACiC,YAAY,CAAC,CAAC/B,SAAS,EAAE;QAIrCF,SAAS,CAACiC,YAAY,CAAC,CAAChC,SAAS,CAAC7D,UAAU,EAAE;AAC9C4D,QAAAA,SAAS,CAACiC,YAAY,CAAC,CAAC/B,SAAS,GAAG,KAAK;AAC3C;KACD;AAID,IAAA,IAAMJ,mBAAmB,GAAG,SAAtBA,mBAAmBA,CACvBV,SAAoC,EACxB;AACZ,MAAA,IAAM5nB,MAAM,GAAG4nB,SAAS,CAACd,OAAO;AAChC,MAAA,IAAM6D,aAAa,GAAGrG,aAAa,CAACtkB,MAAM,CAAC;MAC3C,IAAI,CAAC2qB,aAAa,EAAE;AAClB,QAAA,OAAO,KAAK;AACd;AAEA,MAAA,IAAMC,WAAW,GAAGhD,SAAS,CAACV,YAAY;AAC1C,MAAA,IAAM2D,OAAO,GAAGhgB,QAAW,CAAC7K,MAAM,CAAC;AACnC,MAAA,IAAM8qB,WAAW,GAAGH,aAAa,CAACtmB,IAAI;AACtC,MAAA,IAAM0mB,SAAS,GAAGJ,aAAa,CAACrJ,EAAE;MAElC,IAAM5lB,IAAI,GAAGgrB,MAAM,CAAC8C,KAAK,IAAI3e,OAAU,EAAE;AAGzC,MAAA,IACE,CAAC+f,WAAW,KAAKE,WAAW,IAAI,CAACpvB,IAAI,CAACugB,QAAQ,CAAC6O,WAAW,CAAC,KAC3DD,OAAO,KAAKE,SAAS,EACrB;QACAxG,eAAe,CAACvkB,MAAM,CAAC;AACvB,QAAA,OAAO,IAAI;AACb;AAEA,MAAA,OAAO,KAAK;KACb;IAID,IAAI,CAACqhB,UAAU,GAAGA,UAAU;IAI5B,IAAI,CAAC2J,UAAU,GAAGhC,eAAe;AAIjC,IAAA,IAAI,CAACiC,WAAW,GAAG,UAACzU,OAAO,EAAK;AAAA,MAAA,IAAA0U,kBAAA;AAE9BrgB,MAAAA,MAAS,CAAA,CAAAqgB,kBAAA,GAAC/D,YAAY,CAACxT,GAAG,CAAC6C,OAAO,CAAC,MAAA0U,IAAAA,IAAAA,kBAAA,uBAAzBA,kBAAA,CAA2BrC,SAAS,CAAC;KAChD;AACH;EAAC,OAAAhuB,YAAA,CAAA4rB,UAAA,EAAA,IAAA,EAAA,CAAA;IAAA1e,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA7VD,SAAOyQ,MAAMA,GAAgC;AAAA,MAAA,IAA/BkT,MAAwB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MACzC,OAAO,IAAI8rB,UAAU,CAAC0E,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC3D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAgC;AAAA,MAAA,IAAAC,cAAA;AAAA,MAAA,IAA/B3E,MAAwB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AACxC,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC3C,QAAQ,CAACyb,QAAQ,EAAE;AAAE9B,QAAAA,KAAK,EAAE;AAAK,OAAC,CAAC,CAAC;AAErE,MAAA,IAAM9tB,IAAI,GAAG4vB,QAAQ,CAAC9B,KAAK,KAAK3e,OAAU,EAAE,GAAG,IAAI,GAAGygB,QAAQ,CAAC9B,KAAK;AACpE,MAAA,IAAIgC,QAAQ,GAAAH,CAAAA,cAAA,GAAGI,WAAS,CAAC9X,GAAG,CAACjY,IAAI,CAAC,MAAA,IAAA,IAAA2vB,cAAA,KAAnBA,MAAAA,GAAAA,MAAAA,GAAAA,cAAA,CAAqB1X,GAAG,CAAC4X,YAAY,CAAC;MACrD,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAI/E,UAAU,CAAC6E,QAAQ,EAAE3E,iBAAe,CAAC;QACpD8E,WAAS,CAACvF,IAAI,CAACxqB,IAAI,CAAC,CAAC+c,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AAClD;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AAmfH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG/F,OAAO,CAA0C,YAAA;AAAA,EAAA,OACjE7a,MAAS,EAAE;AAAA,CACb,CAAC;AAED,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CAAIzE,MAAwB,EAA+B;AAAA,EAAA,IAAAgF,eAAA;EACxE,OAAO;AACLlC,IAAAA,KAAK,EAAE9C,MAAM,CAAChrB,IAAI,IAAI,IAAI;IAC1BgvB,QAAQ,EAAA,CAAAgB,eAAA,GAAEhF,MAAM,CAAC3B,OAAO,MAAA2G,IAAAA,IAAAA,eAAA,KAAAA,MAAAA,GAAAA,eAAA,GAAI;GAC7B;AACH,CAAC;AAED,IAAMC,eAAe,GAAGlW,oBAAoB,CAACpB,GAAG;AAChD,IAAMwT,SAAS,GAAG8D,eAAe,CAACpvB,OAAU,CAAC;AAC7C,IAAM0rB,WAAW,GAAG0D,eAAe,CAACpvB,SAAY,CAAC;AACjD,IAAM4rB,aAAa,GAAGwD,eAAe,CAACpvB,WAAc,CAAC;AAIrD,IAAMgtB,YAAU,GAAG,SAAbA,UAAUA,CAAI9qB,OAA0B,EAAgC;EAC5E,IAAI8rB,eAAe,GAAG,CAAC;AACvB,EAAA,IAAMqB,UAAU,GAAG7Y,eAAe,CAChC,YAAY,EACZtU,OAAO,CAACmtB,UAAU,EAClBnW,oBAAoB,CAACnB,GACvB,CAAC;AAED,EAAA,IAAIsX,UAAU,EAAE;AAAA,IAAA,IAAAC,UAAA,GAAA5W,0BAAA,CACI2W,UAAU,CAAA;MAAAE,MAAA;AAAA,IAAA,IAAA;MAA5B,KAAAD,UAAA,CAAAjvB,CAAA,EAAAkvB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAA1W,CAAA,EAAAC,EAAAA,IAAA,GAA8B;AAAA,QAAA,IAAnB2W,GAAG,GAAAD,MAAA,CAAA/oB,KAAA;AACZwnB,QAAAA,eAAe,IAAIoB,eAAe,CAACI,GAAG,CAAC;AACzC;AAAC,KAAA,CAAA,OAAAzW,GAAA,EAAA;MAAAuW,UAAA,CAAAtW,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAuW,MAAAA,UAAA,CAAArW,CAAA,EAAA;AAAA;AACH,GAAC,MAAM;IACL+U,eAAe,GAAG9U,oBAAoB,CAACtB,OAAO;AAChD;AAEA,EAAA,IAAM5R,QAAQ,GAAG9D,OAAO,CAAC8D,QAAQ,IAAI,EAAE;AACvC,EAAA,IAAI,CAACsI,QAAW,CAACtI,QAAQ,CAAC,EAAE;AAC1B,IAAA,MAAMsI,UAAa,CAAC,6BAA6B,CAAC;AACpD;EAEA,OAAO;AACLkc,IAAAA,gBAAgB,EAAEwD,eAAe;AACjCzD,IAAAA,OAAO,EAAEroB,OAAO,CAACuB,MAAM,IAAI,IAAI;AAC/B2pB,IAAAA,SAAS,EAAElrB,OAAO,CAAC8D,QAAQ,IAAI;GAChC;AACH,CAAC;AAED,IAAMunB,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpBkC,UAAqC,EACrCC,UAAiD,EACZ;EACrC,IAAI,CAACA,UAAU,IAAID,UAAU,CAAClF,OAAO,KAAKmF,UAAU,CAACnF,OAAO,EAAE;AAC5D,IAAA,OAAOkF,UAAU;AACnB;AAEA,EAAA,IAAME,UAAU,GAAGrhB,MAAS,EAAU;AAAC,EAAA,IAAAshB,UAAA,GAAAlX,0BAAA,CACpB+W,UAAU,CAAChF,WAAW,CAAA;IAAAoF,MAAA;AAAA,EAAA,IAAA;IAAzC,KAAAD,UAAA,CAAAvvB,CAAA,EAAAwvB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAhX,CAAA,EAAAC,EAAAA,IAAA,GAA2C;AAAA,MAAA,IAAhCiX,IAAI,GAAAD,MAAA,CAAArpB,KAAA;MACb,IAAI,CAACkpB,UAAU,CAACjF,WAAW,CAAC1S,GAAG,CAAC+X,IAAI,CAAC,EAAE;AACrCH,QAAAA,UAAU,CAAC/T,GAAG,CAACkU,IAAI,CAAC;AACtB;AACF;AAAC,GAAA,CAAA,OAAA/W,GAAA,EAAA;IAAA6W,UAAA,CAAA5W,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAA6W,IAAAA,UAAA,CAAA3W,CAAA,EAAA;AAAA;EAED,IAAM+U,eAAe,GACnByB,UAAU,CAACjF,gBAAgB,GAAGkF,UAAU,CAAClF,gBAAgB;AAE3D,EAAA,IAAM8D,OAAO,GACXmB,UAAU,CAAC/E,QAAQ,KAAKgF,UAAU,CAAChF,QAAQ,GAAG,IAAI,GAAG+E,UAAU,CAAC/E,QAAQ;AAE1E,EAAA,IAAM2D,WAAW,GACfoB,UAAU,CAAC9E,YAAY,KAAK+E,UAAU,CAAC/E,YAAY,GAC/C,IAAI,GACJ8E,UAAU,CAAC9E,YAAY;AAE7B,EAAA,IAAI,CAACrc,MAAS,CAACqhB,UAAU,CAAC,IAAI,CAAC3B,eAAe,IAAI,CAACM,OAAO,IAAI,CAACD,WAAW,EAAE;AAC1E,IAAA,OAAO,IAAI;AACb;EAEA,OAAO;IACL9D,OAAO,EAAEkF,UAAU,CAAClF,OAAO;AAC3BC,IAAAA,gBAAgB,EAAEwD,eAAe;AACjCvD,IAAAA,WAAW,EAAEkF,UAAU;AACvBjF,IAAAA,QAAQ,EAAE4D,OAAO;AACjB3D,IAAAA,YAAY,EAAE0D;GACf;AACH,CAAC;AAED,IAAMb,gBAAc,GAAG,SAAjBA,cAAcA,CAClB1gB,QAA4B,EAC5Bue,SAAoC,EAEjC;AAAA,EAAA,IADH4C,cAAyB,GAAA7vB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAE9B,EAAA,IAAI,CAACkQ,QAAW,CAAC2f,cAAc,CAAC,EAAE;AAChCA,IAAAA,cAAc,GAAG,CAAC5C,SAAS,CAACd,OAAO,CAAC;AACtC;AAAC,EAAA,IAAAwF,UAAA,GAAArX,0BAAA,CAE2BuV,cAAc,CAAA;IAAA+B,MAAA;AAAA,EAAA,IAAA;IAA1C,KAAAD,UAAA,CAAA1vB,CAAA,EAAA2vB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAnX,CAAA,EAAAC,EAAAA,IAAA,GAA4C;AAAA,MAAA,IAAjC7N,aAAa,GAAAglB,MAAA,CAAAxpB,KAAA;MACtBsG,QAAQ,CACLsO,MAAM,CAAC;QACN3X,MAAM,EAAE4nB,SAAS,CAACd,OAAO;AACzBvf,QAAAA,aAAa,EAAbA,aAAa;QACb2kB,UAAU,EAAEtE,SAAS,CAACZ,WAAW;QACjC6D,OAAO,EAAEjD,SAAS,CAACX,QAAQ;QAC3B2D,WAAW,EAAEhD,SAAS,CAACV;AACzB,OAAC,CAAC,CAAA,OAAA,CACI,CAACzN,QAAQ,CAAC;AACpB;AAAC,GAAA,CAAA,OAAAnE,GAAA,EAAA;IAAAgX,UAAA,CAAA/W,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAgX,IAAAA,UAAA,CAAA9W,CAAA,EAAA;AAAA;AACH,CAAC;;ACtsBM,IAAMgX,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAC/BC,MAAc,EACdC,MAAc,EACqC;AACnD,EAAA,IAAI,CAAC7hB,GAAM,CAAC4hB,MAAM,CAAC,IAAI,CAAC5hB,GAAM,CAAC6hB,MAAM,CAAC,EAAE;IACtC,OAAOnwB,MAAS;AAClB;AAEA,EAAA,IAAIsO,GAAM,CAAC4hB,MAAM,CAAC,KAAK5hB,GAAM,CAAC6hB,MAAM,CAAC,EAAE;IACrC,OAAOnwB,WAAc;AACvB;AAEA,EAAA,IAAIsO,GAAM,CAAC4hB,MAAM,CAAC,GAAG5hB,GAAM,CAAC6hB,MAAM,CAAC,EAAE;IACnC,OAAOD,MAAM,GAAG,CAAC,GAAGlwB,MAAS,GAAGA,OAAU;AAC5C;EACA,OAAOmwB,MAAM,GAAG,CAAC,GAAGnwB,IAAO,GAAGA,MAAS;AACzC,CAAC;AAkBM,IAAMowB,kBAAkB,GAAG,SAArBA,kBAAkBA,CAC7BC,MAAc,EAEqC;AAAA,EAAA,IADnD/d,kBAAkB,GAAAlU,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;AAEtBkU,EAAAA,kBAAkB,GAAGhE,GAAM,CAAC,KAAK,EAAEA,GAAM,CAACgE,kBAAkB,CAAC,CAAC;EAE9D,IAAI,CAACd,MAAM,CAAAhJ,KAAA,SAAAiJ,kBAAA,CAAI4e,MAAM,CAAA,CAAC,EAAE;IACtB,OAAOrwB,MAAS;AAClB,GAAC,MAAM,IAAImS,WAAW,CAACke,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE/d,kBAAkB,CAAC,EAAE;IAC1D,OAAOtS,OAAU;AACnB,GAAC,MAAM,IAAImS,WAAW,CAACke,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE/d,kBAAkB,CAAC,EAAE;IAC1D,OAAOtS,MAAS;AAClB,GAAC,MAAM,IAAImS,WAAW,CAACke,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE/d,kBAAkB,CAAC,EAAE;IAC3D,OAAOtS,MAAS;AAClB,GAAC,MAAM,IAAImS,WAAW,CAACke,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE/d,kBAAkB,CAAC,EAAE;IAC3D,OAAOtS,IAAO;AAChB;EAEA,OAAOA,WAAc;AACvB,CAAC;AAmHM,IAAMswB,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIC,SAAiB,EAAA;AAAA,EAAA,OAChDjiB,QAAW,CAACkiB,UAAU,EAAED,SAAS,CAAC;AAAA,CAAA;AAgB7B,IAAME,aAAa,GAAG,CAC3BzwB,IAAO,EACPA,MAAS,EACTA,MAAS,EACTA,OAAU,CACF;AAMH,IAAM0wB,YAAY,GAAG,CAAC1wB,IAAO,EAAEA,KAAQ,CAAU;AAMjD,IAAM2wB,iBAAiB,GAAAj1B,EAAAA,CAAAA,MAAA,CACzB+0B,aAAa,EAAA,CAChBzwB,MAAS,EACTA,WAAc,CACN,CAAA;AAMH,IAAMwwB,UAAU,GAAA,EAAA,CAAA90B,MAAA,CAClB+0B,aAAa,EACbC,YAAY,EACf1wB,CAAAA,MAAS,EACTA,WAAc,CACN,CAAA;AAIewF,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA,EAAA,EACtBxF,IAAO,EAAGA,MAAS,GACnBA,MAAS,EAAGA,IAAO,CACnBA,EAAAA,MAAS,EAAGA,OAAU,CACtBA,EAAAA,OAAU,EAAGA,MAAS,CAAA,EACtBA,IAAO,EAAGA,KAAQ,CAAA,EAClBA,KAAQ,EAAGA,IAAO,GAClBA,MAAS,EAAG,IAAI,CAChBA,EAAAA,WAAc,EAAG,IAAI;;ACjPjB,IAAM4wB,iBAAiB,GAAG,SAApBA,iBAAiBA,CAC5B3W,OAA2C,EAC3CvY,KAAY,EACT;AACH,EAAA,IAAI4M,UAAa,CAAC2L,OAAO,CAAC,EAAE;IAC1BA,OAAO,CAAC5Q,IAAI,CAAC3H,KAAK,CAACsJ,aAAa,IAAI5L,IAAI,EAAEsC,KAAK,CAAC;AAClD,GAAC,MAAM;AACLuY,IAAAA,OAAO,CAAC4W,WAAW,CAACxnB,IAAI,CAAC3H,KAAK,CAACsJ,aAAa,IAAI5L,IAAI,EAAEsC,KAAK,CAAC;AAC9D;AACF,CAAC;AAcM,IAAMovB,kBAAkB,GAAG,SAArBA,kBAAkBA,CAC7BrtB,MAAmB,EACnBstB,SAAiB,EACjB9W,OAA2C,EAE/B;AAAA,EAAA,IADZ/X,OAA0C,GAAA9D,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAE/C2yB,EAAAA,SAAS,GAAGC,kBAAkB,CAACD,SAAS,CAAC;EACzC,IAAIE,mBAAmB,CAACxtB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,EAAE/X,OAAO,CAAC,EAAE;AAE5D,IAAA,OAAO,KAAK;AACd;EAEA,IAAIgvB,QAAQ,GAAGhvB,OAAO;EACtB,IAAIivB,cAAc,GAAGlX,OAAO;AAI5B,EAAA,IAAMmX,QAAQ,GAAGC,iBAAiB,EAAE;AACpC,EAAA,IAAI/iB,cAAiB,CAACpM,OAAO,CAAC,EAAE;AAC9B,IAAA,IAAI,CAACkvB,QAAQ,CAACE,WAAW,EAAE;AAAA,MAAA,IAAAC,gBAAA;MACzBL,QAAQ,GAAA,CAAAK,gBAAA,GAAGrvB,OAAO,CAACsvB,OAAO,MAAA,IAAA,IAAAD,gBAAA,KAAA,MAAA,GAAAA,gBAAA,GAAI,KAAK;AACrC;IAEA,IAAIrvB,OAAO,CAACuvB,IAAI,IAAI,CAACL,QAAQ,CAAC5E,QAAQ,CAACiF,IAAI,EAAE;AAE3CN,MAAAA,cAAc,GAAG,SAAjBA,cAAcA,CAAIzvB,KAAK,EAAK;QAC1BgwB,uBAAuB,CAACjuB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,EAAE/X,OAAO,CAAC;AAC5D0uB,QAAAA,iBAAiB,CAAC3W,OAAO,EAAEvY,KAAK,CAAC;OAClC;AACH;AACF;EAEAiwB,mBAAmB,CAACluB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,EAAE/X,OAAO,EAAE;AACvD0vB,IAAAA,eAAe,EAAET,cAAc;AAC/BU,IAAAA,SAAS,EAAEX;AACb,GAAC,CAAC;EAEFztB,MAAM,CAACqlB,gBAAgB,CAACiI,SAAS,EAAEI,cAAc,EAAED,QAAQ,CAAC;AAC5D,EAAA,OAAO,IAAI;AACb,CAAC;AAiBM,IAAMQ,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAClCjuB,MAAmB,EACnBstB,SAAiB,EACjB9W,OAA2C,EAExC;AAAA,EAAA,IADH/X,OAA0C,GAAA9D,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAE/C2yB,EAAAA,SAAS,GAAGC,kBAAkB,CAACD,SAAS,CAAC;EACzC,IAAMe,IAAI,GAAGb,mBAAmB,CAACxtB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,EAAE/X,OAAO,CAAC;EAErE,IAAI,CAAC4vB,IAAI,EAAE;AACT,IAAA,OAAO,KAAK;AACd;AAEAruB,EAAAA,MAAM,CAACsuB,mBAAmB,CAAChB,SAAS,EAAEe,IAAI,CAACF,eAAe,EAAEE,IAAI,CAACD,SAAS,CAAC;EAC3EG,sBAAsB,CAACvuB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,EAAE/X,OAAO,CAAC;AAC3D,EAAA,OAAO,IAAI;AACb,CAAC;AAMM,IAAM+vB,aAAa,GAAG,SAAhBA,aAAaA,CAAIxuB,MAAmB,EAAK;EACpDqtB,kBAAkB,CAACrtB,MAAM,EAAEzD,aAAgB,EAAEsO,cAAiB,CAAC;AAC/D,EAAA,IAAIA,SAAY,CAAC7K,MAAM,CAAC,EAAE;AACxBoc,IAAAA,UAAU,CAACpc,MAAM,EAAEzD,gBAAmB,CAAC;AACzC;AACF,CAAC;AAMM,IAAMkyB,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIzuB,MAAmB,EAAK;EACxDiuB,uBAAuB,CAACjuB,MAAM,EAAEzD,aAAgB,EAAEsO,cAAiB,CAAC;AACpE,EAAA,IAAIA,SAAY,CAAC7K,MAAM,CAAC,EAAE;AACxBsc,IAAAA,aAAa,CAACtc,MAAM,EAAEzD,gBAAmB,CAAC;AAC5C;AACF,CAAC;AAMM,IAAMqxB,iBAAiB,GAAG,SAApBA,iBAAiBA,GAA8B;AAC1D,EAAA,IAAIc,mBAAmB,EAAE;AAEvB,IAAA,OAAOA,mBAAmB;AAC5B;AAEA,EAAA,IAAMf,QAAQ,GAAG;AACfgB,IAAAA,QAAQ,EAAE,KAAK;AACfd,IAAAA,WAAW,EAAE,KAAK;AAClB9E,IAAAA,QAAQ,EAAE;AACRgF,MAAAA,OAAO,EAAE,KAAK;AACda,MAAAA,OAAO,EAAE,KAAK;AACdZ,MAAAA,IAAI,EAAE,KAAK;AACXa,MAAAA,MAAM,EAAE;AACV;GACD;EAGD,IAAMC,OAAO,GAAG,EAAE;AAClB,EAAA,IAAIC,GAAmC;EAAC,IAAAC,KAAA,GAAAA,SAAAA,KAAAA,GACT;IAC7B,IAAMC,OAAO,GAAGF,GAAG;AACnBlkB,IAAAA,cAAiB,CAACikB,OAAO,EAAEG,OAAO,EAAE;AAClCtb,MAAAA,GAAG,EAAE,SAALA,GAAGA,GAAQ;AACTga,QAAAA,QAAQ,CAAC5E,QAAQ,CAACkG,OAAO,CAAC,GAAG,IAAI;QACjC,IAAIA,OAAO,KAAK,QAAQ,EAAE;AACxB,UAAA,OAAO,IAAIC,eAAe,EAAE,CAACL,MAAM;AACrC;AACA,QAAA,OAAO,KAAK;AACd;AACF,KAAC,CAAC;GACH;AAXD,EAAA,KAAKE,GAAG,IAAIpB,QAAQ,CAAC5E,QAAQ,EAAA;IAAAiG,KAAA,EAAA;AAAA;AAa7B,EAAA,IAAMG,YAAY,GAAG,SAAfA,YAAYA,GAAS,EAAE;AAC7B,EAAA,IAAMC,YAAY,GAAGvkB,aAAgB,CAAC,KAAK,CAAC;EAC5C,IAAI;IACFukB,YAAY,CAAC/J,gBAAgB,CAAC,mBAAmB,EAAE8J,YAAY,EAAEL,OAAO,CAAC;IACzEM,YAAY,CAACd,mBAAmB,CAC9B,mBAAmB,EACnBa,YAAY,EACZL,OACF,CAAC;IACDnB,QAAQ,CAACE,WAAW,GAAG,IAAI;AAC7B,GAAC,CAAC,OAAOwB,UAAU,EAAE;AAIrB1B,EAAAA,QAAQ,CAACgB,QAAQ,GAAG,aAAa,IAAIS,YAAY;AAEjDV,EAAAA,mBAAmB,GAAGf,QAAQ;AAC9B,EAAA,OAAOA,QAAQ;AACjB,CAAC;AASD,IAAIe,mBAAwC;AAE5C,IAAMY,0BAA0B,GAAGxJ,WAAW,CAY5CD,aAAa,CAACA,aAAa,CAAC,YAAA;AAAA,EAAA,OAAMhb,MAAS,EAAE;AAAA,CAAA,CAAC,CAAC,CAAC;AAclD,IAAM0kB,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtB9wB,OAA0C,EAC/B;AACX,EAAA,IAAM+wB,YAAqC,GAAG;AAC5CzB,IAAAA,OAAO,EAAE,KAAK;AACda,IAAAA,OAAO,EAAE,KAAK;AACdZ,IAAAA,IAAI,EAAE;GACP;AAED,EAAA,IAAIvvB,OAAO,KAAK,KAAK,IAAIA,OAAO,KAAK,IAAI,EAAE;IACzC+wB,YAAY,CAACzB,OAAO,GAAGtvB,OAAO;GAC/B,MAAM,IAAIoM,QAAW,CAACpM,OAAO,CAAC,EAAE;AAC/BiR,IAAAA,iBAAgB,CAACjR,OAAO,EAAE+wB,YAAY,CAAC;AACzC;AAEA,EAAA,OAAO3kB,SAAY,CAAC2kB,YAAY,CAAC;AACnC,CAAC;AAED,IAAMhC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CACvBxtB,MAAmB,EACnBstB,SAAiB,EACjB9W,OAA2C,EAC3C/X,OAA0C,EACvC;AAAA,EAAA,IAAAgxB,qBAAA;AACH,EAAA,IAAMC,UAAU,GAAGH,kBAAkB,CAAC9wB,OAAO,CAAC;AAC9C,EAAA,OAAA,CAAAgxB,qBAAA,GAAOH,0BAA0B,CAC9B3b,GAAG,CAAC3T,MAAM,CAAC,MAAAyvB,IAAAA,IAAAA,qBAAA,gBAAAA,qBAAA,GADPA,qBAAA,CAEH9b,GAAG,CAAC2Z,SAAS,CAAC,MAAAmC,IAAAA,IAAAA,qBAAA,gBAAAA,qBAAA,GAFXA,qBAAA,CAGH9b,GAAG,CAAC6C,OAAO,CAAC,MAAA,IAAA,IAAAiZ,qBAAA,KAHTA,MAAAA,GAAAA,MAAAA,GAAAA,qBAAA,CAIH9b,GAAG,CAAC+b,UAAU,CAAC;AACrB,CAAC;AAED,IAAMnB,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAC1BvuB,MAAmB,EACnBstB,SAAiB,EACjB9W,OAA2C,EAC3C/X,OAA0C,EACvC;AAAA,EAAA,IAAAkxB,sBAAA;AACH,EAAA,IAAMD,UAAU,GAAGH,kBAAkB,CAAC9wB,OAAO,CAAC;AAC9CoM,EAAAA,SAAY,CAAA8kB,CAAAA,sBAAA,GACVL,0BAA0B,CAAC3b,GAAG,CAAC3T,MAAM,CAAC,MAAA2vB,IAAAA,IAAAA,sBAAA,gBAAAA,sBAAA,GAAtCA,sBAAA,CAAwChc,GAAG,CAAC2Z,SAAS,CAAC,cAAAqC,sBAAA,KAAA,MAAA,GAAA,MAAA,GAAtDA,sBAAA,CAAwDhc,GAAG,CAAC6C,OAAO,CAAC,EACpEkZ,UACF,CAAC;EACDJ,0BAA0B,CAACnJ,KAAK,CAACnmB,MAAM,EAAEstB,SAAS,EAAE9W,OAAO,CAAC;AAC9D,CAAC;AAED,IAAM0X,mBAAmB,GAAG,SAAtBA,mBAAmBA,CACvBluB,MAAmB,EACnBstB,SAAiB,EACjB9W,OAA2C,EAC3C/X,OAA0C,EAC1C4vB,IAAsB,EACnB;AACH,EAAA,IAAMqB,UAAU,GAAGH,kBAAkB,CAAC9wB,OAAO,CAAC;EAC9C6wB,0BAA0B,CACvBpJ,IAAI,CAAClmB,MAAM,CAAC,CACZkmB,IAAI,CAACoH,SAAS,CAAC,CACfpH,IAAI,CAAC1P,OAAO,CAAC,CACbiC,GAAG,CAACiX,UAAU,EAAErB,IAAI,CAAC;AAC1B,CAAC;AAED,IAAMd,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAID,SAAiB,EAAK;AAChD,EAAA,IAAMK,QAAQ,GAAGC,iBAAiB,EAAE;AACpC,EAAA,IAAIN,SAAS,CAACsC,UAAU,CAACrzB,SAAY,CAAC,IAAI,CAACoxB,QAAQ,CAACgB,QAAQ,EAAE;AAG5D,IAAA,OAAO9jB,UAAa,CAACyiB,SAAS,EAAE/wB,SAAY,EAAEA,OAAU,CAAC;AAC3D;AAEA,EAAA,OAAO+wB,SAAS;AAClB,CAAC;;AC9PM,IAAMuC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,MAAc,EAAA;AAAA,EAAA,OAC/CjlB,QAAW,CAACklB,OAAO,EAAED,MAAM,CAAC;AAAA,CAAA;AAOvB,IAAME,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,MAAc,EAAA;AAAA,EAAA,OAC1CplB,QAAW,CAACqlB,OAAO,EAAED,MAAM,CAAC;AAAA,CAAA;AAwBvB,IAAME,SAAS,GAAG,SAAZA,SAASA,CAAIC,OAAe,EAAEC,SAAiB,EAAA;EAAA,OAC1DxlB,GAAM,CAACylB,WAAW,EAAEF,OAAO,GAAGC,SAAS,CAAC;AAAA,CAAA;AAMnC,IAAMN,OAAwB,GAAG,CACtCxzB,KAAQ,EACRA,SAAY,EACZA,OAAU,EACVA,OAAU,CACF;AAMH,IAAM2zB,OAAwB,GAAG,CACtC3zB,QAAW,EACXA,MAAS,EACTA,MAAS,EACTA,SAAY,CACJ;AAGV,IAAM+zB,WAAW,GAAG,GAAG;;AC3BhB,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAChCC,MAAgC,EAChC/xB,OAGC,EAC2B;AAAA,EAAA,IAAAgyB,qBAAA;AAC5B,EAAA,IAAI,CAAC5lB,gBAAmB,CAAC2lB,MAAM,CAAC,EAAE;IAChCA,MAAM,GAAG,CAACA,MAAM,CAAC;AACnB;AAEA,EAAA,IAAME,IAAI,GAAG9lB,QAAQ,CAAC8B,eAAe;AACrC,EAAA,IAAMikB,IAAI,GAAG/lB,QAAQ,CAACgC,eAAe;AACrC,EAAA,IAAMgkB,OAAO,GAAAH,CAAAA,qBAAA,GAAGhyB,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEoyB,YAAY,MAAAJ,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAIE,IAAI;AAE7C,EAAA,IAAMG,QAAQ,GAAG,SAAXA,QAAQA,CAAIC,MAAc,EAAA;AAAA,IAAA,OAAgB,CAAC,CAAC,EAAE,CAACA,MAAM,EAAE,CAAC,CAAC;AAAA,GAAA;AAC/D,EAAA,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAID,MAAc,EAAA;AAAA,IAAA,OAAgB,CAAC,CAAC,EAAEA,MAAM,EAAE,CAAC,CAAC;AAAA,GAAA;AAChE,EAAA,IAAME,UAAU,GAAG,SAAbA,UAAUA,CAAIF,MAAc,EAAA;AAAA,IAAA,OAAgB,CAAC,CAACA,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,GAAA;AACjE,EAAA,IAAMG,WAAW,GAAG,SAAdA,WAAWA,CAAIH,MAAc,EAAA;AAAA,IAAA,OAAgB,CAACA,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,GAAA;EACjE,IAAMI,QAAmB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;EACxC,IAAMC,SAAoB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;AAE7C,EAAA,IAAItE,SAAoB,GAAGvwB,MAAS;EACpC,IAAI0zB,MAA4B,GAAG,IAAI;EACvC,IAAIxD,MAAM,GAAG,CAAC;AACZC,IAAAA,MAAM,GAAG,CAAC;AACV2E,IAAAA,MAAM,GAAG,CAAC;AAAC,EAAA,IAAArc,SAAA,GAAAC,0BAAA,CAEOub,MAAM,CAAA;IAAAtb,KAAA;AAAA,EAAA,IAAA;IAA1B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA4B;AAAA,MAAA,IAAAkc,aAAA;AAAA,MAAA,IAAjBrzB,KAAK,GAAAiX,KAAA,CAAAnS,KAAA;AACd,MAAA,IAAI,CAAC8H,eAAkB,CAAC5M,KAAK,CAAC,IAAIA,KAAK,CAACupB,IAAI,KAAKjrB,SAAY,EAAE;AAC7D,QAAA;AACF;AAEA,MAAA,IAAMg1B,YAA8C,IAAAD,aAAA,GAAA,EAAA,EAAAvvB,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAuvB,aAAA,EACjDE,KAAK,EAAGV,QAAQ,CAACJ,IAAI,CAAC,CAAA,EACtBe,UAAU,EAAGX,QAAQ,CAACJ,IAAI,CAAC,CAAA,EAC3BgB,SAAS,EAAGZ,QAAQ,CAACH,IAAI,CAAC,CAAA,EAAA,MAAA,EACrBG,QAAQ,CAACF,OAAO,CAAC,CAAA,EACtBe,OAAO,EAAGX,UAAU,CAACN,IAAI,CAAC,CAC1BkB,EAAAA,YAAY,EAAGZ,UAAU,CAACN,IAAI,CAAC,CAC/BmB,EAAAA,WAAW,EAAGb,UAAU,CAACL,IAAI,CAAC,UAC1BK,UAAU,CAACJ,OAAO,CAAC,CACvBkB,EAAAA,OAAO,EAAGb,UAAU,CAACP,IAAI,CAAC,CAC1BqB,EAAAA,YAAY,EAAGd,UAAU,CAACP,IAAI,CAAC,GAAA3uB,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAuvB,aAAA,EAC/BU,QAAQ,EAAGd,WAAW,CAACR,IAAI,CAAC,CAC5BuB,EAAAA,aAAa,EAAGf,WAAW,CAACR,IAAI,CAAC,CAAA,EAClC,GAAG,EAAE,CAACzyB,KAAK,CAACi0B,QAAQ,GAAGpB,QAAQ,GAAGE,UAAU,EAAEL,IAAI,CAAC,CACnD,EAAA,GAAG,EAAEQ,QAAQ,CAAA,EACb,GAAG,EAAElzB,KAAK,CAACk0B,OAAO,GAAGhB,QAAQ,GAAG,IAAI,CAAA,EACpC,GAAG,EAAEC,SAAS,CACf,CAAA;MAED,IAAMgB,WAAW,GAAGb,YAAY,CAACtzB,KAAK,CAAC8J,GAAG,CAAC,IAAI,IAAI;MACnD,IAAI,CAACqqB,WAAW,EAAE;AAEhB,QAAA;AACF;AAEA,MAAA,IAAAC,YAAA,GAAAC,cAAA,CAA6CF,WAAW,EAAA,CAAA,CAAA;AAAjDG,QAAAA,UAAU,GAAAF,YAAA,CAAA,CAAA,CAAA;AAAEG,QAAAA,UAAU,GAAAH,YAAA,CAAA,CAAA,CAAA;AAAEI,QAAAA,UAAU,GAAAJ,YAAA,CAAA,CAAA,CAAA;AACzC,MAAA,IAAMK,UAAU,GAAGD,UAAU,KAAK,CAAC,GAAGl2B,MAAS,GAAGA,QAAW;AAE7DkwB,MAAAA,MAAM,IAAI8F,UAAU;AACpB7F,MAAAA,MAAM,IAAI8F,UAAU;AACpBnB,MAAAA,MAAM,GAAGlB,SAAS,CAACkB,MAAM,EAAEoB,UAAU,CAAC;MAEtC,IAAI,CAACxC,MAAM,EAAE;AACXA,QAAAA,MAAM,GAAGyC,UAAU;AACrB,OAAC,MAAM,IAAIzC,MAAM,KAAKyC,UAAU,EAAE;QAEhCzC,MAAM,GAAG1zB,SAAY;AACvB;AACF;AAAC,GAAA,CAAA,OAAA+Y,GAAA,EAAA;IAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAN,IAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;EAED,IAAI,CAACya,MAAM,EAAE;AACX,IAAA,OAAO,KAAK;AACd,GAAC,MAAM,IAAIA,MAAM,KAAK1zB,SAAY,EAAE;IAClCuwB,SAAS,GAAGvwB,WAAc;AAC5B,GAAC,MAAM,IAAI0zB,MAAM,KAAK1zB,MAAS,EAAE;AAC/BuwB,IAAAA,SAAS,GAAGuE,MAAM,GAAG,CAAC,GAAG90B,IAAO,GAAG80B,MAAM,GAAG,CAAC,GAAG90B,KAAQ,GAAGA,MAAS;AACtE,GAAC,MAAM;AACLuwB,IAAAA,SAAS,GAAGH,kBAAkB,CAC5B,CAACF,MAAM,EAAEC,MAAM,CAAC,EAChBjuB,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEoQ,kBACX,CAAC;AACH;AAEA,EAAA,OAAOie,SAAS,KAAKvwB,MAAS,GAC1B,KAAK,GACL;IACEuzB,MAAM,EAAEvzB,KAAQ;AAChBuwB,IAAAA,SAAS,EAATA,SAAS;AACTmD,IAAAA,MAAM,EAANA,MAAM;AACNxD,IAAAA,MAAM,EAANA,MAAM;AACNC,IAAAA,MAAM,EAANA,MAAM;AACN2E,IAAAA,MAAM,EAANA;GACD;AACP,CAAC;AAMD,IAAMG,KAAK,GAAG,IAAI;AAClB,IAAMG,OAAO,GAAG,MAAM;AACtB,IAAMG,OAAO,GAAG,MAAM;AACtB,IAAME,QAAQ,GAAG,OAAO;AACxB,IAAMW,OAAO,GAAG,MAAM;AACtB,IAAMC,QAAQ,GAAG,OAAO;AACxB,IAAMlB,SAAS,GAAIiB,OAAO,GAAGnB,KAA4C;AACzE,IAAMK,WAAW,GAAIc,OAAO,GAAGhB,OAAgD;AAC/E,IAAMF,UAAU,GAAImB,QAAQ,GAAGpB,KAA6C;AAC5E,IAAMI,YAAY,GAAIgB,QAAQ,GAC5BjB,OAAiD;AACnD,IAAMI,YAAY,GAAIa,QAAQ,GAC5Bd,OAAiD;AACnD,IAAMG,aAAa,GAAIW,QAAQ,GAC7BZ,QAAmD;;AC/J9C,IAAMa,yBAAyB,GAAG,SAA5BA,yBAAyBA,CACpCrC,MAAgC,EAChC/xB,OAEC,EACkC;AACnC,EAAA,IAAI,CAACoM,gBAAmB,CAAC2lB,MAAM,CAAC,EAAE;IAChCA,MAAM,GAAG,CAACA,MAAM,CAAC;AACnB;EAEA,IAAItP,WAAW,GAAG,KAAK;AACvB,EAAA,IAAMyM,QAAQ,GAAGC,iBAAiB,EAAE;EAIpC,IAAMkF,iBAAiB,GAAGnF,QAAQ,CAACgB,QAAQ,GAAGzuB,YAAY,GAAGD,UAAU;AACvE,EAAA,IAAM8yB,aAAa,GAAGpF,QAAQ,CAACgB,QAAQ,GAAGpyB,WAAc,GAAGA,SAAY;EAEvE,IAAMy2B,cAA4B,GAAGnoB,MAAS,CAC5C2lB,MAAM,EACN,UAACvyB,KAAK,EAA0B;AAC9B,IAAA,IAAMg1B,KAAK,GAAGh1B,KAAK,CAACupB,IAAI;AACxBtG,IAAAA,WAAW,GAAGA,WAAW,IAAI+R,KAAK,KAAK12B,eAAkB;AACzD,IAAA,IAAI02B,KAAK,KAAK12B,OAAU,IAAIsO,YAAe,CAAC5M,KAAK,EAAE60B,iBAAiB,CAAC,EAAE;MAIrE5R,WAAW,GACTA,WAAW,IACV+R,KAAK,KAAKF,aAAa,IAAI90B,KAAK,CAACi1B,OAAO,KAAK,CAAE,IAC/CD,KAAK,KAAKF,aAAa,IAAI90B,KAAK,CAACi1B,OAAO,KAAK,CAAE;AAElD,MAAA,OAAO,CAACroB,mBAAsB,CAAC5M,KAAK,CAAC;AACvC;AACA,IAAA,OAAO,KAAK;AACd,GACF,CAAC;AAED,EAAA,IAAMk1B,SAAS,GAAGtoB,QAAW,CAACmoB,cAAc,CAAC;EAC7C,IAAIG,SAAS,GAAG,CAAC,EAAE;AACjB,IAAA,OAAO,KAAK;AACd;AAEA,EAAA,IAAIjS,WAAW,EAAE;AACf,IAAA,OAAO,IAAI;AACb;AAEA,EAAA,IAAMkS,UAAU,GAAGJ,cAAc,CAAC,CAAC,CAAC;AACpC,EAAA,IAAMK,SAAS,GAAGL,cAAc,CAACG,SAAS,GAAG,CAAC,CAAC;AAC/C,EAAA,IAAItoB,cAAiB,CAACuoB,UAAU,CAAC,KAAKvoB,cAAiB,CAACwoB,SAAS,CAAC,EAAE;AAClE,IAAA,OAAO,IAAI;AACb;EAEA,IAAM5G,MAAM,GAAG4G,SAAS,CAACC,OAAO,GAAGF,UAAU,CAACE,OAAO;EACrD,IAAM5G,MAAM,GAAG2G,SAAS,CAACE,OAAO,GAAGH,UAAU,CAACG,OAAO;AACrD,EAAA,IAAMzG,SAAS,GAAGH,kBAAkB,CAClC,CAACF,MAAM,EAAEC,MAAM,CAAC,EAChBjuB,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEoQ,kBACX,CAAC;AAED,EAAA,OAAOie,SAAS,KAAKvwB,MAAS,GAC1B,KAAK,GACL;IACEuzB,MAAM,EAAEvzB,SAAY;AACpBuwB,IAAAA,SAAS,EAATA,SAAS;IACTmD,MAAM,EAAE1zB,MAAS;AACjBkwB,IAAAA,MAAM,EAANA,MAAM;AACNC,IAAAA,MAAM,EAANA,MAAM;AACN2E,IAAAA,MAAM,EAAE;GACT;AACP,CAAC;;ACtBM,IAAMmC,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAClChD,MAAe,EACf/xB,OAMC,EACkC;EAAA,IAAAg1B,qBAAA,EAAAC,qBAAA;AACnC,EAAA,IAAI,CAAC7oB,gBAAmB,CAAC2lB,MAAM,CAAC,EAAE;IAChCA,MAAM,GAAG,CAACA,MAAM,CAAC;AACnB;AAEA,EAAA,IAAImD,KAAK,GAAGC,YAAY,CAACpD,MAAM,EAAE/xB,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEo1B,cAAc,CAAC;EAEzD,IAAI,CAACF,KAAK,EAAE;AACV,IAAA,OAAO,IAAI;AACb;AAEA,EAAA,IAAIG,QAAQ,GAAGjpB,QAAW,CAAC8oB,KAAK,CAAC;AAEjC,EAAA,IAAMI,QAAQ,GAAGC,WAAW,CAACxD,MAAM,CAAC;AACpC,EAAA,IAAMyD,SAAS,GACbF,QAAQ,KAAAN,CAAAA,qBAAA,GAAKh1B,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEy1B,YAAY,cAAAT,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,GAAG,CAAC,IAC1CK,QAAQ,MAAAJ,CAAAA,qBAAA,GAAMj1B,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE01B,cAAc,MAAAT,IAAAA,IAAAA,qBAAA,cAAAA,qBAAA,GAAI,CAAC,CAAC;EAC7C,IAAM7kB,kBAAkB,GAAGpQ,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAEoQ,kBAAkB;AAEtD,EAAA,IAAI4d,MAAM,GAAGxe,YAAY,CAAAlJ,KAAA,CAAA,MAAA,EAAAiJ,kBAAA,CAAI2lB,KAAK,CAAC1rB,GAAG,CAAC,UAAChM,CAAC,EAAA;IAAA,OAAKA,CAAC,CAACwwB,MAAM;AAAA,GAAA,CAAC,CAAC,CAAA;AACxD,EAAA,IAAIC,MAAM,GAAGze,YAAY,CAAAlJ,KAAA,CAAA,MAAA,EAAAiJ,kBAAA,CAAI2lB,KAAK,CAAC1rB,GAAG,CAAC,UAAChM,CAAC,EAAA;IAAA,OAAKA,CAAC,CAACywB,MAAM;AAAA,GAAA,CAAC,CAAC,CAAA;EACxD,IAAI2E,MAAM,GAAG,CAAC;EAEd,IAAIyC,QAAQ,GAAG,CAAC,EAAE;IAEhBH,KAAK,GAAG9oB,MAAS,CAAC8oB,KAAK,EAAE,UAACS,CAAC,EAAA;MAAA,OAAKA,CAAC,CAACC,aAAa;KAAC,CAAA;AAChDP,IAAAA,QAAQ,GAAGjpB,QAAW,CAAC8oB,KAAK,CAAC;AAC/B;AAEA,EAAA,IAAI7G,SAAoB,GAAGvwB,MAAS;AACpC,EAAA,IAAI0zB,MAAqB,GAAG1zB,SAAY;EACxC,IAAIu3B,QAAQ,KAAK,CAAC,EAAE;AAElB,IAAA,IAAMQ,OAAe,GAAG,CAACX,KAAK,CAAC,CAAC,CAAC,CAAClH,MAAM,EAAEkH,KAAK,CAAC,CAAC,CAAC,CAACjH,MAAM,CAAC;AAC1D,IAAA,IAAM6H,OAAe,GAAG,CAACZ,KAAK,CAAC,CAAC,CAAC,CAAClH,MAAM,EAAEkH,KAAK,CAAC,CAAC,CAAC,CAACjH,MAAM,CAAC;IAI1D,IACE,CAACze,YAAY,CAAAlJ,KAAA,CAAA,MAAA,EAAIuvB,OAAO,CAAC,IACzB,CAACrmB,YAAY,CAAAlJ,KAAA,SAAIwvB,OAAO,CAAC,IACzBvlB,eAAe,CAACslB,OAAO,EAAEC,OAAO,EAAE1lB,kBAAkB,CAAC,EACrD;AAEA,MAAA,IAAM2lB,aAAa,GAAGvlB,eAAe,CACnC,CAAC0kB,KAAK,CAAC,CAAC,CAAC,CAACc,MAAM,EAAEd,KAAK,CAAC,CAAC,CAAC,CAACe,MAAM,CAAC,EAClC,CAACf,KAAK,CAAC,CAAC,CAAC,CAACc,MAAM,EAAEd,KAAK,CAAC,CAAC,CAAC,CAACe,MAAM,CACnC,CAAC;AAED,MAAA,IAAMC,WAAW,GAAG1lB,eAAe,CACjC,CAAC0kB,KAAK,CAAC,CAAC,CAAC,CAACiB,IAAI,EAAEjB,KAAK,CAAC,CAAC,CAAC,CAACkB,IAAI,CAAC,EAC9B,CAAClB,KAAK,CAAC,CAAC,CAAC,CAACiB,IAAI,EAAEjB,KAAK,CAAC,CAAC,CAAC,CAACkB,IAAI,CAC/B,CAAC;MAED/H,SAAS,GAAG0H,aAAa,GAAGG,WAAW,GAAGp4B,IAAO,GAAGA,KAAQ;MAC5D80B,MAAM,GAAGsD,WAAW,GAAGH,aAAa;MACpC/H,MAAM,GAAGC,MAAM,GAAG,CAAC;MACnBuD,MAAM,GAAG1zB,MAAS;AACpB;AACF;AAEA,EAAA,IAAMu4B,SAAS,GAAGb,SAAS,IAAIx1B,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,IAAAA,OAAO,CAAEs2B,aAAa,GAAG,CAAC,GAAG,EAAE;AAG9DtI,EAAAA,MAAM,GAAGqI,SAAS,GAAGrI,MAAM,GAAG,CAAC;AAC/BC,EAAAA,MAAM,GAAGoI,SAAS,GAAGpI,MAAM,GAAG,CAAC;AAE/B,EAAA,IAAII,SAAS,KAAKvwB,MAAS,EAAE;IAE3B,IAAIy4B,OAAO,GAAG,IAAI;AAAC,IAAA,IAAAhgB,SAAA,GAAAC,0BAAA,CAEH0e,KAAK,CAAA;MAAAze,KAAA;AAAA,IAAA,IAAA;MAArB,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAuB;AAAA,QAAA,IAAZnZ,CAAC,GAAAiZ,KAAA,CAAAnS,KAAA;QAEVktB,MAAM,GAAGgE,SAAS,GAAG13B,MAAS,GAAGA,QAAW;AAE5C,QAAA,IAAM04B,aAAa,GAAGtI,kBAAkB,CACtC,CAACmI,SAAS,GAAG74B,CAAC,CAACwwB,MAAM,EAAEqI,SAAS,GAAG74B,CAAC,CAACywB,MAAM,CAAC,EAC5C7d,kBACF,CAAC;AAED,QAAA,IAAIomB,aAAa,KAAK14B,MAAS,EAAE;AAC/B,UAAA;AACF;AAEA,QAAA,IAAIy4B,OAAO,EAAE;AACXlI,UAAAA,SAAS,GAAGmI,aAAa;AAC3B,SAAC,MAAM,IAAInI,SAAS,KAAKmI,aAAa,EAAE;UACtCnI,SAAS,GAAGvwB,WAAc;AAC1B,UAAA;AACF;AAEAy4B,QAAAA,OAAO,GAAG,KAAK;AACjB;AAAC,KAAA,CAAA,OAAA1f,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH;AAEA,EAAA,IAAIsX,SAAS,KAAKvwB,MAAS,EAAE;AAC3B,IAAA,IAAM24B,cAAc,GAAG1E,MAAM,CAAChtB,MAAM,CAACqH,YAAe,CAAC,CAAC2G,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAGlE,IAAA,OAAO3G,QAAW,CAACqqB,cAAc,KAAdA,IAAAA,IAAAA,cAAc,KAAdA,MAAAA,GAAAA,MAAAA,GAAAA,cAAc,CAAEC,OAAO,CAAC,GAAG,KAAK,GAAG,IAAI;AAC5D;EAEA,OAAO;IACLrF,MAAM,EAAEvzB,OAAU;AAClBuwB,IAAAA,SAAS,EAATA,SAAS;AACTmD,IAAAA,MAAM,EAANA,MAAM;AACNxD,IAAAA,MAAM,EAANA,MAAM;AACNC,IAAAA,MAAM,EAANA,MAAM;AACN2E,IAAAA,MAAM,EAANA;GACD;AACH,CAAC;AAiBM,IAAMuC,YAAY,GAAG,SAAfA,YAAYA,CACvBpD,MAAe,EAEQ;AAAA,EAAA,IADvBqD,cAAc,GAAAl5B,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC;EAIlB,IAAMy6B,cAAc,GAAG1P,OAAO,CAAkB,YAAA;AAAA,IAAA,OAAe,EAAE;GAAC,CAAA;AAAC,EAAA,IAAA0C,UAAA,GAAAnT,0BAAA,CAE/Cub,MAAM,CAAA;IAAAnI,MAAA;AAAA,EAAA,IAAA;IAA1B,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAA4B;AAAA,MAAA,IAAjBnX,KAAK,GAAAoqB,MAAA,CAAAtlB,KAAA;AACd,MAAA,IAAI,CAAC8H,YAAe,CAAC5M,KAAK,CAAC,EAAE;AAC3B,QAAA;AACF;AAEA,MAAA,IAAIA,KAAK,CAACupB,IAAI,KAAKjrB,aAAgB,EAAE;AACnC,QAAA,OAAO,IAAI;AACb;AAAC,MAAA,IAAAurB,UAAA,GAAA7S,0BAAA,CAEmBhX,KAAK,CAACk3B,OAAO,CAAA;QAAAnN,MAAA;AAAA,MAAA,IAAA;QAAjC,KAAAF,UAAA,CAAAlrB,CAAA,EAAAorB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAA3S,CAAA,EAAAC,EAAAA,IAAA,GAAmC;AAAA,UAAA,IAAxBigB,KAAK,GAAArN,MAAA,CAAAjlB,KAAA;UACdqyB,cAAc,CAAClP,IAAI,CAACmP,KAAK,CAACC,UAAU,CAAC,CAACnkB,IAAI,CAACkkB,KAAK,CAAC;AACnD;AAAC,OAAA,CAAA,OAAA/f,GAAA,EAAA;QAAAwS,UAAA,CAAAvS,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAwS,QAAAA,UAAA,CAAAtS,CAAA,EAAA;AAAA;AACH;AAAC,GAAA,CAAA,OAAAF,GAAA,EAAA;IAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAA8S,IAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;EAED,IAAMme,KAAkB,GAAG,EAAE;EAAC,IAAAlM,UAAA,GAAAxS,0BAAA,CAENmgB,cAAc,CAACpsB,MAAM,EAAE,CAAA;IAAA2e,MAAA;AAAA,EAAA,IAAA;IAA/C,KAAAF,UAAA,CAAA7qB,CAAA,EAAA+qB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAAtS,CAAA,EAAAC,EAAAA,IAAA,GAAiD;AAAA,MAAA,IAAtCmgB,SAAS,GAAA5N,MAAA,CAAA5kB,KAAA;AAClB,MAAA,IAAMyyB,QAAQ,GAAG3qB,QAAW,CAAC0qB,SAAS,CAAC;MACvC,IAAIC,QAAQ,GAAG,CAAC,EAAE;AAEhB,QAAA;AACF;AAEA,MAAA,IAAMC,UAAU,GAAGF,SAAS,CAAC,CAAC,CAAC;AAC/B,MAAA,IAAMG,SAAS,GAAGH,SAAS,CAACC,QAAQ,GAAG,CAAC,CAAC;AACzC,MAAA,IAAMf,MAAM,GAAGgB,UAAU,CAACnC,OAAO;AACjC,MAAA,IAAMoB,MAAM,GAAGe,UAAU,CAAClC,OAAO;AAEjC,MAAA,IAAMqB,IAAI,GAAGc,SAAS,CAACpC,OAAO;AAC9B,MAAA,IAAMuB,IAAI,GAAGa,SAAS,CAACnC,OAAO;AAE9B,MAAA,IAAM9G,MAAM,GAAGmI,IAAI,GAAGH,MAAM;AAC5B,MAAA,IAAM/H,MAAM,GAAGmI,IAAI,GAAGH,MAAM;MAE5B,IAAML,aAAa,GAAGtmB,MAAM,CAAC0e,MAAM,EAAEC,MAAM,CAAC,IAAImH,cAAc;MAG9DF,KAAK,CAACxiB,IAAI,CAAC;AACTsjB,QAAAA,MAAM,EAANA,MAAM;AACNC,QAAAA,MAAM,EAANA,MAAM;AACNE,QAAAA,IAAI,EAAJA,IAAI;AACJC,QAAAA,IAAI,EAAJA,IAAI;AACJpI,QAAAA,MAAM,EAANA,MAAM;AACNC,QAAAA,MAAM,EAANA,MAAM;AACN2H,QAAAA,aAAa,EAAbA;AACF,OAAC,CAAC;AACJ;AAAC,GAAA,CAAA,OAAA/e,GAAA,EAAA;IAAAmS,UAAA,CAAAlS,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAmS,IAAAA,UAAA,CAAAjS,CAAA,EAAA;AAAA;AAED,EAAA,OAAOme,KAAK;AACd,CAAC;AAID,IAAMK,WAAW,GAAG,SAAdA,WAAWA,CAAIxD,MAAe,EAAK;AACvC,EAAA,IAAMmF,UAAU,GAAGnF,MAAM,CAACoF,SAAS,CAAC,UAACrgB,CAAC,EAAA;AAAA,IAAA,OAAKA,CAAC,CAACiS,IAAI,KAAKjrB,YAAe;GAAC,CAAA;AACtE,EAAA,IAAMs5B,SAAS,GAAGrF,MAAM,CAACoF,SAAS,CAAC,UAACrgB,CAAC,EAAA;AAAA,IAAA,OAAKA,CAAC,CAACiS,IAAI,KAAKjrB,WAAc;GAAC,CAAA;AACpE,EAAA,IAAIo5B,UAAU,GAAG,CAAC,IAAIE,SAAS,GAAG,CAAC,EAAE;AACnC,IAAA,OAAO,CAAC;AACV;AAEA,EAAA,OAAOrF,MAAM,CAACqF,SAAS,CAAC,CAACC,SAAS,GAAGtF,MAAM,CAACmF,UAAU,CAAC,CAACG,SAAS;AACnE,CAAC;;ACnIM,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAI93B,KAAuB,EAAgB;EACpE,IAAI+3B,KAAK,GAAG,CAAC;AACXC,IAAAA,KAAK,GAAG,CAAC;IACTC,MAAM,GAAGj4B,KAAK,CAACwuB,MAAM;IACrB0J,MAAM,GAAGl4B,KAAK,CAACyuB,MAAM;AAEvB,EAAA,IAAMgE,IAAI,GAAG9lB,QAAQ,CAAC8B,eAAe;AAGrC,EAAA,IAAIzO,KAAK,CAACm4B,MAAM,KAAK/6B,SAAS,EAAE;IAC9B46B,KAAK,GAAGh4B,KAAK,CAACm4B,MAAM;AACtB;AACA,EAAA,IAAIn4B,KAAK,CAACo4B,UAAU,KAAKh7B,SAAS,EAAE;AAClC46B,IAAAA,KAAK,GAAG,CAACh4B,KAAK,CAACo4B,UAAU,GAAG,GAAG;AACjC;AACA,EAAA,IAAIp4B,KAAK,CAACq4B,WAAW,KAAKj7B,SAAS,EAAE;AACnC46B,IAAAA,KAAK,GAAG,CAACh4B,KAAK,CAACq4B,WAAW,GAAG,GAAG;AAClC;AACA,EAAA,IAAIr4B,KAAK,CAACs4B,WAAW,KAAKl7B,SAAS,EAAE;AACnC26B,IAAAA,KAAK,GAAG,CAAC/3B,KAAK,CAACs4B,WAAW,GAAG,GAAG;AAClC;EAEA,IAAI,CAACL,MAAM,IAAIC,MAAM,KAAKl4B,KAAK,CAACu4B,SAAS,EAAE;AACzC,IAAA,IAAIv4B,KAAK,CAACu4B,SAAS,KAAK,CAAC,EAAE;AAEzBN,MAAAA,MAAM,IAAIxF,IAAI;AACdyF,MAAAA,MAAM,IAAIzF,IAAI;AAChB,KAAC,MAAM;MAELwF,MAAM,IAAItrB,QAAQ,CAAC+B,cAAc;MACjCwpB,MAAM,IAAIvrB,QAAQ,CAACgC,eAAe;AACpC;AACF;AAGA,EAAA,IAAIspB,MAAM,IAAI,CAACF,KAAK,EAAE;IACpBA,KAAK,GAAGE,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;AAC7B;AACA,EAAA,IAAIC,MAAM,IAAI,CAACF,KAAK,EAAE;IACpBA,KAAK,GAAGE,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;AAC7B;EAEA,OAAO;AAAEH,IAAAA,KAAK,EAALA,KAAK;AAAEC,IAAAA,KAAK,EAALA,KAAK;AAAEC,IAAAA,MAAM,EAANA,MAAM;AAAEC,IAAAA,MAAM,EAANA;GAAQ;AACzC,CAAC;;AC7IM,IAAMM,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAClCjG,MAAgC,EAChC/xB,OAEC,EACkC;AACnC,EAAA,IAAI,CAACoM,gBAAmB,CAAC2lB,MAAM,CAAC,EAAE;IAChCA,MAAM,GAAG,CAACA,MAAM,CAAC;AACnB;AAEA,EAAA,IAAI1D,SAAoB,GAAGvwB,MAAS;EACpC,IAAI0zB,MAA4B,GAAG,IAAI;EACvC,IAAIxD,MAAM,GAAG,CAAC;AACZC,IAAAA,MAAM,GAAG,CAAC;AACV2E,IAAAA,MAAM,GAAG,CAAC;AAAC,EAAA,IAAArc,SAAA,GAAAC,0BAAA,CAEOub,MAAM,CAAA;IAAAtb,KAAA;AAAA,EAAA,IAAA;IAA1B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA4B;AAAA,MAAA,IAAjBnX,KAAK,GAAAiX,KAAA,CAAAnS,KAAA;AACd,MAAA,IAAI,CAAC8H,YAAe,CAAC5M,KAAK,CAAC,IAAIA,KAAK,CAACupB,IAAI,KAAKjrB,OAAU,EAAE;AACxD,QAAA;AACF;AAEA,MAAA,IAAM8xB,IAAI,GAAG0H,cAAc,CAAC93B,KAAK,CAAC;AAClC,MAAA,IAAIy0B,UAAyB,GAAGn2B,QAAW;AAC3C,MAAA,IAAIg2B,UAAU,GAAGlE,IAAI,CAAC6H,MAAM;AAC5B,MAAA,IAAI1D,UAAU,GAAGnE,IAAI,CAAC8H,MAAM;MAC5B,IAAI1D,UAAU,GAAG,CAAC;AAClB,MAAA,IAAMiE,QAAQ,GAAGzoB,YAAY,CAACskB,UAAU,EAAEC,UAAU,CAAC;AAErD,MAAA,IAAIv0B,KAAK,CAACk0B,OAAO,IAAI,CAACI,UAAU,EAAE;QAEhC,IAAIoE,UAAU,GAAG,CAACD,QAAQ;QAG1B,IAAI7rB,GAAM,CAAC8rB,UAAU,CAAC,IAAI,EAAE,EAAE;AAC5BA,UAAAA,UAAU,IAAI,EAAE;AAClB;AAEAlE,QAAAA,UAAU,GAAG,CAAC,GAAGkE,UAAU,GAAG,GAAG;QAEjCpE,UAAU,GAAGC,UAAU,GAAG,CAAC;QAC3BE,UAAU,GAAGn2B,MAAS;OACvB,MAAM,IAAI0B,KAAK,CAACi0B,QAAQ,IAAI,CAACK,UAAU,EAAE;AAGxCA,QAAAA,UAAU,GAAGC,UAAU;AACvBA,QAAAA,UAAU,GAAG,CAAC;AAChB;AAEA/F,MAAAA,MAAM,IAAI8F,UAAU;AACpB7F,MAAAA,MAAM,IAAI8F,UAAU;AACpBnB,MAAAA,MAAM,GAAGlB,SAAS,CAACkB,MAAM,EAAEoB,UAAU,CAAC;MAEtC,IAAI,CAACC,UAAU,EAAE,EAEhB,MAAM,IAAI,CAACzC,MAAM,EAAE;AAClBA,QAAAA,MAAM,GAAGyC,UAAU;AACrB,OAAC,MAAM,IAAIzC,MAAM,KAAKyC,UAAU,EAAE;QAEhCzC,MAAM,GAAG1zB,SAAY;AACvB;AACF;AAAC,GAAA,CAAA,OAAA+Y,GAAA,EAAA;IAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAN,IAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;EAED,IAAI,CAACya,MAAM,EAAE;AACX,IAAA,OAAO,KAAK;AACd,GAAC,MAAM,IAAIA,MAAM,KAAK1zB,SAAY,EAAE;IAClCuwB,SAAS,GAAGvwB,WAAc;AAC5B,GAAC,MAAM,IAAI0zB,MAAM,KAAK1zB,MAAS,EAAE;AAC/BuwB,IAAAA,SAAS,GAAGuE,MAAM,GAAG,CAAC,GAAG90B,IAAO,GAAG80B,MAAM,GAAG,CAAC,GAAG90B,KAAQ,GAAGA,MAAS;AACtE,GAAC,MAAM;AACLuwB,IAAAA,SAAS,GAAGH,kBAAkB,CAC5B,CAACF,MAAM,EAAEC,MAAM,CAAC,EAChBjuB,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEoQ,kBACX,CAAC;AACH;AAEA,EAAA,OAAOie,SAAS,KAAKvwB,MAAS,GAC1B,KAAK,GACL;IACEuzB,MAAM,EAAEvzB,OAAU;AAClBuwB,IAAAA,SAAS,EAATA,SAAS;AACTmD,IAAAA,MAAM,EAANA,MAAM;AACNxD,IAAAA,MAAM,EAANA,MAAM;AACNC,IAAAA,MAAM,EAANA,MAAM;AACN2E,IAAAA,MAAM,EAANA;GACD;AACP,CAAC;;ACzED,IAAauF,cAAc,GAAA,YAAA;AAyFzB,EAAA,SAAAA,cACElQ,CAAAA,MAAoC,EACpC3e,GAA2B,EAC3B;AAAA,IAAA,IAAA7M,KAAA,GAAA,IAAA;AAAAT,IAAAA,eAAA,OAAAm8B,cAAA,CAAA;IACA,IAAI7uB,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,uBAAuB,CAAC;AAC3D;IAMA,IAAMsc,YAAY,GAAGrB,WAAW,CAU9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;IAIpB,IAAMgsB,YAAY,GAAG/Q,WAAW,CAG9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;IAIpB,IAAM8d,cAAc,GAAG,SAAjBA,cAAcA,CAClB3oB,MAAmB,EACnBwW,OAAyB,EACzB/X,OAAiC,EACX;AAAA,MAAA,IAAAmqB,iBAAA;AACtB/d,MAAAA,MAAS,CAAA+d,CAAAA,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAA4oB,iBAAA,KAAA,MAAA,IAAA,CAAAA,iBAAA,GAAxBA,iBAAA,CAA0BjV,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,KAAtCA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAA,CAAwCC,SAAS,CAAC;MAG5D,IAAAiO,qBAAA,GAAgCC,qBAAqB,CACnDvgB,OAAO,EACP/X,OAEF,CAAC;QAJOoqB,SAAS,GAAAiO,qBAAA,CAATjO,SAAS;QAAEmO,QAAQ,GAAAF,qBAAA,CAARE,QAAQ;MAM3BnO,SAAS,CAAC/Q,QAAQ,CAAC,YAAA;AAAA,QAAA,OAAMgR,aAAa,CAAC9oB,MAAM,EAAEwW,OAAO,EAAE/X,OAAO,CAAC;OAAC,CAAA;MAEjE0oB,YAAY,CAACjB,IAAI,CAAClmB,MAAM,CAAC,CAACyY,GAAG,CAACjC,OAAO,EAAE;AACrCqS,QAAAA,SAAS,EAATA,SAAS;AACTmO,QAAAA,QAAQ,EAARA,QAAQ;AACRjO,QAAAA,QAAQ,EAAEtqB;AACZ,OAAC,CAAC;AAEF,MAAA,OAAOoqB,SAAS;KACjB;AAMD,IAAA,IAAMoO,cAAc,GAAA,YAAA;AAAA,MAAA,IAAAnpB,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAC,OACrB9W,CAAAA,MAAmB,EACnBwW,OAAyB,EACzByS,WAAyC,EAAA;QAAA,IAAAxqB,OAAA,EAAAuW,SAAA,EAAAE,KAAA,EAAAgiB,iBAAA,EAAApH,MAAA,EAAAqH,SAAA;AAAA,QAAA,OAAAvgB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;cAEnC1Y,OAAO,GAAG8qB,YAAU,CAAC7C,MAAM,EAAEuC,WAAW,IAAI,EAAE,CAAC;AACrDN,cAAAA,cAAc,CAAC3oB,MAAM,EAAEwW,OAAO,EAAE/X,OAAO,CAAC;AAACuW,cAAAA,SAAA,GAAAC,0BAAA,CAEpBxW,OAAO,CAAC24B,QAAQ,IAAIrH,OAAO,CAAA;AAAA,cAAA,IAAA;gBAAhD,KAAA/a,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAkD;kBAAvC0a,MAAM,GAAA5a,KAAA,CAAAnS,KAAA;AACXo0B,kBAAAA,SAAS,IAAAD,iBAAA,GAAGL,YAAY,CAACljB,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAAk3B,iBAAA,KAAxBA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,iBAAA,CAA0BvjB,GAAG,CAACmc,MAAM,CAAC;AACrD,kBAAA,IAAIqH,SAAS,EAAE;AAMf,mBAAC,MAAM;oBAOLA,SAAS,GAAGE,cAAc,CAACr3B,MAAM,EAAE8vB,MAAM,EAAErxB,OAAO,CAAC;oBACnDo4B,YAAY,CAAC3Q,IAAI,CAAClmB,MAAM,CAAC,CAACyY,GAAG,CAACqX,MAAM,EAAEqH,SAAS,CAAC;AAClD;kBAEAA,SAAS,CAACG,WAAW,EAAE;kBACvB,IAAI74B,OAAO,CAAC84B,eAAe,EAAE;oBAC3BJ,SAAS,CAACK,gBAAgB,EAAE;AAC9B;AACF;AAAC,eAAA,CAAA,OAAAliB,GAAA,EAAA;gBAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,eAAA,SAAA;AAAAN,gBAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAyB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OACF,CAAA,CAAA;AAAA,MAAA,OAAA,SAhCKmgB,cAAcA,CAAA7d,EAAA,EAAAyC,GAAA,EAAAC,GAAA,EAAA;AAAA,QAAA,OAAAhO,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAgCnB,EAAA;IAID,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CACjB9oB,MAAmB,EACnBwW,OAAyB,EACzB/X,OAAiC,EAC9B;MACHoM,SAAY,CAACsc,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,EAAEwW,OAAO,CAAC;AAC/C2Q,MAAAA,YAAY,CAAChB,KAAK,CAACnmB,MAAM,CAAC;MAAC,IAAAooB,UAAA,GAAAnT,0BAAA,CAENxW,OAAO,CAAC24B,QAAQ,IAAIrH,OAAO,CAAA;QAAA1H,MAAA;AAAA,MAAA,IAAA;QAAhD,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAAkD;AAAA,UAAA,IAAAqiB,kBAAA;AAAA,UAAA,IAAvC3H,MAAM,GAAAzH,MAAA,CAAAtlB,KAAA;AACf,UAAA,IAAMo0B,SAAS,GAAAM,CAAAA,kBAAA,GAAGZ,YAAY,CAACljB,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAAy3B,kBAAA,KAAxBA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,kBAAA,CAA0B9jB,GAAG,CAACmc,MAAM,CAAC;AACvD,UAAA,IAAIqH,SAAS,EAAE;YACbA,SAAS,CAACG,WAAW,EAAE;YACvB,IAAI74B,OAAO,CAAC84B,eAAe,EAAE;cAC3BJ,SAAS,CAACK,gBAAgB,EAAE;AAC9B;AAEA,YAAA,IAAI,CAACL,SAAS,CAACG,WAAW,EAAE;cAM1BzsB,SAAY,CAACgsB,YAAY,CAACljB,GAAG,CAAC3T,MAAM,CAAC,EAAE8vB,MAAM,CAAC;cAC9CqH,SAAS,CAACO,OAAO,EAAE;AACrB;AACF;AACF;AAAC,OAAA,CAAA,OAAApiB,GAAA,EAAA;QAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAA8S,QAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;KACF;IAID,IAAMmiB,eAAe,GAAG,SAAlBA,eAAeA,CACnB33B,MAAmB,EACnB8vB,MAAqB,EACrB7xB,KAAY,EACyB;MAAA,IAAA25B,kBAAA,EAAA1M,kBAAA;AACrC,MAAA,IAAM/mB,cAAc,GAClB,CAAC,CAAA,CAAAyzB,kBAAA,GAAAf,YAAY,CAACljB,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAA43B,kBAAA,KAAAA,MAAAA,IAAAA,CAAAA,kBAAA,GAAxBA,kBAAA,CAA0BjkB,GAAG,CAACmc,MAAM,CAAC,MAAA8H,IAAAA,IAAAA,kBAAA,KAArCA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAAuCJ,gBAAgB,KAAI,CAAC,IAAI,CAAC;MAEpE,IAAIK,YAAY,GAAG,KAAK;MAAC,IAAApQ,UAAA,GAAAxS,0BAAA,CACE,EAAAiW,kBAAA,GAAA/D,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAAkrB,kBAAA,KAAxBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA0BliB,MAAM,EAAE,KAAI,EAAE,CAAA;QAAA2e,MAAA;AAAA,MAAA,IAAA;QAAnE,KAAAF,UAAA,CAAA7qB,CAAA,EAAA+qB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAAtS,CAAA,EAAAC,EAAAA,IAAA,GAAqE;AAAA,UAAA,IAAxD4hB,QAAQ,GAAArP,MAAA,CAAA5kB,KAAA,CAARi0B,QAAQ;AACnBa,UAAAA,YAAY,GACVb,QAAQ,CAACh3B,MAAM,EAAE8vB,MAAM,EAAE7xB,KAAK,EAAEkG,cAAc,CAAC,IAAI0zB,YAAY;AACnE;AAAC,OAAA,CAAA,OAAAviB,GAAA,EAAA;QAAAmS,UAAA,CAAAlS,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAmS,QAAAA,UAAA,CAAAjS,CAAA,EAAA;AAAA;AAED,MAAA,OAAOqiB,YAAY;KACpB;IAID,IAAMR,cAAc,GAAG,SAAjBA,cAAcA,CAClBr3B,MAAmB,EACnB8vB,MAAqB,EACrBrxB,OAAiC,EACb;AACpB,MAAA,IAAMq5B,OAAO,GAAGr5B,OAAO,CAACs5B,QAAQ;MAChC,IAAIC,gBAAgB,GAAG,KAAK;MAC5B,IAAIC,kBAAkB,GAAG,KAAK;MAE9B,IACEnI,MAAM,KAAKvzB,KAAQ,IACnBsO,SAAY,CAAC7K,MAAM,CAAC,IACpB,CAAC6K,WAAc,CAAC7K,MAAM,CAAC,EACvB;AACAg4B,QAAAA,gBAAgB,GAAG,IAAI;AAEvBntB,QAAAA,WAAc,CAAC7K,MAAM,CAAC;AACxB,OAAC,MAAM,IAAI6K,SAAY,CAAC7K,MAAM,CAAC,IAAI8vB,MAAM,KAAKvzB,OAAU,EAAE;QACxD,IAAIkC,OAAO,CAAC84B,eAAe,EAAE;AAC3Bnb,UAAAA,UAAU,CAACpc,MAAM,EAAEzD,sBAAyB,CAAC;AAC/C;AAEA,QAAA,IAAI,CAACu7B,OAAO,IAAIjtB,QAAW,CAACitB,OAAO,EAAEv7B,MAAS,CAAC,EAAE;AAC/C07B,UAAAA,kBAAkB,GAAG,IAAI;UACzBzJ,aAAa,CAACxuB,MAAM,CAAC;AACvB;AACF;MAEA,IAAMk4B,oBAAoB,GAAG,SAAvBA,oBAAoBA,CACxBC,MAAwB,EACxBC,QAAuB,EACvBC,UAA0D,EACvD;QACH,IAAMC,MAAM,GACVH,MAAM,KAAK,KAAK,GAAG9K,kBAAkB,GAAGY,uBAAuB;AAAC,QAAA,IAAAnG,UAAA,GAAA7S,0BAAA,CAC1CojB,UAAU,CAAA;UAAArQ,MAAA;AAAA,QAAA,IAAA;UAAlC,KAAAF,UAAA,CAAAlrB,CAAA,EAAAorB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAA3S,CAAA,EAAAC,EAAAA,IAAA,GAAoC;AAAA,YAAA,IAAzBkY,SAAS,GAAAtF,MAAA,CAAAjlB,KAAA;AAElBu1B,YAAAA,MAAM,CAACt4B,MAAM,EAAEstB,SAAS,EAAE8K,QAAQ,EAAE;AAClCxJ,cAAAA,OAAO,EAAE,KAAK;AACdb,cAAAA,OAAO,EAAE;AACX,aAAC,CAAC;AACJ;AAAC,SAAA,CAAA,OAAAzY,GAAA,EAAA;UAAAwS,UAAA,CAAAvS,CAAA,CAAAD,GAAA,CAAA;AAAA,SAAA,SAAA;AAAAwS,UAAAA,UAAA,CAAAtS,CAAA,EAAA;AAAA;OACF;AAED,MAAA,IAAM+iB,kBAAkB,GAAG,SAArBA,kBAAkBA,GAAA;QAAA,OACtBL,oBAAoB,CAAC,KAAK,EAAEM,eAAe,EAAEC,gBAAgB,CAAC3I,MAAM,CAAC,CAAC;AAAA,OAAA;AAExE,MAAA,IAAM4I,qBAAqB,GAAG,SAAxBA,qBAAqBA,GAAA;QAAA,OACzBR,oBAAoB,CAClB,QAAQ,EACRM,eAAe,EACfC,gBAAgB,CAAC3I,MAAM,CACzB,CAAC;AAAA,OAAA;AAEH,MAAA,IAAM6I,kBAAkB,GAAG,SAArBA,kBAAkBA,GAAA;QAAA,OACtBT,oBAAoB,CAAC,KAAK,EAAEU,YAAY,EAAEC,aAAa,CAAC/I,MAAM,CAAC,CAAC;AAAA,OAAA;AAElE,MAAA,IAAMgJ,qBAAqB,GAAG,SAAxBA,qBAAqBA,GAAA;QAAA,OACzBZ,oBAAoB,CAAC,QAAQ,EAAEU,YAAY,EAAEC,aAAa,CAAC/I,MAAM,CAAC,CAAC;AAAA,OAAA;AAErE,MAAA,IAAM0I,eAAe,GAAG,SAAlBA,eAAeA,CAAIv6B,KAAY,EAAK;QACxC26B,YAAY,CAAC36B,KAAK,CAAC;AACnBy6B,QAAAA,qBAAqB,EAAE;AACvBC,QAAAA,kBAAkB,EAAE;OACrB;AAED,MAAA,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAI36B,KAAY,EAAK;QACrC,IAAM45B,YAAY,GAAGF,eAAe,CAAC33B,MAAM,EAAE8vB,MAAM,EAAE7xB,KAAK,CAAC;AAC3D,QAAA,IAAI45B,YAAY,EAAE;AAChBiB,UAAAA,qBAAqB,EAAE;AACvBP,UAAAA,kBAAkB,EAAE;AACtB;OACD;AAEDA,MAAAA,kBAAkB,EAAE;MAEpB,OAAO;AACLjB,QAAAA,WAAW,EAAE,CAAC;AACdE,QAAAA,gBAAgB,EAAE,CAAC;AACnBE,QAAAA,OAAO,EAAE,SAATA,OAAOA,GAAQ;AACb,UAAA,IAAI7sB,SAAY,CAAC7K,MAAM,CAAC,EAAE;AACxB,YAAA,IAAIg4B,gBAAgB,EAAE;AACpBntB,cAAAA,aAAgB,CAAC7K,MAAM,CAAC;AAC1B;AAEAsc,YAAAA,aAAa,CAACtc,MAAM,EAAEzD,sBAAyB,CAAC;AAEhD,YAAA,IAAI07B,kBAAkB,EAAE;cACtBxJ,iBAAiB,CAACzuB,MAAM,CAAC;AAC3B;AACF;AAEA84B,UAAAA,qBAAqB,EAAE;AACvBJ,UAAAA,qBAAqB,EAAE;AACzB;OACD;KACF;IAID,IAAI,CAACK,YAAY,GAAG,UAAC9xB,OAAO,EAAEuP,OAAQ,EAAE/X,OAAQ,EAAK;MACnD,IAAI,CAAC+X,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAGwiB,kBAAkB;AAAC,QAAA,IAAA/O,UAAA,GAAAhV,0BAAA,CAERib,OAAO,CAAA;UAAAhG,MAAA;AAAA,QAAA,IAAA;UAA5B,KAAAD,UAAA,CAAArtB,CAAA,EAAAstB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAA9U,CAAA,EAAAC,EAAAA,IAAA,GAA8B;AAAA,YAAA,IAAnB6a,MAAM,GAAA/F,MAAA,CAAAnnB,KAAA;YACfi2B,kBAAkB,CAAC/xB,OAAO,EAAE;AAC1BgpB,cAAAA,MAAM,EAANA,MAAM;AACNgJ,cAAAA,WAAW,EAAE,CAAC;AACdC,cAAAA,WAAW,EAAE,CAAC;AACdC,cAAAA,WAAW,EAAE;AACf,aAAC,CAAC;AACJ;AAAC,SAAA,CAAA,OAAA7jB,GAAA,EAAA;UAAA2U,UAAA,CAAA1U,CAAA,CAAAD,GAAA,CAAA;AAAA,SAAA,SAAA;AAAA2U,UAAAA,UAAA,CAAAzU,CAAA,EAAA;AAAA;AACH;AAEA,MAAA,OAAOyhB,cAAc,CAAChwB,OAAO,EAAEuP,OAAO,EAAE/X,OAAO,CAAC;KACjD;AAID,IAAA,IAAI,CAAC26B,cAAc,GAAG,UAACnyB,OAAO,EAAEuP,OAAQ,EAAK;MAC3C,IAAI,CAACA,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAGwiB,kBAAkB;AAAC,QAAA,IAAA3O,UAAA,GAAApV,0BAAA,CAGRib,OAAO,CAAA;UAAA5F,MAAA;AAAA,QAAA,IAAA;UAA5B,KAAAD,UAAA,CAAAztB,CAAA,EAAA0tB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAlV,CAAA,EAAAC,EAAAA,IAAA,GAA8B;AAAA,YAAA,IAAnB6a,MAAM,GAAA3F,MAAA,CAAAvnB,KAAA;YACfi2B,kBAAkB,CAAC/xB,OAAO,EAAE;AAAEgpB,cAAAA,MAAM,EAANA;AAAO,aAAC,CAAC;AACzC;AAAC,SAAA,CAAA,OAAA3a,GAAA,EAAA;UAAA+U,UAAA,CAAA9U,CAAA,CAAAD,GAAA,CAAA;AAAA,SAAA,SAAA;AAAA+U,UAAAA,UAAA,CAAA7U,CAAA,EAAA;AAAA;AACH;AAEAta,MAAAA,KAAI,CAACm+B,UAAU,CAACpyB,OAAO,EAAEuP,OAAO,CAAC;KAClC;IAID,IAAI,CAAC8iB,SAAS,GAAGrC,cAAc;AAI/B,IAAA,IAAI,CAACoC,UAAU,GAAG,UAACr5B,MAAM,EAAEwW,OAAO,EAAK;AAAA,MAAA,IAAA+iB,kBAAA;AAErC1uB,MAAAA,MAAS,CAAA0uB,CAAAA,kBAAA,GAACpS,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,MAAA,IAAA,IAAAu5B,kBAAA,KAAA,MAAA,IAAA,CAAAA,kBAAA,GAAxBA,kBAAA,CAA0B5lB,GAAG,CAAC6C,OAAO,CAAC,MAAA+iB,IAAAA,IAAAA,kBAAA,KAAtCA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAAwC1Q,SAAS,CAAC;KAC7D;AACH;EAAC,OAAAhuB,YAAA,CAAA+7B,cAAA,EAAA,IAAA,EAAA,CAAA;IAAA7uB,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA1TD,SAAOyQ,MAAMA,GAAoC;AAAA,MAAA,IAAnCkT,MAA4B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC7C,OAAO,IAAIi8B,cAAc,CAACzL,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC/D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAoC;AAAA,MAAA,IAAnC1E,MAA4B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAC5C,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC8Y,QAAQ,CAAC;AAE1C,MAAA,IAAIE,QAAQ,GAAGC,WAAS,CAAC9X,GAAG,CAAC4X,YAAY,CAAC;MAC1C,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAIoL,cAAc,CAACtL,QAAQ,EAAE3E,iBAAe,CAAC;AACxD8E,QAAAA,WAAS,CAAChT,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AACvC;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AAqpBH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG5gB,MAAS,EAA0B;AAErD,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CACbzE,MAA4B,EACK;AAAA,EAAA,IAAA8S,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;EACjC,OAAO;IACLpC,eAAe,EAAA,CAAAiC,qBAAA,GAAE9S,MAAM,CAACviB,cAAc,MAAA,IAAA,IAAAq1B,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,IAAI;IAC9CI,eAAe,EAAEpsB,WAAW,CAACkZ,MAAM,CAACnqB,iBAAoB,CAAC,EAAE,GAAG,CAAC;IAC/Ds9B,eAAe,EAAErsB,WAAW,CAACkZ,MAAM,CAACmN,cAAc,EAAE,CAAC,CAAC;IACtDiG,mBAAmB,EAAErsB,QAAQ,CAACiZ,MAAM,CAAC7X,kBAAkB,EAAE,EAAE,CAAC;IAC5DkrB,mBAAmB,EAAA,CAAAN,qBAAA,GAAE/S,MAAM,CAACsT,kBAAkB,MAAA,IAAA,IAAAP,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,IAAI;IACtDQ,kBAAkB,EAAA,CAAAP,qBAAA,GAAEhT,MAAM,CAACwT,iBAAiB,MAAA,IAAA,IAAAR,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,GAAG;IACnDS,oBAAoB,EAAA,CAAAR,qBAAA,GAAEjT,MAAM,CAAC0T,mBAAmB,MAAAT,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAI;GACrD;AACH,CAAC;AAED,IAAMlB,gBAEL,GAAG;AACF1wB,EAAAA,GAAG,EAAE,CAACxL,SAAY,CAAC;EAOnB89B,OAAO,EAAE,CAAC99B,aAAgB,EAAEA,OAAU,CAAC;AACvC84B,EAAAA,KAAK,EAAE,CAAC94B,YAAe,CAAC;AACxB+9B,EAAAA,KAAK,EAAE,CAAC/9B,OAAU;AACpB,CAAU;AAEV,IAAMs8B,aAEL,GAAG;AACF9wB,EAAAA,GAAG,EAAE,CAACxL,SAAY,CAAC;EACnB89B,OAAO,EAAE,CAGP99B,aAAgB,EAChBA,WAAc,EACdA,aAAgB,EAChBA,eAAkB,EAClBA,OAAU,CACX;AACD84B,EAAAA,KAAK,EAAE,CAAC94B,YAAe,EAAEA,UAAa,EAAEA,WAAc,EAAEA,aAAgB,CAAC;AACzE+9B,EAAAA,KAAK,EAAE,CAAC/9B,OAAU;AACpB,CAAU;AAEV,IAAMg+B,eAWL,GAAAx4B,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CACExF,EAAAA,EAAAA,KAAQ,EAAGg0B,qBAAqB,CAAA,EAChCh0B,SAAY,EAAGs2B,yBAAyB,CAAA,EACxCt2B,OAAU,EAAGi3B,uBAAuB,GACpCj3B,OAAU,EAAGk6B,uBAAuB,CACtC;AAED,IAAMlN,YAAU,GAAG,SAAbA,UAAUA,CACd7C,MAAoC,EACpCjoB,OAAyB,EACI;AAAA,EAAA,IAAA+7B,qBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;AAC7B,EAAA,IAAM1kB,cAAc,GAAG/I,WAAW,CAChC/O,OAAO,CAAClC,iBAAoB,CAAC,EAC7BmqB,MAAM,CAACkT,eACT,CAAC;EACD,IAAM/F,cAAc,GAAGrmB,WAAW,CAChC/O,OAAO,CAACo1B,cAAc,EACtBnN,MAAM,CAACmT,eACT,CAAC;EAED,OAAO;AACLzC,IAAAA,QAAQ,EACNrkB,eAAe,CAAC,SAAS,EAAEtU,OAAO,CAACy8B,OAAO,EAAErL,kBAAkB,CAAC,IAAI,IAAI;AACzEsL,IAAAA,WAAW,EACTpoB,eAAe,CAAC,YAAY,EAAEtU,OAAO,CAAC28B,UAAU,EAAEvO,gBAAgB,CAAC,IACnE,IAAI;AACNkL,IAAAA,QAAQ,EACNhlB,eAAe,CAAC,SAAS,EAAEtU,OAAO,CAACq5B,OAAO,EAAE9H,aAAa,CAAC,IAAI,IAAI;IACpEqL,eAAe,EAAA,CAAAb,qBAAA,GAAE/7B,OAAO,CAAC68B,cAAc,MAAA,IAAA,IAAAd,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,IAAI;IAC/Ce,eAAe,EAAA,CAAAd,qBAAA,GAAEh8B,OAAO,CAAC+8B,cAAc,MAAA,IAAA,IAAAf,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI,IAAI;IAC/CgB,eAAe,EAAA,CAAAf,sBAAA,GAAEj8B,OAAO,CAACi9B,cAAc,MAAA,IAAA,IAAAhB,sBAAA,KAAA,MAAA,GAAAA,sBAAA,GAAI,IAAI;IAC/CiB,eAAe,EAAA,CAAAhB,sBAAA,GAAEl8B,OAAO,CAACm9B,cAAc,MAAA,IAAA,IAAAjB,sBAAA,KAAA,MAAA,GAAAA,sBAAA,GAAI,IAAI;IAC/CkB,eAAe,EAAA,CAAAjB,sBAAA,GAAEn8B,OAAO,CAACq9B,cAAc,MAAA,IAAA,IAAAlB,sBAAA,KAAA,MAAA,GAAAA,sBAAA,GAAI,IAAI;IAC/CmB,eAAe,EAAA,CAAAlB,sBAAA,GAAEp8B,OAAO,CAACu9B,cAAc,MAAA,IAAA,IAAAnB,sBAAA,KAAA,MAAA,GAAAA,sBAAA,GAAI,IAAI;AAC/CtD,IAAAA,eAAe,EAAAuD,CAAAA,qBAAA,GAAEr8B,OAAO,CAAC0F,cAAc,MAAA22B,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAIpU,MAAM,CAAC6Q,eAAe;AACjEqC,IAAAA,eAAe,EAAErjB,cAAc;AAC/BsjB,IAAAA,eAAe,EAAEhG,cAAc;IAC/BiG,mBAAmB,EAAEtsB,WAAW,CAC9B/O,OAAO,CAACoQ,kBAAkB,EAC1B6X,MAAM,CAACoT,mBACT,CAAC;AACDC,IAAAA,mBAAmB,EAAAgB,CAAAA,qBAAA,GACjBt8B,OAAO,CAACu7B,kBAAkB,MAAAe,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAIrU,MAAM,CAACqT,mBAAmB;AAC1DE,IAAAA,kBAAkB,EAAAe,CAAAA,qBAAA,GAAEv8B,OAAO,CAACy7B,iBAAiB,MAAAc,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAItU,MAAM,CAACuT,kBAAkB;AAC1EE,IAAAA,oBAAoB,EAAAc,CAAAA,qBAAA,GAClBx8B,OAAO,CAAC27B,mBAAmB,MAAAa,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAIvU,MAAM,CAACyT;GACzC;AACH,CAAC;AAKD,IAAMpD,qBAAqB,GAAG,SAAxBA,qBAAqBA,CACzBvgB,OAAyB,EACzB/X,OAAiC,EACjCw9B,MAA8B,EAC0C;EACxE,IAAIhD,WAAW,GAAG,CAAC;AACjBC,IAAAA,WAAW,GAAG,CAAC;AACfC,IAAAA,WAAW,GAAG,CAAC;EAKjB,IAAI+C,gBAAgB,GAAG,KAAK;AAE5B,EAAA,IAAMd,UAAU,GAAG38B,OAAO,CAAC08B,WAAW;AACtC,EAAA,IAAMrD,OAAO,GAAGr5B,OAAO,CAACs5B,QAAQ;AAChC,EAAA,IAAMuD,cAAc,GAAG78B,OAAO,CAAC48B,eAAe;AAC9C,EAAA,IAAMG,cAAc,GAAG/8B,OAAO,CAAC88B,eAAe;AAC9C,EAAA,IAAMG,cAAc,GAAGj9B,OAAO,CAACg9B,eAAe;AAC9C,EAAA,IAAMG,cAAc,GAAGn9B,OAAO,CAACk9B,eAAe;AAC9C,EAAA,IAAMG,cAAc,GAAGr9B,OAAO,CAACo9B,eAAe;AAC9C,EAAA,IAAMG,cAAc,GAAGv9B,OAAO,CAACs9B,eAAe;AAC9C,EAAA,IAAMlI,cAAc,GAAGp1B,OAAO,CAACo7B,eAAe;AAC9C,EAAA,IAAMhrB,kBAAkB,GAAGpQ,OAAO,CAACq7B,mBAAmB;AACtD,EAAA,IAAM/E,aAAa,GAAG,CAACt2B,OAAO,CAACs7B,mBAAmB;AAClD,EAAA,IAAM7F,YAAY,GAAGz1B,OAAO,CAACw7B,kBAAkB;AAC/C,EAAA,IAAM9F,cAAc,GAAG11B,OAAO,CAAC07B,oBAAoB;EAKnD,IAAMgC,UAAmB,GAAG,EAAE;AAC9B,EAAW1qB,MAAM;AAMjB,EAAA,IAAMpI,QAAQ,GAAGkO,aAAY,CAACf,OAAO,CAAC;AAQtC,EAAA,IAAM4lB,gBAAgB,GAAG9lB,mBAAmB,CAC1C7X,OAAO,CAACm7B,eAAe,EACvB,UACE55B,MAAmB,EACnBq8B,QAAyB,EACzBC,cAAuB,EACpB;IAAA,IAAAC,eAAA,EAAAC,gBAAA;AACH,IAAA,IAAInzB,QAAQ,CAACoO,SAAS,EAAE,EAAE;AACxB,MAAA;AACF;AAEA,IAAA,IAAMgV,MAAM,GAAG4P,QAAQ,CAAC5P,MAAM;AAC9B,IAAA,IAAMC,MAAM,GAAG2P,QAAQ,CAAC3P,MAAM;AAC9B,IAAA,IAAM2E,MAAM,GAAGgL,QAAQ,CAAChL,MAAM;AAC9B,IAAA,IAAMvB,MAAM,GAAGuM,QAAQ,CAACvM,MAAM;IAE9B,IACEjlB,KAAQ,CAACkD,MAAM,CAAC0e,MAAM,EAAEC,MAAM,EAAE,CAAC,CAAC,GAAG2E,MAAM,IAAI,GAAG,CAAC,CAAC,GAAGwC,cAAc,EACrE;AAIA,MAAA;AACF;AAGA4I,IAAAA,eAAe,CAAC3M,MAAM,EAAEqM,UAAU,CAAC;AAEnC,IAAA,IAAMO,cAAc,GAAGhvB,eAAe,CAACurB,WAAW,GAAGxM,MAAM,EAAE;AAC3DpmB,MAAAA,GAAG,EAAEi1B,cAAc;AACnBl1B,MAAAA,GAAG,EAAEo1B;AACP,KAAC,CAAC;AAEF,IAAA,IAAMmB,cAAc,GAAGjvB,eAAe,CAACwrB,WAAW,GAAGxM,MAAM,EAAE;AAC3DrmB,MAAAA,GAAG,EAAEq1B,cAAc;AACnBt1B,MAAAA,GAAG,EAAEw1B;AACP,KAAC,CAAC;IAEF,IAAMgB,cAAc,GAAGlvB,eAAe,CAACyiB,SAAS,CAACgJ,WAAW,EAAE9H,MAAM,CAAC,EAAE;AACrEhrB,MAAAA,GAAG,EAAEy1B,cAAc;AACnB11B,MAAAA,GAAG,EAAE41B;AACP,KAAC,CAAC;IAEF,IACEU,cAAc,KAAKzD,WAAW,IAC9B0D,cAAc,KAAKzD,WAAW,IAC9B0D,cAAc,KAAKzD,WAAW,EAC9B;AACA,MAAA;AACF;AAEAF,IAAAA,WAAW,GAAGyD,cAAc;AAC5BxD,IAAAA,WAAW,GAAGyD,cAAc;AAC5BxD,IAAAA,WAAW,GAAGyD,cAAc;AAE5B,IAAA,IAAM9P,SAAS,GAAGuP,QAAQ,CAACvP,SAAS;AACpC,IAAA,IAAMmD,MAAM,GAAGoM,QAAQ,CAACpM,MAAM;AAC9B,IAAA,IAAM4M,IAAI,GACR,CAAA,CAAAN,eAAA,GAAAD,cAAc,CAACzxB,QAAW,CAACyxB,cAAc,CAAC,GAAG,CAAC,CAAC,MAAAC,IAAAA,IAAAA,eAAA,KAA/CA,MAAAA,GAAAA,MAAAA,GAAAA,eAAA,CAAiDzG,SAAS,KAAA,CAAA0G,gBAAA,GACxDF,cAAc,CAAC,CAAC,CAAC,MAAA,IAAA,IAAAE,gBAAA,KAAjBA,MAAAA,GAAAA,MAAAA,GAAAA,gBAAA,CAAmB1G,SAAS,KAAI,CAAC;AAErC,IAAA,IAAMzH,IAAI,GAAG;AACXyB,MAAAA,MAAM,EAANA,MAAM;AACNhD,MAAAA,SAAS,EAATA,SAAS;AACTmD,MAAAA,MAAM,EAANA,MAAM;AACNxD,MAAAA,MAAM,EAANA,MAAM;AACNC,MAAAA,MAAM,EAANA,MAAM;AACN2E,MAAAA,MAAM,EAANA,MAAM;AACNwL,MAAAA,IAAI,EAAJA,IAAI;AACJ5D,MAAAA,WAAW,EAAXA,WAAW;AACXC,MAAAA,WAAW,EAAXA,WAAW;AACXC,MAAAA,WAAW,EAAXA;KACD;AAED,IAAA,IACErM,SAAS,KAAKvwB,MAAS,KACtB,CAAC6+B,UAAU,IAAIvwB,QAAW,CAACuwB,UAAU,EAAEtO,SAAS,CAAC,CAAC,KAClD,CAACgL,OAAO,IAAIjtB,QAAW,CAACitB,OAAO,EAAE7H,MAAM,CAAC,CAAC,EAC1C;AACA5mB,MAAAA,QAAQ,CAACsO,MAAM,CAAC3X,MAAM,EAAEquB,IAAI,EAAEiO,cAAc,CAAC,CAAA,OAAA,CAAM,CAAC7iB,QAAQ,CAAC;AAC/D;AAKF,GACF,CAAC;AAID,EAAA,IAAM7B,OAAO,GAAG,SAAVA,OAAOA,CACX5X,MAAmB,EACnB8vB,MAAqB,EACrB7xB,KAAY,EACZkG,cAAuB,EACpB;AACHg4B,IAAAA,UAAU,CAAChrB,IAAI,CAAClT,KAAK,CAAC;IAEtB,IAAMo+B,QAAQ,GAAG9B,eAAe,CAACzK,MAAM,CAAC,CAACqM,UAAU,EAAE;AACnDttB,MAAAA,kBAAkB,EAAlBA,kBAAkB;AAClBglB,MAAAA,cAAc,EAAdA,cAAc;AACdkB,MAAAA,aAAa,EAAbA,aAAa;AACbb,MAAAA,YAAY,EAAZA,YAAY;AACZC,MAAAA,cAAc,EAAdA;AACF,KAAC,CAAC;AAQF,IAAA,IAAIhwB,cAAc,EAAE;AAClB24B,MAAAA,uBAAuB,CACrB7+B,KAAK,EACL,CAAC,CAACo+B,QAAQ,IAAKp+B,KAAK,CAACupB,IAAI,KAAKjrB,OAAU,IAAI2/B,gBAC9C,CAAC;AACH;IAEA,IAAIG,QAAQ,KAAK,KAAK,EAAE;AAGtB,MAAA,OAAO,KAAK;AACd,KAAC,MAAM,IAAIA,QAAQ,KAAK,IAAI,EAAE;AAE5BI,MAAAA,eAAe,CAAC3M,MAAM,EAAEqM,UAAU,CAAC;AAEnC,MAAA,OAAO,IAAI;AACb;AAEA,IAAA,IAAIrM,MAAM,KAAKvzB,SAAY,EAAE;AAG3B2/B,MAAAA,gBAAgB,GAAG,IAAI;MACvBrxB,QAAW,CAAC,YAAM;AAChBqxB,QAAAA,gBAAgB,GAAG,KAAK;OACzB,EAAE,EAAE,CAAC;AACR;IAEAE,gBAAgB,CACdp8B,MAAM,EACNq8B,QAAQ,KAAApkC,MAAA,CACJkkC,UAAU,CAChB,CAAC;AAED,IAAA,OAAO,KAAK;GACb;EAED,OAAO;AAAEtT,IAAAA,SAAS,EAAExf,QAAQ;AAAE2tB,IAAAA,QAAQ,EAAEpf;GAAS;AACnD,CAAC;AAED,IAAM6kB,eAAe,GAAG,SAAlBA,eAAeA,CAAI3M,MAAqB,EAAEhX,KAAc,EAAK;AACjE,EAAA,IAAMikB,aAAa,GAAGjN,MAAM,KAAKvzB,SAAY,IAAIuzB,MAAM,KAAKvzB,OAAU;AACtEuc,EAAAA,KAAK,CAACkkB,MAAM,CAAC,CAAC,EAAEnyB,QAAW,CAACiO,KAAK,CAAC,IAAIikB,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D,CAAC;AAED,IAAMD,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAI7+B,KAAY,EAAEg/B,eAAwB,EAAK;AAC1E,EAAA,IAAMj9B,MAAM,GAAG/B,KAAK,CAACsJ,aAAa;AAClC,EAAA,IAAM+lB,SAAS,GAAGrvB,KAAK,CAACupB,IAAI;AAC5B,EAAA,IAAM0V,aAAa,GACjB5P,SAAS,KAAK/wB,aAAgB,IAAI+wB,SAAS,KAAK/wB,WAAc;AAEhE,EAAA,IACE+wB,SAAS,KAAK/wB,WAAc,IAC5B+wB,SAAS,KAAK/wB,OAAU,IACvB,CAAC+wB,SAAS,KAAK/wB,OAAU,IAAI+wB,SAAS,KAAK/wB,SAAY,KACtD0gC,eAAgB,IACjBC,aAAa,IAAKj/B,KAAK,CAAgBi1B,OAAO,KAAK,CAAE,EACtD;AACAroB,IAAAA,cAAiB,CAAC5M,KAAK,CAAC;IAExB,IAAIi/B,aAAa,IAAIryB,aAAgB,CAAC7K,MAAM,CAAC,EAAE;MAE7CA,MAAM,CAACm9B,KAAK,CAAC;AAAEC,QAAAA,aAAa,EAAE;AAAK,OAAC,CAAC;AACvC;AACF;AACF,CAAC;AAED,IAAMpE,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtBh5B,MAAmB,EACnBquB,IAA0B,EACvB;AACH,EAAA,IAAM4B,MAAM,GAAG5B,IAAI,CAAC4B,MAAM;AAE1B,EAAA,IAAI,CAACplB,SAAY,CAAC7K,MAAM,CAAC,IAAI,CAACiwB,MAAM,IAAIA,MAAM,KAAK1zB,SAAY,EAAE;AAC/D,IAAA;AACF;AAEA,EAAA,IAAM8gC,MAAM,GAAA,EAAA,CAAAplC,MAAA,CAAMg4B,MAAM,EAAG,GAAA,CAAA;AAE3B,EAAA,IAAIA,MAAM,KAAK1zB,MAAS,EAAE;IACxB4iB,oBAAoB,CAClBnf,MAAM,EACN;MACEqxB,MAAM,EAAEhD,IAAI,CAAC8K;AACf,KAAC,EACD;AACElZ,MAAAA,OAAO,EAAEod,MAAM;AACfld,MAAAA,WAAW,EAAE;AACf,KACF,CAAC;AACH,GAAC,MAAM;IACLhB,oBAAoB,CAClBnf,MAAM,EACN;MACEysB,MAAM,EAAE4B,IAAI,CAAC4K,WAAW;MACxBvM,MAAM,EAAE2B,IAAI,CAAC6K;AACf,KAAC,EACD;AACEjZ,MAAAA,OAAO,EAAEod;AACX,KACF,CAAC;AACH;AACF,CAAC;;AC7jCM,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAI7+B,OAGhC,EAAa;AACZ,EAAA,IAAI8+B,aAAa,GACfC,kBAAkB,CAACC,SAAS,EAAEh/B,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEy8B,OAAO,EAAEwC,eAAe,CAAC,GAChEF,kBAAkB,CAChBG,gBAAgB,EAChBl/B,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEm/B,YAAY,EACrBC,eACF,CAAC;EAEH,IAAI,CAACN,aAAa,EAAE;AAClBA,IAAAA,aAAa,GAAGG,eAAe,CAACvpB,OAAO,GAAG0pB,eAAe,CAAC1pB,OAAO;AACnE;AAEA,EAAA,OAAOopB,aAAa;AACtB,CAAC;AAGD,IAAMO,oBAAoB,GAAGzuB,eAAe,CAACzE,QAAQ,CAACoB,iBAAiB,CAAC;AACxE,IAAM+xB,qBAAqB,GAAG1uB,eAAe,CAACzE,QAAQ,CAACwB,sBAAsB,CAAC;AAE9E,IAAM4xB,SAAS,GAAGlqB,YAAY,EAAE;AAMzB,IAAM4pB,eAAe,GAAG3pB,cAAc,CAAAhP,KAAA,CAAA,MAAA,EAAA,CAC3Ci5B,SAAS,CAAA,CAAA/lC,MAAA,CAAA+V,kBAAA,CACN8vB,oBAAoB,EACzB,CAAC;AAMM,IAAMD,eAAe,GAAG9pB,cAAc,CAAAhP,KAAA,CAAA,MAAA,EAAA,CAC3Ci5B,SAAS,CAAA,CAAA/lC,MAAA,CAAA+V,kBAAA,CACN+vB,qBAAqB,EAC1B,CAAC;AAMM,IAAME,WAAW,GACtBpzB,QAAW,CAACizB,oBAAoB,CAAC,GAAGjzB,QAAW,CAACkzB,qBAAqB,CAAC;AAIxE,IAAMN,SAAS,GAAG,SAAS;AAC3B,IAAME,gBAAgB,GAAG,cAAc;AAEvC,IAAMO,kBAAkB,GAAGC,MAAM,CAC/B,MAAM,GACJ,+CAA+C,GAC/C,6BAA6B,GAC7B,4BAA4B,GAC5B,MACJ,CAAC;AAmDD,IAAMX,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtBY,OAAe,EACfC,IAA0C,EAC1CC,QAAqB,EACV;AACX,EAAA,IAAIzzB,OAAU,CAACwzB,IAAI,CAAC,EAAE;AACpB,IAAA,OAAO,CAAC;AACV;EACA,IAAME,aAAa,GAAGH,OAAO,CAAC5sB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AAE1C,EAAA,IAAI3G,QAAW,CAACwzB,IAAI,CAAC,EAAE;AACrB,IAAA,IAAMG,UAAU,GAAGH,IAAI,CAAC/jC,KAAK,CAAC4jC,kBAAkB,CAAC;AACjD,IAAA,IAAIM,UAAU,EAAE;AAEd,MAAA,IAAI,CAACA,UAAU,CAACC,MAAM,EAAE;AACtB,QAAA,MAAM5zB,QAAW,CAAC,kCAAkC,CAAC;AACvD;AAEA,MAAA,IAAM6zB,SAAS,GACbF,UAAU,CAACC,MAAM,CAACE,OAAO,IAAIH,UAAU,CAACC,MAAM,CAACC,SAAS;AAC1D,MAAA,IAAME,SAAS,GACbJ,UAAU,CAACC,MAAM,CAACI,OAAO,IAAIL,UAAU,CAACC,MAAM,CAACG,SAAS;MAE1D,IAAIF,SAAS,KAAKrjC,SAAS,IAAI,CAACijC,QAAQ,CAAChqB,GAAG,CAACoqB,SAAS,CAAC,EAAE;AACvD,QAAA,MAAM7zB,UAAa,CAAA,UAAA,CAAA5S,MAAA,CAAYsmC,aAAa,EAAA,IAAA,CAAA,CAAAtmC,MAAA,CAAKymC,SAAS,EAAA,GAAA,CAAG,CAAC;AAChE;MAEA,IAAIE,SAAS,KAAKvjC,SAAS,IAAI,CAACijC,QAAQ,CAAChqB,GAAG,CAACsqB,SAAS,CAAC,EAAE;AACvD,QAAA,MAAM/zB,UAAa,CAAA,UAAA,CAAA5S,MAAA,CAAYsmC,aAAa,EAAA,IAAA,CAAA,CAAAtmC,MAAA,CAAK2mC,SAAS,EAAA,GAAA,CAAG,CAAC;AAChE;AAEA,MAAA,OAAON,QAAQ,CAAC9pB,UAAU,CAACkqB,SAAS,EAAEE,SAAS,CAAC;AAClD;AACF;EAEA,IAAIzqB,OAAO,GAAG,CAAC;EACf,IAAM2qB,OAAO,GAAG/rB,eAAe,CAACqrB,OAAO,EAAEC,IAAI,EAAEC,QAAQ,CAAChqB,GAAG,CAAC;AAC5D,EAAA,IAAIwqB,OAAO,EAAE;AAAA,IAAA,IAAA9pB,SAAA,GAAAC,0BAAA,CACM6pB,OAAO,CAAA;MAAA5pB,KAAA;AAAA,IAAA,IAAA;MAAxB,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA0B;AAAA,QAAA,IAAf2pB,EAAE,GAAA7pB,KAAA,CAAAnS,KAAA;AACXoR,QAAAA,OAAO,IAAImqB,QAAQ,CAACjqB,GAAG,CAAC0qB,EAAE,CAAC;AAC7B;AAAC,KAAA,CAAA,OAAAzpB,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH;AAEA,EAAA,OAAOrB,OAAO;AAChB,CAAC;;ACnHM,IAAM6qB,aAAY,GAAG,SAAfA,YAAYA,CACvB/3B,OAAgB,EAChBxI,OAIC,EACW;AACZ,EAAA,IAAAqP,IAAA,GAAkCrP,OAAO,IAAI,EAAE;IAAvCwgC,IAAI,GAAAnxB,IAAA,CAAJmxB,IAAI;IAAEC,MAAM,GAAApxB,IAAA,CAANoxB,MAAM;IAAEC,OAAO,GAAArxB,IAAA,CAAPqxB,OAAO;EAC7B,IAAI,CAACF,IAAI,EAAE;IACT,OACED,aAAY,CAAC/3B,OAAO,EAAE;AAAEg4B,MAAAA,IAAI,EAAE,GAAG;AAAEC,MAAAA,MAAM,EAANA,MAAM;AAAEC,MAAAA,OAAO,EAAPA;AAAQ,KAAC,CAAC,IACrDH,aAAY,CAAC/3B,OAAO,EAAE;AAAEg4B,MAAAA,IAAI,EAAE,GAAG;AAAEC,MAAAA,MAAM,EAANA,MAAM;AAAEC,MAAAA,OAAO,EAAPA;AAAQ,KAAC,CAAC;AAEzD;EAEA,IAAI,CAACA,OAAO,EAAE;AAAA,IAAA,IAAAC,qBAAA;AACZ,IAAA,IAAMC,YAAY,GAAAD,CAAAA,qBAAA,GAAGE,iBAAiB,CAAC3rB,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAm4B,qBAAA,KAA9BA,MAAAA,GAAAA,MAAAA,GAAAA,qBAAA,CAAgCzrB,GAAG,CAACsrB,IAAI,CAAC;AAC9D,IAAA,IAAI,CAACp0B,SAAY,CAACw0B,YAAY,CAAC,EAAE;AAC/B,MAAA,OAAOA,YAAY;AACrB;AACF;EAEA,IAAME,MAAM,GAAGN,IAAI,KAAK,GAAG,GAAG,MAAM,GAAG,KAAK;EAC5C,IAAIr7B,MAAM,GAAG,KAAK;EAClB,IAAI47B,OAAO,GAAG,CAACL,OAAO;AAEtB,EAAA,IAAIl4B,OAAO,CAAAhP,QAAAA,CAAAA,MAAA,CAAUsnC,MAAM,EAAG,EAAE;AAC9B37B,IAAAA,MAAM,GAAG,IAAI;GACd,MAAM,IAAIs7B,MAAM,EAAE;AAIjBr0B,IAAAA,UAAa,CAAC5D,OAAO,EAAAlF,eAAA,CAAK8I,EAAAA,EAAAA,WAAc,CAAC00B,MAAM,CAAC,EAAG,CAAC,CAAE,CAAC;IACvD,IAAME,SAAS,GAAGx4B,OAAO,CAAA,QAAA,CAAAhP,MAAA,CAAUsnC,MAAM,CAAG,CAAA,GAAG,CAAC;AAChD10B,IAAAA,UAAa,CAAC5D,OAAO,EAAAlF,eAAA,CAAK8I,EAAAA,EAAAA,WAAc,CAAC00B,MAAM,CAAC,EAAG,CAAC,CAAE,CAAC;AACvD37B,IAAAA,MAAM,GAAG67B,SAAS;AACpB,GAAC,MAAM;IACL,IAAMC,SAAS,GAAGT,IAAI,KAAK,GAAG,GAAG,OAAO,GAAG,QAAQ;AACnDr7B,IAAAA,MAAM,GAAGqD,OAAO,CAAAhP,QAAAA,CAAAA,MAAA,CAAUynC,SAAS,CAAG,CAAA,GAAGz4B,OAAO,CAAA,QAAA,CAAAhP,MAAA,CAAUynC,SAAS,CAAG,CAAA;AAEtEF,IAAAA,OAAO,GAAG,KAAK;AACjB;AAEA,EAAA,IAAIA,OAAO,EAAE;IACXF,iBAAiB,CAACpZ,IAAI,CAACjf,OAAO,CAAC,CAACwR,GAAG,CAACwmB,IAAI,EAAEr7B,MAAM,CAAC;IACjDiH,QAAW,CAAC,YAAM;MAChBA,SAAY,CAACy0B,iBAAiB,CAAC3rB,GAAG,CAAC1M,OAAO,CAAC,EAAEg4B,IAAI,CAAC;AAClDK,MAAAA,iBAAiB,CAACnZ,KAAK,CAAClf,OAAO,CAAC;KACjC,EAAE04B,2BAA2B,CAAC;AACjC;AAEA,EAAA,OAAO/7B,MAAM;AACf,CAAC;AAYM,IAAMg8B,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAC/B34B,OAAgB,EAChBxI,OAIC,EACE;EAEH,IAAIohC,QAAoC,GAAG54B,OAAO;EAClD,OAAQ44B,QAAQ,GAAGh1B,QAAW,CAACg1B,QAAQ,CAAC,EAAG;AACzC,IAAA,IAAIb,aAAY,CAACa,QAAQ,EAAEphC,OAAO,CAAC,EAAE;AACnC,MAAA,OAAOohC,QAAQ;AACjB;AACF;AAEA,EAAA,OAAO,IAAI;AACb,CAAC;AAOM,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAsBA,CACjCC,UAAoB,EACI;AACxBA,EAAAA,UAAU,GAAGC,qBAAqB,CAACD,UAAU,CAAC;AAC9C,EAAA,IAAM5H,MAAM,GAAG8H,mBAAmB,CAACtsB,GAAG,CAACosB,UAAU,CAAC;AAClD,EAAA,IAAI5H,MAAM,EAAE;AACV,IAAA,OAAOttB,UAAa,CAACstB,MAAM,CAAC;AAC9B;AACA,EAAA,OAAO,IAAI;AACb,CAAC;AAsBM,IAAM9vB,QAAQ,GAAG,SAAXA,QAAQA,CACnBiZ,EAAwC,EACxC2H,WAA6B,EACL;AACxB,EAAA,IAAMxqB,OAAO,GAAG8qB,YAAU,CAACjI,EAAE,EAAE2H,WAAW,CAAC;AAC3C,EAAA,IAAM8W,UAAU,GAAGthC,OAAO,CAACyhC,WAAW;AAGtC,EAAA,IAAMC,aAAa,GAAGF,mBAAmB,CAACtsB,GAAG,CAACosB,UAAU,CAAC;AACzD,EAAA,IAAII,aAAa,EAAE;AACjB,IAAA,IAAI,CAACA,aAAa,CAACC,MAAM,EAAE,EAAE;AAE3B,MAAA,OAAO,IAAI;AACb;AACF;EAEA,IAAIlf,WAAW,GAAG,KAAK;AAEvB,EAAA,IAAMmf,QAAQ,GAAG5hC,OAAO,CAAC6hC,eAAe,GACpC,YAAA;IAAA,OAAOpf,WAAW,GAAG,IAAI;AAAA,GAAC,GAC1B,YAAA;AAAA,IAAA,OAAM,KAAK;AAAA,GAAA;AAEf,EAAA,IAAMqf,YAAY,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC;EAC3C,IAAIC,oBAA0C,GAAG,IAAI;EAErD,IAAI/hC,OAAO,CAACgiC,iBAAiB,EAAE;AAAA,IAAA,IAAAzrB,SAAA,GAAAC,0BAAA,CACLsrB,YAAY,CAAA;MAAArrB,KAAA;AAAA,IAAA,IAAA;MAApC,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAsC;AAAA,QAAA,IAA3BkY,SAAS,GAAApY,KAAA,CAAAnS,KAAA;AAClBsqB,QAAAA,kBAAkB,CAChB0S,UAAU,EACVzS,SAAS,EACT,YAAM;AACJpM,UAAAA,WAAW,GAAG,IAAI;AACpB,SAAC,EACD;AAAE8M,UAAAA,IAAI,EAAE;AAAK,SACf,CAAC;AACH;AAAC,KAAA,CAAA,OAAA1Y,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH,GAAC,MAAM;IACLgrB,oBAAoB,GAAG31B,cAAiB;AAAC,IAAA,IAAAud,UAAA,GAAAnT,0BAAA,CACjBsrB,YAAY,CAAA;MAAAlY,MAAA;AAAA,IAAA,IAAA;MAApC,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAAsC;AAAA,QAAA,IAA3BkY,UAAS,GAAAjF,MAAA,CAAAtlB,KAAA;AAClBsqB,QAAAA,kBAAkB,CAAC0S,UAAU,EAAEzS,UAAS,EAAEkT,oBAAoB,EAAE;AAC9D5R,UAAAA,OAAO,EAAE;AACX,SAAC,CAAC;AACJ;AAAC,KAAA,CAAA,OAAAtZ,GAAA,EAAA;MAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAA8S,MAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;AACH;AAEA,EAAA,IAAMkrB,OAAO,GAAGC,cAAc,CAACliC,OAAO,EAAE,YAAA;AAAA,IAAA,OAAMyiB,WAAW;GAAC,CAAA;AAE1D,EAAA,IAAM0f,gBAA8B,GAAG;IACrCC,OAAO,EAAE,SAATA,OAAOA,GAAA;AAAA,MAAA,OAAQH,OAAO;AAAA,KAAA;AACtBN,IAAAA,MAAM,EAAEC;GACT;AAED,EAAA,IAAMS,OAAO,GAAG,SAAVA,OAAOA,GAAS;IACpB,IAAIb,mBAAmB,CAACtsB,GAAG,CAACosB,UAAU,CAAC,KAAKa,gBAAgB,EAAE;AAC5D/1B,MAAAA,SAAY,CAACo1B,mBAAmB,EAAEF,UAAU,CAAC;AAC/C;AAEA,IAAA,IAAIS,oBAAoB,EAAE;AACxB,MAAA,KAAA,IAAA1f,EAAA,GAAA,CAAA,EAAAigB,aAAA,GAAwBR,YAAY,EAAAzf,EAAA,GAAAigB,aAAA,CAAA3lC,MAAA,EAAA0lB,EAAA,EAAE,EAAA;AAAjC,QAAA,IAAMwM,WAAS,GAAAyT,aAAA,CAAAjgB,EAAA,CAAA;AAClBmN,QAAAA,uBAAuB,CAAC8R,UAAU,EAAEzS,WAAS,EAAEkT,oBAAoB,EAAE;AACnE5R,UAAAA,OAAO,EAAE;AACX,SAAC,CAAC;AACJ;AACF;GACD;AAEDgS,EAAAA,gBAAgB,CAACC,OAAO,EAAE,CAAC3mB,IAAI,CAAC4mB,OAAO,CAAC,CAAA,OAAA,CAAM,CAACA,OAAO,CAAC;AAEvDb,EAAAA,mBAAmB,CAACxnB,GAAG,CAACsnB,UAAU,EAAEa,gBAAgB,CAAC;AACrD,EAAA,OAAOA,gBAAgB;AACzB,CAAC;AAOM,IAAMI,sBAAsB,GAAG,SAAzBA,sBAAsBA,CACjClU,SAAiB,EAAA;AAAA,EAAA,OACgBjiB,QAAW,CAACqiB,iBAAiB,EAAEJ,SAAS,CAAC;AAAA,CAAA;AA6BrE,IAAMmU,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIh6B,OAAgB,EAAA;AAAA,EAAA,OAChDi6B,wBAAwB,CAACj6B,OAAO,CAAC,GAC7BA,OAAO,CAACk6B,WAAW,GACnBC,cAAc,CAACn6B,OAAO,EAAE1K,MAAS,CAAC,GAClC6kC,cAAc,CAACn6B,OAAO,EAAE1K,OAAU,CAAC,GACnC0K,OAAO,CAAC1K,cAAiB,CAAC;AAAA,CAAA;AAMzB,IAAM8kC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIp6B,OAAgB,EAAA;AAAA,EAAA,OACjDi6B,wBAAwB,CAACj6B,OAAO,CAAC,GAC7BA,OAAO,CAACq6B,YAAY,GACpBF,cAAc,CAACn6B,OAAO,EAAE1K,KAAQ,CAAC,GACjC6kC,cAAc,CAACn6B,OAAO,EAAE1K,QAAW,CAAC,GACpC0K,OAAO,CAAC1K,eAAkB,CAAC;AAAA,CAAA;AAe1B,IAAMglC,uBAAuB,GAAA,YAAA;EAAA,IAAA3oB,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAC,OAAA,GAAA;AAAA,IAAA,OAAAF,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,QAAA,KAAA,CAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;UAAA,OAC/BqqB,MAAI,EAAE;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,OAAAvqB,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAEL+lB,kBAAkB,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAxqB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAN,OAAA,CAAA;GAC1B,CAAA,CAAA;AAAA,EAAA,OAAA,SAJYyqB,uBAAuBA,GAAA;AAAA,IAAA,OAAA3oB,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAInC,EAAA;AAMM,IAAM+mC,2BAA2B,GAAG,SAA9BA,2BAA2BA,GAAA;AAAA,EAAA,OACtCC,qBAAqB,KAArBA,IAAAA,IAAAA,qBAAqB,KAArBA,MAAAA,GAAAA,qBAAqB,GAAI,IAAI;AAAA,CAAA;AAQxB,IAAMC,0BAA0B,GAAA,YAAA;EAAA,IAAA9jB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAgC,QAAA,GAAA;AAAA,IAAA,OAAAjC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA6B,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;UAAA,OAClCqqB,MAAI,EAAE;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,OAAAxoB,SAAA,CAAA0C,MAAA,CAAA,QAAA,EAELimB,qBAAqB,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA3oB,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;GAC7B,CAAA,CAAA;AAAA,EAAA,OAAA,SAJY+oB,0BAA0BA,GAAA;AAAA,IAAA,OAAA9jB,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAItC,EAAA;AAMM,IAAMknC,0BAA0B,GAAG,SAA7BA,0BAA0BA,GAAS;AAC9C,EAAA,IAAMhkC,IAAI,GAAGgN,OAAU,EAAE;AACzB,EAAA,OAAOm0B,aAAY,CAACnhC,IAAI,CAAC,GAAGA,IAAI,GAAGgN,sBAAyB,EAAE,IAAIhN,IAAI;AACxE,CAAC;AAcM,IAAMikC,sBAAsB,GAAA,YAAA;EAAA,IAAAzjB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAkH,QAAAA,CACpC/d,MAAuC,EAAA;AAAA,IAAA,OAAA4W,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,OAAA+G,SAAA,CAAAxC,MAAA,CAAA,QAAA,EAClBqmB,kBAAkB,CAAC/hC,MAAM,EAAE4hC,0BAA0B,CAAC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA1jB,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2G,QAAA,CAAA;AAAA,GAAA,CAAA,CAAA;EAAA,OAFhE+jB,SAAAA,sBAAsBA,CAAA1oB,EAAA,EAAA;AAAA,IAAA,OAAAiF,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAE0C,EAAA;AAe7E,IAAMglC,2BAA2B,GAAG,IAAI;AAExC,IAAML,iBAAiB,GAAG5Z,OAAO,CAAmC,YAAA;AAAA,EAAA,OAClE7a,MAAS,EAAE;AAAA,CACb,CAAC;AAED,IAAMm3B,iBAAiB,GAAGn3B,MAAS,EAAoB;AAEvD,IAAMo1B,mBAAmB,GAAGp1B,MAAS,EAAyB;AAE9D,IAAMo3B,cAAc,GAAG,CAAC;AACxB,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAI1yB,KAAqB,EAAEC,GAAmB,EAAA;AAAA,EAAA,OACvE1B,MAAM,CAACyB,KAAK,CAACpN,GAAG,GAAGqN,GAAG,CAACrN,GAAG,EAAEoN,KAAK,CAACvN,IAAI,GAAGwN,GAAG,CAACxN,IAAI,CAAC,IAAIggC,cAAc;AAAA,CAAA;AAEtE,IAAMF,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtB/hC,MAAuC,EACvCmiC,OAAgB,EACA;AAChB,EAAA,IAAIt3B,SAAY,CAAC7K,MAAM,CAAC,EAAE;AACxB,IAAA,OAAOgiC,iBAAiB,CAACruB,GAAG,CAAC3T,MAAM,CAAC,IAAIA,MAAM;AAChD;AAEA,EAAA,IAAI,CAACA,MAAM,IAAIA,MAAM,KAAK6K,SAAY,EAAE,IAAI7K,MAAM,KAAK6K,MAAS,EAAE,EAAE;IAClE,OAAOs3B,OAAO,EAAE;AAClB;AAEA,EAAA,MAAMt3B,UAAa,CAAC,2BAA2B,CAAC;AAClD,CAAC;AAED,IAAMm1B,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAID,UAA+B,EAAA;EAAA,OAC5DA,UAAU,aAAVA,UAAU,KAAA,MAAA,GAAVA,UAAU,GAAI8B,0BAA0B,EAAE;AAAA,CAAA;AAE5C,IAAMtY,YAAU,GAAG,SAAbA,UAAUA,CACdjI,EAAwC,EACxC7iB,OAAoC,EACR;EAAA,IAAA2jC,qBAAA,EAAAC,qBAAA;EAC5B,IAAMtC,UAAU,GAAGC,qBAAqB,CAACvhC,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAEshC,UAAU,CAAC;AAC7D,EAAA,IAAM//B,MAAM,GAAGsiC,qBAAoB,CAACvC,UAAU,EAAEze,EAAE,CAAC;EACnD,IAAMihB,SAAS,GAAG9jC,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAPA,MAAAA,IAAAA,OAAO,CAAE8jC,SAAS,GAChCD,qBAAoB,CAACvC,UAAU,EAAEthC,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE8jC,SAAS,CAAC,GACpD,IAAI;EAER,OAAO;AACLzb,IAAAA,OAAO,EAAE9mB,MAAM;IACfwiC,OAAO,EAAE,CAAA/jC,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAE8gC,MAAM,KAAI,IAAI;AAChCkD,IAAAA,UAAU,EAAEF,SAAS;IACrBG,UAAU,EAAE,CAAAjkC,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEkkC,SAAS,KAAI,IAAI;AACtCzC,IAAAA,WAAW,EAAEH,UAAU;IACvB6C,SAAS,EAAE,CAAAnkC,OAAO,KAAPA,IAAAA,IAAAA,OAAO,uBAAPA,OAAO,CAAEmf,QAAQ,KAAI,CAAC;AACjC0iB,IAAAA,eAAe,EAAA8B,CAAAA,qBAAA,GAAE3jC,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEokC,cAAc,MAAAT,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAI,KAAK;AACjD3B,IAAAA,iBAAiB,EAAA4B,CAAAA,qBAAA,GAAE5jC,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEqkC,gBAAgB,MAAA,IAAA,IAAAT,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI;GACjD;AACH,CAAC;AAED,IAAMC,qBAAoB,GAAG,SAAvBA,oBAAoBA,CACxBvC,UAAmB,EACnB//B,MAA4C,EACtB;AACtB,EAAA,IAAM+iC,mBAAmB,GAAGl4B,sBAAyB,EAAE;AAEvD,EAAA,IAAIA,SAAY,CAAC7K,MAAM,CAAC,EAAE;IACxB,IAAI+/B,UAAU,KAAK//B,MAAM,IAAI,CAAC+/B,UAAU,CAAC9jB,QAAQ,CAACjc,MAAM,CAAC,EAAE;AACzD,MAAA,MAAM6K,UAAa,CAAC,mDAAmD,CAAC;AAC1E;IAEA,OAAO;MACLzI,GAAG,EAAE,SAALA,GAAGA,GAAA;AAAA,QAAA,OACD29B,UAAU,CAACxjC,YAAe,CAAC,GAC3BsO,qBAAwB,CAAC7K,MAAM,CAAC,CAACoC,GAAG,IACnC29B,UAAU,KAAKgD,mBAAmB,GAC/B,CAAC,GACDl4B,qBAAwB,CAACk1B,UAAU,CAAC,CAAC39B,GAAG,CAAC;AAAA,OAAA;MAC/CH,IAAI,EAAE,SAANA,IAAIA,GAAA;AAAA,QAAA,OACF89B,UAAU,CAACxjC,aAAgB,CAAC,GAC5BsO,qBAAwB,CAAC7K,MAAM,CAAC,CAACiC,IAAI,IACpC89B,UAAU,KAAKgD,mBAAmB,GAC/B,CAAC,GACDl4B,qBAAwB,CAACk1B,UAAU,CAAC,CAAC99B,IAAI,CAAC;AAAA;KACjD;AACH;AAEA,EAAA,IAAI4I,QAAW,CAAC7K,MAAM,CAAC,EAAE;AACvB,IAAA,IAAMgjC,QAAQ,GAAGn4B,gBAAmB,CAAC7K,MAAM,CAAC;IAC5C,IAAI,CAACgjC,QAAQ,EAAE;MACb,MAAMn4B,UAAa,CAAA,gBAAA,CAAA5S,MAAA,CAAkB+H,MAAM,MAAG,CAAC;AACjD;AAEA,IAAA,OAAOsiC,qBAAoB,CAACvC,UAAU,EAAEiD,QAAQ,CAAC;AACnD;AAEA,EAAA,IAAI,CAACn4B,QAAW,CAAC7K,MAAM,CAAC,IAAI,EAAE,KAAK,IAAIA,MAAM,IAAI,MAAM,IAAIA,MAAM,CAAC,EAAE;AAClE,IAAA,MAAM6K,UAAa,CAAC,qBAAqB,CAAC;AAC5C;AAEA,EAAA,OAAO7K,MAAM;AACf,CAAC;AAED,IAAMijC,mBAAmB,GAAA,YAAA;EAAA,IAAA7jB,KAAA,GAAAzI,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAyH,QAAAA,CAC1B7f,OAAgC,EAAA;AAAA,IAAA,IAAAykC,WAAA,EAAAnD,UAAA,EAAAvwB,KAAA,EAAAC,GAAA;AAAA,IAAA,OAAAmH,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA2H,UAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;UAAA,OAE1B4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;AAEpBmpB,UAAAA,WAAW,GAAG,SAAdA,WAAWA,CACfpgB,QAAwB,EACxByc,MAA+B,EAC5B;AACHzc,YAAAA,QAAQ,CAAC1gB,GAAG,IAAI,CAAAm9B,MAAM,KAAA,IAAA,IAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEn9B,GAAG,KAAI,CAAC;AAChC0gB,YAAAA,QAAQ,CAAC7gB,IAAI,IAAI,CAAAs9B,MAAM,KAAA,IAAA,IAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEt9B,IAAI,KAAI,CAAC;WACnC;UAEK89B,UAAU,GAAGthC,OAAO,CAACyhC,WAAW;AAChC1wB,UAAAA,KAAK,GAAG;AACZpN,YAAAA,GAAG,EAAE29B,UAAU,CAACxjC,YAAe,CAAC;AAChC0F,YAAAA,IAAI,EAAE89B,UAAU,CAACxjC,aAAgB;WAClC;UAEGkT,GAAG,GAAG0zB,cAAc,CAACpD,UAAU,EAAEvwB,KAAK,EAAE/Q,OAAO,CAACqoB,OAAO,CAAC;AAC5Doc,UAAAA,WAAW,CAACzzB,GAAG,EAAEhR,OAAO,CAAC+jC,OAAO,CAAC;UAEjC,IAAI,CAACN,qBAAqB,CAAC1yB,KAAK,EAAEC,GAAG,CAAC,IAAIhR,OAAO,CAACgkC,UAAU,EAAE;YAC5DhzB,GAAG,GAAG0zB,cAAc,CAACpD,UAAU,EAAEvwB,KAAK,EAAE/Q,OAAO,CAACgkC,UAAU,CAAC;AAC3DS,YAAAA,WAAW,CAACzzB,GAAG,EAAEhR,OAAO,CAACikC,UAAU,CAAC;AACtC;UAAC,OAAA5jB,SAAA,CAAApD,MAAA,CAEM,QAAA,EAAA;AAAElM,YAAAA,KAAK,EAALA,KAAK;AAAEC,YAAAA,GAAG,EAAHA;WAAK,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAqP,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAkH,QAAA,CAAA;GACtB,CAAA,CAAA;EAAA,OA5BK2kB,SAAAA,mBAAmBA,CAAApnB,GAAA,EAAA;AAAA,IAAA,OAAAuD,KAAA,CAAAra,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CA4BxB,EAAA;AAGD,IAAMwoC,cAAc,GAAG,SAAjBA,cAAcA,CAClBpD,UAAmB,EACnBqD,aAA6B,EAC7BC,iBAAoC,EACjB;AAEnB,EAAA,IAAMC,WAAW,GAAGz4B,UAAa,CAACu4B,aAAa,CAAC;AAEhD,EAAA,IAAI,CAACv4B,SAAY,CAACw4B,iBAAiB,KAAjBA,IAAAA,IAAAA,iBAAiB,KAAjBA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAiB,CAAEjhC,GAAG,CAAC,EAAE;IACzC,IAAIyI,UAAa,CAACw4B,iBAAiB,CAACjhC,GAAG,CAAC,EAAE;MACxCkhC,WAAW,CAAClhC,GAAG,GAAGihC,iBAAiB,CAACjhC,GAAG,CAAC29B,UAAU,CAAC;AACrD,KAAC,MAAM;AACLuD,MAAAA,WAAW,CAAClhC,GAAG,GAAGihC,iBAAiB,CAACjhC,GAAG;AACzC;AACF;AAEA,EAAA,IAAI,CAACyI,SAAY,CAACw4B,iBAAiB,KAAjBA,IAAAA,IAAAA,iBAAiB,KAAjBA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAiB,CAAEphC,IAAI,CAAC,EAAE;IAC1C,IAAI4I,UAAa,CAACw4B,iBAAiB,CAACphC,IAAI,CAAC,EAAE;MACzCqhC,WAAW,CAACrhC,IAAI,GAAGohC,iBAAiB,CAACphC,IAAI,CAAC89B,UAAU,CAAC;AACvD,KAAC,MAAM;AACLuD,MAAAA,WAAW,CAACrhC,IAAI,GAAGohC,iBAAiB,CAACphC,IAAI;AAC3C;AACF;AAGA,EAAA,IAAMshC,OAAO,GAAGxD,UAAU,CAACxjC,eAAkB,CAAC;AAC9C,EAAA,IAAMinC,OAAO,GAAGzD,UAAU,CAACxjC,cAAiB,CAAC;AAC7C,EAAA,IAAMknC,OAAO,GAAGpC,kBAAkB,CAACtB,UAAU,CAAC;AAC9C,EAAA,IAAM2D,OAAO,GAAGzC,iBAAiB,CAAClB,UAAU,CAAC;AAC7CuD,EAAAA,WAAW,CAAClhC,GAAG,GAAGyI,GAAM,CAAC04B,OAAO,GAAGE,OAAO,EAAEH,WAAW,CAAClhC,GAAG,CAAC;AAC5DkhC,EAAAA,WAAW,CAAClhC,GAAG,GAAGyI,GAAM,CAAC,CAAC,EAAEy4B,WAAW,CAAClhC,GAAG,CAAC;AAE5CkhC,EAAAA,WAAW,CAACrhC,IAAI,GAAG4I,GAAM,CAAC24B,OAAO,GAAGE,OAAO,EAAEJ,WAAW,CAACrhC,IAAI,CAAC;AAC9DqhC,EAAAA,WAAW,CAACrhC,IAAI,GAAG4I,GAAM,CAAC,CAAC,EAAEy4B,WAAW,CAACrhC,IAAI,CAAC;AAE9C,EAAA,OAAOqhC,WAAW;AACpB,CAAC;AAED,IAAM3C,cAAc,GAAA,YAAA;AAAA,EAAA,IAAA3d,KAAA,GAAArM,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAoM,QAAAA,CACrBxkB,OAAgC,EAChCyiB,WAA0B,EAAA;AAAA,IAAA,IAAA4B,QAAA,EAAAlF,QAAA,EAAAmiB,UAAA,EAAA7iC,SAAA,EAAAymC,iBAAA,EAAAC,eAAA,EAAAjc,MAAA;AAAA,IAAA,OAAA/Q,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAmM,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAjM,IAAA,GAAAiM,SAAA,CAAAhM,IAAA;AAAA,QAAA,KAAA,CAAA;AAAAgM,UAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;UAAA,OAEH8rB,mBAAmB,CAACxkC,OAAO,CAAC;AAAA,QAAA,KAAA,CAAA;UAA7CqkB,QAAQ,GAAAK,SAAA,CAAA7K,IAAA;UACRsF,QAAQ,GAAGnf,OAAO,CAACmkC,SAAS;UAC5B7C,UAAU,GAAGthC,OAAO,CAACyhC,WAAW;UAGlC0D,eAA+B,GAAG9gB,QAAQ,CAACtT,KAAK;UAE9Cq0B,MAAI,GAAA,YAAA;YAAA,IAAAvgB,KAAA,GAAA3M,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAwI,QAAA,GAAA;AAAA,cAAA,IAAAyW,SAAA,EAAAgO,OAAA,EAAAC,QAAA;AAAA,cAAA,OAAAntB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,gBAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,kBAAA,KAAA,CAAA;AAAA4I,oBAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;oBAAA,OACLyC,iBAAiB,EAAE;AAAA,kBAAA,KAAA,CAAA;AAAAmG,oBAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;oBAAA,OAGnB4C,kBAAkB,EAAE;AAAA,kBAAA,KAAA,CAAA;AACpB+b,oBAAAA,SAAS,GAAGjrB,OAAU,EAAE;oBAAA,IAE1BqW,CAAAA,WAAW,EAAE,EAAA;AAAAnB,sBAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;AAAA,sBAAA;AAAA;AAAA,oBAAA,MAETysB,eAAe;AAAA,kBAAA,KAAA,CAAA;AAAA,oBAAA,IAGlB1mC,SAAS,EAAA;AAAA6iB,sBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,sBAAA;AAAA;AAAA,oBAAA,IAAA,EAGVyG,QAAQ,KAAK,CAAC,IACd,CAACskB,qBAAqB,CAAC0B,eAAe,EAAE9gB,QAAQ,CAACrT,GAAG,CAAC,CAAA,EAAA;AAAAsQ,sBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,sBAAA;AAAA;oBAErDtM,UAAa,CAACk1B,UAAU,EAAEjd,QAAQ,CAACrT,GAAG,CAAC;AAAC,oBAAA,OAAAsQ,SAAA,CAAArE,MAAA,CACjCoH,QAAAA,EAAAA,QAAQ,CAACrT,GAAG,CAAA;AAAA,kBAAA,KAAA,EAAA;AAGrBvS,oBAAAA,SAAS,GAAG44B,SAAS;AAAC,kBAAA,KAAA,EAAA;AAAA,oBAAA,IAAA,EAGpB54B,SAAS,KAAK44B,SAAS,IAAI6N,iBAAiB,KAAK7N,SAAS,CAAA,EAAA;AAAA/V,sBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,sBAAA;AAAA;oBACtD2sB,OAAO,GAAGhO,SAAS,GAAG54B,SAAS;AAC/B6mC,oBAAAA,QAAQ,GAAG30B,aAAa,CAACvE,GAAM,CAAC,CAAC,EAAEi5B,OAAO,GAAGlmB,QAAQ,CAAC,CAAC;AAE7DgmB,oBAAAA,eAAe,GAAG;sBAChBxhC,GAAG,EACD0gB,QAAQ,CAACtT,KAAK,CAACpN,GAAG,GAClB,CAAC0gB,QAAQ,CAACrT,GAAG,CAACrN,GAAG,GAAG0gB,QAAQ,CAACtT,KAAK,CAACpN,GAAG,IAAI2hC,QAAQ;AACpD9hC,sBAAAA,IAAI,EACF6gB,QAAQ,CAACtT,KAAK,CAACvN,IAAI,GACnB,CAAC6gB,QAAQ,CAACrT,GAAG,CAACxN,IAAI,GAAG6gB,QAAQ,CAACtT,KAAK,CAACvN,IAAI,IAAI8hC;qBAC/C;AAEDl5B,oBAAAA,UAAa,CAACk1B,UAAU,EAAE6D,eAAe,CAAC;oBAAC,IAEvCG,EAAAA,QAAQ,KAAK,CAAC,CAAA,EAAA;AAAAhkB,sBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,sBAAA;AAAA;AAAA,oBAAA,OAAA4I,SAAA,CAAArE,MAAA,CAAA,QAAA,EACTkoB,eAAe,CAAA;AAAA,kBAAA,KAAA,EAAA;AAI1BD,oBAAAA,iBAAiB,GAAG7N,SAAS;AAAC,oBAAA,OAAA/V,SAAA,CAAArE,MAAA,CACvBmoB,QAAAA,EAAAA,MAAI,EAAE,CAAA;AAAA,kBAAA,KAAA,EAAA;AAAA,kBAAA,KAAA,KAAA;oBAAA,OAAA9jB,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,eAAA,EAAAiI,QAAA,CAAA;aACd,CAAA,CAAA;AAAA,YAAA,OAAA,SA/CKwkB,IAAIA,GAAA;AAAA,cAAA,OAAAvgB,KAAA,CAAAve,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,aAAA;AAAA,WAAA,EAAA;AAAA,UAAA,OAAAwoB,SAAA,CAAAzH,MAAA,CAiDHmoB,QAAAA,EAAAA,MAAI,EAAE,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA1gB,SAAA,CAAA/L,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA6L,QAAA,CAAA;GACd,CAAA,CAAA;AAAA,EAAA,OAAA,SA7DK0d,cAAcA,CAAA7kB,GAAA,EAAA+B,GAAA,EAAA;AAAA,IAAA,OAAAmF,KAAA,CAAAje,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CA6DnB,EAAA;AAED,IAAMumC,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAIj6B,OAAgB,EAAA;AAAA,EAAA,OAChDA,OAAO,KAAK4D,OAAU,EAAE,IAAIA,sBAAyB,EAAE,KAAK,IAAI;AAAA,CAAA;AAGlE,IAAMu2B,cAAc,GAAG,SAAjBA,cAAcA,CAAIn6B,OAAgB,EAAE+8B,IAAY,EAAA;AAAA,EAAA,OACpDn5B,IAAO,CAACA,UAAa,CAAC8R,uBAAuB,CAAC1V,OAAO,YAAAhP,MAAA,CAAY+rC,IAAI,CAAE,CAAC,CAAC,CAAC;AAAA,CAAA;AAI5E,IAAIvC,kBAA+B;AACnC,IAAIE,qBAAkC;AAEtC,IAAIsC,aAAiC,GAAG,IAAI;AAC5C,IAAMzC,MAAI,GAAG,SAAPA,IAAIA,GAAwB;EAChC,IAAI,CAACyC,aAAW,EAAE;IAChBA,aAAW,GAAGttB,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAA0M,QAAA,GAAA;MAAA,IAAAzY,6BAAA,EAAAo5B,cAAA;AAAA,MAAA,OAAAttB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA0M,UAAAC,SAAA,EAAA;AAAA,QAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAxM,IAAA,GAAAwM,SAAA,CAAAvM,IAAA;AAAA,UAAA,KAAA,CAAA;YACPrM,6BAA6B,GACjCF,QAAQ,CAACE,6BAA6B;AAAA4Y,YAAAA,SAAA,CAAAvM,IAAA,GAAA,CAAA;YAAA,OAEX6N,2BAA2B,CAAC,YAAM;AAC7D,cAAA,OAAOla,6BAA6B,GAChCD,gBAAmB,CAACC,6BAA6B,CAAC,GAClDD,OAAU,EAAE;AAClB,aAAC,CAAC;AAAA,UAAA,KAAA,CAAA;YAJIq5B,cAAc,GAAAxgB,SAAA,CAAApL,IAAA;YAOpBqpB,qBAAqB,GAAGE,0BAA0B,EAAE;AACpDJ,YAAAA,kBAAkB,GAAG52B,OAAU,EAAE;YAEjC,IAAI,CAACq5B,cAAc,EAAE;AACnBzqB,cAAAA,QAAQ,CACN5O,UAAa,CACX,gBAAA,CAAA5S,MAAA,CAAiB6S,6BAA6B,EAAA,KAAA,CAAA,GAC5C,qDACJ,CACF,CAAC;aACF,MAAM,IAAI,CAACD,aAAgB,CAACq5B,cAAc,CAAC,EAAE;cAC5C3qB,OAAO,CAAC,8DAA8D,CAAC;AACzE,aAAC,MAAM,IAAI2qB,cAAc,KAAKzC,kBAAkB,EAAE;cAChDE,qBAAqB,GAAGF,kBAAkB,GAAGyC,cAAc;AAC7D;AAAC,UAAA,KAAA,CAAA;AAAA,UAAA,KAAA,KAAA;YAAA,OAAAxgB,SAAA,CAAAtM,IAAA,EAAA;AAAA;AAAA,OAAA,EAAAmM,QAAA,CAAA;AAAA,KACF,IAAG;AACN;AAEA,EAAA,OAAO0gB,aAAW;AACpB,CAAC;AAID,IAAIp5B,MAAS,EAAE,EAAE;AACfqa,EAAAA,kBAAkB,EAAE,CAAChL,IAAI,CAACsnB,MAAI,CAAC;AACjC;;ACloBO,IAAM2C,aAAa,GAAA,YAAA;EAAA,IAAAr2B,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,OAAAA,CAAOmS,WAA4B,EAAA;AAAA,IAAA,IAAAxqB,OAAA,EAAA2lC,QAAA,EAAAC,cAAA,EAAAC,eAAA,EAAAC,OAAA,EAAAC,mBAAA,EAAAC,mBAAA,EAAAC,oBAAA,EAAA7hB,QAAA;AAAA,IAAA,OAAAjM,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,QAAA,KAAA,CAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;UAAA,OACxCwtB,mBAAmB,CAAC1b,WAAW,CAAC;AAAA,QAAA,KAAA,CAAA;UAAhDxqB,OAAO,GAAAwY,QAAA,CAAAqB,IAAA;AACP8rB,UAAAA,QAAQ,GAAG,CAAC3lC,OAAO,CAACmmC,GAAG;AAAA,UAAA,IAAA,CAEzBR,QAAQ,EAAA;AAAAntB,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UACJmtB,eAAe,GAAA,CAAAD,cAAA,GAAGQ,QAAQ,CAC7BlxB,GAAG,CAAClV,OAAO,CAACqmC,OAAO,CAAC,MAAAT,IAAAA,IAAAA,cAAA,uBADCA,cAAA,CAEpB1wB,GAAG,CAAClV,OAAO,CAACsmC,WAAW,CAAC;AAAA,UAAA,IAAA,CAExBT,eAAe,EAAA;AAAArtB,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAA,UAAA,IACZtM,QAAW,CAACy5B,eAAe,CAAC,EAAA;AAAArtB,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;UAAA,OAEzByC,iBAAiB,EAAE;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,OAAA3C,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAEpB4oB,eAAe,CAAA;AAAA,QAAA,KAAA,EAAA;AAKpBC,UAAAA,OAAO,GAAGS,iBAAiB,CAACvmC,OAAO,CAAC;AAC1C,UAAA,IAAI2lC,QAAQ,EAAE;AAGZS,YAAAA,QAAQ,CAAC3e,IAAI,CAACznB,OAAO,CAACqmC,OAAO,CAAC,CAACrsB,GAAG,CAACha,OAAO,CAACsmC,WAAW,EAAER,OAAO,CAAC;AAClE,WAAC,MAAM;AACLA,YAAAA,OAAO,CAAC3hC,EAAE,GAAGnE,OAAO,CAACmmC,GAAG;AAC1B;UAEMJ,mBAAmB,GAAG35B,QAAW,CACrC,CAACpM,OAAO,CAACue,MAAM,CAAC/a,IAAI,IAAI,EAAE,KAAKxD,OAAO,CAACue,MAAM,CAAC9a,KAAK,IAAI,EAAE,CAAC,EAC1D,GACF,CAAC;UAEKuiC,mBAAmB,GAAG55B,QAAW,CACrC,CAACpM,OAAO,CAACue,MAAM,CAAC5a,GAAG,IAAI,EAAE,KAAK3D,OAAO,CAACue,MAAM,CAAC3a,MAAM,IAAI,EAAE,CAAC,EAC1D,GACF,CAAC;AAEGqiC,UAAAA,oBAAoB,GAAG,KAAK;UAC5B7hB,QAAQ,GAAGpkB,OAAO,CAACqmC,OAAO;UAC9B,IAAIN,mBAAmB,IAAIC,mBAAmB,EAAE;AAC9CC,YAAAA,oBAAoB,GACjBF,mBAAmB,IAAIxF,aAAY,CAACnc,QAAQ,EAAE;AAAEoc,cAAAA,IAAI,EAAE;AAAI,aAAC,CAAC,IAC5DwF,mBAAmB,IAAIzF,aAAY,CAACnc,QAAQ,EAAE;AAAEoc,cAAAA,IAAI,EAAE;AAAI,aAAC,CAAE;AAClE;AAAC,UAAA,IAAA,CAEGyF,oBAAoB,EAAA;AAAAztB,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UAAA,IAClBvM,CAAAA,QAAQ,CAACG,sBAAsB,EAAA;AAAAkM,YAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;UAAA,OAChB0M,oBAAoB,CAAChB,QAAQ,CAAC;AAAA,QAAA,KAAA,EAAA;UAA/CA,QAAQ,GAAA5L,QAAA,CAAAqB,IAAA;AAAArB,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,EAAA;UAERoC,OAAO,CACL,oFACF,CAAC;AAAC,QAAA,KAAA,EAAA;UAIN,IAAI9a,OAAO,CAACue,MAAM,CAAC8F,QAAQ,KAAKvmB,UAAa,EAAE;YAE7C6f,UAAU,CAACyG,QAAQ,EAAEhY,UAAa,CAAC,mBAAmB,CAAC,CAAC;AAC1D;AAACoM,UAAAA,QAAA,CAAAE,IAAA,GAAA,EAAA;UAAA,OAEK4L,WAAW,CAACwhB,OAAO,EAAE;AAAEjjB,YAAAA,EAAE,EAAEuB;AAAS,WAAC,CAAC;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,OAAA5L,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAErC6oB,OAAO,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAttB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAN,OAAA,CAAA;GACf,CAAA,CAAA;EAAA,OAhEYqtB,SAAAA,aAAaA,CAAA/qB,EAAA,EAAA;AAAA,IAAA,OAAAtL,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAgEzB,EAAA;AAYD,IAAMkqC,QAAQ,GAAG/e,WAAW,CAAwC,YAAA;AAAA,EAAA,OAClEjb,MAAS,EAAE;AAAA,CACb,CAAC;AAqBD,IAAM85B,mBAAmB,GAAA,YAAA;EAAA,IAAA/rB,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAgC,QAAAA,CAC1BoQ,WAAuC,EAAA;IAAA,IAAAgc,kBAAA,EAAAC,gBAAA;AAAA,IAAA,IAAAjoB,KAAA,EAAAoR,IAAA,EAAAxL,QAAA;AAAA,IAAA,OAAAjM,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;UAEjC8F,KAAK,GAAGkoB,gBAAgB,CAAClc,WAAW,KAAA,IAAA,IAAXA,WAAW,KAAXA,MAAAA,GAAAA,MAAAA,GAAAA,WAAW,CAAEhM,KAAK,CAAC;AAC5CoR,UAAAA,IAAI,IAAA4W,kBAAA,GAAGhc,WAAW,KAAA,IAAA,IAAXA,WAAW,KAAXA,MAAAA,GAAAA,MAAAA,GAAAA,WAAW,CAAEoF,IAAI,cAAA4W,kBAAA,KAAA,MAAA,GAAAA,kBAAA,GAAI,EAAE;AAAAjsB,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,UAAA,OACbiuB,WAAW,CAACnc,WAAW,KAAA,IAAA,IAAXA,WAAW,KAAA,MAAA,GAAA,MAAA,GAAXA,WAAW,CAAEoc,MAAM,EAAEpoB,KAAK,CAAC6F,QAAQ,CAAC;AAAA,QAAA,KAAA,CAAA;UAAjED,QAAQ,GAAA7J,SAAA,CAAAV,IAAA;UAAA,OAAAU,SAAA,CAAA0C,MAAA,CAEP,QAAA,EAAA;AACLopB,YAAAA,OAAO,EAAEjiB,QAAQ;AACjB+hB,YAAAA,GAAG,EAAAM,CAAAA,gBAAA,GAAEjc,WAAW,aAAXA,WAAW,KAAA,MAAA,GAAA,MAAA,GAAXA,WAAW,CAAErmB,EAAE,MAAAsiC,IAAAA,IAAAA,gBAAA,KAAAA,MAAAA,GAAAA,gBAAA,GAAI,EAAE;AAC1BloB,YAAAA,MAAM,EAAEC,KAAK;AACbqoB,YAAAA,KAAK,EAAEjX,IAAI;AACX0W,YAAAA,WAAW,EAAEQ,aAAa,CAACtoB,KAAK,EAAEoR,IAAI;WACvC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAArV,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;GACF,CAAA,CAAA;EAAA,OAdK8rB,SAAAA,mBAAmBA,CAAA9oB,GAAA,EAAA;AAAA,IAAA,OAAAjD,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAcxB,EAAA;AAED,IAAM4qC,aAAa,GAAG,SAAhBA,aAAaA,CACjBtoB,KAA6B,EAC7BoR,IAA4B,EAAA;EAAA,OACzB7b,WAAW,CAACyK,KAAK,CAAC,GAAG,GAAG,GAAGzK,WAAW,CAAC6b,IAAI,CAAC;AAAA,CAAA;AAEjD,IAAM8W,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIloB,KAAyC,EAAK;AACtE,EAAA,IAAMuoB,kBAA0C,GAAG36B,KAAQ,CACzD;IAAEiY,QAAQ,EAAEvmB;GAAe,EAC3B0gB,KACF,CAAC;AAED,EAAA,IACEuoB,kBAAkB,CAAC1iB,QAAQ,KAAKvmB,UAAa,IAC7CipC,kBAAkB,CAAC1iB,QAAQ,KAAKvmB,OAAU,EAC1C;AACA,IAAA,IACEsO,OAAU,CAAC26B,kBAAkB,CAACpjC,GAAG,CAAC,IAClCyI,OAAU,CAAC26B,kBAAkB,CAACnjC,MAAM,CAAC,EACrC;MACAmjC,kBAAkB,CAACpjC,GAAG,GAAG,KAAK;AAChC;AAEA,IAAA,IACEyI,OAAU,CAAC26B,kBAAkB,CAACvjC,IAAI,CAAC,IACnC4I,OAAU,CAAC26B,kBAAkB,CAACtjC,KAAK,CAAC,EACpC;MACAsjC,kBAAkB,CAACvjC,IAAI,GAAG,KAAK;AACjC;AACF;AAEA,EAAA,OAAOujC,kBAAkB;AAC3B,CAAC;AASD,IAAMJ,WAAW,GAAA,YAAA;AAAA,EAAA,IAAAtnB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAkH,QAAAA,CAClB0nB,kBAAkD,EAClD3iB,QAAgB,EAAA;AAAA,IAAA,OAAAlM,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,IAEhBsuB,EAAAA,kBAAkB,aAAlBA,kBAAkB,KAAA,MAAA,CAAA,EAAA;AAAAvnB,YAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UAAA+G,SAAA,CAAA3F,EAAA,GAAlBktB,kBAAkB;AAAAvnB,UAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,EACjB2L,QAAQ,KAAKvmB,OAAU,CAAA,EAAA;AAAA2hB,YAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAA+G,UAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,UAAA,OACdqN,cAAc,CAAC3Z,OAAU,CAAC;AAAA,QAAA,KAAA,CAAA;AAAAqT,UAAAA,SAAA,CAAAgC,EAAA,GAAAhC,SAAA,CAAA5F,IAAA;AAAA4F,UAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,EAAA;AAAA+G,UAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;UAAA,OAC1BoqB,uBAAuB,EAAE;AAAA,QAAA,KAAA,EAAA;AAAArjB,UAAAA,SAAA,CAAAgC,EAAA,GAAAhC,SAAA,CAAA5F,IAAA;AAAA,QAAA,KAAA,EAAA;AAAA4F,UAAAA,SAAA,CAAA3F,EAAA,GAAA2F,SAAA,CAAAgC,EAAA;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,OAAAhC,SAAA,CAAAxC,MAAA,CAAAwC,QAAAA,EAAAA,SAAA,CAAA3F,EAAA,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA2F,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2G,QAAA,CAAA;GAAC,CAAA,CAAA;AAAA,EAAA,OAAA,SAPhCqnB,WAAWA,CAAAtpB,GAAA,EAAA+B,GAAA,EAAA;AAAA,IAAA,OAAAC,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAOqB,EAAA;AAEtC,IAAMqqC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIvmC,OAA+B,EAAK;AAC7D,EAAA,IAAM8lC,OAAO,GAAG15B,aAAgB,CAAC,KAAK,CAAC;EAEvCsQ,aAAa,CAACopB,OAAO,EAAE15B,UAAa,CAAC,SAAS,CAAC,CAAC;AAEhD,EAAA,IAAMwjB,IAAI,GAAG5vB,OAAO,CAAC6mC,KAAK;EAAC,IAAAtwB,SAAA,GAAAC,0BAAA,CACRpK,MAAS,CAACwjB,IAAI,CAAC,CAAA;IAAAnZ,KAAA;AAAA,EAAA,IAAA;IAAlC,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAoC;AAAA,MAAA,IAAzBiX,IAAI,GAAAnX,KAAA,CAAAnS,KAAA;AACb2Z,MAAAA,UAAU,CAAC6nB,OAAO,EAAEnoC,gBAAgB,CAACiwB,IAAI,CAAC,EAAEgC,IAAI,CAAChC,IAAI,CAAC,CAAC;AACzD;AAAC,GAAA,CAAA,OAAA/W,GAAA,EAAA;IAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAAN,IAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAED,EAAA,IAAMyH,KAAK,GAAGxe,OAAO,CAACue,MAAM;EAAC,IAAAoL,UAAA,GAAAnT,0BAAA,CACVpK,MAAS,CAACoS,KAAK,CAAC,CAAA;IAAAoL,MAAA;AAAA,EAAA,IAAA;IAAnC,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAAqC;AAAA,MAAA,IAA1B3P,IAAI,GAAA4iB,MAAA,CAAAtlB,KAAA;MACboa,eAAe,CAAConB,OAAO,EAAE9+B,IAAI,EAAEwX,KAAK,CAACxX,IAAI,CAAC,CAAC;AAC7C;AAAC,GAAA,CAAA,OAAA6P,GAAA,EAAA;IAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,GAAA,SAAA;AAAA8S,IAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;AAED,EAAA,OAAO+uB,OAAO;AAChB,CAAC;;AC3QM,IAAMmB,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIvb,KAA0B,EAAW;AACtE,EAAA,IAAMlmB,IAAI,GAAGkmB,KAAK,CAACwb,cAAc;AAEjC,EAAA,IAAI1hC,IAAI,EAAE;IACR,OAAO2hC,sBAAsB,CAAC3hC,IAAI,CAAC;AACrC;AAEA,EAAA,IAAMnC,IAAI,GAAGqoB,KAAK,CAAC0b,WAAW;EAC9B,OAAA9jC,eAAA,CAAAA,eAAA,CAAUxF,EAAAA,EAAAA,OAAU,EAAGuF,IAAI,CAACvF,OAAU,CAAC,CAAA,EAAGA,QAAW,EAAGuF,IAAI,CAACvF,QAAW,CAAC,CAAA;AAC3E,CAAC;AAcM,IAAMupC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAC5B3b,KAA0B,EAEjB;AAAA,EAAA,IADT4b,iBAAiB,GAAAprC,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAEzB,EAAA,IAAMsJ,IAAI,GAAGkmB,KAAK,CAAC6b,aAAa;AAEhC,EAAA,IAAI/hC,IAAI,EAAE;IACR,OAAO2hC,sBAAsB,CAAC3hC,IAAI,CAAC;GACpC,MAAM,IAAI8hC,iBAAiB,EAAE;IAC5B,OAAOL,kBAAkB,CAACvb,KAAK,CAAC;AAClC;AAEA,EAAA,OAAApoB,eAAA,CAAAA,eAAA,CAAA,EAAA,EAAUxF,OAAU,EAAG0pC,GAAG,CAAG1pC,EAAAA,QAAW,EAAG0pC,GAAG,CAAA;AAChD,CAAC;AAOM,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIC,GAAW,EAAA;AAAA,EAAA,OACpCt7B,QAAW,CAACu7B,SAAS,EAAED,GAAG,CAAC;AAAA,CAAA;AAOtB,IAAME,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAI3G,SAAiB,EAAA;AAAA,EAAA,OAChD70B,QAAW,CAACy7B,cAAc,EAAE5G,SAAS,CAAC;AAAA,CAAA;AAMjC,IAAM6G,qBAAqB,GAAG,SAAxBA,qBAAqBA,GAAA;AAAA,EAAA,OAChCC,eAAe,KAAfA,IAAAA,IAAAA,eAAe,KAAfA,MAAAA,GAAAA,eAAe,GAAI,IAAI;AAAA,CAAA;AAQlB,IAAMC,oBAAoB,GAAA,YAAA;EAAA,IAAA3oB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAC,OAAA,GAAA;AAAA,IAAA,OAAAF,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,QAAA,KAAA,CAAA;AAAAF,UAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;UAAA,OAC5BqqB,IAAI,EAAE;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,OAAAvqB,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAEL8qB,eAAe,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAvvB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAN,OAAA,CAAA;GACvB,CAAA,CAAA;AAAA,EAAA,OAAA,SAJY2vB,oBAAoBA,GAAA;AAAA,IAAA,OAAA3oB,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAIhC,EAAA;AAMM,IAAM+rC,iBAAiB,GAAA,YAAA;EAAA,IAAAroB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAgC,QAAA,GAAA;AAAA,IAAA,IAAA8tB,qBAAA;AAAA,IAAA,IAAAC,QAAA;MAAAlrC,IAAA;AAAAmrC,MAAAA,MAAA,GAAAlsC,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,QAAA,KAAA,CAAA;UAAOyvB,QAAQ,GAAAC,MAAA,CAAAzrC,MAAA,GAAA,CAAA,IAAAyrC,MAAA,CAAA,CAAA,CAAA,KAAAxrC,SAAA,GAAAwrC,MAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAAA,UAAA,IACjDD,QAAQ,EAAA;AAAA5tB,YAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA6B,UAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;UAAA,OACL4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;UAGtBre,IAAI,GAAGmP,MAAS,EAAE,GAAA87B,CAAAA,qBAAA,GACnB97B,sBAAyB,EAAE,MAAA,IAAA,IAAA87B,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI97B,OAAU,EAAE,GAC5C,IAAI;AAAA,UAAA,OAAAmO,SAAA,CAAA0C,MAAA,CAAA3Z,QAAAA,EAAAA,eAAA,CAAAA,eAAA,CAAA,EAAA,EAGLxF,OAAU,EAAG,CAAAb,IAAI,KAAA,IAAA,IAAJA,IAAI,KAAJA,MAAAA,GAAAA,MAAAA,GAAAA,IAAI,CAAEorC,WAAW,KAAI,CAAC,CAAA,EACnCvqC,QAAW,EAAG,CAAAb,IAAI,KAAA,IAAA,IAAJA,IAAI,KAAJA,MAAAA,GAAAA,MAAAA,GAAAA,IAAI,CAAEqrC,YAAY,KAAI,CAAC,CAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA/tB,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAyB,QAAA,CAAA;GAEzC,CAAA,CAAA;AAAA,EAAA,OAAA,SAbY6tB,iBAAiBA,GAAA;AAAA,IAAA,OAAAroB,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAa7B,EAAA;AAID,IAAMqsC,aAAa,GAAG,YAAY;AAClC,IAAMC,YAAY,GAAG,WAAW;AAEhC,IAAMb,SAAgB,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAU;AACvD,IAAME,cAA2B,GAAG,CAAC/pC,OAAU,EAAEA,QAAW,CAAU;AAEtE,IAAMqpC,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAC1B3hC,IAA4D,EACnD;AAET,EAAA,IAAI4G,gBAAmB,CAAC5G,IAAI,CAAC,EAAE;IAC7B,OAAAlC,eAAA,CAAAA,eAAA,CACGxF,EAAAA,EAAAA,OAAU,EAAG0H,IAAI,CAAC,CAAC,CAAC,CAAC+iC,aAAa,CAAC,CAAA,EACnCzqC,QAAW,EAAG0H,IAAI,CAAC,CAAC,CAAC,CAACgjC,YAAY,CAAC,CAAA;AAExC;EACA,OAAAllC,eAAA,CAAAA,eAAA,CAAA,EAAA,EAEGxF,OAAU,EAAI0H,IAAI,CAAiC+iC,aAAa,CAAC,CAAA,EACjEzqC,QAAW,EAAI0H,IAAI,CAAgCgjC,YAAY,CAAC,CAAA;AAErE,CAAC;AAID,IAAIT,eAA4B;AAChC,IAAIvC,WAAiC,GAAG,IAAI;AAC5C,IAAMzC,IAAI,GAAG,SAAPA,IAAIA,GAAwB;EAChC,IAAI,CAACyC,WAAW,EAAE;IAChBA,WAAW,GAAGttB,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAAkH,QAAA,GAAA;AAAA,MAAA,OAAAnH,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,QAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,UAAA,KAAA,CAAA;AAAA+G,YAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,YAAA,OACWgtB,aAAa,CAAC;AACpCvhC,cAAAA,EAAE,EAAEiI,UAAa,CAAC,SAAS,CAAC;cAC5BoS,KAAK,EAAAlb,eAAA,CAAAA,eAAA,CAAA;AACH+gB,gBAAAA,QAAQ,EAAE;eACTvmB,EAAAA,OAAU,EAAG,OAAO,GACpBA,QAAW,EAAG,OAAO;AAE1B,aAAC,CAAC;AAAA,UAAA,KAAA,CAAA;YAPFiqC,eAAe,GAAAtoB,SAAA,CAAA5F,IAAA;AAAA,UAAA,KAAA,CAAA;AAAA,UAAA,KAAA,KAAA;YAAA,OAAA4F,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,OAAA,EAAA2G,QAAA,CAAA;AAAA,KAQhB,IAAG;AACN;AAEA,EAAA,OAAOkmB,WAAW;AACpB,CAAC;;ACnIYiD,IAAAA,eAAe,GAAArsC,YAAA,CA4B1B,SAAAqsC,eAAY79B,CAAAA,QAAiC,EAAEkN,cAAuB,EAAE;AAAA,EAAA,IAAArb,KAAA,GAAA,IAAA;AAAAT,EAAAA,eAAA,OAAAysC,eAAA,CAAA;AAKtE,EAAA,IAAMtgB,MAAM,GAAG/b,MAAS,EAAgC;AAKxD,EAAA,IAAMs8B,aAAa,GAAGt8B,UAAa,EAAkB;AAErD,EAAA,IAAIu8B,eAAe,GAAGv8B,UAAa,EAAW;EAE9C0L,cAAc,GAAGA,cAAc,IAAI,CAAC;EAEpC,IAAIE,KAA2C,GAAG,IAAI;AACtD,EAAA,IAAM4wB,aAAa,GAAG,SAAhBA,aAAaA,CAAI1+B,OAA8B,EAAK;AAAA,IAAA,IAAAqM,SAAA,GAAAC,0BAAA,CAGpCtM,OAAO,CAAA;MAAAuM,KAAA;AAAA,IAAA,IAAA;MAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,QAAA,IAAlB+U,KAAK,GAAAjV,KAAA,CAAAnS,KAAA;AACd,QAAA,IAAM/C,MAAM,GAAG6K,QAAW,CAACsf,KAAK,CAAC;AACjC,QAAA,IAAMmd,OAAO,GAAGH,aAAa,CAACxzB,GAAG,CAAC3T,MAAM,CAAC;QACzC,IAAIsnC,OAAO,KAAKjsC,SAAS,EAAE;UACzB,IAAIisC,OAAO,KAAK,CAAC,EAAE;AAEjBH,YAAAA,aAAa,CAAC1uB,GAAG,CAACzY,MAAM,EAAE,CAAC,CAAC;AAC9B,WAAC,MAAM;YAGL,IAAIsnC,OAAO,KAAK,CAAC,EAAE;cACjB7tB,QAAQ,CAAC5O,QAAW,CAAA,qBAAA,CAAA5S,MAAA,CAAuBqvC,OAAO,CAAE,CAAC,CAAC;AACxD;AACAz8B,YAAAA,SAAY,CAACs8B,aAAa,EAAEnnC,MAAM,CAAC;AACrC;AAEA,UAAA;AACF;AAEA4mB,QAAAA,MAAM,CAACnO,GAAG,CAACzY,MAAM,EAAEmqB,KAAK,CAAC;AAC3B;AAAC,KAAA,CAAA,OAAA7U,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;IAQD,IAAI,CAACiB,KAAK,IAAI5L,MAAS,CAAC+b,MAAM,CAAC,EAAE;AAC/BnQ,MAAAA,KAAK,GAAG5L,QAAW,CAAC,YAAM;AACxB,QAAA,IAAIA,MAAS,CAAC+b,MAAM,CAAC,EAAE;AACrBvd,UAAAA,QAAQ,CAACwB,SAAY,CAAC+b,MAAM,CAAC5d,MAAM,EAAE,CAAC,EAAE9N,KAAI,CAAC;UAC7C0rB,MAAM,CAACL,KAAK,EAAE;AAChB;AAEA9P,QAAAA,KAAK,GAAG,IAAI;OACb,EAAEF,cAAc,CAAC;AACpB;GACD;AAED,EAAA,IAAMgxB,cAAc,GAAG18B,iBAAoB,CAACw8B,aAAa,CAAC;AAC1D,EAAA,IAAMG,eAAe,GAAG38B,iBAAoB,CAACw8B,aAAa,CAAC;AAC3D,EAAA,IAAI,CAACE,cAAc,IAAI,CAACC,eAAe,EAAE;IACvCjuB,OAAO,CACL,yEACF,CAAC;AACH;AAEA,EAAA,IAAMkuB,aAAa,GAAG,SAAhBA,aAAaA,CAAIznC,MAAe,EAAK;AACzConC,IAAAA,eAAe,CAACjvB,GAAG,CAACnY,MAAM,CAAC;IAC3BunC,cAAc,KAAA,IAAA,IAAdA,cAAc,KAAdA,MAAAA,IAAAA,cAAc,CAAE1iB,OAAO,CAAC7kB,MAAM,EAAE;AAAEmmC,MAAAA,GAAG,EAAE;AAAa,KAAC,CAAC;IACtDqB,eAAe,KAAA,IAAA,IAAfA,eAAe,KAAfA,MAAAA,IAAAA,eAAe,CAAE3iB,OAAO,CAAC7kB,MAAM,CAAC;GACjC;EAID,IAAI,CAAC6kB,OAAO,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAAlgB,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAP6iC,MAAAA,OAAO,CAAA7iC,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AAGxB,IAAA,KAAA,IAAAic,EAAA,GAAA,CAAA,EAAA6mB,QAAA,GAAqBD,OAAO,EAAA5mB,EAAA,GAAA6mB,QAAA,CAAAvsC,MAAA,EAAA0lB,EAAA,EAAE,EAAA;AAAzB,MAAA,IAAM9gB,MAAM,GAAA2nC,QAAA,CAAA7mB,EAAA,CAAA;MACf2mB,aAAa,CAACznC,MAAM,CAAC;AACvB;GACD;EAED,IAAI,CAAC4nC,YAAY,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAA3zB,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAA+e,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAPwzB,MAAAA,OAAO,CAAAxzB,KAAA,CAAAvZ,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;AAE7B,IAAA,KAAA,IAAA2zB,GAAA,GAAA,CAAA,EAAAC,SAAA,GAAqBJ,OAAO,EAAAG,GAAA,GAAAC,SAAA,CAAA1sC,MAAA,EAAAysC,GAAA,EAAE,EAAA;AAAzB,MAAA,IAAM7nC,MAAM,GAAA8nC,SAAA,CAAAD,GAAA,CAAA;AAGf,MAAA,IAAIT,eAAe,CAAC9yB,GAAG,CAACtU,MAAM,CAAC,EAAE;AAC/B,QAAA;AACF;AAEAmnC,MAAAA,aAAa,CAAC1uB,GAAG,CAACzY,MAAM,EAAE,CAAC,CAAC;MAC5BynC,aAAa,CAACznC,MAAM,CAAC;AACvB;GACD;EAED,IAAI,CAAC+nC,SAAS,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAA75B,KAAA,GAAAvT,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAAgZ,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAPu5B,MAAAA,OAAO,CAAAv5B,KAAA,CAAAxT,GAAAA,SAAA,CAAAwT,KAAA,CAAA;AAAA;AAG1B,IAAA,KAAA,IAAA65B,GAAA,GAAA,CAAA,EAAAC,SAAA,GAAqBP,OAAO,EAAAM,GAAA,GAAAC,SAAA,CAAA7sC,MAAA,EAAA4sC,GAAA,EAAE,EAAA;AAAzB,MAAA,IAAMhoC,MAAM,GAAAioC,SAAA,CAAAD,GAAA,CAAA;AACfn9B,MAAAA,SAAY,CAACu8B,eAAe,EAAEpnC,MAAM,CAAC;MACrCunC,cAAc,KAAA,IAAA,IAAdA,cAAc,KAAdA,MAAAA,IAAAA,cAAc,CAAEQ,SAAS,CAAC/nC,MAAM,CAAC;MACjCwnC,eAAe,KAAA,IAAA,IAAfA,eAAe,KAAfA,MAAAA,IAAAA,eAAe,CAAEO,SAAS,CAAC/nC,MAAM,CAAC;AACpC;GACD;EAED,IAAI,CAAC4kB,UAAU,GAAG,YAAM;AAEtBwiB,IAAAA,eAAe,GAAGv8B,UAAa,EAAE;AACjC08B,IAAAA,cAAc,aAAdA,cAAc,KAAA,MAAA,IAAdA,cAAc,CAAE3iB,UAAU,EAAE;AAC5B4iB,IAAAA,eAAe,aAAfA,eAAe,KAAA,MAAA,IAAfA,eAAe,CAAE5iB,UAAU,EAAE;GAC9B;AACH,CAAC,CAAA;;AC5HH,IAAasjB,WAAW,GAAA,YAAA;AA+GtB,EAAA,SAAAA,WACExhB,CAAAA,MAAiC,EACjC3e,GAA2B,EAC3B;AAAAtN,IAAAA,eAAA,OAAAytC,WAAA,CAAA;IACA,IAAIngC,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,oBAAoB,CAAC;AACxD;AAMA,IAAA,IAAMs9B,WAAW,GAAGt9B,UAAa,EAAqB;IAEtD,IAAMsc,YAAY,GAAGrB,WAAW,CAG9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;AAIpB,IAAA,IAAMw8B,aAAa,GAAG,SAAhBA,aAAaA,CAAI1+B,OAA8B,EAAK;AAAA,MAAA,IAAAqM,SAAA,GAAAC,0BAAA,CACpCtM,OAAO,CAAA;QAAAuM,KAAA;AAAA,MAAA,IAAA;QAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,UAAA,IAAlB+U,KAAK,GAAAjV,KAAA,CAAAnS,KAAA;UACdqlC,YAAY,CAACje,KAAK,CAAC;AACrB;AAAC,OAAA,CAAA,OAAA7U,GAAA,EAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAN,QAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;KACF;AAGD,IAAA,IAAM6yB,SAAS,GAAG,IAAInB,eAAe,CAACG,aAAa,CAAC;AAIpD,IAAA,IAAMiB,gBAAgB,GAAA,YAAA;MAAA,IAAAx6B,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,OAAAA,CACvB9W,MAA8B,EAAA;QAAA,IAAAiH,OAAA,EAAAshC,QAAA;AAAA,QAAA,OAAA3xB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;cAAA,OAERqxB,cAAY,CAACxoC,MAAM,CAAC;AAAA,YAAA,KAAA,CAAA;cAApCiH,OAAO,GAAAgQ,QAAA,CAAAqB,IAAA;AACPiwB,cAAAA,QAAQ,GAAGJ,WAAW,CAACx0B,GAAG,CAAC1M,OAAO,CAAC;AAAA,cAAA,IAAA,CACrCshC,QAAQ,EAAA;AAAAtxB,gBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;cAAA,OAAAF,QAAA,CAAAyE,MAAA,CAAA,QAAA,EACH7Q,UAAa,CAAC09B,QAAQ,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;cAAA,OAAAtxB,QAAA,CAAAyE,MAAA,CAGzB7Q,QAAAA,EAAAA,UAAa,CAAC,UAAC3F,OAAO,EAAK;gBAEhC,IAAMyf,QAAQ,GAAG9Z,iBAAoB,CAAC,UAAClC,OAAO,EAAK;kBACjD,IAAM4/B,QAAQ,GAAGE,WAAW,CAAC9/B,OAAO,CAAC,CAAC,CAAC,CAAC;AACxCgc,kBAAAA,QAAQ,aAARA,QAAQ,KAAA,MAAA,IAARA,QAAQ,CAAEC,UAAU,EAAE;kBACtB1f,OAAO,CAACqjC,QAAQ,CAAC;AACnB,iBAAC,CAAC;AAEF,gBAAA,IAAI5jB,QAAQ,EAAE;AACZA,kBAAAA,QAAQ,CAACE,OAAO,CAAC5d,OAAO,CAAC;AAC3B,iBAAC,MAAM;AAEL/B,kBAAAA,OAAO,CAAC;AACNwjC,oBAAAA,MAAM,EAAA3mC,eAAA,CAAAA,eAAA,CAAA,EAAA,EAAKxF,OAAU,EAAG,CAAC,GAAGA,QAAW,EAAG,CAAC,CAAE;AAC7CosC,oBAAAA,OAAO,EAAA5mC,eAAA,CAAAA,eAAA,KAAKxF,OAAU,EAAG,CAAC,CAAGA,EAAAA,QAAW,EAAG,CAAC;AAC9C,mBAAC,CAAC;AACJ;AACF,eAAC,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA0a,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OACH,CAAA,CAAA;MAAA,OA3BKwxB,SAAAA,gBAAgBA,CAAAlvB,EAAA,EAAA;AAAA,QAAA,OAAAtL,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KA2BrB,EAAA;AAID,IAAA,IAAMiuC,YAAY,GAAA,YAAA;MAAA,IAAAhwB,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAgC,QAAAA,CACnBpa,OAAwB,EAAA;AAAA,QAAA,IAAAoqC,YAAA,EAAAC,kBAAA,EAAAC,qBAAA;QAAA,IAAA5C,GAAA,EAAAzG,SAAA;AAAA,QAAA,OAAA9oB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,YAAA,KAAA,CAAA;cAElBgvB,GAAG,GAAA,CAAA0C,YAAA,GAAGpqC,OAAO,CAAC0nC,GAAG,MAAA,IAAA,IAAA0C,YAAA,KAAA,MAAA,GAAAA,YAAA,GAAI,IAAI;AAAA,cAAA,IAAA,EAC3B1C,GAAG,IAAI,CAACD,UAAU,CAACC,GAAG,CAAC,CAAA,EAAA;AAAAntB,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;cAAA,MACnBtM,UAAa,CAAA,qBAAA,CAAA5S,MAAA,CAAuBkuC,GAAG,MAAG,CAAC;AAAA,YAAA,KAAA,CAAA;cAG7CzG,SAAS,GAAA,CAAAoJ,kBAAA,GAAGrqC,OAAO,CAACihC,SAAS,MAAA,IAAA,IAAAoJ,kBAAA,KAAA,MAAA,GAAAA,kBAAA,GAAI,IAAI;AAAA,cAAA,IAAA,EACvCpJ,SAAS,IAAI,CAAC2G,gBAAgB,CAAC3G,SAAS,CAAC,CAAA,EAAA;AAAA1mB,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;cAAA,MACrCtM,UAAa,CAAA,sBAAA,CAAA5S,MAAA,CAAwBynC,SAAS,MAAG,CAAC;AAAA,YAAA,KAAA,CAAA;AAAA1mB,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OAIxCqxB,cAAY,CAAC39B,QAAW,CAACpM,OAAO,CAAC,CAAC;AAAA,YAAA,KAAA,CAAA;AAAAua,cAAAA,SAAA,CAAAT,EAAA,GAAAS,SAAA,CAAAV,IAAA;cAAAU,SAAA,CAAAkH,EAAA,GAC5CimB,GAAG;cAAAntB,SAAA,CAAAoH,EAAA,GACGsf,SAAS;AAAA1mB,cAAAA,SAAA,CAAAqH,EAAA,GAGnB7S,WAAW,CAAC/O,OAAO,CAACuqC,SAAS,EAAEtiB,MAAM,CAACuiB,gBAAgB,CAAC,IAAI,CAAC;AAAAjwB,cAAAA,SAAA,CAAAkwB,EAAA,GAAA,CAAAH,qBAAA,GAE5DtqC,OAAO,CAAClC,iBAAoB,CAAC,cAAAwsC,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAIriB,MAAM,CAACkT,eAAe;cAAA,OAAA5gB,SAAA,CAAA0C,MAAA,CAAA,QAAA,EAAA;gBAPzDytB,QAAQ,EAAAnwB,SAAA,CAAAT,EAAA;gBACR6wB,IAAI,EAAApwB,SAAA,CAAAkH,EAAA;gBACJmpB,UAAU,EAAArwB,SAAA,CAAAoH,EAAA;gBAEVkpB,UAAU,EAAAtwB,SAAA,CAAAqH,EAAA;gBAEVuZ,eAAe,EAAA5gB,SAAA,CAAAkwB;AAAA,eAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAlwB,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAyB,QAAA,CAAA;OAGlB,CAAA,CAAA;MAAA,OAvBK+vB,SAAAA,YAAYA,CAAA/sB,GAAA,EAAA;AAAA,QAAA,OAAAjD,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAuBjB,EAAA;IAID,IAAMguB,cAAc,GAAG,SAAjBA,cAAcA,CAClBnS,OAAwB,EACxB/X,OAAgC,EACd;AAAA,MAAA,IAAAmqB,iBAAA;AAClB,MAAA,IAAM3hB,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAChCt+B,MAAAA,MAAS,CAAA+d,CAAAA,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAA2hB,iBAAA,KAAA,MAAA,IAAA,CAAAA,iBAAA,GAAzBA,iBAAA,CAA2BjV,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,KAAvCA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAA,CAAyCC,SAAS,CAAC;MAG7D,IAAMxf,QAAQ,GAAGkO,aAAY,CAACf,OAAO,EAAE/X,OAAO,CAACm7B,eAAe,CAAC;MAC/DvwB,QAAQ,CAACyO,QAAQ,CAAC,YAAM;AACtBgR,QAAAA,aAAa,CAACtS,OAAO,EAAE/X,OAAO,CAAC;AACjC,OAAC,CAAC;AAEF,MAAA,IAAM0rB,KAAK,GAAG;AAAEtB,QAAAA,SAAS,EAAExf,QAAQ;AAAE0f,QAAAA,QAAQ,EAAEtqB;OAAS;MACxD0oB,YAAY,CAACjB,IAAI,CAACjf,OAAO,CAAC,CAACwR,GAAG,CAACjC,OAAO,EAAE2T,KAAK,CAAC;AAC9C,MAAA,OAAOA,KAAK;KACb;AAID,IAAA,IAAMof,aAAa,GAAA,YAAA;AAAA,MAAA,IAAAzrB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAkH,QAAAA,CACpBvH,OAAwB,EACxByS,WAAwC,EAAA;QAAA,IAAAxqB,OAAA,EAAAwI,OAAA,EAAAkjB,KAAA,EAAA9gB,QAAA,EAAAk/B,QAAA;AAAA,QAAA,OAAA3xB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA+G,cAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,cAAA,OAElByxB,YAAY,CAAC3f,WAAW,IAAI,EAAE,CAAC;AAAA,YAAA,KAAA,CAAA;cAA/CxqB,OAAO,GAAAyf,SAAA,CAAA5F,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAM1Bhf,cAAAA,KAAK,GAAGxB,cAAc,CAACnS,OAAO,EAAE/X,OAAO,CAAC;cACxC4K,QAAQ,GAAG8gB,KAAK,CAACtB,SAAS;AAAA3K,cAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;cAAA,OACTmxB,gBAAgB,CAACrhC,OAAO,CAAC;AAAA,YAAA,KAAA,CAAA;cAA1CshC,QAAQ,GAAArqB,SAAA,CAAA5F,IAAA;AAAA,cAAA,IAAA,CAEVjP,QAAQ,CAACoO,SAAS,EAAE,EAAA;AAAAyG,gBAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAA+G,SAAA,CAAAxC,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAIxByO,KAAK,CAACmb,KAAK,GAAGiD,QAAQ;AACtBJ,cAAAA,WAAW,CAAC1vB,GAAG,CAACxR,OAAO,EAAEshC,QAAQ,CAAC;AAOlCF,cAAAA,SAAS,CAACT,YAAY,CAAC3gC,OAAO,CAAC;AAAC,cAAA,IAE3BgiB,WAAW,KAAXA,IAAAA,IAAAA,WAAW,KAAXA,MAAAA,IAAAA,WAAW,CAAES,WAAW,EAAA;AAAAxL,gBAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AACwC+G,cAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;cAAA,OAE7D4S,gBAAc,CAACxS,aAAY,CAACf,OAAO,CAAC,EAAEvP,OAAO,EAAEshC,QAAQ,CAAC;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAArqB,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA2G,QAAA,CAAA;OAEjE,CAAA,CAAA;AAAA,MAAA,OAAA,SAlCKwrB,aAAaA,CAAAztB,GAAA,EAAA+B,GAAA,EAAA;AAAA,QAAA,OAAAC,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAkClB,EAAA;AAID,IAAA,IAAM6uC,cAAc,GAAA,YAAA;AAAA,MAAA,IAAAnrB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAyH,QAAAA,CACrB9H,OAAwB,EACxBxW,MAA8B,EAAA;AAAA,QAAA,IAAAkrB,kBAAA;AAAA,QAAA,IAAAzsB,OAAA,EAAAwI,OAAA,EAAAwiC,SAAA;AAAA,QAAA,OAAA7yB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA2H,cAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,cAAA,OAERyxB,YAAY,CAAC;AAAE5oC,gBAAAA,MAAM,EAANA;AAAO,eAAC,CAAC;AAAA,YAAA,KAAA,CAAA;cAAxCvB,OAAO,GAAAqgB,SAAA,CAAAxG,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAC1BM,cAAAA,SAAS,IAAAve,kBAAA,GAAG/D,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAikB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvX,GAAG,CAAC6C,OAAO,CAAC;AACzD,cAAA,IAAIizB,SAAS,EAAE;AACb5+B,gBAAAA,MAAS,CAAC4+B,SAAS,CAAC5gB,SAAS,CAAC;gBAE9B,IAAIrS,OAAO,KAAKkzB,eAAe,EAAE;AAE/BA,kBAAAA,eAAe,CAACziC,OAAO,EAAE,IAAI,CAAC;AAChC;AACF;AAAC,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA6X,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAkH,QAAA,CAAA;OACF,CAAA,CAAA;AAAA,MAAA,OAAA,SAfKkrB,cAAcA,CAAAprB,GAAA,EAAAY,GAAA,EAAA;AAAA,QAAA,OAAAX,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAenB,EAAA;IAID,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CACjBtS,OAAwB,EACxB/X,OAAgC,EAC7B;AACH,MAAA,IAAMwI,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;MAChCt+B,SAAY,CAACsc,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,EAAEuP,OAAO,CAAC;AAChD2Q,MAAAA,YAAY,CAAChB,KAAK,CAAClf,OAAO,CAAC;AAE3B,MAAA,IAAI,CAACkgB,YAAY,CAAC7S,GAAG,CAACrN,OAAO,CAAC,EAAE;AAK9BohC,QAAAA,SAAS,CAACN,SAAS,CAAC9gC,OAAO,CAAC;AAC5B4D,QAAAA,SAAY,CAACs9B,WAAW,EAAElhC,OAAO,CAAC;AACpC;KACD;AAID,IAAA,IAAMmhC,YAAY,GAAG,SAAfA,YAAYA,CAAIje,KAA0B,EAAK;AAAA,MAAA,IAAAoP,kBAAA;AAEnD,MAAA,IAAMtyB,OAAO,GAAG4D,QAAW,CAACsf,KAAK,CAAC;AAElC,MAAA,IAAMwf,UAAU,GAAGlB,WAAW,CAACte,KAAK,CAAC;AACrCge,MAAAA,WAAW,CAAC1vB,GAAG,CAACxR,OAAO,EAAE0iC,UAAU,CAAC;MAEwB,IAAAvhB,UAAA,GAAAnT,0BAAA,CAExC,EAAAskB,kBAAA,GAAApS,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAsyB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvwB,MAAM,EAAE,KAAI,EAAE,CAAA;QAAAqf,MAAA;AAAA,MAAA,IAAA;QAA7D,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAA+D;AAAA,UAAA,IAApD+U,MAAK,GAAA9B,MAAA,CAAAtlB,KAAA;AACd,UAAA,IAAM6mC,kBAAkB,GAAGC,sBAAoB,CAC7C1f,MAAK,CAACpB,QAAQ,EACd4gB,UAAU,EACVxf,MAAK,CAACmb,KACR,CAAC;UAED,IAAI,CAACsE,kBAAkB,EAAE;AAEvB,YAAA;AACF;UAEAzf,MAAK,CAACmb,KAAK,GAAGqE,UAAU;UAExB5f,gBAAc,CAACI,MAAK,CAACtB,SAAS,EAAE5hB,OAAO,EAAE0iC,UAAU,CAAC;AACtD;AAAC,OAAA,CAAA,OAAAr0B,GAAA,EAAA;QAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAA8S,QAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;KACF;IAID,IAAI,CAAC8yB,gBAAgB,GAAGA,gBAAgB;AAIxC,IAAA,IAAI,CAACwB,SAAS,GAAA,YAAA;AAAA,MAAA,IAAA1qB,KAAA,GAAAzI,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAwI,QAAAA,CAAO7I,OAAQ,EAAE/X,OAAQ,EAAA;AAAA,QAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,YAAA,KAAA,CAAA;cACxC,IAAI,CAACX,OAAO,EAAE;AACZA,gBAAAA,OAAO,GAAGkzB,eAAe;AAC3B;cAAC,OAAA3pB,SAAA,CAAArE,MAAA,CAAA,QAAA,EAEM6tB,aAAa,CAAC/yB,OAAO,EAAE/X,OAAO,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAshB,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAiI,QAAA,CAAA;OACvC,CAAA,CAAA;MAAA,OAAAJ,UAAAA,GAAA,EAAAC,GAAA,EAAA;AAAA,QAAA,OAAAE,KAAA,CAAAra,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;AAAA,KAAA,EAAA;AAID,IAAA,IAAI,CAACovC,WAAW,GAAG,UAACvzB,OAAQ,EAAExW,MAAO,EAAK;MACxC,IAAI,CAACwW,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAGkzB,eAAe;AAC3B;AAEAF,MAAAA,cAAc,CAAChzB,OAAO,EAAExW,MAAM,CAAC;KAChC;IAID,IAAI,CAACgqC,QAAQ,GAAGT,aAAa;AAI7B,IAAA,IAAI,CAACU,SAAS,GAAG,UAACzzB,OAAO,EAAExW,MAAO,EAAK;AACrCwpC,MAAAA,cAAc,CAAChzB,OAAO,EAAExW,MAAM,CAAC;KAChC;AACH;EAAC,OAAAnF,YAAA,CAAAqtC,WAAA,EAAA,IAAA,EAAA,CAAA;IAAAngC,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA/QD,SAAOyQ,MAAMA,GAAiC;AAAA,MAAA,IAAhCkT,MAAyB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC1C,OAAO,IAAIutC,WAAW,CAAC/c,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC5D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAiC;AAAA,MAAA,IAAhC1E,MAAyB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AACzC,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC8Y,QAAQ,CAAC;AAE1C,MAAA,IAAIE,QAAQ,GAAGC,WAAS,CAAC9X,GAAG,CAAC4X,YAAY,CAAC;MAC1C,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAI0c,WAAW,CAAC5c,QAAQ,EAAE3E,iBAAe,CAAC;AACrD8E,QAAAA,WAAS,CAAChT,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AACvC;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AA6XH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG5gB,MAAS,EAAuB;AAElD,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CAAIzE,MAAyB,EAAgC;EAC1E,OAAO;IACLkT,eAAe,EAAEpsB,WAAW,CAACkZ,MAAM,CAACnqB,iBAAoB,CAAC,EAAE,EAAE,CAAC;IAE9D0sC,gBAAgB,EAAEz7B,WAAW,CAACkZ,MAAM,CAACwjB,eAAe,EAAE,EAAE,CAAC,IAAI;GAC9D;AACH,CAAC;AAID,IAAML,sBAAoB,GAAG,SAAvBA,oBAAoBA,CACxBprC,OAAgC,EAChCkrC,UAAoB,EACpBQ,iBAAuC,EAC3B;EACZ,IAAI,CAACA,iBAAiB,EAAE;AAEtB,IAAA,OAAO,KAAK;AACd;EAEA,IAAIhE,GAAQ,EAAEiE,GAAc;EAC5B,KAAKjE,GAAG,IAAIwD,UAAU,EAAE;IACtB,IAAIlrC,OAAO,CAAC2qC,IAAI,IAAI3qC,OAAO,CAAC2qC,IAAI,KAAKjD,GAAG,EAAE;AACxC,MAAA;AACF;AAEA,IAAA,KAAKiE,GAAG,IAAIT,UAAU,CAACxD,GAAG,CAAC,EAAE;MAC3B,IAAI1nC,OAAO,CAAC4qC,UAAU,IAAI5qC,OAAO,CAAC4qC,UAAU,KAAKe,GAAG,EAAE;AACpD,QAAA;AACF;MAEA,IAAMC,IAAI,GAAGx/B,GAAM,CAAC8+B,UAAU,CAACxD,GAAG,CAAC,CAACiE,GAAG,CAAC,GAAGD,iBAAiB,CAAChE,GAAG,CAAC,CAACiE,GAAG,CAAC,CAAC;AACvE,MAAA,IAAIC,IAAI,IAAI5rC,OAAO,CAAC6qC,UAAU,EAAE;AAC9B,QAAA,OAAO,IAAI;AACb;AACF;AACF;AAEA,EAAA,OAAO,KAAK;AACd,CAAC;AAED,IAAMb,WAAW,GAAG,SAAdA,WAAWA,CAAIte,KAA0B,EAAe;AAC5D,EAAA,IAAMmgB,SAAS,GAAGxE,iBAAiB,CAAC3b,KAAK,EAAE,IAAI,CAAC;AAChD,EAAA,IAAMogB,UAAU,GAAG7E,kBAAkB,CAACvb,KAAK,CAAC;EAE5C,OAAO;AACLue,IAAAA,MAAM,EAAE4B,SAAS;AACjB3B,IAAAA,OAAO,EAAE4B;GACV;AACH,CAAC;AAED,IAAMb,eAAe,GAAG,SAAlBA,eAAeA,CACnBziC,OAAgB,EAChBshC,QAAqC,EAClC;EACH,IAAIlL,MAAM,GAAG,EAAE;AACf,EAAA,IAAIp2B,OAAO,KAAKs/B,qBAAqB,EAAE,EAAE;AAEvCt/B,IAAAA,OAAO,GAAG4D,aAAgB,EAAE;AAC5BwyB,IAAAA,MAAM,GAAG,SAAS;AACpB;AAEA,EAAA,IAAM3e,KAAK,GAAG;AACZ8rB,IAAAA,WAAW,EAAEjC,QAAQ,KAARA,IAAAA,IAAAA,QAAQ,KAARA,MAAAA,GAAAA,MAAAA,GAAAA,QAAQ,CAAEG,MAAM,CAACnsC,OAAU,CAAC;AACzCkuC,IAAAA,YAAY,EAAElC,QAAQ,KAARA,IAAAA,IAAAA,QAAQ,KAARA,MAAAA,GAAAA,MAAAA,GAAAA,QAAQ,CAAEG,MAAM,CAACnsC,QAAW,CAAC;AAC3CmuC,IAAAA,YAAY,EAAEnC,QAAQ,KAARA,IAAAA,IAAAA,QAAQ,KAARA,MAAAA,GAAAA,MAAAA,GAAAA,QAAQ,CAAEI,OAAO,CAACpsC,OAAU,CAAC;IAC3CouC,aAAa,EAAEpC,QAAQ,KAAA,IAAA,IAARA,QAAQ,KAAA,MAAA,GAAA,MAAA,GAARA,QAAQ,CAAEI,OAAO,CAACpsC,QAAW;GAC7C;AACD4iB,EAAAA,oBAAoB,CAAClY,OAAO,EAAEyX,KAAK,EAAE;AAAEuB,IAAAA,OAAO,EAAEod;AAAO,GAAC,CAAC;AAC3D,CAAC;AAED,IAAMmL,cAAY,GAAA,YAAA;EAAA,IAAAxlB,KAAA,GAAArM,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAoM,QAAAA,CACnBjjB,MAA8B,EAAA;AAAA,IAAA,OAAA4W,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAmM,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAjM,IAAA,GAAAiM,SAAA,CAAAhM,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CAE1BtM,SAAY,CAAC7K,MAAM,CAAC,EAAA;AAAAmjB,YAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,QAAA,EACf1b,MAAM,CAAA;AAAA,QAAA,KAAA,CAAA;UAAA,IAGX,EAAA,CAACA,MAAM,IAAIA,MAAM,KAAK6K,SAAY,EAAE,CAAA,EAAA;AAAAsY,YAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAC/B+qB,QAAAA,EAAAA,oBAAoB,EAAE,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,EAG3BzmC,MAAM,KAAK6K,MAAS,EAAE,CAAA,EAAA;AAAAsY,YAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,QAAA,EACjB7Q,aAAgB,EAAE,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,MAGrBA,UAAa,CAAC,2BAA2B,CAAC;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAsY,SAAA,CAAA/L,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA6L,QAAA,CAAA;GACjD,CAAA,CAAA;EAAA,OAhBKulB,SAAAA,YAAYA,CAAAjoB,GAAA,EAAA;AAAA,IAAA,OAAAyC,KAAA,CAAAje,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAgBjB,EAAA;AAED,IAAMovB,gBAAc,GAAG,SAAjBA,cAAcA,CAClB1gB,QAA0B,EAC1BpC,OAAgB,EAChBshC,QAAkB,EAAA;AAAA,EAAA,OACfl/B,QAAQ,CAACsO,MAAM,CAAC1Q,OAAO,EAAE4D,UAAa,CAAC09B,QAAQ,CAAC,CAAC,CAAM,OAAA,CAAA,CAAC9uB,QAAQ,CAAC;AAAA,CAAA;;AC9gBtE,IAAamxB,aAAa,GAAA,YAAA;AAyDxB,EAAA,SAAAA,aACElkB,CAAAA,MAAmC,EACnC3e,GAA2B,EAC3B;AAAAtN,IAAAA,eAAA,OAAAmwC,aAAA,CAAA;IACA,IAAI7iC,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,sBAAsB,CAAC;AAC1D;IAKA,IAAIggC,sBAAsB,GAAG,CAAC;AAC9B,IAAA,IAAIC,iBAA6B,GAAG;AAClChb,MAAAA,MAAM,EAAE,IAAI;AACZib,MAAAA,WAAW,EAAE;KACd;AAED,IAAA,IAAM5jB,YAAY,GAAGtc,MAAS,EAM3B;AAIH,IAAA,IAAMmgC,kBAAkB,GAAA,YAAA;MAAA,IAAAl9B,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAC,OAAA,GAAA;AAAA,QAAA,OAAAF,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAAAF,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA,OACnB8zB,YAAY;AAAA,YAAA,KAAA,CAAA;cAAA,OAAAh0B,QAAA,CAAAyE,MAAA,CAAA,QAAA,EAEX7Q,UAAa,CAACigC,iBAAiB,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA7zB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OACxC,CAAA,CAAA;AAAA,MAAA,OAAA,SAJKk0B,kBAAkBA,GAAA;AAAA,QAAA,OAAAl9B,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAIvB,EAAA;AAID,IAAA,IAAMuwC,aAAa,GAAA,YAAA;MAAA,IAAAtyB,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAgC,QAAA,GAAA;AAAA,QAAA,IAAAsyB,qBAAA,EAAAzvC,IAAA,EAAAmpC,QAAA;AAAA,QAAA,OAAAjuB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;AAAA,cAAA,OACai0B,cAAc,CAC7C1kB,MAAM,CAAC8C,KAAK,EACZ9C,MAAM,CAAC2kB,kBAAkB,EACzB3kB,MAAM,CAAC4kB,uBACT,CAAC;AAAA,YAAA,KAAA,CAAA;cAAAH,qBAAA,GAAAnyB,SAAA,CAAAV,IAAA;cAJO5c,IAAI,GAAAyvC,qBAAA,CAAJzvC,IAAI;cAAEmpC,QAAQ,GAAAsG,qBAAA,CAARtG,QAAQ;cAAA,OAAA7rB,SAAA,CAAA0C,MAAA,CAMf7Q,QAAAA,EAAAA,UAAa,CAAO,UAAC3F,OAAO,EAAK;gBACtC,IAAIqmC,OAAO,GAAG,KAAK;AAEnB,gBAAA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAI7iC,OAAoC,EAAK;AACpE,kBAAA,IAAM8iC,UAAU,GAAG5gC,QAAW,CAAClC,OAAO,CAAC;kBAGvC,IAAI,CAAC4iC,OAAO,EAAE;oBAEZ,IAAIE,UAAU,GAAGxN,WAAW,EAAE;AAC5B1kB,sBAAAA,OAAO,CACL1O,QAAW,CACT,2BAAA5S,CAAAA,MAAA,CAA4BwzC,UAAU,yBAAAxzC,MAAA,CACrBgmC,WAAW,CAC9B,CACF,CAAC;AACH;AACF;AAAC,kBAAA,IAAAjpB,SAAA,GAAAC,0BAAA,CAEmBtM,OAAO,CAAA;oBAAAuM,KAAA;AAAA,kBAAA,IAAA;oBAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,sBAAA,IAAlB+U,KAAK,GAAAjV,KAAA,CAAAnS,KAAA;AACd8nC,sBAAAA,sBAAsB,GAAGa,kBAAkB,CACzCb,sBAAsB,EACtB1gB,KACF,CAAC;AACH;AAAC,mBAAA,CAAA,OAAA7U,GAAA,EAAA;oBAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,mBAAA,SAAA;AAAAN,oBAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;kBAKDm2B,mBAAmB,CAAC,CAACJ,OAAO,CAAC;AAC7BA,kBAAAA,OAAO,GAAG,IAAI;AACdrmC,kBAAAA,OAAO,EAAE;iBACV;AAID,gBAAA,IAAM0mC,cAAc,GAAG;AACrBlwC,kBAAAA,IAAI,EAAJA,IAAI;AACJmwC,kBAAAA,UAAU,EAAE;iBACb;gBAED,IAAMlnB,QAAQ,GAAG9Z,uBAA0B,CACzC2gC,mBAAmB,EACnBI,cACF,CAAC;AAAC,gBAAA,IAAAxjB,UAAA,GAAAnT,0BAAA,CAE2B4vB,QAAQ,CAAA;kBAAAxc,MAAA;AAAA,gBAAA,IAAA;kBAArC,KAAAD,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAAuC;AAAA,oBAAA,IAA5B02B,cAAc,GAAAzjB,MAAA,CAAAtlB,KAAA;AACvB4hB,oBAAAA,QAAQ,CAACE,OAAO,CAACinB,cAAc,CAAC;AAClC;AAAC,iBAAA,CAAA,OAAAx2B,GAAA,EAAA;kBAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,iBAAA,SAAA;AAAA8S,kBAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;AACH,eAAC,CAAC,CAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAwD,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAyB,QAAA,CAAA;OACH,CAAA,CAAA;AAAA,MAAA,OAAA,SAzDKqyB,aAAaA,GAAA;AAAA,QAAA,OAAAtyB,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAyDlB,EAAA;IAID,IAAMguB,cAAc,GAAG,SAAjBA,cAAcA,CAClBnS,OAAwB,EACxB+mB,aAAqB,EACA;AAAA,MAAA,IAAA3U,iBAAA;AACrB/d,MAAAA,MAAS,CAAA,CAAA+d,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,uBAAzBA,iBAAA,CAA2BC,SAAS,CAAC;AAG/C,MAAA,IAAMxf,QAAQ,GAAGkO,aAAY,CAACf,OAAO,CAAC;MACtCnN,QAAQ,CAACyO,QAAQ,CAAC,YAAM;QACtBgR,aAAa,CAACtS,OAAO,CAAC;AACxB,OAAC,CAAC;AAEF2Q,MAAAA,YAAY,CAAC1O,GAAG,CAACjC,OAAO,EAAE;AACxBqS,QAAAA,SAAS,EAAExf,QAAQ;AACnB0iC,QAAAA,cAAc,EAAExO;AAClB,OAAC,CAAC;AACF,MAAA,OAAOl0B,QAAQ;KAChB;AAED,IAAA,IAAM2iC,aAAa,GAAA,YAAA;AAAA,MAAA,IAAAluB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAkH,QAAAA,CACpBvH,OAAwB,EACxB/X,OAAoC,EAAA;AAAA,QAAA,IAAA8+B,aAAA,EAAAl0B,QAAA,EAAA4iC,UAAA;AAAA,QAAA,OAAAr1B,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,YAAA,KAAA,CAAA;AAE9BomB,cAAAA,aAAa,GAAGD,gBAAgB,CAAC7+B,OAAO,CAAC;AACzC4K,cAAAA,QAAQ,GAAGsf,cAAc,CAACnS,OAAO,EAAE+mB,aAAa,CAAC;AAAA,cAAA,IAAA,EAEnD9+B,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,IAAAA,OAAO,CAAEirB,WAAW,CAAA,EAAA;AAAAxL,gBAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;cAAA,OAAA+G,SAAA,CAAAxC,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,CAAA;AAAAwC,cAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;cAAA,OAIC6zB,kBAAkB,EAAE;AAAA,YAAA,KAAA,CAAA;cAAvCiB,UAAU,GAAA/tB,SAAA,CAAA5F,IAAA;AAAA,cAAA,IAAA,EAGd,CAACjP,QAAQ,CAACoO,SAAS,EAAE,IACrBy0B,aAAa,CAAC3O,aAAa,EAAE0O,UAAU,EAAE,IAAI,CAAC,CAAA,EAAA;AAAA/tB,gBAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAEc+G,cAAAA,SAAA,CAAA/G,IAAA,GAAA,EAAA;AAAA,cAAA,OACtD4S,gBAAc,CAAC1gB,QAAQ,EAAE4iC,UAAU,CAAC;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA/tB,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA2G,QAAA,CAAA;OAE7C,CAAA,CAAA;AAAA,MAAA,OAAA,SApBKiuB,aAAaA,CAAA5yB,EAAA,EAAAyC,GAAA,EAAA;AAAA,QAAA,OAAAiC,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAoBlB,EAAA;AAED,IAAA,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CAAItS,OAAwB,EAAK;AAClD3L,MAAAA,SAAY,CAACsc,YAAY,EAAE3Q,OAAO,CAAC;KAEpC;AAED,IAAA,IAAMm1B,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAIQ,aAAsB,EAAK;AACtD,MAAA,IAAMC,SAAS,GAAGvhC,KAAQ,CACxBA,IAAO,CAACggC,sBAAsB,GAAGnN,eAAe,CAACvpB,OAAO,CAC1D,CAAC;AAED,MAAA,IAAMk4B,cAAc,GAAGxhC,KAAQ,CAC7BA,IAAO,CAACggC,sBAAsB,GAAGhN,eAAe,CAAC1pB,OAAO,CAC1D,CAAC;AAED,MAAA,IAAM83B,UAAsB,GAAG;AAAEnc,QAAAA,MAAM,EAAE,IAAI;AAAEib,QAAAA,WAAW,EAAE;OAAM;AAKlE,MAAA,IAAIqB,SAAS,KAAK,CAAC7vC,QAAW,EAAE;QAC9B0vC,UAAU,CAACnc,MAAM,GAAG4N,eAAe,CAAC7oB,MAAM,CAAC,CAAC,IAAIu3B,SAAS,CAAC;AAC5D;AACA,MAAA,IAAIC,cAAc,KAAK,CAAC9vC,QAAW,EAAE;QACnC0vC,UAAU,CAAClB,WAAW,GAAGlN,eAAe,CAAChpB,MAAM,CAAC,CAAC,IAAIw3B,cAAc,CAAC;AACtE;MAIA,IAAI,CAACF,aAAa,EAAE;QAAA,IAAA1kB,UAAA,GAAAxS,0BAAA,CACEkS,YAAY,CAACne,MAAM,EAAE,CAAA;UAAA2e,MAAA;AAAA,QAAA,IAAA;UAAzC,KAAAF,UAAA,CAAA7qB,CAAA,EAAA+qB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAAtS,CAAA,EAAAC,EAAAA,IAAA,GAA2C;AAAA,YAAA,IAAhC+U,KAAK,GAAAxC,MAAA,CAAA5kB,KAAA;AACd,YAAA,IAAMw6B,aAAa,GAAGpT,KAAK,CAAC4hB,cAAc;YAC1C,IAAI,CAACG,aAAa,CAAC3O,aAAa,EAAE0O,UAAU,EAAEnB,iBAAiB,CAAC,EAAE;AAIhE,cAAA;AACF;AAEA/gB,YAAAA,gBAAc,CAACI,KAAK,CAACtB,SAAS,EAAEojB,UAAU,CAAC;AAC7C;AAAC,SAAA,CAAA,OAAA32B,GAAA,EAAA;UAAAmS,UAAA,CAAAlS,CAAA,CAAAD,GAAA,CAAA;AAAA,SAAA,SAAA;AAAAmS,UAAAA,UAAA,CAAAjS,CAAA,EAAA;AAAA;AACH;AAEAs1B,MAAAA,iBAAiB,GAAGmB,UAAU;KAC/B;AAED,IAAA,IAAMhB,YAAY,GAAGC,aAAa,EAAE;IAIpC,IAAI,CAACF,kBAAkB,GAAGA,kBAAkB;IAI5C,IAAI,CAACsB,QAAQ,GAAGN,aAAa;AAI7B,IAAA,IAAI,CAACO,SAAS,GAAG,UAAC/1B,OAAO,EAAK;AAAA,MAAA,IAAA0U,kBAAA;AAE5BrgB,MAAAA,MAAS,CAAA,CAAAqgB,kBAAA,GAAC/D,YAAY,CAACxT,GAAG,CAAC6C,OAAO,CAAC,MAAA0U,IAAAA,IAAAA,kBAAA,uBAAzBA,kBAAA,CAA2BrC,SAAS,CAAC;KAChD;AACH;EAAC,OAAAhuB,YAAA,CAAA+vC,aAAA,EAAA,IAAA,EAAA,CAAA;IAAA7iC,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA9ND,SAAOyQ,MAAMA,GAAmC;AAAA,MAAA,IAAlCkT,MAA2B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC5C,OAAO,IAAIiwC,aAAa,CAACzf,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC9D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAmC;AAAA,MAAA,IAAAC,cAAA;AAAA,MAAA,IAAlC3E,MAA2B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAC3C,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC3C,QAAQ,CAACyb,QAAQ,EAAE;AAAE9B,QAAAA,KAAK,EAAE;AAAK,OAAC,CAAC,CAAC;MAErE,IAAIgC,QAAQ,IAAAH,cAAA,GAAGI,WAAS,CAAC9X,GAAG,CAAC2X,QAAQ,CAAC9B,KAAK,CAAC,MAAA,IAAA,IAAA6B,cAAA,KAA7BA,MAAAA,GAAAA,MAAAA,GAAAA,cAAA,CAA+B1X,GAAG,CAAC4X,YAAY,CAAC;MAC/D,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAIof,aAAa,CAACtf,QAAQ,EAAE3E,iBAAe,CAAC;AACvD8E,QAAAA,WAAS,CAACvF,IAAI,CAACoF,QAAQ,CAAC9B,KAAK,CAAC,CAAC/Q,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AAC5D;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AAkVH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG/F,OAAO,CAAiD,YAAA;AAAA,EAAA,OACxE7a,MAAS,EAAE;AAAA,CACb,CAAC;AAED,IAAM2hC,iBAAiB,GAAG3hC,cAAiB,CAAC,eAAe,CAAC;AAC5D,IAAM4hC,aAAa,GAAG5hC,UAAa,CAAC,QAAQ,CAAC;AAC7C,IAAM6hC,cAAc,GAAG7hC,UAAa,CAAC,cAAc,CAAC;AAEpD,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CACbzE,MAAuC,EACP;EAChC,IAAM1a,iBAAiB,GAAGnB,UAAa,CAACD,QAAQ,CAACoB,iBAAiB,CAAC;AACnE,EAAA,IAAI0a,MAAM,KAANA,IAAAA,IAAAA,MAAM,eAANA,MAAM,CAAE1a,iBAAiB,EAAE;AAC7B0D,IAAAA,iBAAgB,CAACgX,MAAM,CAAC1a,iBAAiB,EAAEA,iBAAiB,CAAC;AAC/D;EAEA,IAAMI,sBAAsB,GAAGvB,UAAa,CAACD,QAAQ,CAACwB,sBAAsB,CAAC;AAE7E,EAAA,IAAIsa,MAAM,KAANA,IAAAA,IAAAA,MAAM,eAANA,MAAM,CAAEta,sBAAsB,EAAE;AAClCsD,IAAAA,iBAAgB,CAACgX,MAAM,CAACta,sBAAsB,EAAEA,sBAAsB,CAAC;AACzE;EAEA,OAAO;IACLod,KAAK,EAAE,CAAA9C,MAAM,KAANA,IAAAA,IAAAA,MAAM,uBAANA,MAAM,CAAEhrB,IAAI,KAAI,IAAI;AAC3B2vC,IAAAA,kBAAkB,EAAEr/B,iBAAiB;AACrCs/B,IAAAA,uBAAuB,EAAEl/B;GAC1B;AACH,CAAC;AAID,IAAMg/B,cAAc,GAAA,YAAA;AAAA,EAAA,IAAA/sB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAyH,QACrB5iB,CAAAA,IAAwB,EACxBsQ,iBAAoD,EACpDI,sBAA8D,EAAA;IAAA,IAAAugC,eAAA,EAAAC,aAAA,EAAA9c,MAAA,EAAA+c,eAAA,EAAA9B,WAAA,EAAAlG,QAAA;AAAA,IAAA,OAAAjuB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,QAAA,KAAA,CAAA;AAExDw1B,UAAAA,eAAe,GAAG,EAAE;AAAA,UAAA,IAAA,CAGtBjxC,IAAI,EAAA;AAAAojB,YAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AACNy1B,UAAAA,aAAa,GAAGlxC,IAAI;AAACojB,UAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,UAAA;AAAA,QAAA,KAAA,CAAA;AAAA2H,UAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,UAAA,OAOCgtB,aAAa,CAAC;AAClClnB,YAAAA,KAAK,EAAAlb,eAAA,CAAA;AACH+gB,cAAAA,QAAQ,EAAE;AAAO,aAAA,EAChBvmB,OAAU,EAAG,OAAO;AAEzB,WAAC,CAAC;AAAA,QAAA,KAAA,CAAA;UALFqwC,aAAa,GAAA9tB,SAAA,CAAAxG,IAAA;AAAA,QAAA,KAAA,CAAA;UASf,KAAKwX,MAAM,IAAI9jB,iBAAiB,EAAE;AAChC2gC,YAAAA,eAAe,CAACx7B,IAAI,CAClBgzB,aAAa,CAAC;AACZkB,cAAAA,MAAM,EAAEuH,aAAa;AACrB3vB,cAAAA,KAAK,EAAAlb,eAAA,CAAA;AACH+gB,gBAAAA,QAAQ,EAAE;eACTvmB,EAAAA,OAAU,EAAGyP,iBAAiB,CAAC8jB,MAAM,CAAC,GAAG,IAAI,CAC/C;AACDzB,cAAAA,IAAI,EAAAtsB,eAAA,CACD0qC,EAAAA,EAAAA,aAAa,EAAG3c,MAAM;AAE3B,aAAC,CACH,CAAC;AACH;AAEM+c,UAAAA,eAAe,GAAGnxC,IAAI,GAAA,MAAA,CAAAzD,MAAA,CAAUu0C,iBAAiB,kBAAe,OAAO;AAC7E,UAAA,IAAI9wC,IAAI,EAAE;YACRwsC,WAAW,CAAC9c,KAAK,EAAE,CAAC0e,SAAS,CAAC,IAAI,EAAE;AAAE9pC,cAAAA,MAAM,EAAEtE;AAAK,aAAC,CAAC;AACvD;UAGA,KAAKqvC,WAAW,IAAI3+B,sBAAsB,EAAE;AAC1CugC,YAAAA,eAAe,CAACx7B,IAAI,CAClBgzB,aAAa,CAAC;AACZkB,cAAAA,MAAM,EAAEuH,aAAa;AACrB3vB,cAAAA,KAAK,EAAAlb,eAAA,CAAA;AACH+gB,gBAAAA,QAAQ,EAAE;AAAU,eAAA,EACnBvmB,OAAU,EACT,OAAA,CAAAtE,MAAA,CAAQmU,sBAAsB,CAAC2+B,WAAW,CAAC,EAAA9yC,GAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAA,CACtC40C,eAAe,MAAG,CAC1B;AACDxe,cAAAA,IAAI,EAAAtsB,eAAA,CACD2qC,EAAAA,EAAAA,cAAc,EAAG3B,WAAW;AAEjC,aAAC,CACH,CAAC;AACH;AAACjsB,UAAAA,SAAA,CAAA3H,IAAA,GAAA,EAAA;AAAA,UAAA,OAEsBtM,UAAa,CAAC8hC,eAAe,CAAC;AAAA,QAAA,KAAA,EAAA;UAA/C9H,QAAQ,GAAA/lB,SAAA,CAAAxG,IAAA;UAAA,OAAAwG,SAAA,CAAApD,MAAA,CACP,QAAA,EAAA;AAAEhgB,YAAAA,IAAI,EAAEkxC,aAAa;AAAE/H,YAAAA,QAAQ,EAARA;WAAU,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA/lB,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAkH,QAAA,CAAA;GACzC,CAAA,CAAA;AAAA,EAAA,OAAA,SAjEK8sB,cAAcA,CAAAtvB,GAAA,EAAA+B,GAAA,EAAAO,GAAA,EAAA;AAAA,IAAA,OAAAC,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAiEnB,EAAA;AAED,IAAMmyC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIvI,OAAoB,EAAoB;AAChE,EAAA,IAAMwI,MAAM,GACVtwB,OAAO,CAAC8nB,OAAO,EAAEkI,aAAa,CAAC,IAAIhwB,OAAO,CAAC8nB,OAAO,EAAEmI,cAAc,CAAC;AAErE,EAAA,IAAIK,MAAM,KAAKrP,eAAe,CAACppB,GAAG,CAACy4B,MAAM,CAAC,IAAIlP,eAAe,CAACvpB,GAAG,CAACy4B,MAAM,CAAC,CAAC,EAAE;AAC1E,IAAA,OAAOA,MAAM;AACf,GAAC,MAAM;AAELtzB,IAAAA,QAAQ,CAAC5O,QAAW,CAAC,yCAAyC,CAAC,CAAC;AAChE,IAAA,OAAO,IAAI;AACb;AACF,CAAC;AAED,IAAMqhC,aAAa,GAAG,SAAhBA,aAAaA,CACjB3O,aAAqB,EACrByP,cAA0B,EAC1BC,cAA6C,EACjC;AAMZ,EAAA,IACE,CAAAA,cAAc,KAAdA,IAAAA,IAAAA,cAAc,KAAdA,MAAAA,GAAAA,MAAAA,GAAAA,cAAc,CAAEnd,MAAM,MAAKkd,cAAc,CAACld,MAAM,KAC/C,CAACkd,cAAc,CAACld,MAAM,IACrB4N,eAAe,CAACrpB,GAAG,CAAC24B,cAAc,CAACld,MAAM,CAAC,GAAGyN,aAAa,CAAC,EAC7D;AACA,IAAA,OAAO,IAAI;AACb;AAEA,EAAA,IACE,CAAA0P,cAAc,KAAdA,IAAAA,IAAAA,cAAc,KAAdA,MAAAA,GAAAA,MAAAA,GAAAA,cAAc,CAAElC,WAAW,MAAKiC,cAAc,CAACjC,WAAW,KACzD,CAACiC,cAAc,CAACjC,WAAW,IAC1BlN,eAAe,CAACxpB,GAAG,CAAC24B,cAAc,CAACjC,WAAW,CAAC,GAAGxN,aAAa,CAAC,EAClE;AACA,IAAA,OAAO,IAAI;AACb;AAEA,EAAA,OAAO,KAAK;AACd,CAAC;AAED,IAAMmO,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtBb,sBAA8B,EAC9B1gB,KAAgC,EACrB;AACX,EAAA,IAAMnqB,MAAM,GAAG6K,QAAW,CAACsf,KAAK,CAAC;AAEjC,EAAA,IAAI,CAACtf,aAAgB,CAAC7K,MAAM,CAAC,EAAE;AAC7ByZ,IAAAA,QAAQ,CACN5O,QAAW,yCAAA5S,MAAA,CAC+B4S,aAAgB,CAAC7K,MAAM,CAAC,EAAA,GAAA,CAClE,CACF,CAAC;AACD,IAAA,OAAO6qC,sBAAsB;AAC/B;AAEA,EAAA,IAAMkC,MAAM,GAAGD,gBAAgB,CAAC9sC,MAAM,CAAC;EACvC,IAAIqU,GAAG,GAAG,CAAC;AACX,EAAA,IAAI,CAAC04B,MAAM,EAAE,CAEZ,MAAM,IAAIrP,eAAe,CAACppB,GAAG,CAACy4B,MAAM,CAAC,EAAE;AACtC14B,IAAAA,GAAG,GAAGqpB,eAAe,CAACrpB,GAAG,CAAC04B,MAAM,CAAC;GAClC,MAAM,IAAIlP,eAAe,CAACvpB,GAAG,CAACy4B,MAAM,CAAC,EAAE;AACtC14B,IAAAA,GAAG,GAAGwpB,eAAe,CAACxpB,GAAG,CAAC04B,MAAM,CAAC;AACnC,GAAC,MAAM;IAELtzB,QAAQ,CACN5O,QAAW,CAAA,gDAAA,CAAA5S,MAAA,CAAkD80C,MAAM,CAAE,CACvE,CAAC;AACH;EAEA,IAAI5iB,KAAK,CAAC+iB,cAAc,EAAE;IACxBrC,sBAAsB,IAAI,CAACx2B,GAAG;AAChC,GAAC,MAAM;AACLw2B,IAAAA,sBAAsB,IAAIx2B,GAAG;AAC/B;AAEA,EAAA,OAAOw2B,sBAAsB;AAC/B,CAAC;AAED,IAAM9gB,gBAAc,GAAG,SAAjBA,cAAcA,CAAI1gB,QAA0B,EAAE4iC,UAAsB,EAAA;AAAA,EAAA,OACxE5iC,QAAQ,CAACsO,MAAM,CAAC9M,UAAa,CAACohC,UAAU,CAAC,CAAC,CAAM,OAAA,CAAA,CAACxyB,QAAQ,CAAC;AAAA,CAAA;;ACnpBrD,IAAM0zB,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIhV,MAAc,EAAA;AAAA,EAAA,OACjDttB,QAAW,CAACuiC,eAAe,EAAEjV,MAAM,CAAC;AAAA,CAAA;AAe/B,IAAMiV,eAAgC,GAAG,CAC9C7wC,OAAU,EACVA,OAAU,EACVA,OAAU,CACF;;ACLV,IAAa8wC,cAAc,GAAA,YAAA;AA0DzB,EAAA,SAAAA,cACE3mB,CAAAA,MAAoC,EACpC3e,GAA2B,EAC3B;AAAAtN,IAAAA,eAAA,OAAA4yC,cAAA,CAAA;IACA,IAAItlC,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,uBAAuB,CAAC;AAC3D;IAUA,IAAMsc,YAAY,GAAGrB,WAAW,CAG9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;IAIpB,IAAM8d,cAAc,GAAG,SAAjBA,cAAcA,CAClB3oB,MAAmB,EACnBwW,OAAyB,EACH;AAAA,MAAA,IAAAoS,iBAAA;MACtB/d,MAAS,CAAA+d,CAAAA,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,MAAA4oB,IAAAA,IAAAA,iBAAA,uBAAxBA,iBAAA,CAA0BjV,GAAG,CAAC6C,OAAO,CAAC,CAAC;AAEjD,MAAA,IAAMnN,QAAQ,GAAGkO,aAAY,CAACf,OAAO,CAAC;MACtCnN,QAAQ,CAACyO,QAAQ,CAAC,YAAM;QACtBjN,SAAY,CAACsc,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC,EAAEwW,OAAO,CAAC;AACjD,OAAC,CAAC;MAEF2Q,YAAY,CAACjB,IAAI,CAAClmB,MAAM,CAAC,CAACyY,GAAG,CAACjC,OAAO,EAAEnN,QAAQ,CAAC;AAChD,MAAA,OAAOA,QAAQ;KAChB;AAID,IAAA,IAAMikC,cAAc,GAAA,YAAA;AAAA,MAAA,IAAAx/B,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,OAAAA,CACrB9W,MAAmB,EACnButC,YAA8B,EAC9BC,UAAwC,EACxCvkB,WAAyC,EAAA;QAAA,IAAAxqB,OAAA,EAAAgvC,aAAA,EAAAC,WAAA,EAAA14B,SAAA,EAAAE,KAAA,EAAAijB,MAAA;AAAA,QAAA,OAAAvhB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;AAEnC1Y,cAAAA,OAAO,GAAG8qB,UAAU,CAAC7C,MAAM,EAAEuC,WAAW,CAAC;AACzCwkB,cAAAA,aAAa,GAAG9kB,cAAc,CAAC3oB,MAAM,EAAEutC,YAAY,CAAC;AACpDG,cAAAA,WAAW,GACfF,UAAU,IAAIA,UAAU,KAAKD,YAAY,GACrC5kB,cAAc,CAAC3oB,MAAM,EAAEwtC,UAAU,CAAC,GAClCC,aAAa;AAAAz4B,cAAAA,SAAA,GAAAC,0BAAA,CAEExW,OAAO,CAACkvC,QAAQ,CAAA;AAAA,cAAA,IAAA;gBAArC,KAAA34B,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAuC;kBAA5B+iB,MAAM,GAAAjjB,KAAA,CAAAnS,KAAA;kBACf6qC,eAAe,CAACzV,MAAM,CAAC,CAACn4B,MAAM,EAAEytC,aAAa,EAAEC,WAAW,EAAEjvC,OAAO,CAAC;AACtE;AAAC,eAAA,CAAA,OAAA6W,GAAA,EAAA;gBAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,eAAA,SAAA;AAAAN,gBAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAyB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OACF,CAAA,CAAA;MAAA,OAhBKw2B,SAAAA,cAAcA,CAAAl0B,EAAA,EAAAyC,GAAA,EAAAC,GAAA,EAAA+B,GAAA,EAAA;AAAA,QAAA,OAAA/P,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAgBnB,EAAA;IAID,IAAI,CAACkzC,SAAS,GAAGP,cAAc;IAI/B,IAAI,CAACQ,UAAU,GAAG,UAAC9tC,MAAM,EAAEutC,YAAY,EAAEC,UAAW,EAAK;AACvD,MAAA,IAAMrjB,KAAK,GAAGhD,YAAY,CAACxT,GAAG,CAAC3T,MAAM,CAAC;AACtC6K,MAAAA,MAAS,CAACsf,KAAK,KAALA,IAAAA,IAAAA,KAAK,KAALA,MAAAA,GAAAA,MAAAA,GAAAA,KAAK,CAAExW,GAAG,CAAC45B,YAAY,CAAC,CAAC;AACnC,MAAA,IAAIC,UAAU,EAAE;AACd3iC,QAAAA,MAAS,CAACsf,KAAK,KAALA,IAAAA,IAAAA,KAAK,KAALA,MAAAA,GAAAA,MAAAA,GAAAA,KAAK,CAAExW,GAAG,CAAC65B,UAAU,CAAC,CAAC;AACnC;KACD;AACH;EAAC,OAAA3yC,YAAA,CAAAwyC,cAAA,EAAA,IAAA,EAAA,CAAA;IAAAtlC,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA/FD,SAAOyQ,MAAMA,GAAoC;AAAA,MAAA,IAAnCkT,MAA4B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC7C,OAAO,IAAI0yC,cAAc,CAACliB,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC/D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAoC;AAAA,MAAA,IAAnC1E,MAA4B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAC5C,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC8Y,QAAQ,CAAC;AAE1C,MAAA,IAAIE,QAAQ,GAAGC,WAAS,CAAC9X,GAAG,CAAC4X,YAAY,CAAC;MAC1C,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAI6hB,cAAc,CAAC/hB,QAAQ,EAAE3E,iBAAe,CAAC;AACxD8E,QAAAA,WAAS,CAAChT,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AACvC;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AA6KH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG5gB,MAAS,EAA0B;AAErD,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CACbzE,MAAwC,EACP;EAAA,IAAA8S,qBAAA,EAAAuU,qBAAA;EACjC,OAAO;AACLxW,IAAAA,eAAe,EAAAiC,CAAAA,qBAAA,GAAE9S,MAAM,aAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEviB,cAAc,MAAAq1B,IAAAA,IAAAA,qBAAA,KAAAA,MAAAA,GAAAA,qBAAA,GAAI,KAAK;AAChDwU,IAAAA,cAAc,EAAAD,CAAAA,qBAAA,GAAErnB,MAAM,aAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAE8H,aAAa,MAAA,IAAA,IAAAuf,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAI;GAC1C;AACH,CAAC;AAED,IAAMxkB,UAAU,GAAG,SAAbA,UAAUA,CACd7C,MAAoC,EACpCjoB,OAAqC,EACR;EAAA,IAAAq8B,qBAAA,EAAAmT,qBAAA;EAC7B,OAAO;AACLN,IAAAA,QAAQ,EACN56B,eAAe,CAAC,SAAS,EAAEtU,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAEyvC,OAAO,EAAEf,oBAAoB,CAAC,IAClEC,eAAe;AACjB7V,IAAAA,eAAe,GAAAuD,qBAAA,GAAEr8B,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAE0F,cAAc,cAAA22B,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAIpU,MAAM,CAAC6Q,eAAe;AAClEyW,IAAAA,cAAc,GAAAC,qBAAA,GAAExvC,OAAO,KAAA,IAAA,IAAPA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAE+vB,aAAa,cAAAyf,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAIvnB,MAAM,CAACsnB;GAClD;AACH,CAAC;AAED,IAAMG,kBAAkB,GAAG,SAArBA,kBAAkBA,CACtBnuC,MAAmB,EACnBytC,aAAgC,EAChCC,WAA8B,EAC9BjvC,OAAiC,EAC9B;EAEH,IAAI2vC,WAAW,GAAG,KAAK;AAEvB,EAAA,IAAMx2B,OAAO,GAAG,SAAVA,OAAOA,CAAI3Z,KAAY,EAAK;IAChC,IAAIQ,OAAO,CAAC84B,eAAe,EAAE;AAC3B1sB,MAAAA,cAAiB,CAAC5M,KAAK,CAAC;AAC1B;IAEAmwC,WAAW,GAAG,CAACA,WAAW;AAE1B,IAAA,IAAM/f,IAAuB,GAAG;MAC9B8J,MAAM,EAAE57B,OAAU;AAClB8xC,MAAAA,KAAK,EAAED,WAAW,GAAG,IAAI,GAAG;KAC7B;AAEDrkB,IAAAA,gBAAc,CACZqkB,WAAW,GAAGX,aAAa,GAAGC,WAAW,EACzC1tC,MAAM,EACNquB,IAAI,EACJpwB,KACF,CAAC;GACF;EAEDovB,kBAAkB,CAACrtB,MAAM,EAAEzD,OAAU,EAAEqb,OAAO,CAAC;AAE/C,EAAA,IAAM/P,MAAM,GAAG,SAATA,MAAMA,GAAA;IAAA,OAASomB,uBAAuB,CAACjuB,MAAM,EAAEzD,OAAU,EAAEqb,OAAO,CAAC;AAAA,GAAA;AAEzE61B,EAAAA,aAAa,CAAC31B,QAAQ,CAACjQ,MAAM,CAAC;AAC9B6lC,EAAAA,WAAW,CAAC51B,QAAQ,CAACjQ,MAAM,CAAC;AAC9B,CAAC;AAED,IAAMymC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CACzBnW,MAA6C,EAC7Cn4B,MAAmB,EACnBytC,aAAgC,EAChCC,WAA8B,EAC9BjvC,OAAiC,EAC9B;EAGH,IAAM8vC,cAAc,GAAGpW,MAAM,KAAK57B,OAAU,GAAG,OAAO,GAAG,MAAM;EAC/D,IAAMiyC,YAAY,GAAGrW,MAAM,KAAK57B,OAAU,GAAG,OAAO,GAAG,IAAI;AAC3D,EAAA,IAAMkyC,UAAU,GAAGlyC,SAAY,GAAGgyC,cAAc;AAChD,EAAA,IAAMG,QAAQ,GAAGnyC,SAAY,GAAGiyC,YAAY;EAE5C,IAAM52B,OAAO,GAAG,SAAVA,OAAOA,CAAI3Z,KAAY,EAAEoL,QAA2B,EAAK;IAC7D,IAAI5K,OAAO,CAAC84B,eAAe,EAAE;AAC3B1sB,MAAAA,cAAiB,CAAC5M,KAAK,CAAC;AAC1B;AAEA,IAAA,IAAMowB,IAAuB,GAAG;AAC9B8J,MAAAA,MAAM,EAANA,MAAM;AACNkW,MAAAA,KAAK,EACHxjC,UAAa,CAAC5M,KAAK,CAACupB,IAAI,EAAE,eAAe,EAAE,EAAE,CAAC,KAAK+mB,cAAc,GAC7D,IAAI,GACJ;KACP;IAEDxkB,gBAAc,CAAC1gB,QAAQ,EAAErJ,MAAM,EAAEquB,IAAI,EAAEpwB,KAAK,CAAC;GAC9C;AACD,EAAA,IAAM0wC,aAAa,GAAG,SAAhBA,aAAaA,CAAI1wC,KAAY,EAAA;AAAA,IAAA,OAAK2Z,OAAO,CAAC3Z,KAAK,EAAEwvC,aAAa,CAAC;AAAA,GAAA;AACrE,EAAA,IAAMmB,WAAW,GAAG,SAAdA,WAAWA,CAAI3wC,KAAY,EAAA;AAAA,IAAA,OAAK2Z,OAAO,CAAC3Z,KAAK,EAAEyvC,WAAW,CAAC;AAAA,GAAA;AAEjErgB,EAAAA,kBAAkB,CAACrtB,MAAM,EAAEyuC,UAAU,EAAEE,aAAa,CAAC;AACrDthB,EAAAA,kBAAkB,CAACrtB,MAAM,EAAE0uC,QAAQ,EAAEE,WAAW,CAAC;EAIjD,IAAInwC,OAAO,CAACuvC,cAAc,EAAE;IAC1Bxf,aAAa,CAACxuB,MAAM,CAAC;AACvB;EAEAytC,aAAa,CAAC31B,QAAQ,CAAC,YAAM;IAC3B2W,iBAAiB,CAACzuB,MAAM,CAAC;AACzBiuB,IAAAA,uBAAuB,CAACjuB,MAAM,EAAEyuC,UAAU,EAAEE,aAAa,CAAC;AAC5D,GAAC,CAAC;EAEFjB,WAAW,CAAC51B,QAAQ,CAAC,YAAM;IACzB2W,iBAAiB,CAACzuB,MAAM,CAAC;AACzBiuB,IAAAA,uBAAuB,CAACjuB,MAAM,EAAE0uC,QAAQ,EAAEE,WAAW,CAAC;AACxD,GAAC,CAAC;AACJ,CAAC;AAED,IAAMhB,eAOL,GAAG;AACFiB,EAAAA,KAAK,EAAEV,kBAAkB;EACzBW,KAAK,EAAE,SAAPA,KAAKA,GAAA;AAAA,IAAA,KAAA,IAAAnqC,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAMuV,IAAI,GAAAzb,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAJ8L,MAAAA,IAAI,CAAA9L,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;IAAA,OAAKypC,qBAAqB,CAAAvpC,KAAA,CAACxI,MAAAA,EAAAA,CAAAA,OAAU,CAAAtE,CAAAA,MAAA,CAAK0Y,IAAI,CAAC,CAAA;AAAA,GAAA;EAC9Do+B,KAAK,EAAE,SAAPA,KAAKA,GAAA;AAAA,IAAA,KAAA,IAAA96B,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EAAMuV,IAAI,GAAAzb,IAAAA,KAAA,CAAA+e,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAJvD,MAAAA,IAAI,CAAAuD,KAAA,CAAAvZ,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;IAAA,OAAKo6B,qBAAqB,CAAAvpC,KAAA,CAACxI,MAAAA,EAAAA,CAAAA,OAAU,CAAAtE,CAAAA,MAAA,CAAK0Y,IAAI,CAAC,CAAA;AAAA;AAChE,CAAU;AAEV,IAAMoZ,gBAAc,GAAG,SAAjBA,cAAcA,CAClB1gB,QAA2B,EAC3BrJ,MAAmB,EACnBgvC,UAA6B,EAC7B/wC,KAAY,EAAA;AAAA,EAAA,OACToL,QAAQ,CAACsO,MAAM,CAAC3X,MAAM,EAAE6K,UAAa,CAACmkC,UAAU,CAAC,EAAE/wC,KAAK,CAAC,CAAM,OAAA,CAAA,CAACwb,QAAQ,CAAC;AAAA,CAAA;;AC1U9E,IAAaw1B,aAAa,GAAA,YAAA;AAqOxB,EAAA,SAAAA,aACEvoB,CAAAA,MAAmC,EACnC3e,GAA2B,EAC3B;AAAA,IAAA,IAAA7M,KAAA,GAAA,IAAA;AAAAT,IAAAA,eAAA,OAAAw0C,aAAA,CAAA;IACA,IAAIlnC,GAAG,KAAK4e,iBAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,sBAAsB,CAAC;AAC1D;AAMA,IAAA,IAAMqkC,aAAa,GAAGrkC,UAAa,EAAuB;AAE1D,IAAA,IAAMskC,eAAe,GAAGtkC,UAAa,EAGlC;IAEH,IAAMsc,YAAY,GAAGrB,WAAW,CAG9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;AAIpB,IAAA,IAAMukC,kBAAkB,GAAA,YAAA;MAAA,IAAAthC,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,OAAAA,CACzB7P,OAAgB,EAAA;AAAA,QAAA,IAAA2/B,QAAA;UAAAyI,aAAA;UAAAC,iBAAA;UAAA3F,UAAA;AAAApuB,UAAAA,KAAA,GAAA5gB,SAAA;AAAA,QAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,YAAA,KAAA,CAAA;cAChByvB,QAAQ,GAAArrB,KAAA,CAAAngB,MAAA,GAAA,CAAA,IAAAmgB,KAAA,CAAA,CAAA,CAAA,KAAAlgB,SAAA,GAAAkgB,KAAA,CAAA,CAAA,CAAA,GAAG,KAAK;cAChB8zB,aAAa,GAAA9zB,KAAA,CAAAngB,MAAA,GAAA,CAAA,IAAAmgB,KAAA,CAAA,CAAA,CAAA,KAAAlgB,SAAA,GAAAkgB,KAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAIf+zB,cAAAA,iBAAiB,GAAGJ,aAAa,CAACv7B,GAAG,CAAC1M,OAAO,CAAC;AAAAgQ,cAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,cAAA,OAC3Bo4B,eAAe,CACtCtoC,OAAO,EACPqoC,iBAAiB,EACjB1I,QACF,CAAC;AAAA,YAAA,KAAA,CAAA;cAJK+C,UAAU,GAAA1yB,QAAA,CAAAqB,IAAA;AAOhB,cAAA,IAAI,CAAC+2B,aAAa,IAAIC,iBAAiB,EAAE;AACvC3F,gBAAAA,UAAU,CAAC7c,SAAS,GAAGwiB,iBAAiB,CAACxiB,SAAS;AACpD;AAAC,cAAA,OAAA7V,QAAA,CAAAyE,MAAA,CAAA,QAAA,EACMiuB,UAAU,CAAA;AAAA,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA1yB,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAN,OAAA,CAAA;OAClB,CAAA,CAAA;MAAA,OAnBKs4B,SAAAA,kBAAkBA,CAAAh2B,EAAA,EAAA;AAAA,QAAA,OAAAtL,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAmBvB,EAAA;IAID,IAAMguB,cAAc,GAAG,SAAjBA,cAAcA,CAClBnS,OAAwB,EACxB/X,OAAgC,EAChC+wC,SAAoB,EACF;AAAA,MAAA,IAAA5mB,iBAAA;AAClB,MAAA,IAAM3hB,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAChCt+B,MAAAA,MAAS,CAAA+d,CAAAA,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAA2hB,iBAAA,KAAA,MAAA,IAAA,CAAAA,iBAAA,GAAzBA,iBAAA,CAA2BjV,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,KAAvCA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAA,CAAyCC,SAAS,CAAC;MAG7D,IAAMxf,QAAQ,GAAGkO,aAAY,CAACf,OAAO,EAAE/X,OAAO,CAACm7B,eAAe,CAAC;MAC/DvwB,QAAQ,CAACyO,QAAQ,CAAC,YAAM;AACtBgR,QAAAA,aAAa,CAACtS,OAAO,EAAE/X,OAAO,CAAC;AACjC,OAAC,CAAC;AAEF,MAAA,IAAM0rB,KAAK,GAAG;AACZtB,QAAAA,SAAS,EAAExf,QAAQ;AACnBomC,QAAAA,UAAU,EAAED,SAAS;AACrBzmB,QAAAA,QAAQ,EAAEtqB;OACX;MACD0oB,YAAY,CAACjB,IAAI,CAACjf,OAAO,CAAC,CAACwR,GAAG,CAACjC,OAAO,EAAE2T,KAAK,CAAC;AAE9C,MAAA,OAAOA,KAAK;KACb;AAID,IAAA,IAAMulB,aAAa,GAAA,YAAA;AAAA,MAAA,IAAA92B,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAgC,QACpBrC,CAAAA,OAAwB,EACxByS,WAAwC,EACxCumB,SAAoB,EAAA;AAAA,QAAA,IAAA/wC,OAAA,EAAAwI,OAAA,EAAAkjB,KAAA,EAAA9gB,QAAA,EAAAsmC,WAAA,EAAAC,UAAA,EAAAC,eAAA,EAAAzU,UAAA;AAAA,QAAA,OAAAxkB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OAEE24B,oBAAoB,CAACppB,MAAM,EAAEuC,WAAW,IAAI,EAAE,CAAC;AAAA,YAAA,KAAA,CAAA;cAA/DxqB,OAAO,GAAAua,SAAA,CAAAV,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;cAM1Bhf,KAAK,GAAGxB,cAAc,CAACnS,OAAO,EAAE/X,OAAO,EAAE+wC,SAAS,CAAC;cACnDnmC,QAAQ,GAAG8gB,KAAK,CAACtB,SAAS;cAE1B8mB,WAAW,GAAGlxC,OAAO,CAACsxC,YAAY;AAAA/2B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OACfi4B,kBAAkB,CACzCnoC,OAAO,EACPxI,OAAO,CAACm7B,eAAe,KAAK,CAC9B,CAAC;AAAA,YAAA,KAAA,CAAA;cAHKgW,UAAU,GAAA52B,SAAA,CAAAV,IAAA;AAAA,cAAA,IAAA,CAKZjP,QAAQ,CAACoO,SAAS,EAAE,EAAA;AAAAuB,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAA6B,SAAA,CAAA0C,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAIxByO,KAAK,CAACmb,KAAK,GAAGsK,UAAU;AACxBV,cAAAA,aAAa,CAACz2B,GAAG,CAACxR,OAAO,EAAE2oC,UAAU,CAAC;cAAC,IAEnCJ,EAAAA,SAAS,KAAKQ,YAAU,CAAA,EAAA;AAAAh3B,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;cAAA,OACpB84B,cAAc,CAAC9lB,KAAK,CAAC;AAAA,YAAA,KAAA,EAAA;AAGzB0lB,cAAAA,eAAe,GAAGV,eAAe,CAACx7B,GAAG,CAACg8B,WAAW,CAAC;cACtD,IAAI,CAACE,eAAe,EAAE;AAEpBA,gBAAAA,eAAe,GAAG;AAAEK,kBAAAA,UAAU,EAAE;iBAAG;AACnCf,gBAAAA,eAAe,CAAC12B,GAAG,CAACk3B,WAAW,EAAEE,eAAe,CAAC;gBAEjDxiB,kBAAkB,CAACsiB,WAAW,EAAEpzC,QAAW,EAAE4zC,aAAa,CAAC;AAC7D;AAEA,cAAA,IAAI1xC,OAAO,CAACm7B,eAAe,KAAK,CAAC,EAAE;gBACjCiW,eAAe,CAACK,UAAU,EAAE;AAC9B;cAEM9U,UAAU,GAAG38B,OAAO,CAAC08B,WAAW;cAAA,IAEpC,EAAA,CAAC9xB,QAAQ,CAACoO,SAAS,EAAE,IACrB,EAACwR,WAAW,KAAXA,IAAAA,IAAAA,WAAW,eAAXA,WAAW,CAAES,WAAW,CAAA,IACzB0mB,gBAAgB,CAAChV,UAAU,EAAEwU,UAAU,CAAC9iB,SAAS,CAAC,CAAA,EAAA;AAAA9T,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAEmB6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;cAAA,OAE/D4S,gBAAc,CAACxS,aAAY,CAACf,OAAO,CAAC,EAAEvP,OAAO,EAAE2oC,UAAU,CAAC;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA52B,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAyB,QAAA,CAAA;OAEnE,CAAA,CAAA;AAAA,MAAA,OAAA,SAvDK62B,aAAaA,CAAA7zB,GAAA,EAAAC,GAAA,EAAA+B,GAAA,EAAA;AAAA,QAAA,OAAAjF,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAuDlB,EAAA;AAID,IAAA,IAAM01C,cAAc,GAAA,YAAA;AAAA,MAAA,IAAAvyB,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAkH,QACrBvH,CAAAA,OAAwB,EACxBupB,UAAoC,EACpCyP,SAAoB,EAAA;AAAA,QAAA,IAAAtkB,kBAAA;AAAA,QAAA,IAAAzsB,OAAA,EAAAwI,OAAA,EAAAwiC,SAAA;AAAA,QAAA,OAAA7yB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA+G,cAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;cAAA,OAEE24B,oBAAoB,CAACppB,MAAM,EAAE;AAAEqZ,gBAAAA,UAAU,EAAVA;AAAW,eAAC,CAAC;AAAA,YAAA,KAAA,CAAA;cAA5DthC,OAAO,GAAAyf,SAAA,CAAA5F,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAC1BM,cAAAA,SAAS,IAAAve,kBAAA,GAAG/D,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAikB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvX,GAAG,CAAC6C,OAAO,CAAC;cACzD,IAAI,CAAAizB,SAAS,KAAA,IAAA,IAATA,SAAS,KAAA,MAAA,GAAA,MAAA,GAATA,SAAS,CAAEgG,UAAU,MAAKD,SAAS,EAAE;AACvC3kC,gBAAAA,MAAS,CAAC4+B,SAAS,CAAC5gB,SAAS,CAAC;gBAE9B,IAAIrS,OAAO,KAAK85B,iBAAiB,EAAE;AAEjCA,kBAAAA,iBAAiB,CAACrpC,OAAO,EAAE,IAAI,CAAC;AAClC;AACF;AAAC,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAiX,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA2G,QAAA,CAAA;OACF,CAAA,CAAA;AAAA,MAAA,OAAA,SAhBKsyB,cAAcA,CAAAjyB,GAAA,EAAAY,GAAA,EAAAC,GAAA,EAAA;AAAA,QAAA,OAAAnB,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAgBnB,EAAA;IAID,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CACjBtS,OAAwB,EACxB/X,OAAgC,EAC7B;AACH,MAAA,IAAMwI,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAChC,MAAA,IAAMwG,WAAW,GAAGlxC,OAAO,CAACsxC,YAAY;MAExCllC,SAAY,CAACsc,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,EAAEuP,OAAO,CAAC;AAChD2Q,MAAAA,YAAY,CAAChB,KAAK,CAAClf,OAAO,CAAC;AAE3B,MAAA,IAAM4oC,eAAe,GAAGV,eAAe,CAACx7B,GAAG,CAACg8B,WAAW,CAAC;AACxD,MAAA,IAAIE,eAAe,IAAIpxC,OAAO,CAACm7B,eAAe,KAAK,CAAC,EAAE;QACpDiW,eAAe,CAACK,UAAU,EAAE;AAC9B;AAEA,MAAA,IAAI,CAAC/oB,YAAY,CAAC7S,GAAG,CAACrN,OAAO,CAAC,EAAE;AAM9B4D,QAAAA,SAAY,CAACqkC,aAAa,EAAEjoC,OAAO,CAAC;QACpCgnB,uBAAuB,CAAC0hB,WAAW,EAAEpzC,QAAW,EAAE4zC,aAAa,CAAC;AAChEtlC,QAAAA,SAAY,CAACskC,eAAe,EAAEQ,WAAW,CAAC;AAC5C;KACD;AAID,IAAA,IAAMM,cAAc,GAAA,YAAA;MAAA,IAAA5xB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAwI,QAAAA,CAAO8K,KAAoB,EAAA;AAAA,QAAA,IAAA1rB,OAAA,EAAAwI,OAAA,EAAAspC,cAAA,EAAAC,GAAA,EAAAzN,mBAAA,EAAA0N,cAAA,EAAAC,WAAA,EAAAnH,aAAA,EAAAoH,gBAAA,EAAAC,aAAA,EAAAh5B,OAAA,EAAA5C,SAAA,EAAAE,KAAA,EAAAsN,KAAA,EAAAquB,UAAA,EAAAC,eAAA;AAAA,QAAA,OAAAl6B,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,YAAA,KAAA,CAAA;cAC1C1Y,OAAO,GAAG0rB,KAAK,CAACpB,QAAQ;cACxB9hB,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;cAC1BoH,cAAc,GAAGpmB,KAAK,CAACtB,SAAS;AAGhC2nB,cAAAA,GAAG,GAAG3lC,MAAS,EAAE;AACjBk4B,cAAAA,mBAAmB,GAAGl4B,sBAAyB,EAAE;cAEjD4lC,cAAc,GAAGl5B,aAAY,CAAAZ,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAC,SAAAyH,QAAA,GAAA;gBAAA,IAAAqrB,UAAA,EAAAC,kBAAA;AAAA,gBAAA,OAAAhzB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,kBAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,oBAAA,KAAA,CAAA;AAAA2H,sBAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;sBAAA,OAITi4B,kBAAkB,CAACnoC,OAAO,CAAC;AAAA,oBAAA,KAAA,CAAA;sBAA9C0iC,UAAU,GAAA7qB,SAAA,CAAAxG,IAAA;sBACVsxB,kBAAkB,GAAGC,oBAAoB,CAC7CprC,OAAO,EACPkrC,UAAU,EACVxf,KAAK,CAACmb,KACR,CAAC;AAAA,sBAAA,IAEIsE,kBAAkB,EAAA;AAAA9qB,wBAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,wBAAA;AAAA;AAMnB2H,sBAAAA,SAAA,CAAA3H,IAAA,GAAA,EAAA;AAAA,sBAAA;AAAA,oBAAA,KAAA,CAAA;AAAA,sBAAA,IACQo5B,cAAc,CAAC94B,SAAS,EAAE,EAAA;AAAAqH,wBAAAA,SAAA,CAAA3H,IAAA,GAAA,EAAA;AAAA,wBAAA;AAAA;AAAA2H,sBAAAA,SAAA,CAAA3H,IAAA,GAAA,EAAA;AAAA,sBAAA,OAC9B4S,gBAAc,CAACwmB,cAAc,EAAEtpC,OAAO,EAAE0iC,UAAU,CAAC;AAAA,oBAAA,KAAA,EAAA;AAAA,oBAAA,KAAA,KAAA;sBAAA,OAAA7qB,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,iBAAA,EAAAkH,QAAA,CAAA;AAAA,eAE5D,CAAC,CAAA,CAAA;AAEFiyB,cAAAA,cAAc,CAACz4B,QAAQ,CAAC24B,cAAc,CAAC5oC,MAAM,CAAC;AAGxC6oC,cAAAA,WAAW,GAAGxI,WAAW,CAAC9c,KAAK,EAAE;AACjCme,cAAAA,aAAa,GAAG,SAAhBA,aAAaA,CAAIvpC,MAAmB,EAAA;gBAAA,OACxC0wC,WAAW,CAAC1G,QAAQ,CAACyG,cAAc,EAAA1uC,eAAA,CAAAA,eAAA,CAAA;AACjC/B,kBAAAA,MAAM,EAANA;AAAM,iBAAA,EACLzD,iBAAoB,EAAGkC,OAAO,CAACm7B,eAAe,CAAA,EAAA,WAAA,EAEpCn7B,OAAO,CAAC6qC,UAAU,CAC9B,CAAC;AAAA,eAAA;cAAA,IAEAriC,EAAAA,OAAO,KAAK87B,mBAAmB,CAAA,EAAA;AAAAhjB,gBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAKjCoyB,cAAAA,aAAa,EAAE;cACfA,aAAa,CAACiH,GAAG,CAAC;cAAC,OAAAzwB,SAAA,CAAArE,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAYfi1B,gBAAgB,GAAG9lC,MAAS,CAAU,CAAC5D,OAAO,CAAC,CAAC;cAGtDsiC,aAAa,CAACtiC,OAAO,CAAC;cAGhB2pC,aAAa,GACjBhmC,QAAQ,CAACG,sBAAsB,KAAK,IAAI,IACxC9D,OAAO,KAAK87B,mBAAmB,IAC/BtmB,OAAO,CAACxV,OAAO,EAAE1K,cAAiB,CAAC,KAAK,IAAI;AAAA,cAAA,IAAA,CAG1Cq0C,aAAa,EAAA;AAAA7wB,gBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAAA4I,cAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;cAAA,OAEC0M,oBAAoB,CAAC5c,OAAO,CAAC;AAAA,YAAA,KAAA,EAAA;cAA7C2Q,OAAO,GAAAmI,SAAA,CAAAzH,IAAA;cACPixB,aAAa,CAAC3xB,OAAO,CAAC;AACtB+4B,cAAAA,gBAAgB,CAACx4B,GAAG,CAACP,OAAO,CAAC;AAACmI,cAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,EAAA;cAAAnC,SAAA,GAAAC,0BAAA,CAIVpK,UAAa,CAAC5D,OAAO,CAAC,CAAA;AAAA,cAAA,IAAA;gBAA1C,KAAA+N,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA4C;kBAAjCoN,KAAK,GAAAtN,KAAA,CAAAnS,KAAA;kBACdwmC,aAAa,CAAC/mB,KAAK,CAAC;AACpBmuB,kBAAAA,gBAAgB,CAACx4B,GAAG,CAACqK,KAAK,CAAC;AAC7B;AAAC,eAAA,CAAA,OAAAlN,GAAA,EAAA;gBAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,eAAA,SAAA;AAAAN,gBAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAAA,YAAA,KAAA,EAAA;AAIGq7B,cAAAA,UAAU,GAAGpqB,UAAU,CAACjT,MAAM,CAAC;AACnC9X,gBAAAA,IAAI,EAAEuL,OAAO;AAEb8d,gBAAAA,OAAO,EAAE;AACX,eAAC,CAAC;AAEI+rB,cAAAA,eAAe,GAAGv5B,aAAY,CAAC,UAACqQ,SAA4B,EAAK;AACrE,gBAAA,IAAMpF,KAAK,GAAG3X,eAAkB,CAAC+c,SAAS,CAAC;gBAG3C,IAAIpF,KAAK,KAAK5K,OAAO,EAAE;AACrB,kBAAA,IAAIg5B,aAAa,EAAE;oBAGjB7tB,WAAW,CAACP,KAAK,EAAE;AAAElB,sBAAAA,EAAE,EAAE1J,OAAO;AAAEyJ,sBAAAA,UAAU,EAAE;AAAK,qBAAC,CAAC;AACvD,mBAAC,MAAM;oBAGLkoB,aAAa,CAAC/mB,KAAK,CAAC;AACpBmuB,oBAAAA,gBAAgB,CAACx4B,GAAG,CAACqK,KAAK,CAAC;AAC7B;AACF;AACF,eAAC,CAAC;AAEFquB,cAAAA,UAAU,CAAC7lB,UAAU,CAAC8lB,eAAe,EAAE;AAAEllB,gBAAAA,UAAU,EAAE,CAACrvB,OAAU;AAAE,eAAC,CAAC;AACpEk0C,cAAAA,cAAc,CAAC34B,QAAQ,CAACg5B,eAAe,CAACjpC,MAAM,CAAC;AAAC,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAkY,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAiI,QAAA,CAAA;OACjD,CAAA,CAAA;MAAA,OAnHK4wB,SAAAA,cAAcA,CAAA/wB,GAAA,EAAA;AAAA,QAAA,OAAAb,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAmHnB,EAAA;AAID,IAAA,IAAMw1C,aAAa,GAAA,YAAA;MAAA,IAAAntB,KAAA,GAAArM,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAoM,QAAAA,CAAOhlB,KAAY,EAAA;QAAA,IAAA8yC,oBAAA,EAAAxX,kBAAA;AAAA,QAAA,IAAAwG,UAAA,EAAA94B,OAAA,EAAA2/B,QAAA,EAAA+C,UAAA,EAAAvhB,UAAA,EAAAC,MAAA,EAAA8B,KAAA,EAAApB,QAAA,EAAA6gB,kBAAA;AAAA,QAAA,OAAAhzB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAmM,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAjM,IAAA,GAAAiM,SAAA,CAAAhM,IAAA;AAAA,YAAA,KAAA,CAAA;AAcjC4oB,cAAAA,UAAU,GAAGl1B,QAAW,CAAC5M,KAAK,CAAC;AAAA,cAAA,IAAA,EAEjC,CAAC8hC,UAAU,IAAI,EAAEl1B,SAAY,CAACk1B,UAAU,CAAC,IAAIl1B,KAAQ,CAACk1B,UAAU,CAAC,CAAC,CAAA,EAAA;AAAA5c,gBAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;AAAA,gBAAA;AAAA;cAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,CAAA;AAAAyH,cAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;cAAA,OAIhD2qB,sBAAsB,CAAC/B,UAAU,CAAC;AAAA,YAAA,KAAA,CAAA;cAAlD94B,OAAO,GAAAkc,SAAA,CAAA7K,IAAA;cACPsuB,QAAQ,GAAG,CAAC,CAAAmK,CAAAA,oBAAA,GAAA5B,eAAe,CAACx7B,GAAG,CAACosB,UAAU,CAAC,MAAAgR,IAAAA,IAAAA,oBAAA,uBAA/BA,oBAAA,CAAiCb,UAAU,KAAI,CAAC,IAAI,CAAC;AAAA/sB,cAAAA,SAAA,CAAAhM,IAAA,GAAA,CAAA;AAAA,cAAA,OAC9Ci4B,kBAAkB,CAACnoC,OAAO,EAAE2/B,QAAQ,EAAE,IAAI,CAAC;AAAA,YAAA,KAAA,CAAA;cAA9D+C,UAAU,GAAAxmB,SAAA,CAAA7K,IAAA;AAChB42B,cAAAA,aAAa,CAACz2B,GAAG,CAACxR,OAAO,EAAE0iC,UAAU,CAAC;cAEqBvhB,UAAA,GAAAnT,0BAAA,CAEvC,CAAA,CAAAskB,kBAAA,GAAApS,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAsyB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvwB,MAAM,EAAE,KAAI,EAAE,CAAA;AAAAma,cAAAA,SAAA,CAAAjM,IAAA,GAAA,EAAA;AAAAkR,cAAAA,UAAA,CAAAxrB,CAAA,EAAA;AAAA,YAAA,KAAA,EAAA;AAAA,cAAA,IAAA,CAAAyrB,MAAA,GAAAD,UAAA,CAAAjT,CAAA,IAAAC,IAAA,EAAA;AAAA+N,gBAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAlDgT,KAAK,GAAA9B,MAAA,CAAAtlB,KAAA;cAIRtE,QAAO,GAAG0rB,KAAK,CAACpB,QAAQ;cACxB6gB,kBAAkB,GAAGC,oBAAoB,CAC7CprC,QAAO,EACPkrC,UAAU,EACVxf,KAAK,CAACmb,KACR,CAAC;AAAA,cAAA,IAEIsE,kBAAkB,EAAA;AAAAzmB,gBAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAMnB,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,UAAA,EAAA,EAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAMJyO,KAAK,CAACmb,KAAK,GAAGqE,UAAU;cAAC,IAEpByG,gBAAgB,CAAC3xC,QAAO,CAAC08B,WAAW,EAAEwO,UAAU,CAAC7c,SAAS,CAAC,EAAA;AAAA3J,gBAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAK5D,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,UAAA,EAAA,EAAA,CAAA;AAAA,YAAA,KAAA,EAAA;cAIJqO,gBAAc,CAACI,KAAK,CAACtB,SAAS,EAAE5hB,OAAO,EAAE0iC,UAAU,CAAC;AAAC,YAAA,KAAA,EAAA;AAAAxmB,cAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,EAAA;AAAAgM,cAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,cAAA;AAAA,YAAA,KAAA,EAAA;AAAAgM,cAAAA,SAAA,CAAAjM,IAAA,GAAA,EAAA;cAAAiM,SAAA,CAAA5K,EAAA,GAAA4K,SAAA,CAAA,OAAA,CAAA,CAAA,EAAA,CAAA;AAAAiF,cAAAA,UAAA,CAAA7S,CAAA,CAAA4N,SAAA,CAAA5K,EAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAAA4K,cAAAA,SAAA,CAAAjM,IAAA,GAAA,EAAA;AAAAkR,cAAAA,UAAA,CAAA5S,CAAA,EAAA;cAAA,OAAA2N,SAAA,CAAA6tB,MAAA,CAAA,EAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAA7tB,SAAA,CAAA/L,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA6L,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAAA,CAAA,CAAA;OAExD,CAAA,CAAA;MAAA,OA/DKktB,SAAAA,aAAaA,CAAA5vB,GAAA,EAAA;AAAA,QAAA,OAAAyC,KAAA,CAAAje,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KA+DlB,EAAA;AAID,IAAA,IAAI,CAACy0C,kBAAkB,GAAG,UAACrP,UAAW,EAAE6G,QAAS,EAAA;MAAA,OAC/C9E,sBAAsB,CAAC/B,UAAU,CAAC,CAAC7lB,IAAI,CAAC,UAACjT,OAAO,EAAA;AAAA,QAAA,OAC9CmoC,kBAAkB,CAACnoC,OAAO,EAAE2/B,QAAQ,CAAC;AAAA,OACvC,CAAC;AAAA,KAAA;AAIH,IAAA,IAAI,CAACqK,MAAM,GAAG,UAACnkB,SAAS,EAAmB;AAAA,MAAA,IAAAokB,eAAA;AAAA,MAAA,IAAjBzyC,OAAO,GAAA9D,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AACpC,MAAA,IAAI,CAACqmC,sBAAsB,CAAClU,SAAS,CAAC,EAAE;QACtC,MAAMjiB,UAAa,CAAA,6BAAA,CAAA5S,MAAA,CAA+B60B,SAAS,MAAG,CAAC;AACjE;AAEA,MAAA,IAAMqkB,UAAU,GAAGrkB,SAAS,KAAKvwB,IAAO,IAAIuwB,SAAS,KAAKvwB,MAAS;AACnE,MAAA,IAAM60C,IAAI,GAAGtkB,SAAS,KAAKvwB,IAAO,IAAIuwB,SAAS,KAAKvwB,MAAS,GAAG,EAAE,GAAG,CAAC;AACtE,MAAA,IAAI80C,gBAAkC;AAEtC,MAAA,IAAMtgB,MAAM,GAAA,CAAAmgB,eAAA,GAAGzyC,OAAO,CAACsyB,MAAM,MAAA,IAAA,IAAAmgB,eAAA,KAAA,MAAA,GAAAA,eAAA,GAAI,GAAG;AACpC,MAAA,IAAMI,YAAY,GAAG7yC,OAAO,CAAC6yC,YAAY;MAEzC,IAAIA,YAAY,KAAK,SAAS,EAAE;AAC9BD,QAAAA,gBAAgB,GAAGF,UAAU,GACzB,UAACvvC,EAAE,EAAA;AAAA,UAAA,OACDA,EAAE,CAACrF,YAAe,CAAC,GAClB60C,IAAI,GAAGrgB,MAAM,GAAGsQ,kBAAkB,CAACz/B,EAAE,CAAC,GAAI,GAAG;AAAA,SAAA,GAChD,UAACA,EAAE,EAAA;AAAA,UAAA,OACDA,EAAE,CAACrF,aAAgB,CAAC,GACnB60C,IAAI,GAAGrgB,MAAM,GAAGkQ,iBAAiB,CAACr/B,EAAE,CAAC,GAAI,GAAG;AAAA,SAAA;AAGrD,OAAC,MAAM,IAAI0vC,YAAY,KAAK,SAAS,EAAE;AACrCD,QAAAA,gBAAgB,GAAGF,UAAU,GACzB,UAACvvC,EAAE,EAAA;AAAA,UAAA,OACDA,EAAE,CAACrF,YAAe,CAAC,GAClB60C,IAAI,GAAGrgB,MAAM,GAAGnvB,EAAE,CAACrF,eAAkB,CAAC,GAAI,GAAG;AAAA,SAAA,GAChD,UAACqF,EAAE,EAAA;AAAA,UAAA,OACDA,EAAE,CAACrF,aAAgB,CAAC,GACnB60C,IAAI,GAAGrgB,MAAM,GAAGnvB,EAAE,CAACrF,cAAiB,CAAC,GAAI,GAAG;AAAA,SAAA;OAGpD,MAAM,IAAI+0C,YAAY,KAAKj2C,SAAS,IAAIi2C,YAAY,KAAK,OAAO,EAAE;QACjE,MAAMzmC,UAAa,CAAA,mCAAA,CAAA5S,MAAA,CACmBq5C,YAAY,MAClD,CAAC;AAGH,OAAC,MAAM;AACLD,QAAAA,gBAAgB,GAAGF,UAAU,GACzB,UAACvvC,EAAE,EAAA;UAAA,OAAKA,EAAE,CAACrF,YAAe,CAAC,GAAG60C,IAAI,GAAGrgB,MAAM;AAAA,SAAA,GAC3C,UAACnvB,EAAE,EAAA;UAAA,OAAKA,EAAE,CAACrF,aAAgB,CAAC,GAAG60C,IAAI,GAAGrgB,MAAM;AAAA,SAAA;AAClD;MAEA,IAAM/wB,MAAM,GAAGmxC,UAAU,GACrB;AAAE/uC,QAAAA,GAAG,EAAEivC;AAAiB,OAAC,GACzB;AAAEpvC,QAAAA,IAAI,EAAEovC;OAAkB;AAE9B,MAAA,OAAOn2C,KAAI,CAACmN,QAAQ,CAACrI,MAAM,EAAEvB,OAAO,CAAC;KACtC;AAID,IAAA,IAAI,CAAC4J,QAAQ,GAAA,YAAA;MAAA,IAAAib,KAAA,GAAA3M,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAA0M,QAAAA,CAAOjC,EAAE,EAAA;AAAA,QAAA,IAAA7iB,OAAA;AAAA+kB,UAAAA,MAAA,GAAA7oB,SAAA;AAAA,QAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA0M,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAxM,IAAA,GAAAwM,SAAA,CAAAvM,IAAA;AAAA,YAAA,KAAA,CAAA;AAAE1Y,cAAAA,OAAO,GAAA+kB,MAAA,CAAApoB,MAAA,GAAAooB,CAAAA,IAAAA,MAAA,CAAAnoB,CAAAA,CAAAA,KAAAA,SAAA,GAAAmoB,MAAA,CAAG,CAAA,CAAA,GAAA,EAAE;cAAAE,SAAA,CAAAnL,EAAA,GACrClQ,QAAQ;cAAAqb,SAAA,CAAAxD,EAAA,GACNoB,EAAE;cAAAoC,SAAA,CAAAtD,EAAA,GACFvV,EAAE;cAAA6Y,SAAA,CAAArD,EAAA,GACA;gBAAEzC,QAAQ,EAAE8I,MAAM,CAAC6qB;eAAiB;cAAA7tB,SAAA,CAAAwlB,EAAA,GACpCzqC,OAAO;AAAAilB,cAAAA,SAAA,CAAAvM,IAAA,GAAA,CAAA;AAAA,cAAA,OAEa2qB,sBAAsB,CAACrjC,OAAO,CAACshC,UAAU,CAAC;AAAA,YAAA,KAAA,CAAA;AAAArc,cAAAA,SAAA,CAAA8tB,EAAA,GAAA9tB,SAAA,CAAApL,IAAA;AAAAoL,cAAAA,SAAA,CAAA+tB,EAAA,GAAA;gBAA5D1R,UAAU,EAAArc,SAAA,CAAA8tB;AAAA,eAAA;cAAA9tB,SAAA,CAAAguB,EAAA,GAAAhuB,SAAA,CAAAtD,EAAA,CAJX3b,KAAK,CAAAmB,IAAA,CAAA8d,SAAA,CAAAtD,EAAA,EAAAsD,SAAA,CAAArD,EAAA,EAAAqD,SAAA,CAAAwlB,EAAA,EAAAxlB,SAAA,CAAA+tB,EAAA,CAAA;AAAA,cAAA,OAAA/tB,SAAA,CAAAhI,MAAA,CAAA,QAAA,EAAA,IAAAgI,SAAA,CAAAnL,EAAA,EAAAmL,SAAA,CAAAxD,EAAA,EAAAwD,SAAA,CAAAguB,EAAA,CAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAhuB,SAAA,CAAAtM,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAmM,QAAA,CAAA;OAOT,CAAA,CAAA;AAAA,MAAA,OAAA,UAAA/C,IAAA,EAAA;AAAA,QAAA,OAAA8C,KAAA,CAAAve,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;AAAA,KAAA,EAAA;AAIH,IAAA,IAAI,CAACg3C,wBAAwB,GAAG,UAAC5R,UAAW,EAAA;MAAA,OAC1C+B,sBAAsB,CAAC/B,UAAU,CAAC,CAAC7lB,IAAI,CAAC,UAACjT,OAAO,EAAA;QAAA,OAC9C64B,sBAAsB,CAAC74B,OAAO,CAAC;AAAA,OACjC,CAAC;AAAA,KAAA;IAIH,IAAI,CAAC2qC,iBAAiB,GAAAj7B,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAkN,QAAA,GAAA;AAAA,MAAA,IAAAtlB,OAAA;QAAAwI,OAAA;QAAA4qC,UAAA;AAAAC,QAAAA,MAAA,GAAAn3C,SAAA;AAAA,MAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkN,UAAAC,SAAA,EAAA;AAAA,QAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhN,IAAA,GAAAgN,SAAA,CAAA/M,IAAA;AAAA,UAAA,KAAA,CAAA;AAAO1Y,YAAAA,OAAO,GAAAqzC,MAAA,CAAA12C,MAAA,GAAA02C,CAAAA,IAAAA,MAAA,CAAAz2C,CAAAA,CAAAA,KAAAA,SAAA,GAAAy2C,MAAA,CAAG,CAAA,CAAA,GAAA,EAAE;AAAA5tB,YAAAA,SAAA,CAAA/M,IAAA,GAAA,CAAA;AAAA,YAAA,OACpB2qB,sBAAsB,CAACrjC,OAAO,CAACshC,UAAU,CAAC;AAAA,UAAA,KAAA,CAAA;YAA1D94B,OAAO,GAAAid,SAAA,CAAA5L,IAAA;YACPu5B,UAAU,GAAG,SAAbA,UAAUA,GAAA;AAAA,cAAA,OACdhnC,UAAa,CAAC5D,OAAO,EAAE;AACrB7E,gBAAAA,GAAG,EAAE6E,OAAO,CAAC1K,YAAe,CAAC;AAC7B0F,gBAAAA,IAAI,EAAEgF,OAAO,CAAC1K,aAAgB;AAChC,eAAC,CAAC;AAAA,aAAA;YAEJ,IAAIkC,OAAO,CAACszC,SAAS,EAAE;AACrBF,cAAAA,UAAU,EAAE;AACd,aAAC,MAAM;AACL93B,cAAAA,kBAAkB,EAAE,CAACG,IAAI,CAAC23B,UAAU,CAAC;AACvC;AAAC,UAAA,KAAA,CAAA;AAAA,UAAA,KAAA,KAAA;YAAA,OAAA3tB,SAAA,CAAA9M,IAAA,EAAA;AAAA;AAAA,OAAA,EAAA2M,QAAA,CAAA;KACF,CAAA,CAAA;AAID,IAAA,IAAI,CAACiuB,WAAW,GAAG,UAACx7B,OAAQ,EAAE/X,OAAQ,EAAK;MACzC,IAAI,CAAC+X,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAG85B,iBAAiB;AAC7B;AAEA,MAAA,OAAOZ,aAAa,CAACl5B,OAAO,EAAE/X,OAAO,EAAEuxC,YAAU,CAAC;KACnD;AAID,IAAA,IAAI,CAACiC,aAAa,GAAG,UAACz7B,OAAQ,EAAEupB,UAAW,EAAK;MAC9C,IAAI,CAACvpB,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAG85B,iBAAiB;AAC7B;AAEAD,MAAAA,cAAc,CAAC75B,OAAO,EAAEupB,UAAU,EAAEiQ,YAAU,CAAC;KAChD;AAID,IAAA,IAAI,CAACkC,QAAQ,GAAG,UAAC17B,OAAO,EAAE/X,OAAQ,EAAA;AAAA,MAAA,OAChCixC,aAAa,CAACl5B,OAAO,EAAE/X,OAAO,EAAE0zC,eAAa,CAAC;AAAA,KAAA;AAIhD,IAAA,IAAI,CAACC,SAAS,GAAG,UAAC57B,OAAO,EAAEupB,UAAW,EAAK;AACzCsQ,MAAAA,cAAc,CAAC75B,OAAO,EAAEupB,UAAU,EAAEoS,eAAa,CAAC;KACnD;AACH;EAAC,OAAAt3C,YAAA,CAAAo0C,aAAA,EAAA,IAAA,EAAA,CAAA;IAAAlnC,GAAA,EAAA,yBAAA;AAAAhF,IAAAA,KAAA,EA3hBD,SAAOw+B,yBAAuBA,GAAyB;MACrD,OAAOA,uBAAuB,EAAE;AAClC;AAAC,GAAA,EAAA;IAAAx5B,GAAA,EAAA,4BAAA;AAAAhF,IAAAA,KAAA,EAUD,SAAO6+B,4BAA0BA,GAAyB;MACxD,OAAOA,0BAA0B,EAAE;AACrC;AAAC,GAAA,EAAA;IAAA75B,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EAMD,SAAOyQ,MAAMA,GAAmC;AAAA,MAAA,IAAlCkT,MAA2B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC5C,OAAO,IAAIs0C,aAAa,CAAC9jB,WAAS,CAACzE,MAAM,CAAC,EAAEC,iBAAe,CAAC;AAC9D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAmC;AAAA,MAAA,IAAlC1E,MAA2B,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AAC3C,MAAA,IAAM2wB,QAAQ,GAAGH,WAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC8Y,QAAQ,CAAC;AAE1C,MAAA,IAAIE,QAAQ,GAAGC,WAAS,CAAC9X,GAAG,CAAC4X,YAAY,CAAC;MAC1C,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAIyjB,aAAa,CAAC3jB,QAAQ,EAAE3E,iBAAe,CAAC;AACvD8E,QAAAA,WAAS,CAAChT,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AACvC;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AAmtBH,IAAM7E,iBAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,WAAS,GAAG5gB,MAAS,EAAyB;AAEpD,IAAMsgB,WAAS,GAAG,SAAZA,SAASA,CACbzE,MAA2B,EACK;EAChC,OAAO;IACLkT,eAAe,EAAEpsB,WAAW,CAACkZ,MAAM,CAACnqB,iBAAoB,CAAC,EAAE,EAAE,CAAC;IAE9D81C,gBAAgB,EAAE7kC,WAAW,CAACkZ,MAAM,CAAC4rB,eAAe,EAAE,EAAE,CAAC,IAAI,CAAC;AAC9Df,IAAAA,eAAe,EAAE/jC,WAAW,CAACkZ,MAAM,CAAC6rB,cAAc,EAAE,IAAI;GACzD;AACH,CAAC;AAED,IAAMJ,eAAa,GAAG,CAAC;AACvB,IAAMnC,YAAU,GAAG,CAAC;AAIpB,IAAMF,oBAAoB,GAAA,YAAA;AAAA,EAAA,IAAA0C,KAAA,GAAA77B,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAA47B,QAAAA,CAC3B/rB,MAAmC,EACnCjoB,OAAwB,EAAA;AAAA,IAAA,IAAAsqC,qBAAA;IAAA,IAAA3N,UAAA,EAAAn0B,OAAA;AAAA,IAAA,OAAA2P,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA27B,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAz7B,IAAA,GAAAy7B,SAAA,CAAAx7B,IAAA;AAAA,QAAA,KAAA,CAAA;AAElBikB,UAAAA,UAAU,GACdroB,eAAe,CAAC,YAAY,EAAEtU,OAAO,CAAC28B,UAAU,EAAE4F,sBAAsB,CAAC,IACzE,IAAI;AAAA2R,UAAAA,SAAA,CAAAx7B,IAAA,GAAA,CAAA;AAAA,UAAA,OAEgB2qB,sBAAsB,CAACrjC,OAAO,CAACshC,UAAU,CAAC;AAAA,QAAA,KAAA,CAAA;UAA1D94B,OAAO,GAAA0rC,SAAA,CAAAr6B,IAAA;UAAA,OAAAq6B,SAAA,CAAAj3B,MAAA,CAEN,QAAA,EAAA;AACLytB,YAAAA,QAAQ,EAAEliC,OAAO;AACjB8oC,YAAAA,YAAY,EAAE6C,cAAc,CAAC3rC,OAAO,CAAC;AACrCk0B,YAAAA,WAAW,EAAEC,UAAU;AAEvBkO,YAAAA,UAAU,EAAE97B,WAAW,CAAC/O,OAAO,CAACuqC,SAAS,EAAEtiB,MAAM,CAAC2rB,gBAAgB,CAAC,IAAI,CAAC;AACxEzY,YAAAA,eAAe,EAAAmP,CAAAA,qBAAA,GAAEtqC,OAAO,CAAClC,iBAAoB,CAAC,cAAAwsC,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAIriB,MAAM,CAACkT;WAC1D,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA+Y,SAAA,CAAAv7B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAq7B,QAAA,CAAA;GACF,CAAA,CAAA;AAAA,EAAA,OAAA,SAlBK3C,oBAAoBA,CAAAptB,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAA6vB,KAAA,CAAAztC,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAkBzB,EAAA;AAED,IAAMy1C,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpByC,cAAwC,EACxCC,eAAgC,EAAA;EAAA,OAC7B,CAACD,cAAc,IAAIhoC,QAAW,CAACgoC,cAAc,EAAEC,eAAe,CAAC;AAAA,CAAA;AAEpE,IAAMjJ,oBAAoB,GAAG,SAAvBA,oBAAoBA,CACxBprC,OAAgC,EAChCkrC,UAAsB,EACtBQ,iBAAyC,EAC7B;AACZ,EAAA,IAAM/O,UAAU,GAAG38B,OAAO,CAAC08B,WAAW;AACtC,EAAA,IAAM6N,SAAS,GAAGvqC,OAAO,CAAC6qC,UAAU;EACpC,IAAI,CAACa,iBAAiB,EAAE;AAEtB,IAAA,OAAO,KAAK;AACd;EAEA,IAAM4I,OAAO,GAAGhlC,MAAM,CACpB47B,UAAU,CAACptC,YAAe,CAAC,GAAG4tC,iBAAiB,CAAC5tC,YAAe,CAAC,EAChEotC,UAAU,CAACptC,eAAkB,CAAC,GAAG4tC,iBAAiB,CAAC5tC,eAAkB,CAAC,EACtEotC,UAAU,CAACptC,eAAkB,CAAC,GAAG4tC,iBAAiB,CAAC5tC,eAAkB,CACvE,CAAC;EAED,IAAMy2C,QAAQ,GAAGjlC,MAAM,CACrB47B,UAAU,CAACptC,aAAgB,CAAC,GAAG4tC,iBAAiB,CAAC5tC,aAAgB,CAAC,EAClEotC,UAAU,CAACptC,cAAiB,CAAC,GAAG4tC,iBAAiB,CAAC5tC,cAAiB,CAAC,EACpEotC,UAAU,CAACptC,cAAiB,CAAC,GAAG4tC,iBAAiB,CAAC5tC,cAAiB,CACrE,CAAC;EAID,IAAI02C,QAAQ,GAAG,KAAK;AAClBC,IAAAA,SAAS,GAAG,KAAK;EACnB,IACE,CAAC9X,UAAU,IACXvwB,QAAW,CAACuwB,UAAU,EAAE7+B,MAAS,CAAC,IAClCsO,QAAW,CAACuwB,UAAU,EAAE7+B,WAAc,CAAC,EACvC;IACA02C,QAAQ,GAAGC,SAAS,GAAG,IAAI;AAC7B,GAAC,MAAM;IACL,IACEroC,QAAW,CAACuwB,UAAU,EAAE7+B,IAAO,CAAC,IAChCsO,QAAW,CAACuwB,UAAU,EAAE7+B,MAAS,CAAC,EAClC;AACA02C,MAAAA,QAAQ,GAAG,IAAI;AACjB;IACA,IACEpoC,QAAW,CAACuwB,UAAU,EAAE7+B,MAAS,CAAC,IAClCsO,QAAW,CAACuwB,UAAU,EAAE7+B,OAAU,CAAC,EACnC;AACA22C,MAAAA,SAAS,GAAG,IAAI;AAClB;AACF;EAEA,OACGD,QAAQ,IAAIF,OAAO,IAAI/J,SAAS,IAAMkK,SAAS,IAAIF,QAAQ,IAAIhK,SAAU;AAE9E,CAAC;AAED,IAAMuG,eAAe,GAAA,YAAA;AAAA,EAAA,IAAA4D,MAAA,GAAAx8B,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAu8B,SACtBnsC,CAAAA,OAAgB,EAChBqoC,iBAAyC,EACzC1I,QAAiB,EAAA;IAAA,IAAAyM,SAAA,EAAAC,UAAA,EAAAC,WAAA,EAAA1iB,YAAA,EAAAiW,WAAA,EAAAC,YAAA,EAAAyM,iBAAA,EAAAC,kBAAA,EAAAC,aAAA,EAAAC,cAAA,EAAA7mB,SAAA;AAAA,IAAA,OAAAlW,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA68B,WAAAC,UAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,UAAA,CAAA38B,IAAA,GAAA28B,UAAA,CAAA18B,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAEZyvB,QAAQ,EAAA;AAAAiN,YAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA08B,UAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;UAAA,OACL4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;UAGtBs5B,SAAS,GAAGxoC,IAAO,CAAC5D,OAAO,CAAC1K,YAAe,CAAC,CAAC;UAC7C+2C,UAAU,GAAGzoC,IAAO,CAAC5D,OAAO,CAAC1K,aAAgB,CAAC,CAAC;AAC/Cg3C,UAAAA,WAAW,GAAGtsC,OAAO,CAAC1K,cAAiB,CAAC;AACxCs0B,UAAAA,YAAY,GAAG5pB,OAAO,CAAC1K,eAAkB,CAAC;AAC1CuqC,UAAAA,WAAW,GAAG7F,iBAAiB,CAACh6B,OAAO,CAAC;AACxC8/B,UAAAA,YAAY,GAAG1F,kBAAkB,CAACp6B,OAAO,CAAC;AAE1CusC,UAAAA,iBAAiB,GACrB3oC,KAAQ,CAACwoC,SAAS,CAAC,IAAIxiB,YAAY,GAAGkW,YAAY,IAAIxqC,QAAW,CAAC;AAC9Dk3C,UAAAA,kBAAkB,GACtB5oC,KAAQ,CAACyoC,UAAU,CAAC,IAAIC,WAAW,GAAGzM,WAAW,IAAIvqC,QAAW,CAAC;UAE7Dm3C,aAAa,GAAG,CAAApE,iBAAiB,KAAjBA,IAAAA,IAAAA,iBAAiB,uBAAjBA,iBAAiB,CAAE+D,SAAS,KAAI,CAAC;UACjDM,cAAc,GAAG,CAAArE,iBAAiB,KAAjBA,IAAAA,IAAAA,iBAAiB,uBAAjBA,iBAAiB,CAAEgE,UAAU,KAAI,CAAC;UAEnDxmB,SAAS,GAAGN,oBAAoB,CACpC8mB,UAAU,GAAGK,cAAc,EAC3BN,SAAS,GAAGK,aACd,CAAC;AAAA,UAAA,OAAAG,UAAA,CAAAn4B,MAAA,WAAA3Z,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;AAGC+qB,YAAAA,SAAS,EAATA;WACCvwB,EAAAA,YAAe,EAAG82C,SAAS,CAC3B92C,EAAAA,qBAAwB,EAAGi3C,iBAAiB,CAC5Cj3C,EAAAA,aAAgB,EAAG+2C,UAAU,CAC7B/2C,EAAAA,sBAAyB,EAAGk3C,kBAAkB,GAC9Cl3C,cAAiB,EAAGg3C,WAAW,GAC/Bh3C,eAAkB,EAAGs0B,YAAY,GACjCt0B,cAAiB,EAAGuqC,WAAW,GAC/BvqC,eAAkB,EAAGwqC,YAAY,CAAA,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA8M,UAAA,CAAAz8B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAg8B,SAAA,CAAA;GAErC,CAAA,CAAA;AAAA,EAAA,OAAA,SAxCK7D,eAAeA,CAAA3sB,IAAA,EAAAQ,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAA8vB,MAAA,CAAApuC,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAwCpB,EAAA;AAED,IAAM21C,iBAAiB,GAAG,SAApBA,iBAAiBA,CACrBrpC,OAAgB,EAChB2oC,UAAkD,EAC/C;EACH,IAAIvS,MAAM,GAAG,EAAE;AACf,EAAA,IAAIp2B,OAAO,KAAKy6B,2BAA2B,EAAE,EAAE;AAE7Cz6B,IAAAA,OAAO,GAAG4D,aAAgB,EAAE;AAC5BwyB,IAAAA,MAAM,GAAG,OAAO;AAClB;AAEAuS,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAAE;AAC7B,EAAA,IAAMlxB,KAAK,GAAA3c,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CACRxF,EAAAA,EAAAA,YAAe,EAAGqzC,UAAU,CAACrzC,YAAe,CAAC,CAAA,EAC7CA,qBAAwB,EAAGqzC,UAAU,CAACrzC,qBAAwB,CAAC,CAAA,EAC/DA,aAAgB,EAAGqzC,UAAU,CAACrzC,aAAgB,CAAC,GAC/CA,sBAAyB,EAAGqzC,UAAU,CAACrzC,sBAAyB,CAAC,GACjEA,cAAiB,EAAGqzC,UAAU,CAACrzC,cAAiB,CAAC,CACjDA,EAAAA,eAAkB,EAAGqzC,UAAU,CAACrzC,eAAkB,CAAC,CACrD;AACD4iB,EAAAA,oBAAoB,CAAClY,OAAO,EAAEyX,KAAK,EAAE;AAAEuB,IAAAA,OAAO,EAAEod;AAAO,GAAC,CAAC;AAC3D,CAAC;AAED,IAAMuV,cAAc,GAAG,SAAjBA,cAAcA,CAAI3rC,OAAgB,EAAmB;AACzD,EAAA,IAAIA,OAAO,KAAK4D,sBAAyB,EAAE,EAAE;AAC3C,IAAA,OAAOA,MAAS,EAAE;AACpB;AAEA,EAAA,OAAO5D,OAAO;AAChB,CAAC;AAED,IAAM8iB,gBAAc,GAAG,SAAjBA,cAAcA,CAClB1gB,QAA0B,EAC1BpC,OAAgB,EAChB2oC,UAAsB,EAAA;AAAA,EAAA,OACnBvmC,QAAQ,CAACsO,MAAM,CAAC1Q,OAAO,EAAE4D,UAAa,CAAC+kC,UAAU,CAAC,CAAC,CAAM,OAAA,CAAA,CAACn2B,QAAQ,CAAC;AAAA,CAAA;;ACzoCjE,IAAMq6B,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAY,EAAA;AAAA,EAAA,OACtClpC,QAAW,CAACmpC,KAAK,EAAED,IAAI,CAAC;AAAA,CAAA;AAmHnB,IAAME,eAAe,GAAG,SAAlBA,eAAeA,CAC1BC,QAAqC,EAC1B;EACX,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAMC,KAAK,GAAGrhC,eAAe,CAAC,OAAO,EAAEmhC,QAAQ,EAAEJ,WAAW,CAAC;AAE7D,EAAA,IAAIM,KAAK,EAAE;AAAA,IAAA,IAAAp/B,SAAA,GAAAC,0BAAA,CACOm/B,KAAK,CAAA;MAAAl/B,KAAA;AAAA,IAAA,IAAA;MAArB,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAAuB;AAAA,QAAA,IAAZnW,CAAC,GAAAiW,KAAA,CAAAnS,KAAA;AACV,QAAA,IAAI,CAAC+wC,WAAW,CAAC70C,CAAC,CAAC,EAAE;UACnB,MAAM4L,UAAa,CAAA,gBAAA,CAAA5S,MAAA,CAAkBgH,CAAC,MAAG,CAAC;AAC5C;AAEAk1C,QAAAA,YAAY,IAAIE,WAAW,CAAChgC,GAAG,CAACpV,CAAC,CAAC;AACpC;AAAC,KAAA,CAAA,OAAAqW,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AACH,GAAC,MAAM;IACL2+B,YAAY,GAAGE,WAAW,CAAClgC,OAAO;AACpC;AAEA,EAAA,OAAOggC,YAAY;AACrB,CAAC;AAMM,IAAMG,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIxjC,KAAa,EAAK;EAAA,IAAAyjC,aAAA,EAAAC,cAAA;AAClD,EAAA,IAAMl6C,KAAK,GAAGwW,KAAK,CAACxW,KAAK,CAACm6C,YAAY,CAAC;EACvC,IAAI,CAACn6C,KAAK,EAAE;IACV,MAAMuQ,UAAa,CAAA,mBAAA,CAAA5S,MAAA,CAAqB6Y,KAAK,MAAG,CAAC;AACnD;AAEA,EAAA,IAAM4jC,SAAS,GAAA,CAAAH,aAAA,GAAGj6C,KAAK,CAACmkC,MAAM,MAAA,IAAA,IAAA8V,aAAA,KAAA,MAAA,GAAA,MAAA,GAAZA,aAAA,CAAcI,GAAG;AACnC,EAAA,IAAM5xC,KAAK,GAAA,CAAAyxC,cAAA,GAAGl6C,KAAK,CAACmkC,MAAM,MAAA,IAAA,IAAA+V,cAAA,KAAA,MAAA,GAAA,MAAA,GAAZA,cAAA,CAAczxC,KAAK;AAEjC,EAAA,IAAI,CAAC2xC,SAAS,IAAI,CAAC3xC,KAAK,EAAE;AACxB,IAAA,MAAM8H,QAAW,CAAC,kCAAkC,CAAC;AACvD;EAEA,OAAO;AAAE6pC,IAAAA,SAAS,EAATA,SAAS;AAAE3xC,IAAAA,KAAK,EAALA;GAAO;AAC7B,CAAC;AAED,IAAMixC,KAAa,GAAG,CACpBz3C,IAAO,EACPA,OAAU,EACVA,OAAU,EACVA,MAAS,EACTA,OAAU,CACF;AAMH,IAAM83C,WAAW,GAAGtgC,cAAc,CAAAhP,KAAA,CAAA,MAAA,EAAA,CAAO+O,YAAY,EAAE,CAAA,CAAA7b,MAAA,CAAK+7C,KAAK,CAAC,CAAA;AAIzE,IAAMS,YAAY,GAAGtW,MAAM,CAAC,kDAAkD,CAAC;;ACrLlEyW,IAAAA,qBAAqB,GAAA/5C,YAAA,CA4ChC,SAAA+5C,qBACEvrC,CAAAA,QAAuC,EACvCuiC,cAAyC,EACzC;AAAA,EAAA,IAAA1wC,KAAA,GAAA,IAAA;AAAAT,EAAAA,eAAA,OAAAm6C,qBAAA,CAAA;AACA,EAAA,IAAIxN,eAAe,GAAGv8B,UAAa,EAAW;AAC9C,EAAA,IAAMs8B,aAAa,GAAGt8B,UAAa,EAAW;AAE9C,EAAA,IAAM2gC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAI7iC,OAAoC,EAAK;IACpE,IAAMksC,eAAe,GAAG,EAAE;AAAC,IAAA,IAAA7/B,SAAA,GAAAC,0BAAA,CAEPtM,OAAO,CAAA;MAAAuM,KAAA;AAAA,IAAA,IAAA;MAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,QAAA,IAAlB+U,KAAK,GAAAjV,KAAA,CAAAnS,KAAA;QACd,IAAIokC,aAAa,CAAC7yB,GAAG,CAACzJ,QAAW,CAACsf,KAAK,CAAC,CAAC,EAAE;UACzCtf,SAAY,CAACs8B,aAAa,EAAEt8B,QAAW,CAACsf,KAAK,CAAC,CAAC;AAC/C,UAAA;AACF;AAEA0qB,QAAAA,eAAe,CAAC1jC,IAAI,CAACgZ,KAAK,CAAC;AAC7B;AAAC,KAAA,CAAA,OAAA7U,GAAA,EAAA;MAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,KAAA,SAAA;AAAAN,MAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;AAED,IAAA,IAAI3K,QAAW,CAACgqC,eAAe,CAAC,EAAE;AAChCxrC,MAAAA,QAAQ,CAACwrC,eAAe,EAAE35C,KAAI,CAAC;AACjC;GACD;EAED,IAAMypB,QAAQ,GAAG9Z,uBAA0B,CACzC2gC,mBAAmB,EACnBI,cACF,CAAC;AAED/gC,EAAAA,cAAiB,CAAC,IAAI,EAAE,MAAM,EAAE;IAAE8I,GAAG,EAAE,SAALA,GAAGA,GAAA;MAAA,OAAQgR,QAAQ,CAACjpB,IAAI;AAAA;AAAC,GAAC,CAAC;AAC7DmP,EAAAA,cAAiB,CAAC,IAAI,EAAE,YAAY,EAAE;IACpC8I,GAAG,EAAE,SAALA,GAAGA,GAAA;MAAA,OAAQgR,QAAQ,CAACknB,UAAU;AAAA;AAChC,GAAC,CAAC;AACFhhC,EAAAA,cAAiB,CAAC,IAAI,EAAE,YAAY,EAAE;IACpC8I,GAAG,EAAE,SAALA,GAAGA,GAAA;MAAA,OAAQgR,QAAQ,CAACmwB,UAAU;AAAA;AAChC,GAAC,CAAC;EAEF,IAAI,CAACjwB,OAAO,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAAlgB,IAAA,GAAAhK,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAAyP,IAAA,GAAAE,IAAA,GAAA,CAAA,EAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA,EAAA,EAAA;AAAP6iC,MAAAA,OAAO,CAAA7iC,IAAA,CAAAlK,GAAAA,SAAA,CAAAkK,IAAA,CAAA;AAAA;AACxB,IAAA,KAAA,IAAAic,EAAA,GAAA,CAAA,EAAA6mB,QAAA,GAAqBD,OAAO,EAAA5mB,EAAA,GAAA6mB,QAAA,CAAAvsC,MAAA,EAAA0lB,EAAA,EAAE,EAAA;AAAzB,MAAA,IAAM9gB,MAAM,GAAA2nC,QAAA,CAAA7mB,EAAA,CAAA;AACfsmB,MAAAA,eAAe,CAACjvB,GAAG,CAACnY,MAAM,CAAC;AAC3B2kB,MAAAA,QAAQ,CAACE,OAAO,CAAC7kB,MAAM,CAAC;AAC1B;GACD;EAED,IAAI,CAAC4nC,YAAY,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAA3zB,KAAA,GAAAtZ,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAA+e,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAPwzB,MAAAA,OAAO,CAAAxzB,KAAA,CAAAvZ,GAAAA,SAAA,CAAAuZ,KAAA,CAAA;AAAA;AAC7B,IAAA,KAAA,IAAA2zB,GAAA,GAAA,CAAA,EAAAC,SAAA,GAAqBJ,OAAO,EAAAG,GAAA,GAAAC,SAAA,CAAA1sC,MAAA,EAAAysC,GAAA,EAAE,EAAA;AAAzB,MAAA,IAAM7nC,MAAM,GAAA8nC,SAAA,CAAAD,GAAA,CAAA;AAGf,MAAA,IAAIT,eAAe,CAAC9yB,GAAG,CAACtU,MAAM,CAAC,EAAE;AAC/B,QAAA;AACF;AAEAmnC,MAAAA,aAAa,CAAChvB,GAAG,CAACnY,MAAM,CAAC;AACzB9E,MAAAA,KAAI,CAAC2pB,OAAO,CAAC7kB,MAAM,CAAC;AACtB;GACD;EAED,IAAI,CAAC+nC,SAAS,GAAG,YAAgB;AAAA,IAAA,KAAA,IAAA75B,KAAA,GAAAvT,SAAA,CAAAS,MAAA,EAAZssC,OAAO,GAAAxyC,IAAAA,KAAA,CAAAgZ,KAAA,GAAAC,KAAA,GAAA,CAAA,EAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA,EAAA,EAAA;AAAPu5B,MAAAA,OAAO,CAAAv5B,KAAA,CAAAxT,GAAAA,SAAA,CAAAwT,KAAA,CAAA;AAAA;AAC1B,IAAA,KAAA,IAAA65B,GAAA,GAAA,CAAA,EAAAC,SAAA,GAAqBP,OAAO,EAAAM,GAAA,GAAAC,SAAA,CAAA7sC,MAAA,EAAA4sC,GAAA,EAAE,EAAA;AAAzB,MAAA,IAAMhoC,MAAM,GAAAioC,SAAA,CAAAD,GAAA,CAAA;AACfn9B,MAAAA,SAAY,CAACu8B,eAAe,EAAEpnC,MAAM,CAAC;AACrC2kB,MAAAA,QAAQ,CAACojB,SAAS,CAAC/nC,MAAM,CAAC;AAC5B;GACD;EAED,IAAI,CAAC4kB,UAAU,GAAG,YAAM;AACtBwiB,IAAAA,eAAe,GAAGv8B,UAAa,EAAE;IACjC8Z,QAAQ,CAACC,UAAU,EAAE;GACtB;EAED,IAAI,CAACgF,WAAW,GAAG,YAAA;AAAA,IAAA,OAAMjF,QAAQ,CAACiF,WAAW,EAAE;AAAA,GAAA;AACjD,CAAC,CAAA;;AC5EH,IAAamrB,WAAW,GAAA,YAAA;AA8ItB,EAAA,SAAAA,WACEruB,CAAAA,MAAiC,EACjC3e,GAA2B,EAC3B;AAAAtN,IAAAA,eAAA,OAAAs6C,WAAA,CAAA;IACA,IAAIhtC,GAAG,KAAK4e,eAAe,EAAE;AAC3B,MAAA,MAAM9b,uBAA0B,CAAC,oBAAoB,CAAC;AACxD;AAMA,IAAA,IAAMmqC,WAAW,GAAGnqC,UAAa,EAAqB;IAEtD,IAAMsc,YAAY,GAAGrB,WAAW,CAU9B,YAAA;AAAA,MAAA,OAAMjb,MAAS,EAAE;KAAC,CAAA;AAEpB,IAAA,IAAM2gC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAI7iC,OAAoC,EAAK;AACA,MAAA,IAAAqM,SAAA,GAAAC,0BAAA,CAEhDtM,OAAO,CAAA;QAAAuM,KAAA;AAAA,MAAA,IAAA;QAA3B,KAAAF,SAAA,CAAApY,CAAA,EAAAsY,EAAAA,CAAAA,CAAAA,KAAA,GAAAF,SAAA,CAAAG,CAAA,EAAAC,EAAAA,IAAA,GAA6B;AAAA,UAAA,IAAlB+U,KAAK,GAAAjV,KAAA,CAAAnS,KAAA;UACdqlC,YAAY,CAACje,KAAK,CAAC;AACrB;AAAC,OAAA,CAAA,OAAA7U,GAAA,EAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA,CAAA;AAAA,OAAA,SAAA;AAAAN,QAAAA,SAAA,CAAAQ,CAAA,EAAA;AAAA;KACF;AAED,IAAA,IAAMo2B,cAAc,GAAG;MACrBlwC,IAAI,EAAEgrB,MAAM,CAAC8C,KAAK;MAClBwf,SAAS,EAAEtiB,MAAM,CAAC4iB,UAAU;MAC5BuC,UAAU,EAAEnlB,MAAM,CAACuuB;KACpB;IAED,IAAM5M,SAAS,GAAG,IAAIuM,qBAAqB,CACzCpJ,mBAAmB,EACnBI,cACF,CAAC;AAID,IAAA,IAAMsJ,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpBjuC,OAAgB,EAEM;AAAA,MAAA,IADtB2/B,QAAQ,GAAAjsC,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAEhB,MAAA,IAAMw6C,SAAS,GAAA,YAAA;QAAA,IAAArnC,IAAA,GAAA6I,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,OAAAA,CAChBs+B,cAAmD,EAAA;UAAA,IAAAC,YAAA,EAAAhnB,IAAA;AAAA,UAAA,OAAAzX,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAC,SAAAC,QAAA,EAAA;AAAA,YAAA,OAAA,CAAA,EAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;AAAA,cAAA,KAAA,CAAA;AAAAF,gBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,gBAAA,OAExBm+B,qBAAqB,CAC9C5uB,MAAM,EACN0uB,cAAc,EACdxO,QACF,CAAC;AAAA,cAAA,KAAA,CAAA;gBAJKyO,YAAY,GAAAp+B,QAAA,CAAAqB,IAAA;AAAArB,gBAAAA,QAAA,CAAAE,IAAA,GAAA,CAAA;AAAA,gBAAA,OAKCo+B,aAAa,CAACF,YAAY,EAAEzO,QAAQ,CAAC;AAAA,cAAA,KAAA,CAAA;gBAAlDvY,IAAI,GAAApX,QAAA,CAAAqB,IAAA;AAAA,gBAAA,OAAArB,QAAA,CAAAyE,MAAA,CAAA,QAAA,EACH2S,IAAI,CAAA;AAAA,cAAA,KAAA,CAAA;AAAA,cAAA,KAAA,KAAA;gBAAA,OAAApX,QAAA,CAAAG,IAAA,EAAA;AAAA;AAAA,WAAA,EAAAN,OAAA,CAAA;SACZ,CAAA,CAAA;QAAA,OAVKq+B,SAAAA,SAASA,CAAA/7B,EAAA,EAAA;AAAA,UAAA,OAAAtL,IAAA,CAAA/I,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,SAAA;OAUd,EAAA;AAED,MAAA,IAAIisC,QAAQ,EAAE;QACZ,OAAOuO,SAAS,CAACluC,OAAO,CAAC;AAC3B;AAEA,MAAA,OAAO4D,UAAa,CAAC,UAAC3F,OAAO,EAAK;QAEhC,IAAMyf,QAAQ,GAAG9Z,uBAA0B,CAAC,UAAClC,OAAO,EAAK;UACvD,IAAM+3B,OAAO,GAAGyU,SAAS,CAACxsC,OAAO,CAAC,CAAC,CAAC,CAAC;UACrCgc,QAAQ,CAACC,UAAU,EAAE;AACrB8b,UAAAA,OAAO,CAACxmB,IAAI,CAAChV,OAAO,CAAC;SACtB,EAAE0mC,cAAc,CAAC;AAElBjnB,QAAAA,QAAQ,CAACE,OAAO,CAAC5d,OAAO,CAAC;AAC3B,OAAC,CAAC;KACH;IAID,IAAM0hB,cAAc,GAAG,SAAjBA,cAAcA,CAClBnS,OAAsB,EACtB/X,OAA8B,EAC9B+wC,SAAoB,EACD;AAAA,MAAA,IAAA5mB,iBAAA;AACnB,MAAA,IAAM3hB,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAChCt+B,MAAAA,MAAS,CAAA+d,CAAAA,iBAAA,GAACzB,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAA2hB,iBAAA,KAAA,MAAA,IAAA,CAAAA,iBAAA,GAAzBA,iBAAA,CAA2BjV,GAAG,CAAC6C,OAAO,CAAC,MAAAoS,IAAAA,IAAAA,iBAAA,KAAvCA,MAAAA,GAAAA,MAAAA,GAAAA,iBAAA,CAAyCC,SAAS,CAAC;AAG7D,MAAA,IAAMxf,QAAQ,GAAGkO,aAAY,CAACf,OAAO,CAAC;MACtCnN,QAAQ,CAACyO,QAAQ,CAAC,YAAM;AACtBgR,QAAAA,aAAa,CAACtS,OAAO,EAAE/X,OAAO,CAAC;AACjC,OAAC,CAAC;MAEF0oB,YAAY,CAACjB,IAAI,CAACjf,OAAO,CAAC,CAACwR,GAAG,CAACjC,OAAO,EAAE;AACtCqS,QAAAA,SAAS,EAAExf,QAAQ;AACnBomC,QAAAA,UAAU,EAAED,SAAS;AACrBzmB,QAAAA,QAAQ,EAAEtqB;AACZ,OAAC,CAAC;AAEF,MAAA,OAAO4K,QAAQ;KAChB;AAID,IAAA,IAAMmsC,WAAW,GAAA,YAAA;AAAA,MAAA,IAAA58B,KAAA,GAAAjC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAgC,QAAAA,CAClB7Y,MAAkB,EAClBwW,OAAsB,EACtByS,WAA2D,EAC3DumB,SAAoB,EAAA;AAAA,QAAA,IAAA/wC,OAAA,EAAAwI,OAAA,EAAAoC,QAAA,EAAAosC,QAAA;AAAA,QAAA,OAAA7+B,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAgC,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OAEEyxB,YAAY,CAACliB,MAAM,CAAC8C,KAAK,EAAExpB,MAAM,EAAEipB,WAAW,CAAC;AAAA,YAAA,KAAA,CAAA;cAA/DxqB,OAAO,GAAAua,SAAA,CAAAV,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;cAE1B9/B,QAAQ,GAAGsf,cAAc,CAACnS,OAAO,EAAE/X,OAAO,EAAE+wC,SAAS,CAAC;AAAAx2B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OAKtD+N,kBAAkB,EAAE;AAAA,YAAA,KAAA,CAAA;AAAAlM,cAAAA,SAAA,CAAA7B,IAAA,GAAA,CAAA;cAAA,OAIL+9B,gBAAgB,CAACjuC,OAAO,CAAC;AAAA,YAAA,KAAA,CAAA;cAA1CwuC,QAAQ,GAAAz8B,SAAA,CAAAV,IAAA;cAAA,IAGVm9B,EAAAA,QAAQ,CAACC,UAAU,CAACn5C,OAAU,CAAC,KAAK,CAAC,IACrCk5C,QAAQ,CAACC,UAAU,CAACn5C,QAAW,CAAC,KAAK,CAAC,CAAA,EAAA;AAAAyc,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAMpC6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;cAAA,OACIgD,4BAA4B,EAAE;AAAA,YAAA,KAAA,EAAA;AAAAnB,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;cAAA,OACnB+9B,gBAAgB,CAACjuC,OAAO,CAAC;AAAA,YAAA,KAAA,EAAA;cAA1CwuC,QAAQ,GAAAz8B,SAAA,CAAAV,IAAA;AAAA,YAAA,KAAA,EAAA;cAAA,IAGNk3B,EAAAA,SAAS,KAAKQ,UAAU,CAAA,EAAA;AAAAh3B,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,cAAA,OAEpBw+B,gBAAgB,CAACl3C,OAAO,EAAE4K,QAAQ,EAAEosC,QAAQ,CAAC;AAAA,YAAA,KAAA,EAAA;AAAA,cAAA,IAAA,CAGjDpsC,QAAQ,CAACoO,SAAS,EAAE,EAAA;AAAAuB,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAA6B,SAAA,CAAA0C,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAUxB2sB,cAAAA,SAAS,CAACT,YAAY,CAAC3gC,OAAO,CAAC;AAAC,cAAA,IAE3BgiB,WAAW,KAAXA,IAAAA,IAAAA,WAAW,KAAXA,MAAAA,IAAAA,WAAW,CAAES,WAAW,EAAA;AAAA1Q,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cACwC,IAC/Dy+B,EAAAA,cAAc,CAACH,QAAQ,CAACrB,KAAK,CAAC,GAAG31C,OAAO,CAACo3C,aAAa,CAAA,EAAA;AAAA78B,gBAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;AAAA6B,cAAAA,SAAA,CAAA7B,IAAA,GAAA,EAAA;AAAA,cAAA,OAClD4S,cAAc,CAAC1gB,QAAQ,EAAEpC,OAAO,EAAEwuC,QAAQ,CAAC;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAz8B,SAAA,CAAA5B,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAyB,QAAA,CAAA;OAGtD,CAAA,CAAA;MAAA,OAxDK28B,SAAAA,WAAWA,CAAA35B,GAAA,EAAAC,GAAA,EAAA+B,GAAA,EAAAO,GAAA,EAAA;AAAA,QAAA,OAAAxF,KAAA,CAAA7T,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAwDhB,EAAA;AAID,IAAA,IAAMm7C,YAAY,GAAA,YAAA;AAAA,MAAA,IAAAh4B,KAAA,GAAAnH,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAkH,QACnB/d,CAAAA,MAAkB,EAClBwW,OAAsB,EACtBg5B,SAAoB,EAAA;AAAA,QAAA,IAAAtkB,kBAAA;AAAA,QAAA,IAAAzsB,OAAA,EAAAwI,OAAA,EAAAwiC,SAAA;AAAA,QAAA,OAAA7yB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkH,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhH,IAAA,GAAAgH,SAAA,CAAA/G,IAAA;AAAA,YAAA,KAAA,CAAA;AAAA+G,cAAAA,SAAA,CAAA/G,IAAA,GAAA,CAAA;cAAA,OAMEyxB,YAAY,CAACliB,MAAM,CAAC8C,KAAK,EAAExpB,MAAM,EAAE,EAAE,CAAC;AAAA,YAAA,KAAA,CAAA;cAAtDvB,OAAO,GAAAyf,SAAA,CAAA5F,IAAA;cACPrR,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAE1BM,cAAAA,SAAS,IAAAve,kBAAA,GAAG/D,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAikB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvX,GAAG,CAAC6C,OAAO,CAAC;cACzD,IAAI,CAAAizB,SAAS,KAAA,IAAA,IAATA,SAAS,KAAA,MAAA,GAAA,MAAA,GAATA,SAAS,CAAEgG,UAAU,MAAKD,SAAS,EAAE;AACvC3kC,gBAAAA,MAAS,CAAC4+B,SAAS,CAAC5gB,SAAS,CAAC;gBAE9B,IAAIrS,OAAO,KAAKu/B,eAAe,EAAE;AAE/BA,kBAAAA,eAAe,CAAC9uC,OAAO,EAAE,IAAI,CAAC;AAChC;AACF;AAAC,YAAA,KAAA,CAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAiX,SAAA,CAAA9G,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA2G,QAAA,CAAA;OACF,CAAA,CAAA;AAAA,MAAA,OAAA,SArBK+3B,YAAYA,CAAA92B,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAA;AAAA,QAAA,OAAApB,KAAA,CAAA/Y,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAqBjB,EAAA;IAID,IAAMmuB,aAAa,GAAG,SAAhBA,aAAaA,CACjBtS,OAAsB,EACtB/X,OAA8B,EAC3B;AACH,MAAA,IAAMwI,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;MAEhCt+B,SAAY,CAACsc,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,EAAEuP,OAAO,CAAC;AAChD2Q,MAAAA,YAAY,CAAChB,KAAK,CAAClf,OAAO,CAAC;AAE3B,MAAA,IAAI,CAACkgB,YAAY,CAAC7S,GAAG,CAACrN,OAAO,CAAC,EAAE;AAM9BohC,QAAAA,SAAS,CAACN,SAAS,CAAC9gC,OAAO,CAAC;AAC5B4D,QAAAA,SAAY,CAACmqC,WAAW,EAAE/tC,OAAO,CAAC;AACpC;KACD;AAID,IAAA,IAAMmhC,YAAY,GAAA,YAAA;MAAA,IAAA/pB,KAAA,GAAA1H,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAyH,QAAAA,CAAO6L,KAAgC,EAAA;AAAA,QAAA,IAAAoP,kBAAA;AAAA,QAAA,IAAAtyB,OAAA,EAAAouC,YAAA,EAAA1L,UAAA,EAAAwK,YAAA,EAAA/rB,UAAA,EAAAC,MAAA,EAAA2tB,MAAA;AAAA,QAAA,OAAAp/B,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA8H,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3H,IAAA;AAAA,YAAA,KAAA,CAAA;AAEpDlQ,cAAAA,OAAO,GAAG4D,QAAW,CAACsf,KAAK,CAAC;AAAArL,cAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;AAAA,cAAA,OAIPm+B,qBAAqB,CAAC5uB,MAAM,EAAEyD,KAAK,CAAC;AAAA,YAAA,KAAA,CAAA;cAAzDkrB,YAAY,GAAAv2B,SAAA,CAAAxG,IAAA;AAAAwG,cAAAA,SAAA,CAAA3H,IAAA,GAAA,CAAA;cAAA,OACOo+B,aAAa,CAACF,YAAY,CAAC;AAAA,YAAA,KAAA,CAAA;cAA9C1L,UAAU,GAAA7qB,SAAA,CAAAxG,IAAA;AAGV67B,cAAAA,YAAY,GAAGyB,cAAc,CAACjM,UAAU,CAACyK,KAAK,CAAC;cAAAhsB,UAAA,GAAAnT,0BAAA,CAEjC,CAAA,CAAAskB,kBAAA,GAAApS,YAAY,CAACxT,GAAG,CAAC1M,OAAO,CAAC,MAAA,IAAA,IAAAsyB,kBAAA,KAAzBA,MAAAA,GAAAA,MAAAA,GAAAA,kBAAA,CAA2BvwB,MAAM,EAAE,KAAI,EAAE,CAAA;AAAA,cAAA,IAAA;gBAA7D,KAAAof,UAAA,CAAAxrB,CAAA,EAAAyrB,EAAAA,CAAAA,CAAAA,MAAA,GAAAD,UAAA,CAAAjT,CAAA,EAAAC,EAAAA,IAAA,GAA+D;kBAApD+U,MAAK,GAAA9B,MAAA,CAAAtlB,KAAA;AACd,kBAAA,IAAIoxC,YAAY,GAAGhqB,MAAK,CAACpB,QAAQ,CAAC8sB,aAAa,EAAE;oBAC/C9rB,cAAc,CAACI,MAAK,CAACtB,SAAS,EAAE5hB,OAAO,EAAE0iC,UAAU,CAAC;AACtD;AACF;AAAC,eAAA,CAAA,OAAAr0B,GAAA,EAAA;gBAAA8S,UAAA,CAAA7S,CAAA,CAAAD,GAAA,CAAA;AAAA,eAAA,SAAA;AAAA8S,gBAAAA,UAAA,CAAA5S,CAAA,EAAA;AAAA;AAAA,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAsJ,SAAA,CAAA1H,IAAA,EAAA;AAAA;AAAA,SAAA,EAAAkH,QAAA,CAAA;OACF,CAAA,CAAA;MAAA,OAjBK8pB,SAAAA,YAAYA,CAAA7nB,GAAA,EAAA;AAAA,QAAA,OAAAlC,KAAA,CAAAtZ,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAiBjB,EAAA;AAID,IAAA,IAAMg7C,gBAAgB,GAAA,YAAA;AAAA,MAAA,IAAAv2B,KAAA,GAAAzI,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAoM,QACvBxkB,CAAAA,OAA8B,EAC9Bw3C,YAA4B,EAC5BR,QAAkB,EAAA;AAAA,QAAA,IAAAxuC,OAAA,EAAAypC,WAAA,EAAAwF,aAAA,EAAAtP,QAAA,EAAAiK,UAAA,EAAAsF,QAAA,EAAAC,mBAAA,EAAAC,mBAAA,EAAAC,gBAAA,EAAAC,oBAAA;AAAA,QAAA,OAAA3/B,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAmM,UAAAC,SAAA,EAAA;AAAA,UAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAjM,IAAA,GAAAiM,SAAA,CAAAhM,IAAA;AAAA,YAAA,KAAA,CAAA;cAEZlQ,OAAO,GAAGxI,OAAO,CAAC0qC,QAAQ;AAM1BuH,cAAAA,WAAW,GAAGxI,WAAW,CAAC9c,KAAK,EAAE;AACjC8qB,cAAAA,aAAa,GAAGjH,aAAa,CAAC7jB,KAAK,EAAE;AACrCwb,cAAAA,QAAQ,GAAGnoC,OAAO,CAACm7B,eAAe,KAAK,CAAC;AAGxCiX,cAAAA,UAAU,GAAGpqB,UAAU,CAACjT,MAAM,CAAC;AACnC9X,gBAAAA,IAAI,EAAEuL,OAAO;AAEb8d,gBAAAA,OAAO,EAAE;AACX,eAAC,CAAC;AAOEoxB,cAAAA,QAAQ,GAAG,KAAK;AAEhBC,cAAAA,mBAAwC,GAAG,IAAI;AAAAjzB,cAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,cAAA,OAGjBq/B,wBAAwB,CACxDvvC,OAAO,EACP2/B,QACF,CAAC;AAAA,YAAA,KAAA,EAAA;cAHKyP,mBAAmB,GAAAlzB,SAAA,CAAA7K,IAAA;AAAA,cAAA,IAAA,CAIrB29B,YAAY,CAACx+B,SAAS,EAAE,EAAA;AAAA0L,gBAAAA,SAAA,CAAAhM,IAAA,GAAA,EAAA;AAAA,gBAAA;AAAA;cAAA,OAAAgM,SAAA,CAAAzH,MAAA,CAAA,QAAA,CAAA;AAAA,YAAA,KAAA,EAAA;AAItB46B,cAAAA,gBAAgB,GAAG,SAAnBA,gBAAgBA,GAAS;AAAA,gBAAA,IAAAG,aAAA;gBAC7B,IAAMC,aAAa,GAAGn/B,aAAY,CAAAZ,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAC,SAAAwI,QAAA,GAAA;AAAA,kBAAA,IAAAs3B,QAAA,EAAAhN,UAAA,EAAAiN,OAAA;AAAA,kBAAA,OAAAhgC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+I,UAAAC,SAAA,EAAA;AAAA,oBAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAA7I,IAAA,GAAA6I,SAAA,CAAA5I,IAAA;AAAA,sBAAA,KAAA,CAAA;AAC3Bw/B,wBAAAA,QAAQ,GAAG3B,WAAW,CAACrhC,GAAG,CAAC1M,OAAO,CAAC;AAAA8Y,wBAAAA,SAAA,CAAA5I,IAAA,GAAA,CAAA;AAAA,wBAAA,OAGhB+9B,gBAAgB,CAACjuC,OAAO,EAAE2/B,QAAQ,CAAC;AAAA,sBAAA,KAAA,CAAA;wBAAtD+C,UAAU,GAAA5pB,SAAA,CAAAzH,IAAA;AAGVs+B,wBAAAA,OAAO,GAAGC,WAAW,CAAClN,UAAU,EAAEgN,QAAQ,CAAC;AAAA,wBAAA,IAAA,CAC7CC,OAAO,EAAA;AAAA72B,0BAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,0BAAA;AAAA;AAMT69B,wBAAAA,WAAW,CAACv8B,GAAG,CAACxR,OAAO,EAAE0iC,UAAU,CAAC;AAAC,wBAAA,IAAA,EAEjCwM,QAAQ,IAAI,CAACF,YAAY,CAACx+B,SAAS,EAAE,CAAA,EAAA;AAAAsI,0BAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,0BAAA;AAAA;AAAA4I,wBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,wBAAA,OAEjC4S,cAAc,CAACksB,YAAY,EAAEhvC,OAAO,EAAE0iC,UAAU,CAAC;AAAA,sBAAA,KAAA,EAAA;AAAA5pB,wBAAAA,SAAA,CAAA5I,IAAA,GAAA,EAAA;AAAA,wBAAA;AAAA,sBAAA,KAAA,EAAA;AAGV,sBAAA,KAAA,EAAA;AAAA,sBAAA,KAAA,KAAA;wBAAA,OAAA4I,SAAA,CAAA3I,IAAA,EAAA;AAAA;AAAA,mBAAA,EAAAiI,QAAA,CAAA;AAAA,iBAElD,CAAC,CAAA,CAAA;AAGF42B,gBAAAA,YAAY,CAACn+B,QAAQ,CAAC4+B,aAAa,CAAC7uC,MAAM,CAAC;gBAC3CuuC,mBAAmB,GAAGM,aAAa,CAAC7uC,MAAM;AAG1CgpC,gBAAAA,UAAU,CAAC7lB,UAAU,CAAC0rB,aAAa,EAAA30C,eAAA,CAAA;AACjC6pB,kBAAAA,UAAU,EAAE,CAACrvB,WAAc;AAAC,iBAAA,EAC3BA,cAAiB,EAAG,IAAI,CAC1B,CAAC;gBAGFm0C,WAAW,CAAC1G,QAAQ,CAAC0M,aAAa,EAAA30C,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;AAChC/B,kBAAAA,MAAM,EAAEiH;AAAO,iBAAA,EACd1K,iBAAoB,EAAGkC,OAAO,CAACm7B,eAAe,CACpCn7B,EAAAA,WAAAA,EAAAA,OAAO,CAACwqC,gBAAgB,GAClC1sC,cAAiB,EAAG,IAAI,CAC1B,CAAC;gBAGFm0C,WAAW,CAAC1G,QAAQ,CAAC0M,aAAa,EAAA30C,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;AAChC/B,kBAAAA,MAAM,EAAAy2C,CAAAA,aAAA,GAAE/vB,MAAM,CAAC8C,KAAK,MAAA,IAAA,IAAAitB,aAAA,KAAA,MAAA,GAAAA,aAAA,GAAI5rC,SAAY;AAAE,iBAAA,EACrCtO,iBAAoB,EAAGkC,OAAO,CAACm7B,eAAe,CACpCn7B,EAAAA,WAAAA,EAAAA,OAAO,CAACwqC,gBAAgB,GAClC1sC,cAAiB,EAAG,IAAI,CAC1B,CAAC;AAAC,gBAAA,IAAAkrB,UAAA,GAAAxS,0BAAA,CAIoBohC,mBAAmB,CAAA;kBAAA1uB,MAAA;AAAA,gBAAA,IAAA;kBAA1C,KAAAF,UAAA,CAAA7qB,CAAA,EAAA+qB,EAAAA,CAAAA,CAAAA,MAAA,GAAAF,UAAA,CAAAtS,CAAA,EAAAC,EAAAA,IAAA,GAA4C;AAAA,oBAAA,IAAjCyqB,QAAQ,GAAAlY,MAAA,CAAA5kB,KAAA;oBACjBmzC,aAAa,CAAChE,QAAQ,CAACwE,aAAa,EAAA30C,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;AAClCg+B,sBAAAA,UAAU,EAAEF;AAAQ,qBAAA,EACnBtjC,iBAAoB,EAAGkC,OAAO,CAACm7B,eAAe,CACpCn7B,EAAAA,WAAAA,EAAAA,OAAO,CAAC4zC,gBAAgB,GAClC91C,cAAiB,EAAG,IAAI,CAC1B,CAAC;AACJ;AAAC,iBAAA,CAAA,OAAA+Y,GAAA,EAAA;kBAAAmS,UAAA,CAAAlS,CAAA,CAAAD,GAAA,CAAA;AAAA,iBAAA,SAAA;AAAAmS,kBAAAA,UAAA,CAAAjS,CAAA,EAAA;AAAA;eACF;AAEK+gC,cAAAA,oBAAoB,GAAG5tB,cAAc,CACzC,UAACmuB,eAAe,EAAErB,QAAQ,EAAK;gBAC7B,IAAIA,QAAQ,CAACrB,KAAK,CAAC,CAAC,CAAC,KAAK73C,IAAO,EAAE;kBACjC,IAAI,CAAC45C,QAAQ,EAAE;AACbA,oBAAAA,QAAQ,GAAG,IAAI;AACfG,oBAAAA,gBAAgB,EAAE;AACpB;iBACD,MAAM,IAAIF,mBAAmB,EAAE;AAC9BD,kBAAAA,QAAQ,GAAG,KAAK;AAChBC,kBAAAA,mBAAmB,EAAE;AACrBA,kBAAAA,mBAAmB,GAAG,IAAI;AAC5B;AACF,eAAC,EACDvrC,MAAS,CAACpM,OAAO,EAAE;gBACjBo3C,aAAa,EAAExB,WAAW,CAAClgC;eAC5B,CAAC,EACFg+B,aACF,CAAC;AAED8D,cAAAA,YAAY,CAACn+B,QAAQ,CAACy+B,oBAAoB,CAAC1uC,MAAM,CAAC;AAElDmtC,cAAAA,WAAW,CAACv8B,GAAG,CAACxR,OAAO,EAAEwuC,QAAQ,CAAC;AAElC,cAAA,IAAI,CAACc,oBAAoB,CAAC9+B,SAAS,EAAE,EAAE;AACrCsS,gBAAAA,cAAc,CAACwsB,oBAAoB,EAAEtvC,OAAO,EAAEwuC,QAAQ,CAAC;AACzD;AAAC,YAAA,KAAA,EAAA;AAAA,YAAA,KAAA,KAAA;cAAA,OAAAtyB,SAAA,CAAA/L,IAAA,EAAA;AAAA;AAAA,SAAA,EAAA6L,QAAA,CAAA;OACF,CAAA,CAAA;AAAA,MAAA,OAAA,SAlIK0yB,gBAAgBA,CAAAn1B,IAAA,EAAAkC,IAAA,EAAAC,IAAA,EAAA;AAAA,QAAA,OAAAvD,KAAA,CAAAra,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,OAAA;KAkIrB,EAAA;AAID,IAAA,IAAI,CAACu6C,gBAAgB,GAAG,UAACl1C,MAAM,EAAA;AAAA,MAAA,IAAE4mC,QAAQ,GAAAjsC,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAAA,MAAA,OAC/C6tC,YAAY,CAAC9hB,MAAM,CAAC8C,KAAK,EAAExpB,MAAM,CAAC,CAACka,IAAI,CAAC,UAACjT,OAAO,EAAA;AAAA,QAAA,OAC9CiuC,gBAAgB,CAACjuC,OAAO,EAAE2/B,QAAQ,CAAC;AAAA,OACrC,CAAC;AAAA,KAAA;IAIH,IAAI,CAACmQ,SAAS,GAAG,UAAC9vC,OAAO,EAAEuP,OAAQ,EAAE/X,OAAQ,EAAK;MAChD,IAAI,CAAC+X,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAGu/B,eAAe;AAC3B;MAEA,OAAOP,WAAW,CAACvuC,OAAO,EAAEuP,OAAO,EAAE/X,OAAO,EAAEuxC,UAAU,CAAC;KAC1D;AAID,IAAA,IAAI,CAACgH,WAAW,GAAG,UAAC/vC,OAAO,EAAEuP,OAAQ,EAAK;MACxC,IAAI,CAACA,OAAO,EAAE;AACZA,QAAAA,OAAO,GAAGu/B,eAAe;AAC3B;AAEAD,MAAAA,YAAY,CAAC7uC,OAAO,EAAEuP,OAAO,EAAEw5B,UAAU,CAAC;KAC3C;IAID,IAAI,CAACiH,MAAM,GAAG,UAACj3C,MAAM,EAAEwW,OAAO,EAAE/X,OAAQ,EAAA;MAAA,OACtC+2C,WAAW,CAACx1C,MAAM,EAAEwW,OAAO,EAAE/X,OAAO,EAAE0zC,aAAa,CAAC;AAAA,KAAA;AAItD,IAAA,IAAI,CAAC+E,OAAO,GAAG,UAACl3C,MAAM,EAAEwW,OAAO,EAAA;AAAA,MAAA,OAC7Bs/B,YAAY,CAAC91C,MAAM,EAAEwW,OAAO,EAAE27B,aAAa,CAAC;AAAA,KAAA;AAChD;EAAC,OAAAt3C,YAAA,CAAAk6C,WAAA,EAAA,IAAA,EAAA,CAAA;IAAAhtC,GAAA,EAAA,QAAA;AAAAhF,IAAAA,KAAA,EA1aD,SAAOyQ,MAAMA,GAAiC;AAAA,MAAA,IAAhCkT,MAAyB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;MAC1C,OAAO,IAAIo6C,WAAW,CAAC5pB,SAAS,CAACzE,MAAM,CAAC,EAAEC,eAAe,CAAC;AAC5D;AAAC,GAAA,EAAA;IAAA5e,GAAA,EAAA,OAAA;AAAAhF,IAAAA,KAAA,EASD,SAAOqoB,KAAKA,GAAiC;AAAA,MAAA,IAAAC,cAAA;AAAA,MAAA,IAAhC3E,MAAyB,GAAA/rB,SAAA,CAAAS,MAAA,GAAA,CAAA,IAAAT,SAAA,CAAA,CAAA,CAAA,KAAAU,SAAA,GAAAV,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE;AACzC,MAAA,IAAM2wB,QAAQ,GAAGH,SAAS,CAACzE,MAAM,CAAC;AAClC,MAAA,IAAM6E,YAAY,GAAG/Y,WAAW,CAAC3C,QAAQ,CAACyb,QAAQ,EAAE;AAAE9B,QAAAA,KAAK,EAAE;AAAK,OAAC,CAAC,CAAC;MAErE,IAAIgC,QAAQ,IAAAH,cAAA,GAAGI,SAAS,CAAC9X,GAAG,CAAC2X,QAAQ,CAAC9B,KAAK,CAAC,MAAA,IAAA,IAAA6B,cAAA,KAA7BA,MAAAA,GAAAA,MAAAA,GAAAA,cAAA,CAA+B1X,GAAG,CAAC4X,YAAY,CAAC;MAC/D,IAAI,CAACC,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAG,IAAIupB,WAAW,CAACzpB,QAAQ,EAAE3E,eAAe,CAAC;AACrD8E,QAAAA,SAAS,CAACvF,IAAI,CAACoF,QAAQ,CAAC9B,KAAK,CAAC,CAAC/Q,GAAG,CAAC8S,YAAY,EAAEC,QAAQ,CAAC;AAC5D;AAEA,MAAA,OAAOA,QAAQ;AACjB;AAAC,GAAA,CAAA,CAAA;AAAA,CAAA,EAAA;AA8lBH,IAAM7E,eAA8B,GAAGpqB,MAAS,EAA4B;AAC5E,IAAMkvB,SAAS,GAAG/F,OAAO,CAA2C,YAAA;AAAA,EAAA,OAClE7a,MAAS,EAAE;AAAA,CACb,CAAC;AAED,IAAMsgB,SAAS,GAAG,SAAZA,SAASA,CACbzE,MAAqC,EACP;AAAA,EAAA,IAAAywB,kBAAA;EAC9B,OAAO;IACL3tB,KAAK,EAAE,CAAA9C,MAAM,KAANA,IAAAA,IAAAA,MAAM,uBAANA,MAAM,CAAEhrB,IAAI,KAAI,IAAI;AAC3Bu5C,IAAAA,WAAW,EAAAkC,CAAAA,kBAAA,GAAEzwB,MAAM,aAANA,MAAM,KAAA,MAAA,GAAA,MAAA,GAANA,MAAM,CAAEmlB,UAAU,MAAAsL,IAAAA,IAAAA,kBAAA,KAAAA,MAAAA,GAAAA,kBAAA,GAAI,iBAAiB;IACpD7N,UAAU,EAAE,CAAA5iB,MAAM,KAAA,IAAA,IAANA,MAAM,KAANA,MAAAA,GAAAA,MAAAA,GAAAA,MAAM,CAAEsiB,SAAS,KAAI;GAClC;AACH,CAAC;AAED,IAAMmJ,aAAa,GAAG,CAAC;AACvB,IAAMnC,UAAU,GAAG,CAAC;AAIpB,IAAMpH,YAAY,GAAA,YAAA;AAAA,EAAA,IAAAtlB,KAAA,GAAA3M,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAA0M,QACnB7nB,CAAAA,IAAoB,EACpBsE,MAAkB,EAClBvB,OAAuD,EAAA;AAAA,IAAA,OAAAmY,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA0M,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAxM,IAAA,GAAAwM,SAAA,CAAAvM,IAAA;AAAA,QAAA,KAAA,CAAA;AAAAuM,UAAAA,SAAA,CAAAvM,IAAA,GAAA,CAAA;AAAA,UAAA,OAGrCqxB,YAAY,CAAC9sC,IAAI,EAAEsE,MAAM,CAAC;AAAA,QAAA,KAAA,CAAA;AAAA0jB,UAAAA,SAAA,CAAAnL,EAAA,GAAAmL,SAAA,CAAApL,IAAA;AAAAoL,UAAAA,SAAA,CAAAxD,EAAA,GAC3B+zB,eAAe,CAACx1C,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,MAAAA,GAAAA,MAAAA,GAAAA,OAAO,CAAE21C,KAAK,CAAC;UAAA1wB,SAAA,CAAAtD,EAAA,GAC7B3hB,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE8X,cAAc;UAAAmN,SAAA,CAAArD,EAAA,GACtB5hB,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAEyrC,eAAe;UAAAxmB,SAAA,CAAAwlB,EAAA,GACxBzqC,OAAO,aAAPA,OAAO,KAAA,MAAA,GAAA,MAAA,GAAPA,OAAO,CAAE6zC,eAAe;UAAA,OAAA5uB,SAAA,CAAAhI,MAAA,CAAA,QAAA,EAAA;YAJ1CytB,QAAQ,EAAAzlB,SAAA,CAAAnL,EAAA;YACRs9B,aAAa,EAAAnyB,SAAA,CAAAxD,EAAA;YACb0Z,eAAe,EAAAlW,SAAA,CAAAtD,EAAA;YACf6oB,gBAAgB,EAAAvlB,SAAA,CAAArD,EAAA;YAChBgyB,gBAAgB,EAAA3uB,SAAA,CAAAwlB;AAAA,WAAA,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAxlB,SAAA,CAAAtM,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAmM,QAAA,CAAA;GAEnB,CAAA,CAAA;AAAA,EAAA,OAAA,SAZKqlB,YAAYA,CAAAhmB,IAAA,EAAAQ,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAC,KAAA,CAAAve,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAYjB,EAAA;AAED,IAAM67C,wBAAwB,GAAA,YAAA;AAAA,EAAA,IAAA1yB,KAAA,GAAAnN,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAAkN,QAAAA,CAC/B9c,OAAgB,EAChB2/B,QAAiB,EAAA;IAAA,IAAAyP,mBAAA,EAAAxW,QAAA;AAAA,IAAA,OAAAjpB,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkN,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAhN,IAAA,GAAAgN,SAAA,CAAA/M,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAEZyvB,QAAQ,EAAA;AAAA1iB,YAAAA,SAAA,CAAA/M,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA+M,UAAAA,SAAA,CAAA/M,IAAA,GAAA,CAAA;UAAA,OACL4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;AAGtBs8B,UAAAA,mBAAmB,GAAG,EAAE;AAC1BxW,UAAAA,QAAoC,GAAG54B,OAAO;AAClD,UAAA,OAAQ44B,QAAQ,GAAGD,oBAAoB,CAACC,QAAQ,EAAE;AAAEX,YAAAA,MAAM,EAAE;AAAK,WAAC,CAAC,EAAG;AACpEmX,YAAAA,mBAAmB,CAACllC,IAAI,CAAC0uB,QAAQ,CAAC;AACpC;AAAC,UAAA,OAAA3b,SAAA,CAAAxI,MAAA,CAAA,QAAA,EAEM26B,mBAAmB,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAnyB,SAAA,CAAA9M,IAAA,EAAA;AAAA;AAAA,KAAA,EAAA2M,QAAA,CAAA;GAC3B,CAAA,CAAA;AAAA,EAAA,OAAA,SAfKyyB,wBAAwBA,CAAA5yB,IAAA,EAAAQ,IAAA,EAAA;AAAA,IAAA,OAAAN,KAAA,CAAA/e,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAe7B,EAAA;AAED,IAAMk8C,WAAW,GAAG,SAAdA,WAAWA,CAAIlN,UAAoB,EAAEgN,QAA8B,EAAA;AAAA,EAAA,OACvE,CAACA,QAAQ,IACTf,cAAc,CAACe,QAAQ,CAACvC,KAAK,CAAC,KAAKwB,cAAc,CAACjM,UAAU,CAACyK,KAAK,CAAC,IACnE,CAACpkC,gBAAe,CACdnF,qBAAwB,CAAC8rC,QAAQ,CAACS,YAAY,CAAC,EAC/CvsC,qBAAwB,CAAC8+B,UAAU,CAACyN,YAAY,CAClD,CAAC,IACD,CAACpnC,gBAAe,CAAC2mC,QAAQ,CAACjB,UAAU,EAAE/L,UAAU,CAAC+L,UAAU,CAAC,IAC5D,CAAC1lC,gBAAe,CAAC2mC,QAAQ,CAACU,QAAQ,EAAE1N,UAAU,CAAC0N,QAAQ,CAAC;AAAA,CAAA;AAE1D,IAAMzB,cAAc,GAAG,SAAjBA,cAAcA,CAAIxB,KAAoB,EAAA;EAAA,OAC1CC,WAAW,CAAChgC,GAAG,CAAC+/B,KAAK,CAAC,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAChgC,GAAG,CAAC+/B,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAAA,CAAA;AAExE,IAAMkB,qBAAqB,GAAA,YAAA;AAAA,EAAA,IAAA9C,KAAA,GAAA77B,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAA47B,QAAAA,CAC5B/rB,MAAiC,EACjC4wB,aAAkD,EAAA;AAAA,IAAA,IAAA1Q,QAAA;MAAAlrC,IAAA;MAAA67C,MAAA;MAAAC,WAAA;MAAAx3C,MAAA;MAAAo3C,YAAA;MAAA1B,UAAA;MAAAxI,cAAA;MAAAuK,aAAA;AAAAC,MAAAA,MAAA,GAAA/8C,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA27B,UAAAC,SAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,SAAA,CAAAz7B,IAAA,GAAAy7B,SAAA,CAAAx7B,IAAA;AAAA,QAAA,KAAA,CAAA;UAClDyvB,QAAQ,GAAA8Q,MAAA,CAAAt8C,MAAA,GAAA,CAAA,IAAAs8C,MAAA,CAAA,CAAA,CAAA,KAAAr8C,SAAA,GAAAq8C,MAAA,CAAA,CAAA,CAAA,GAAG,KAAK;UAEVh8C,IAAI,GAAGgrB,MAAM,CAAC8C,KAAK;AAAAmpB,UAAAA,SAAA,CAAAx7B,IAAA,GAAA,CAAA;UAAA,OACJuvB,iBAAiB,CAACE,QAAQ,CAAC;AAAA,QAAA,KAAA,CAAA;UAA1C2Q,MAAM,GAAA5E,SAAA,CAAAr6B,IAAA;UACNk/B,WAAW,GAAG1lC,SAAS,CAAC4U,MAAM,CAACuuB,WAAW,EAAEsC,MAAM,CAAC;AAIrD7B,UAAAA,UAA+B,GAAG,IAAI;AACtCxI,UAAAA,cAA8B,GAAG,IAAI;AACrCuK,UAAAA,aAA6B,GAAG,IAAI;AAAA,UAAA,IAAA,CAEpC5sC,YAAe,CAACysC,aAAa,EAAEK,yBAAyB,CAAC,EAAA;AAAAhF,YAAAA,SAAA,CAAAx7B,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UAC3DnX,MAAM,GAAGs3C,aAAa,CAACt3C,MAAM;UAC7Bo3C,YAAY,GAAGE,aAAa,CAACM,kBAAkB;UAC/ClC,UAAU,GAAG4B,aAAa,CAAC5B,UAAU;UACrCxI,cAAc,GAAGoK,aAAa,CAACpK,cAAc;AAC7CuK,UAAAA,aAAa,GAAG,CAACH,aAAa,CAAC5B,UAAU;AAAC/C,UAAAA,SAAA,CAAAx7B,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,EAAA;AAE1CnX,UAAAA,MAAM,GAAGs3C,aAAa;AAAC3E,UAAAA,SAAA,CAAAx7B,IAAA,GAAA,EAAA;AAAA,UAAA,OACF0gC,WAAW,CAAC73C,MAAM,EAAE4mC,QAAQ,CAAC;AAAA,QAAA,KAAA,EAAA;UAAlDwQ,YAAY,GAAAzE,SAAA,CAAAr6B,IAAA;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,IAGTo9B,UAAU,EAAA;AAAA/C,YAAAA,SAAA,CAAAx7B,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAAw7B,UAAAA,SAAA,CAAAx7B,IAAA,GAAA,EAAA;AAAA,UAAA,OACM0gC,WAAW,CAACn8C,IAAI,EAAEkrC,QAAQ,EAAE4Q,WAAW,CAAC;AAAA,QAAA,KAAA,EAAA;UAA3D9B,UAAU,GAAA/C,SAAA,CAAAr6B,IAAA;AAAA,QAAA,KAAA,EAAA;UAAA,OAAAq6B,SAAA,CAAAj3B,MAAA,CAGL,QAAA,EAAA;AACLoL,YAAAA,OAAO,EAAE9mB,MAAM;AACf83C,YAAAA,aAAa,EAAEV,YAAY;AAC3B5tB,YAAAA,KAAK,EAAE9tB,IAAI;AACXq8C,YAAAA,YAAY,EAAEP,WAAW;AACzBQ,YAAAA,WAAW,EAAEtC,UAAU;AACvBuC,YAAAA,eAAe,EAAE/K,cAAc;AAC/BgL,YAAAA,cAAc,EAAET;WACjB,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA9E,SAAA,CAAAv7B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAq7B,QAAA,CAAA;GACF,CAAA,CAAA;AAAA,EAAA,OAAA,SAvCK6C,qBAAqBA,CAAA6C,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAA5F,KAAA,CAAAztC,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAuC1B,EAAA;AAED,IAAMk9C,WAAW,GAAA,YAAA;AAAA,EAAA,IAAA1E,MAAA,GAAAx8B,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAAu8B,SAClB13C,CAAAA,IAAoB,EACpBkrC,QAAiB,EACjB4Q,WAA8C,EAAA;AAAA,IAAA,IAAA11C,IAAA,EAAAu2C,qBAAA,EAAAC,KAAA,EAAAC,MAAA;AAAA,IAAA,OAAA3hC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA68B,WAAAC,UAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,UAAA,CAAA38B,IAAA,GAAA28B,UAAA,CAAA18B,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CAI1Czb,IAAI,EAAA;AAAAm4C,YAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,IACDyvB,QAAQ,EAAA;AAAAiN,YAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA08B,UAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;UAAA,OACL4C,kBAAkB,EAAE;AAAA,QAAA,KAAA,CAAA;UAG5BjY,IAAI,GAAG+I,qBAAwB,CAACA,qBAAwB,CAACnP,IAAI,CAAC,CAAC;AAACm4C,UAAAA,UAAA,CAAA18B,IAAA,GAAA,EAAA;AAAA,UAAA;AAAA,QAAA,KAAA,CAAA;AAAA08B,UAAAA,UAAA,CAAA18B,IAAA,GAAA,CAAA;UAAA,OAEhCuvB,iBAAiB,CAACE,QAAQ,CAAC;AAAA,QAAA,KAAA,CAAA;UAAAyR,qBAAA,GAAAxE,UAAA,CAAAv7B,IAAA;UAAnDggC,KAAK,GAAAD,qBAAA,CAALC,KAAK;UAAEC,MAAM,GAAAF,qBAAA,CAANE,MAAM;AACrBz2C,UAAAA,IAAI,GAAG;AACLE,YAAAA,CAAC,EAAE,CAAC;AACJC,YAAAA,IAAI,EAAE,CAAC;AACPC,YAAAA,KAAK,EAAEo2C,KAAK;AACZA,YAAAA,KAAK,EAALA,KAAK;AACLn2C,YAAAA,CAAC,EAAE,CAAC;AACJC,YAAAA,GAAG,EAAE,CAAC;AACNC,YAAAA,MAAM,EAAEk2C,MAAM;AACdA,YAAAA,MAAM,EAANA;WACD;AAAC,QAAA,KAAA,EAAA;AAGJ,UAAA,IAAIf,WAAW,EAAE;AACf11C,YAAAA,IAAI,CAACE,CAAC,GAAGF,IAAI,CAACvF,MAAS,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC;YAC1C11C,IAAI,CAACvF,OAAU,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC;AAClC11C,YAAAA,IAAI,CAACvF,OAAU,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAC;AAEnD11C,YAAAA,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACvF,KAAQ,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC;YACzC11C,IAAI,CAACvF,QAAW,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC;AACnC11C,YAAAA,IAAI,CAACvF,QAAW,CAAC,IAAIi7C,WAAW,CAAC,CAAC,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAC;AACtD;AAAC,UAAA,OAAA3D,UAAA,CAAAn4B,MAAA,CAAA,QAAA,EAEM5Z,IAAI,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAA+xC,UAAA,CAAAz8B,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAg8B,SAAA,CAAA;GACZ,CAAA,CAAA;AAAA,EAAA,OAAA,SAtCKyE,WAAWA,CAAAW,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAvF,MAAA,CAAApuC,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAsChB,EAAA;AAED,IAAM46C,aAAa,GAAA,YAAA;EAAA,IAAAoD,MAAA,GAAAhiC,iBAAA,CAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAA+hC,SAAAA,CACpBvD,YAA8B,EAAA;AAAA,IAAA,IAAAwD,qBAAA;AAAA,IAAA,IAAAjS,QAAA;MAAA2Q,MAAA;MAAAuB,QAAA;MAAAC,OAAA;MAAA3E,KAAA;MAAAiD,QAAA;MAAA5B,QAAA;AAAAuD,MAAAA,OAAA,GAAAr+C,SAAA;AAAA,IAAA,OAAAic,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAAkiC,WAAAC,UAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,UAAA,CAAAhiC,IAAA,GAAAgiC,UAAA,CAAA/hC,IAAA;AAAA,QAAA,KAAA,CAAA;UAC9ByvB,QAAQ,GAAAoS,OAAA,CAAA59C,MAAA,GAAA,CAAA,IAAA49C,OAAA,CAAA,CAAA,CAAA,KAAA39C,SAAA,GAAA29C,OAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAAAE,UAAAA,UAAA,CAAA/hC,IAAA,GAAA,CAAA;UAAA,OAEKuvB,iBAAiB,CAACE,QAAQ,CAAC;AAAA,QAAA,KAAA,CAAA;UAA1C2Q,MAAM,GAAA2B,UAAA,CAAA5gC,IAAA;AACNwgC,UAAAA,QAAQ,GAAGvB,MAAM,CAACh7C,QAAW,CAAC;AAC9Bw8C,UAAAA,OAAO,GAAGxB,MAAM,CAACh7C,OAAU,CAAC;AAAA28C,UAAAA,UAAA,CAAA/hC,IAAA,GAAA,CAAA;AAAA,UAAA,OAEdgiC,WAAU,CAAC9D,YAAY,EAAEzO,QAAQ,CAAC;AAAA,QAAA,KAAA,CAAA;UAAhDwN,KAAK,GAAA8E,UAAA,CAAA5gC,IAAA;AAEL++B,UAAAA,QAAQ,GAAGxsC,KAAQ,CACvB;AAAEuuC,YAAAA,OAAO,EAAEnT,GAAG;AAAEoT,YAAAA,OAAO,EAAEpT;WAAK,EAC9Bp7B,qBAAwB,CAACwqC,YAAY,CAACyC,aAAa,CACrD,CAAC;UAEDT,QAAQ,CAACl1C,CAAC,IAAI22C,QAAQ;AACtBzB,UAAAA,QAAQ,CAAC96C,KAAQ,CAAC,IAAIu8C,QAAQ;AAC9BzB,UAAAA,QAAQ,CAAC96C,QAAW,CAAC,IAAIu8C,QAAQ;AACjCzB,UAAAA,QAAQ,CAAC96C,QAAW,CAAC,IAAIu8C,QAAQ;UAEjCzB,QAAQ,CAACr1C,CAAC,IAAI+2C,OAAO;AACrB1B,UAAAA,QAAQ,CAAC96C,MAAS,CAAC,IAAIw8C,OAAO;AAC9B1B,UAAAA,QAAQ,CAAC96C,OAAU,CAAC,IAAIw8C,OAAO;AAC/B1B,UAAAA,QAAQ,CAAC96C,OAAU,CAAC,IAAIw8C,OAAO;AAE/B1B,UAAAA,QAAQ,CAAC+B,OAAO,GAAG,CAAC/B,QAAQ,CAAC96C,MAAS,CAAC,GAAG86C,QAAQ,CAAC96C,OAAU,CAAC,IAAI,CAAC;AACnE86C,UAAAA,QAAQ,CAACgC,OAAO,GAAG,CAAChC,QAAQ,CAAC96C,KAAQ,CAAC,GAAG86C,QAAQ,CAAC96C,QAAW,CAAC,IAAI,CAAC;AAE7Dk5C,UAAAA,QAAkB,GAAG;AACzBvI,YAAAA,cAAc,GAAA2L,qBAAA,GAAExD,YAAY,CAAC4C,eAAe,cAAAY,qBAAA,KAAA,MAAA,GAAAA,qBAAA,GAAIzE,KAAK,CAAC,CAAC,CAAC,KAAK73C,IAAO;YACpE66C,YAAY,EAAE/B,YAAY,CAACyC,aAAa;YACxCpC,UAAU,EAAEL,YAAY,CAAC2C,WAAW;AACpC5D,YAAAA,KAAK,EAALA,KAAK;AACLiD,YAAAA,QAAQ,EAARA;WACD;AAAA,UAAA,OAAA6B,UAAA,CAAAx9B,MAAA,CAAA,QAAA,EAEM+5B,QAAQ,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAyD,UAAA,CAAA9hC,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAwhC,SAAA,CAAA;GAChB,CAAA,CAAA;EAAA,OArCKrD,SAAAA,aAAaA,CAAA+D,IAAA,EAAA;AAAA,IAAA,OAAAX,MAAA,CAAA5zC,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAqClB,EAAA;AAED,IAAMw+C,WAAU,GAAA,YAAA;AAAA,EAAA,IAAAI,MAAA,GAAA5iC,iBAAA,CAAAC,mBAAA,EAAAC,CAAAA,IAAA,CAAG,SAAA2iC,SACjBnE,CAAAA,YAA8B,EAC9BzO,QAAiB,EACjB6S,oBAA8B,EAAA;IAAA,IAAA/D,UAAA,EAAA0B,YAAA,EAAAsC,KAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,iBAAA;AAAA,IAAA,OAAAjjC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA+iC,WAAAC,UAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,UAAA,CAAA7iC,IAAA,GAAA6iC,UAAA,CAAA5iC,IAAA;AAAA,QAAA,KAAA,CAAA;UAAA,IAE1Bk+B,CAAAA,YAAY,CAAC4C,eAAe,EAAA;AAAA8B,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;UAAA,OAAA4iC,UAAA,CAAAr+B,MAAA,CAAA,QAAA,EACvB,CAACnf,IAAO,CAAC,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CAIdk9C,oBAAoB,EAAA;AAAAM,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA4iC,UAAAA,UAAA,CAAA5iC,IAAA,GAAA,CAAA;UAAA,OACH0gC,WAAW,CAC5B4B,oBAAoB,EACpB7S,QAAQ,EACRyO,YAAY,CAAC0C,YACf,CAAC;AAAA,QAAA,KAAA,CAAA;UAJDrC,UAAU,GAAAqE,UAAA,CAAAzhC,IAAA;AAAAyhC,UAAAA,UAAA,CAAA5iC,IAAA,GAAA,CAAA;AAAA,UAAA;AAAA,QAAA,KAAA,CAAA;UAMVu+B,UAAU,GAAGL,YAAY,CAAC2C,WAAW;AAAC,QAAA,KAAA,CAAA;UAGlCZ,YAAY,GAAG/B,YAAY,CAACyC,aAAa;AACzC4B,UAAAA,KAAK,GAAG;AACZM,YAAAA,KAAK,EAAEtE,UAAU,CAACn5C,MAAS,CAAC,GAAG66C,YAAY,CAAC76C,MAAS,CAAC;AACtD09C,YAAAA,MAAM,EAAE7C,YAAY,CAAC76C,OAAU,CAAC,GAAGm5C,UAAU,CAACn5C,OAAU,CAAC;AACzD29C,YAAAA,IAAI,EAAExE,UAAU,CAACn5C,KAAQ,CAAC,GAAG66C,YAAY,CAAC76C,KAAQ,CAAC;AACnD49C,YAAAA,OAAO,EAAE/C,YAAY,CAAC76C,QAAW,CAAC,GAAGm5C,UAAU,CAACn5C,QAAW;WAC5D;AAEGo9C,UAAAA,KAAkB,GAAG,IAAI;AACzBC,UAAAA,KAAkB,GAAG,IAAI;UAC7B,IAAIF,KAAK,CAACM,KAAK,GAAG,CAAC,IAAIN,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;AAGvCN,YAAAA,KAAK,GAAGD,KAAK,CAACM,KAAK,GAAGN,KAAK,CAACO,MAAM,GAAG19C,OAAU,GAAGA,MAAS;AAC7D,WAAC,MAAM,IAAIm9C,KAAK,CAACM,KAAK,GAAG,CAAC,EAAE;YAE1BL,KAAK,GAAGp9C,OAAU;AACpB,WAAC,MAAM,IAAIm9C,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;YAE3BN,KAAK,GAAGp9C,MAAS;AACnB;UAEA,IAAIm9C,KAAK,CAACQ,IAAI,GAAG,CAAC,IAAIR,KAAK,CAACS,OAAO,GAAG,CAAC,EAAE;AAGvCP,YAAAA,KAAK,GAAGF,KAAK,CAACQ,IAAI,GAAGR,KAAK,CAACS,OAAO,GAAG59C,OAAU,GAAGA,OAAU;AAC9D,WAAC,MAAM,IAAIm9C,KAAK,CAACQ,IAAI,GAAG,CAAC,EAAE;YAEzBN,KAAK,GAAGr9C,OAAU;AACpB,WAAC,MAAM,IAAIm9C,KAAK,CAACS,OAAO,GAAG,CAAC,EAAE;YAE5BP,KAAK,GAAGr9C,OAAU;AACpB;UAAC,IAEGo9C,EAAAA,KAAK,IAAIC,KAAK,CAAA,EAAA;AAAAG,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UAAA,OAAA4iC,UAAA,CAAAr+B,MAAA,CAAA,QAAA,EAET,CAACi+B,KAAK,EAAEC,KAAK,CAAC,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,IAAA,CACZD,KAAK,EAAA;AAAAI,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAA4iC,UAAA,CAAAr+B,MAAA,CAEP,QAAA,EAAA,CAACi+B,KAAK,CAAC,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,UAAA,IAAA,CACLC,KAAK,EAAA;AAAAG,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAA4iC,UAAA,CAAAr+B,MAAA,CAEP,QAAA,EAAA,CAACk+B,KAAK,CAAC,CAAA;AAAA,QAAA,KAAA,EAAA;UAAA,IAeXvE,YAAY,CAAC6C,cAAc,EAAA;AAAA6B,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;AASxB0iC,UAAAA,iBAAiB,GAAGja,oBAAoB,CAC5C6Z,oBAAoB,KAApBA,IAAAA,IAAAA,oBAAoB,KAApBA,MAAAA,GAAAA,oBAAoB,GAAIpE,YAAY,CAACvuB,OACvC,CAAC;AAAA,UAAA,IAAA,CAEG+yB,iBAAiB,EAAA;AAAAE,YAAAA,UAAA,CAAA5iC,IAAA,GAAA,EAAA;AAAA,YAAA;AAAA;UAAA,OAAA4iC,UAAA,CAAAr+B,MAAA,CACZy9B,QAAAA,EAAAA,WAAU,CAAC9D,YAAY,EAAEzO,QAAQ,EAAEiT,iBAAiB,CAAC,CAAA;AAAA,QAAA,KAAA,EAAA;UAAA,OAAAE,UAAA,CAAAr+B,MAAA,CAAA,QAAA,EAOzD,CAACnf,IAAO,CAAC,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAw9C,UAAA,CAAA3iC,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAoiC,SAAA,CAAA;GACjB,CAAA,CAAA;AAAA,EAAA,OAAA,SAnGKL,UAAUA,CAAAiB,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAf,MAAA,CAAAx0C,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAmGf,EAAA;AAED,IAAMo7C,eAAe,GAAG,SAAlBA,eAAeA,CACnB9uC,OAAgB,EAChBwuC,QAAqC,EAClC;AACH,EAAA,IAAM4B,QAAgC,GAAG,CAAA5B,QAAQ,KAARA,IAAAA,IAAAA,QAAQ,KAARA,MAAAA,GAAAA,MAAAA,GAAAA,QAAQ,CAAE4B,QAAQ,KAAI,EAAE;EACjE,IAAM34B,KAAK,GAAA3c,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAA;IACTK,GAAG,EAAEi1C,QAAQ,CAACj1C,GAAG;IACjBC,MAAM,EAAEg1C,QAAQ,CAACh1C,MAAM;IACvBJ,IAAI,EAAEo1C,QAAQ,CAACp1C,IAAI;IACnBC,KAAK,EAAEm1C,QAAQ,CAACn1C;AAAK,GAAA,EACpB3F,OAAU,EAAG86C,QAAQ,CAAC96C,OAAU,CAAC,CACjCA,EAAAA,QAAW,EAAG86C,QAAQ,CAAC96C,QAAW,CAAC,CAAA,EAAA,SAAA,EAC3B86C,QAAQ,CAAC+B,OAAO,CAAA,EAAA,SAAA,EAChB/B,QAAQ,CAACgC,OAAO,CAC1B;AACDl6B,EAAAA,oBAAoB,CAAClY,OAAO,EAAEyX,KAAK,EAAE;AAAEuB,IAAAA,OAAO,EAAE,IAAI;AAAEE,IAAAA,WAAW,EAAE;AAAE,GAAC,CAAC;AACzE,CAAC;AAED,IAAMqoB,YAAY,GAAA,YAAA;AAAA,EAAA,IAAA+R,MAAA,GAAA5jC,iBAAA,CAAAC,mBAAA,EAAA,CAAAC,IAAA,CAAG,SAAA2jC,SAAAA,CACnB9+C,IAAoB,EACpBsE,MAAkB,EAAA;AAAA,IAAA,IAAAy6C,cAAA;AAAA,IAAA,OAAA7jC,mBAAA,EAAA,CAAAG,IAAA,CAAA,SAAA2jC,WAAAC,UAAA,EAAA;AAAA,MAAA,OAAA,CAAA,EAAA,QAAAA,UAAA,CAAAzjC,IAAA,GAAAyjC,UAAA,CAAAxjC,IAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IAAA,CAEdtM,SAAY,CAAC7K,MAAM,CAAC,EAAA;AAAA26C,YAAAA,UAAA,CAAAxjC,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,OAAAwjC,UAAA,CAAAj/B,MAAA,CAAA,QAAA,EACf1b,MAAM,CAAA;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,IACH6K,QAAW,CAAC7K,MAAM,CAAC,EAAA;AAAA26C,YAAAA,UAAA,CAAAxjC,IAAA,GAAA,CAAA;AAAA,YAAA;AAAA;AAAA,UAAA,MACvBtM,UAAa,CACjB,kFACF,CAAC;AAAA,QAAA,KAAA,CAAA;AAGG4vC,UAAAA,cAAc,GAAGG,iBAAiB,CAACl/C,IAAI,EAAEsE,MAAM,CAAC;AAAA26C,UAAAA,UAAA,CAAAxjC,IAAA,GAAA,CAAA;UAAA,OACzCgtB,aAAa,CAACsW,cAAc,CAAC;AAAA,QAAA,KAAA,CAAA;AAAA,UAAA,OAAAE,UAAA,CAAAj/B,MAAA,CAAAi/B,QAAAA,EAAAA,UAAA,CAAAriC,IAAA,CAAA;AAAA,QAAA,KAAA,EAAA;AAAA,QAAA,KAAA,KAAA;UAAA,OAAAqiC,UAAA,CAAAvjC,IAAA,EAAA;AAAA;AAAA,KAAA,EAAAojC,SAAA,CAAA;GAC3C,CAAA,CAAA;AAAA,EAAA,OAAA,SAdKhS,YAAYA,CAAAqS,IAAA,EAAAC,IAAA,EAAA;AAAA,IAAA,OAAAP,MAAA,CAAAx1C,KAAA,CAAA,IAAA,EAAApK,SAAA,CAAA;AAAA,GAAA;AAAA,CAcjB,EAAA;AAED,IAAMigD,iBAAiB,GAAG,SAApBA,iBAAiBA,CACrBl/C,IAAoB,EACpBsE,MAAc,EACK;AACnB,EAAA,IAAA+6C,kBAAA,GAA6BzG,iBAAiB,CAACt0C,MAAM,CAAC;IAA9C00C,SAAS,GAAAqG,kBAAA,CAATrG,SAAS;IAAE3xC,KAAK,GAAAg4C,kBAAA,CAALh4C,KAAK;AAExB,EAAA,IAAIi4C,YAAgC;EACpC,IAAItG,SAAS,KAAKn4C,KAAQ,IAAIm4C,SAAS,KAAKn4C,QAAW,EAAE;IACvDy+C,YAAY,GAAGz+C,OAAU;AAC3B,GAAC,MAAM,IAAIm4C,SAAS,KAAKn4C,MAAS,IAAIm4C,SAAS,KAAKn4C,OAAU,EAAE;IAC9Dy+C,YAAY,GAAGz+C,QAAW;AAC5B,GAAC,MAAM;IACL,MAAMsO,UAAa,CAAA,6BAAA,CAAA5S,MAAA,CAA+By8C,SAAS,MAAG,CAAC;AACjE;EAEA,OAAO;IACLrP,MAAM,EAAEx6B,aAAgB,CAACnP,IAAI,CAAC,GAAGA,IAAI,GAAGL,SAAS;IACjD4hB,KAAK,EAAAlb,eAAA,CAAAA,eAAA,CAAA,EAAA,EACF2yC,SAAS,EAAG3xC,KAAK,CAAA,EACjBi4C,YAAY,EAAG,MAAM;GAEzB;AACH,CAAC;AAED,IAAMjxB,cAAc,GAAG,SAAjBA,cAAcA,CAClB1gB,QAAwB,EACxBpC,OAAgB,EAChBwuC,QAAkB,EAAA;AAAA,EAAA,OACfpsC,QAAQ,CAACsO,MAAM,CAAC1Q,OAAO,EAAE4D,UAAa,CAAC4qC,QAAQ,CAAC,CAAC,CAAM,OAAA,CAAA,CAACh8B,QAAQ,CAAC;AAAA,CAAA;;;;;;;;;;;;;ACtnCtE7O,QAAQ,CAACK,WAAW,GAAG,IAAI;;;;"}