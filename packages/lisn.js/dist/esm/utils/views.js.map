{"version":3,"file":"views.js","names":["MC","MH","isValidStrList","validateStrList","newBitSpaces","createBitSpace","isValidScrollOffset","offset","match","OFFSET_REGEX","isValidView","view","includes","VIEWS","isValidViewList","views","getOppositeViews","usageError","bitmask","getViewsBitmask","oppositeBitmask","VIEWS_SPACE","bit","at","above","below","left","right","getViewsFromBitmask","viewsStr","viewsBitmask","v","parseScrollOffset","input","_match$groups","_match$groups2","reference","groups","ref","value","bugError","S_AT","S_ABOVE","S_BELOW","S_LEFT","S_RIGHT","RegExp","start","end","name","nameOf","push"],"sources":["../../../src/ts/utils/views.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { ScrollOffset, View, CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { isValidStrList, validateStrList } from \"@lisn/utils/validation\";\n\nimport { newBitSpaces, createBitSpace } from \"@lisn/modules/bit-spaces\";\n\n/**\n * Returns true if the given string is a valid {@link ScrollOffset}.\n *\n * @category Validation\n */\nexport const isValidScrollOffset = (offset: string): offset is ScrollOffset =>\n  offset.match(OFFSET_REGEX) !== null;\n\n/**\n * Returns true if the given string is a valid \"view\".\n *\n * @category Validation\n */\nexport const isValidView = (view: string): view is View =>\n  MH.includes(VIEWS, view);\n\n/**\n * Returns true if the given string or array is a list of valid views.\n *\n * @category Validation\n */\nexport const isValidViewList = (views: string | string[]) =>\n  isValidStrList(views, isValidView, false);\n\n/**\n * Returns the views that are opposite to the given set of views.\n *\n * Above and below are opposites, and so are left and right.\n *\n * \"at\" is a special case. It is considered opposite to any view in the sense\n * that if it is not present in `views` it will always be included in the\n * returned array. However it is not \"strongly\" opposite in the sense that it\n * will not cause other views to be included in the result unless it is the\n * only view in `views`. That is, there are two sets of strongly opposite pairs\n * (\"above\"/\"below\" and \"left\"/\"right\") and at least one of the two opposing\n * views of a pair must be present for the other one to be included, _except in\n * the special case of `views` being \"at\"_. See examples below for\n * clarification.\n *\n * **Note** that the order of the returned array is not defined.\n *\n * @example\n * Returns [\"above\", \"below\", \"left\", \"right\"] (not definite order), since\n * \"at\" is the only view present and is opposite to all:\n *\n * ```javascript\n * getOppositeViews(\"at\"); // -> [\"above\", \"below\", \"left\", \"right\"] (not necessarily in this order)\n * ```\n *\n * @example\n * Returns [\"below\"]. \"left\" and \"right\" are NOT included even though \"at\" is\n * given, because at least one of the two opposing views of a pair must be\n * present for the other one to be included (except in the special case of\n * `views` being \"at\").\n *\n * ```javascript\n * getOppositeViews(\"at,above\"); // -> [\"below\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above\"); // -> [\"at\", \"below\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,below\"); // -> [\"at\"]\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,below\"); // -> []\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"above,right\"); // -> [\"at\", \"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @example\n * ```javascript\n * getOppositeViews(\"at,above,right\"); // -> [\"below\", \"left\"] (not necessarily in this order)\n * ```\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the given view is not valid, including if it's empty \"\".\n *\n * @category Views\n */\nexport const getOppositeViews = (\n  views: CommaSeparatedStr<View> | View[],\n): View[] => {\n  if (!views) {\n    throw MH.usageError(\"'views' cannot be empty\");\n  }\n\n  const bitmask = getViewsBitmask(views);\n  let oppositeBitmask = VIEWS_SPACE.bitmask & ~bitmask; // initial, all not present in bitmask\n\n  // If the given view is \"at\", then include all the other ones.\n  // Otherwise include only the opposite views of those directional\n  // (above/below/left/right) that are present. I.e. if neither left not right\n  // is given, then don't include them\n  if (bitmask !== VIEWS_SPACE.bit.at) {\n    // remove the opposite ones to those not present\n    if (!(bitmask & VIEWS_SPACE.bit.above)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.below;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.below)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.above;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.left)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.right;\n    }\n\n    if (!(bitmask & VIEWS_SPACE.bit.right)) {\n      oppositeBitmask &= ~VIEWS_SPACE.bit.left;\n    }\n  }\n\n  return getViewsFromBitmask(oppositeBitmask);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getViewsBitmask = (\n  viewsStr: View[] | string | undefined,\n): number => {\n  let viewsBitmask = 0;\n  const views = validateStrList(\"views\", viewsStr, isValidView);\n\n  if (views) {\n    for (const v of views) {\n      if (!isValidView(v)) {\n        throw MH.usageError(`Unknown view '${v}'`);\n      }\n\n      viewsBitmask |= VIEWS_SPACE.bit[v];\n    }\n  } else {\n    viewsBitmask = VIEWS_SPACE.bitmask; // default: all\n  }\n\n  return viewsBitmask;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const parseScrollOffset = (input: string) => {\n  const match = input.match(OFFSET_REGEX);\n  if (!match) {\n    throw MH.usageError(`Invalid offset: '${input}'`);\n  }\n\n  const reference = match.groups?.ref;\n  const value = match.groups?.value;\n  /* istanbul ignore next */ // shouldn't happen\n  if (!reference || !value) {\n    throw MH.bugError(\"Offset regex: blank named groups\");\n  }\n\n  return { reference, value };\n};\n\nconst VIEWS: View[] = [\n  MC.S_AT,\n  MC.S_ABOVE,\n  MC.S_BELOW,\n  MC.S_LEFT,\n  MC.S_RIGHT,\n] as const;\n\n/**\n * @ignore\n * @internal\n */\nexport const VIEWS_SPACE = createBitSpace<View>(newBitSpaces(), ...VIEWS);\n\n// --------------------\n\nconst OFFSET_REGEX = RegExp(\"(?<ref>top|bottom|left|right): *(?<value>[^ ].+)\");\n\nconst getViewsFromBitmask = (bitmask: number): View[] => {\n  const views: View[] = [];\n  for (let bit = VIEWS_SPACE.start; bit <= VIEWS_SPACE.end; bit++) {\n    const value = 1 << bit;\n    if (bitmask & value) {\n      const name = VIEWS_SPACE.nameOf(value);\n      if (name) {\n        views.push(name);\n      }\n    }\n  }\n\n  return views;\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAId,SAASC,cAAc,EAAEC,eAAe;AAExC,SAASC,YAAY,EAAEC,cAAc;;AAErC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAIC,MAAc,IAChDA,MAAM,CAACC,KAAK,CAACC,YAAY,CAAC,KAAK,IAAI;;AAErC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAIC,IAAY,IACtCV,EAAE,CAACW,QAAQ,CAACC,KAAK,EAAEF,IAAI,CAAC;;AAE1B;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,eAAe,GAAIC,KAAwB,IACtDb,cAAc,CAACa,KAAK,EAAEL,WAAW,EAAE,KAAK,CAAC;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMM,gBAAgB,GAC3BD,KAAuC,IAC5B;EACX,IAAI,CAACA,KAAK,EAAE;IACV,MAAMd,EAAE,CAACgB,UAAU,CAAC,yBAAyB,CAAC;EAChD;EAEA,MAAMC,OAAO,GAAGC,eAAe,CAACJ,KAAK,CAAC;EACtC,IAAIK,eAAe,GAAGC,WAAW,CAACH,OAAO,GAAG,CAACA,OAAO,CAAC,CAAC;;EAEtD;EACA;EACA;EACA;EACA,IAAIA,OAAO,KAAKG,WAAW,CAACC,GAAG,CAACC,EAAE,EAAE;IAClC;IACA,IAAI,EAAEL,OAAO,GAAGG,WAAW,CAACC,GAAG,CAACE,KAAK,CAAC,EAAE;MACtCJ,eAAe,IAAI,CAACC,WAAW,CAACC,GAAG,CAACG,KAAK;IAC3C;IAE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","ignoreList":[]}