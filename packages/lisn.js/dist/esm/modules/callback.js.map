{"version":3,"file":"callback.js","names":["MC","MH","getDebouncedHandler","debug","wrapCallback","handlerOrCallback","debounceWindow","isFunction","isRemoved","callback","callablesMap","get","handler","args","invoke","wrapper","Callback","onRemove","remove","constructor","_defineProperty","logger","Logger","name","logAtCreation","id","SYMBOL","newSet","debug8","rmFn","CallbackScheduler","_clear","fn","add","newPromise","resolve","reject","usageError","_push","result","err","REMOVE","set","_Callback","newWeakMap","queues","newMap","flush","queue","lengthOf","_running","_task","shift","item","_onRemove","deleteKey","task","push"],"sources":["../../../src/ts/modules/callback.ts"],"sourcesContent":["/**\n * @module Modules/Callback\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * @typeParam Args  See {@link Callback}\n */\nexport type CallbackHandler<Args extends unknown[] = []> = (\n  ...args: Args\n) => CallbackReturnType | Promise<CallbackReturnType>;\n\nexport type CallbackReturnType =\n  | typeof Callback.KEEP\n  | typeof Callback.REMOVE\n  | void;\n\n/**\n * For minification optimization. Exposed through Callback.wrap.\n *\n * @ignore\n * @internal\n */\nexport const wrapCallback = <Args extends unknown[] = []>(\n  handlerOrCallback: CallbackHandler<Args> | Callback<Args>,\n  debounceWindow = 0,\n): Callback<Args> => {\n  const isFunction = MH.isFunction(handlerOrCallback);\n  let isRemoved = () => false;\n\n  if (isFunction) {\n    // check if it's an invoke method\n    const callback = callablesMap.get(handlerOrCallback);\n    if (callback) {\n      return wrapCallback(callback);\n    }\n  } else {\n    isRemoved = handlerOrCallback.isRemoved;\n  }\n\n  const handler: CallbackHandler<Args> = isFunction\n    ? handlerOrCallback\n    : (...args: Args) => handlerOrCallback.invoke(...args);\n\n  const wrapper = new Callback<Args>(\n    getDebouncedHandler(debounceWindow, (...args: Args) => {\n      if (!isRemoved()) {\n        return handler(...args);\n      }\n    }),\n  );\n\n  if (!isFunction) {\n    handlerOrCallback.onRemove(wrapper.remove);\n  }\n\n  return wrapper;\n};\n\n/**\n * {@link Callback} wraps user-supplied callbacks. Supports\n * - removing a callback either when calling {@link remove} or if the user\n *   handler returns {@link Callback.REMOVE}\n * - calling custom {@link onRemove} hooks\n * - debouncing (via {@link wrap})\n * - awaiting on an asynchronous handler and ensuring that the handler does not\n *  run concurrently to itself, i.e. subsequent {@link invoke}s will be queued\n *\n * @typeParam Args  The type of arguments that the callback expects.\n */\nexport class Callback<Args extends unknown[] = []> {\n  /**\n   * Possible return value for the handler.\n   *\n   * Do not do anything. Same as not retuning anything from the function.\n   */\n  static readonly KEEP: unique symbol = MC.SYMBOL(\n    \"KEEP\",\n  ) as typeof Callback.KEEP;\n\n  /**\n   * Possible return value for the handler.\n   *\n   * Will remove this callback.\n   */\n  static readonly REMOVE: unique symbol = MC.SYMBOL(\n    \"REMOVE\",\n  ) as typeof Callback.REMOVE;\n\n  /**\n   * Call the handler with the given arguments.\n   *\n   * If the handler is asynchronous, it awaits on it. Furthermore, calls will\n   * always wait for previous calls to this handler to complete first, i.e. it\n   * never runs concurrently to itself. If you need multiple calls to the async\n   * handler to run concurrently, then wrap it in a non-async function that\n   * does not await it.\n   *\n   * The returned promise is rejected in two cases:\n   * - If the callback throws an error or returns a rejected Promise.\n   * - If the callback is removed _after_ you call {@link invoke} but before the\n   *   handler is actually called (while it's waiting in the queue to be called)\n   *   In this case, the rejection reason is {@link Callback.REMOVE}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the callback is already removed.\n   */\n  readonly invoke: (...args: Args) => Promise<void>;\n\n  /**\n   * Mark the callback as removed and call the registered {@link onRemove} hooks.\n   *\n   * Future attempts to call it will result in\n   * {@link Errors.LisnUsageError | LisnUsageError}.\n   */\n  readonly remove: () => void;\n\n  /**\n   * Returns true if the callback has been removed and cannot be called again.\n   */\n  readonly isRemoved: () => boolean;\n\n  /**\n   * Registers the given function to be called when the callback is removed.\n   *\n   * You can call {@link onRemove} multiple times to register multiple hooks.\n   */\n  readonly onRemove: (fn: () => void) => void;\n\n  /**\n   * Wraps the given handler or callback as a callback, optionally debounced by\n   * the given debounce window.\n   *\n   * If the argument is already a callback _or an invoke method of a callback_,\n   * then the wrapper will call that callback and return the same value as it.\n   * It will also set up the returned wrapper callback so that it is removed\n   * when the original (given) callback is removed. However, removing the\n   * returned wrapper callback will _not_ cause the original callback (being\n   * wrapped) to be removed. If you want to do this, then do\n   * `wrapper.onRemove(wrapped.remove)`.\n   *\n   * Note that if the argument is a callback that's already debounced by a\n   * _larger_ window, then `debounceWindow` will have no effect.\n   *\n   * @param {} debounceWindow  If non-0, the callback will be called at most\n   *                           every `debounceWindow` ms. The arguments it will\n   *                           be called with will be the last arguments the\n   *                           wrapper was called with.\n   */\n  static readonly wrap = wrapCallback;\n\n  /**\n   * @param {} handler     The actual function to call. This should return one of\n   *                       the known {@link CallbackReturnType} values.\n   */\n  constructor(handler: CallbackHandler<Args>) {\n    const logger = debug\n      ? new debug.Logger({ name: \"Callback\", logAtCreation: handler })\n      : null;\n\n    let isRemoved = false;\n    const id = MC.SYMBOL();\n\n    const onRemove = MH.newSet<() => void>();\n\n    this.isRemoved = () => isRemoved;\n\n    this.remove = () => {\n      if (!isRemoved) {\n        debug: logger?.debug8(\"Removing\");\n        isRemoved = true;\n\n        for (const rmFn of onRemove) {\n          rmFn();\n        }\n\n        CallbackScheduler._clear(id);\n      }\n    };\n\n    this.onRemove = (fn) => onRemove.add(fn);\n\n    this.invoke = (...args) =>\n      MH.newPromise((resolve, reject) => {\n        debug: logger?.debug8(\"Calling with\", args);\n        if (isRemoved) {\n          reject(MH.usageError(\"Callback has been removed\"));\n          return;\n        }\n\n        CallbackScheduler._push(\n          id,\n          async () => {\n            let result;\n            try {\n              result = await handler(...args);\n            } catch (err) {\n              reject(err);\n            }\n\n            if (result === Callback.REMOVE) {\n              this.remove();\n            }\n\n            resolve();\n          },\n          reject,\n        );\n      });\n\n    callablesMap.set(this.invoke, this);\n  }\n}\n\n// ----------------------------------------\n\ntype CallbackSchedulerTask = () => Promise<void>;\ntype CallbackSchedulerQueueItem = {\n  _task: CallbackSchedulerTask;\n  _running: boolean;\n  _onRemove: (reason: typeof Callback.REMOVE) => void;\n};\n\ntype CallableCallback<Args extends unknown[] = []> = (...args: Args) => void;\n\nconst callablesMap = MH.newWeakMap<CallableCallback, Callback>();\n\nconst CallbackScheduler = (() => {\n  const queues = MH.newMap<symbol, CallbackSchedulerQueueItem[]>();\n\n  const flush = async (queue: CallbackSchedulerQueueItem[]) => {\n    // So that callbacks are always called asynchronously for consistency,\n    // await here before calling 1st\n    await null;\n    while (MH.lengthOf(queue)) {\n      // shouldn't throw anything as Callback must catch errors\n      queue[0]._running = true;\n      await queue[0]._task();\n\n      // only remove when done\n      queue.shift();\n    }\n  };\n\n  return {\n    _clear: (id: symbol) => {\n      const queue = queues.get(id);\n      if (queue) {\n        let item: CallbackSchedulerQueueItem | undefined;\n        while ((item = queue.shift())) {\n          if (!item._running) {\n            item._onRemove(Callback.REMOVE);\n          }\n        }\n\n        MH.deleteKey(queues, id);\n      }\n    },\n\n    _push: (id: symbol, task: CallbackSchedulerTask, onRemove: () => void) => {\n      let queue = queues.get(id);\n      if (!queue) {\n        queue = [];\n        queues.set(id, queue);\n      }\n\n      queue.push({ _task: task, _onRemove: onRemove, _running: false });\n      if (MH.lengthOf(queue) === 1) {\n        flush(queue);\n      }\n    },\n  };\n})();\n"],"mappings":"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","ignoreList":[]}