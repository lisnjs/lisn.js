{"version":3,"file":"scroll.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_cssAlter","_directions","_domEvents","_domOptimize","_event","_log","_math","_validation","_xMap","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","isScrollable","element","options","axis","active","noCache","_isScrollableCache$ge","cachedResult","isScrollableCache","isNullish","offset","result","doCache","elScrollTo","toLowerCase","canScroll","dimension","sGet","setTimer","deleteKey","prune","IS_SCROLLABLE_CACHE_TIMEOUT","exports","getClosestScrollable","ancestor","parentOf","getCurrentScrollAction","scrollable","toScrollableOrDefault","action","currentScrollAction","copyObject","scrollTo","to","userOptions","getOptions","_scrollable","currentScroll","cancel","isCancelled","cancelFn","_weCanInterrupt","scrollEvents","preventScrollHandler","_userCanInterrupt","eventType","addEventListenerTo","once","preventDefault","passive","promise","initiateScroll","thisScrollAction","waitFor","cleanup","removeEventListenerFrom","then","catch","isValidScrollDirection","direction","includes","SCROLL_DIRECTIONS","isValidScrollDirectionList","directions","isValidStrList","mapScrollable","original","actualScrollable","mappedScrollables","unmapScrollable","getClientWidthNow","isScrollableBodyInQuirks","offsetWidth","getBorderWidth","S_LEFT","S_RIGHT","S_CLIENT_WIDTH","getClientHeightNow","offsetHeight","S_TOP","S_BOTTOM","S_CLIENT_HEIGHT","tryGetMainContentElement","mainContentElement","fetchMainContentElement","init","tryGetMainScrollableElement","mainScrollableElement","fetchMainScrollableElement","getDefaultScrollingElement","body","getBody","getDocScrollingElement","tryGetScrollableElement","target","toScrollableOrMain","fetchScrollableElement","newXMap","newMap","DIFF_THRESHOLD","arePositionsDifferent","start","end","maxAbs","top","left","getMain","isElement","getWindow","getDoc","usageError","_options$weCanInterru","_options$userCanInter","getTargetCoordinates","altTarget","_target","_offset","_altTarget","_altOffset","altOffset","_duration","duration","weCanInterrupt","userCanInterrupt","docScrollingElement","contains","S_SCROLL_TOP","getBoundingClientRect","S_SCROLL_LEFT","isString","targetEl","docQuerySelector","isObject","getStartEndPosition","waitForMeasureTime","applyOffset","position","getEndPosition","startPosition","targetCoordinates","endPosition","isFunction","scrollH","S_SCROLL_HEIGHT","scrollW","S_SCROLL_WIDTH","clientH","clientW","min","max","startTime","previousTimeStamp","currentPosition","step","waitForMutateTime","timeStamp","timeNow","elapsed","progress","easeInOutQuad","side","ceil","parseFloat","getComputedStylePropNow","initPromise","mainScrollableElementSelector","settings","contentElement","waitForElementOrInteractive","logError","isHTMLElement","logWarn","hasDOM","waitForInteractive"],"sources":["../../../src/ts/utils/scroll.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  ScrollDirection,\n  ScrollTarget,\n  TargetCoordinates,\n  CoordinateOffset,\n  ScrollPosition,\n  Offset,\n} from \"@lisn/globals/types\";\n\nimport { getComputedStylePropNow } from \"@lisn/utils/css-alter\";\nimport { SCROLL_DIRECTIONS } from \"@lisn/utils/directions\";\nimport {\n  waitForInteractive,\n  waitForElementOrInteractive,\n} from \"@lisn/utils/dom-events\";\nimport {\n  waitForMeasureTime,\n  waitForMutateTime,\n} from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { maxAbs, easeInOutQuad } from \"@lisn/utils/math\";\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\nimport { newXMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Scrolling\n */\nexport type ScrollAction = {\n  cancel: () => boolean;\n\n  /**\n   * Will reject if the scroll is cancelled.\n   */\n  waitFor: () => Promise<ScrollPosition>;\n};\n\n/**\n * @category Scrolling\n * @interface\n */\nexport type ScrollToOptions = {\n  /**\n   * The element that should be scrolled.\n   *\n   * @defaultValue If `document.body` is scrollable, will use that; otherwise `document.scrollingElement`\n   */\n  scrollable?: Element;\n\n  /**\n   * Offset the target coordinates by the given amount(s).\n   *\n   * E.g. if the final target coordinates are computed to be\n   * `{top: 100, left: 0}` and you specify offset as `{top: 10, left: 20}`, it\n   * will scroll to  `{top: 110, left: 20}`.\n   *\n   * @defaultValue undefined\n   */\n  offset?: CoordinateOffset;\n\n  // TODO maybe support fixed velocity as an alternative to fixed duration?\n  /**\n   * The duration of the scroll animation. If not given, it is instant.\n   *\n   * @defaultValue 0\n   */\n  duration?: number;\n\n  /**\n   * Whether another request to us to scroll the same target can interrupt this\n   * scroll before it finishes.\n   *\n   * @defaultValue false\n   */\n  weCanInterrupt?: boolean;\n\n  /**\n   * Whether a user attempt to scroll the target can interrupt this before it\n   * finishes.\n   *\n   * @defaultValue false\n   */\n  userCanInterrupt?: boolean;\n\n  /**\n   * If the scrolling element is already at the given coordinates (or strictly\n   * speaking we allow for 5 pixels difference), then if `altTarget` is given,\n   * this will become the target to scroll to.\n   *\n   * @defaultValue undefined\n   */\n  altTarget?: TargetCoordinates | Element | string;\n\n  /**\n   * Offset the target coordinates by the given amount(s) when `altTarget` is used.\n   *\n   * See {@link ScrollToOptions.offset}.\n   *\n   * @defaultValue undefined\n   */\n  altOffset?: CoordinateOffset;\n};\n\n// ----------\n\n/**\n * Returns true if the given element is scrollable in the given direction, or\n * in either direction (if `axis` is not given).\n *\n * **IMPORTANT:** If you enable `active` then be aware that:\n * 1. It may attempt to scroll the target in order to determine whether it's\n *    scrollable in a more reliable way than the default method of comparing\n *    clientWidth/Height to scrollWidth/Height. If there is currently any\n *    ongoing scroll on the target, this will stop it, so never use that inside\n *    scroll-triggered handlers.\n * 2. If the layout has been invalidated and not yet recalculated,\n *    this will cause a forced layout, so always {@link waitForMeasureTime}\n *    before calling this function when possible.\n *\n * @param {} [options.axis]    One of \"x\" or \"y\" for horizontal or vertical\n *                             scroll respectively. If not given, it checks\n *                             both.\n * @param {} [options.active]  If true, then if the target's current scroll\n *                             offset is 0, it will attempt to scroll it rather\n *                             than looking at the clientWidth/Height to\n *                             scrollWidth/Height. This is more reliable but can\n *                             cause issues, see note above.\n * @param {} [options.noCache] By default the result of a check is cached for\n *                             1s and if there's already a cached result for\n *                             this element, it is returns. Set this to true to\n *                             disable checking the cache and also saving the\n *                             result into the cache.\n *\n * @category Scrolling\n */\nexport const isScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n): boolean => {\n  const { axis, active, noCache } = options || {};\n  if (!axis) {\n    return (\n      isScrollable(element, { axis: \"y\", active, noCache }) ||\n      isScrollable(element, { axis: \"x\", active, noCache })\n    );\n  }\n\n  if (!noCache) {\n    const cachedResult = isScrollableCache.get(element)?.get(axis);\n    if (!MH.isNullish(cachedResult)) {\n      return cachedResult;\n    }\n  }\n\n  const offset = axis === \"x\" ? \"Left\" : \"Top\";\n  let result = false;\n  let doCache = !noCache;\n\n  if (element[`scroll${offset}`]) {\n    result = true;\n  } else if (active) {\n    // Use scrollTo with explicit behavior set to instant instead of setting\n    // the scrollTop/Left properties since the latter doesn't work with\n    // scroll-behavior smooth.\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 1 });\n    const canScroll = element[`scroll${offset}`] > 0;\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 0 });\n    result = canScroll;\n  } else {\n    const dimension = axis === \"x\" ? \"Width\" : \"Height\";\n    result = element[`scroll${dimension}`] > element[`client${dimension}`];\n    // No need to cache a passive check.\n    doCache = false;\n  }\n\n  if (doCache) {\n    isScrollableCache.sGet(element).set(axis, result);\n    MH.setTimer(() => {\n      MH.deleteKey(isScrollableCache.get(element), axis);\n      isScrollableCache.prune(element);\n    }, IS_SCROLLABLE_CACHE_TIMEOUT);\n  }\n\n  return result;\n};\n\n/**\n * Returns the closest scrollable ancestor of the given element, _not including\n * it_.\n *\n * @param {} options See {@link isScrollable}\n *\n * @return {} `null` if no scrollable ancestors are found.\n *\n * @category Scrolling\n */\nexport const getClosestScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n) => {\n  // Walk up the tree, starting at the element in question but excluding it.\n  let ancestor: Element | null | undefined = element;\n  while ((ancestor = MH.parentOf(ancestor))) {\n    if (isScrollable(ancestor, options)) {\n      return ancestor;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Returns the current {@link ScrollAction} if any.\n *\n * @category Scrolling\n */\nexport const getCurrentScrollAction = (\n  scrollable?: Element,\n): ScrollAction | null => {\n  scrollable = toScrollableOrDefault(scrollable);\n  const action = currentScrollAction.get(scrollable);\n  if (action) {\n    return MH.copyObject(action);\n  }\n  return null;\n};\n\n/**\n * Scrolls the given scrollable element to the given `to` target.\n *\n * Returns `null` if there's an ongoing scroll that is not cancellable.\n *\n * Note that if `to` is an element or a selector, then it _must_ be a\n * descendant of the scrollable element.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *               If the target coordinates are invalid.\n *\n * @param {} to  If this is an element, then its top-left position is used as\n *               the target coordinates. If it is a string, then it is treated\n *               as a selector for an element using `querySelector`.\n *\n * @return {} `null` if there's an ongoing scroll that is not cancellable,\n * otherwise a {@link ScrollAction}.\n *\n * @category Scrolling\n */\nexport const scrollTo = (\n  to: TargetCoordinates | Element | string,\n  userOptions?: ScrollToOptions,\n): ScrollAction | null => {\n  const options = getOptions(to, userOptions);\n  const scrollable = options._scrollable;\n\n  // cancel current scroll action if any\n  const currentScroll = currentScrollAction.get(scrollable);\n  if (currentScroll) {\n    if (!currentScroll.cancel()) {\n      // current scroll action is not cancellable by us\n      return null;\n    }\n  }\n\n  let isCancelled = false;\n\n  const cancelFn = options._weCanInterrupt\n    ? () => (isCancelled = true)\n    : () => false;\n\n  const scrollEvents = [\"touchmove\", \"wheel\"]; // don't bother with keyboard\n  let preventScrollHandler: EventListener | null = null;\n\n  if (options._userCanInterrupt) {\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(\n        scrollable,\n        eventType,\n        () => {\n          isCancelled = true;\n        },\n        { once: true },\n      );\n    }\n  } else {\n    preventScrollHandler = MH.preventDefault;\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(scrollable, eventType, preventScrollHandler, {\n        passive: false,\n      });\n    }\n  }\n\n  const promise = initiateScroll(options, () => isCancelled);\n\n  const thisScrollAction: ScrollAction = {\n    waitFor: () => promise,\n    cancel: cancelFn,\n  };\n\n  const cleanup = () => {\n    if (currentScrollAction.get(scrollable) === thisScrollAction) {\n      MH.deleteKey(currentScrollAction, scrollable);\n    }\n\n    if (preventScrollHandler) {\n      for (const eventType of scrollEvents) {\n        removeEventListenerFrom(scrollable, eventType, preventScrollHandler, {\n          passive: false,\n        });\n      }\n    }\n  };\n\n  thisScrollAction.waitFor().then(cleanup).catch(cleanup);\n\n  currentScrollAction.set(scrollable, thisScrollAction);\n  return thisScrollAction;\n};\n\n/**\n * Returns true if the given string is a valid scroll direction.\n *\n * @category Validation\n */\nexport const isValidScrollDirection = (\n  direction: string,\n): direction is ScrollDirection => MH.includes(SCROLL_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid scroll\n * directions.\n *\n * @category Validation\n */\nexport const isValidScrollDirectionList = (directions: string | string[]) =>\n  isValidStrList(directions, isValidScrollDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const mapScrollable = (original: Element, actualScrollable: Element) =>\n  mappedScrollables.set(original, actualScrollable);\n\n/**\n * @ignore\n * @internal\n */\nexport const unmapScrollable = (original: Element) =>\n  MH.deleteKey(mappedScrollables, original);\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientWidthNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetWidth -\n      getBorderWidth(element, MC.S_LEFT) -\n      getBorderWidth(element, MC.S_RIGHT)\n    : element[MC.S_CLIENT_WIDTH];\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientHeightNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetHeight -\n      getBorderWidth(element, MC.S_TOP) -\n      getBorderWidth(element, MC.S_BOTTOM)\n    : element[MC.S_CLIENT_HEIGHT];\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainContentElement = (): HTMLElement | null =>\n  mainContentElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainContentElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainContentElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainScrollableElement = (): HTMLElement | null =>\n  mainScrollableElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainScrollableElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainScrollableElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getDefaultScrollingElement = () => {\n  const body = MH.getBody();\n  return isScrollable(body) ? body : MH.getDocScrollingElement() || body;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetScrollableElement = (\n  target: ScrollTarget | null | undefined,\n): Element | null => toScrollableOrMain(target, tryGetMainScrollableElement);\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchScrollableElement = async (\n  target: ScrollTarget | null | undefined,\n): Promise<Element> => toScrollableOrMain(target, fetchMainScrollableElement);\n\n// ----------------------------------------\n\ntype ScrollToOptionsInternal = {\n  _target: TargetCoordinates;\n  _offset: CoordinateOffset | null;\n  _altTarget: TargetCoordinates | null;\n  _altOffset: CoordinateOffset | null;\n  _scrollable: Element;\n  _duration: number;\n  _weCanInterrupt: boolean;\n  _userCanInterrupt: boolean;\n};\n\nconst IS_SCROLLABLE_CACHE_TIMEOUT = 1000;\n\nconst isScrollableCache = newXMap<Element, Map<\"x\" | \"y\", boolean>>(() =>\n  MH.newMap(),\n);\n\nconst mappedScrollables = MH.newMap<Element, Element>();\n\nconst currentScrollAction = MH.newMap<Element, ScrollAction>();\n\nconst DIFF_THRESHOLD = 5;\nconst arePositionsDifferent = (start: ScrollPosition, end: ScrollPosition) =>\n  maxAbs(start.top - end.top, start.left - end.left) >= DIFF_THRESHOLD;\n\nconst toScrollableOrMain = <R>(\n  target: ScrollTarget | null | undefined,\n  getMain: () => R,\n): Element | R => {\n  if (MH.isElement(target)) {\n    return mappedScrollables.get(target) || target;\n  }\n\n  if (!target || target === MH.getWindow() || target === MH.getDoc()) {\n    return getMain();\n  }\n\n  throw MH.usageError(\"Unsupported scroll target\");\n};\n\nconst toScrollableOrDefault = (scrollable: Element | undefined): Element =>\n  scrollable ?? getDefaultScrollingElement();\n\nconst getOptions = (\n  to: TargetCoordinates | Element | string,\n  options: ScrollToOptions | undefined,\n): ScrollToOptionsInternal => {\n  const scrollable = toScrollableOrDefault(options?.scrollable);\n  const target = getTargetCoordinates(scrollable, to);\n  const altTarget = options?.altTarget\n    ? getTargetCoordinates(scrollable, options?.altTarget)\n    : null;\n\n  return {\n    _target: target,\n    _offset: options?.offset || null,\n    _altTarget: altTarget,\n    _altOffset: options?.altOffset || null,\n    _scrollable: scrollable,\n    _duration: options?.duration || 0,\n    _weCanInterrupt: options?.weCanInterrupt ?? false,\n    _userCanInterrupt: options?.userCanInterrupt ?? false,\n  };\n};\n\nconst getTargetCoordinates = (\n  scrollable: Element,\n  target: TargetCoordinates | Element | string,\n): TargetCoordinates => {\n  const docScrollingElement = MH.getDocScrollingElement();\n\n  if (MH.isElement(target)) {\n    if (scrollable === target || !scrollable.contains(target)) {\n      throw MH.usageError(\"Target must be a descendant of the scrollable one\");\n    }\n\n    return {\n      top: () =>\n        scrollable[MC.S_SCROLL_TOP] +\n        MH.getBoundingClientRect(target).top -\n        (scrollable === docScrollingElement\n          ? 0\n          : MH.getBoundingClientRect(scrollable).top),\n      left: () =>\n        scrollable[MC.S_SCROLL_LEFT] +\n        MH.getBoundingClientRect(target).left -\n        (scrollable === docScrollingElement\n          ? 0\n          : MH.getBoundingClientRect(scrollable).left),\n    };\n  }\n\n  if (MH.isString(target)) {\n    const targetEl = MH.docQuerySelector(target);\n    if (!targetEl) {\n      throw MH.usageError(`No match for '${target}'`);\n    }\n\n    return getTargetCoordinates(scrollable, targetEl);\n  }\n\n  if (!MH.isObject(target) || !(\"top\" in target || \"left\" in target)) {\n    throw MH.usageError(\"Invalid coordinates\");\n  }\n\n  return target;\n};\n\nconst getStartEndPosition = async (\n  options: ScrollToOptionsInternal,\n): Promise<{ start: ScrollPosition; end: ScrollPosition }> => {\n  await waitForMeasureTime();\n\n  const applyOffset = (\n    position: ScrollPosition,\n    offset: CoordinateOffset | null,\n  ) => {\n    position.top += offset?.top || 0;\n    position.left += offset?.left || 0;\n  };\n\n  const scrollable = options._scrollable;\n  const start = {\n    top: scrollable[MC.S_SCROLL_TOP],\n    left: scrollable[MC.S_SCROLL_LEFT],\n  };\n\n  let end = getEndPosition(scrollable, start, options._target);\n  applyOffset(end, options._offset);\n\n  if (!arePositionsDifferent(start, end) && options._altTarget) {\n    end = getEndPosition(scrollable, start, options._altTarget);\n    applyOffset(end, options._altOffset);\n  }\n\n  return { start, end };\n};\n\n// must be called in \"measure time\"\nconst getEndPosition = (\n  scrollable: Element,\n  startPosition: ScrollPosition,\n  targetCoordinates: TargetCoordinates,\n): ScrollPosition => {\n  // by default no change in scroll top or left\n  const endPosition = MH.copyObject(startPosition);\n\n  if (!MH.isNullish(targetCoordinates?.top)) {\n    if (MH.isFunction(targetCoordinates.top)) {\n      endPosition.top = targetCoordinates.top(scrollable);\n    } else {\n      endPosition.top = targetCoordinates.top;\n    }\n  }\n\n  if (!MH.isNullish(targetCoordinates?.left)) {\n    if (MH.isFunction(targetCoordinates.left)) {\n      endPosition.left = targetCoordinates.left(scrollable);\n    } else {\n      endPosition.left = targetCoordinates.left;\n    }\n  }\n\n  // Set boundaries\n  const scrollH = scrollable[MC.S_SCROLL_HEIGHT];\n  const scrollW = scrollable[MC.S_SCROLL_WIDTH];\n  const clientH = getClientHeightNow(scrollable);\n  const clientW = getClientWidthNow(scrollable);\n  endPosition.top = MH.min(scrollH - clientH, endPosition.top);\n  endPosition.top = MH.max(0, endPosition.top);\n\n  endPosition.left = MH.min(scrollW - clientW, endPosition.left);\n  endPosition.left = MH.max(0, endPosition.left);\n\n  return endPosition;\n};\n\nconst initiateScroll = async (\n  options: ScrollToOptionsInternal,\n  isCancelled: () => boolean,\n) => {\n  const position = await getStartEndPosition(options);\n  const duration = options._duration;\n  const scrollable = options._scrollable;\n\n  let startTime: number, previousTimeStamp: number;\n  let currentPosition: ScrollPosition = position.start;\n\n  const step = async () => {\n    await waitForMutateTime(); // effectively next animation frame\n    // Element.scrollTo equates to a measurement and needs to run after\n    // painting to avoid forced layout.\n    await waitForMeasureTime();\n    const timeStamp = MH.timeNow();\n\n    if (isCancelled()) {\n      // Reject the promise\n      throw currentPosition;\n    }\n\n    if (!startTime) {\n      // If it's very close to the target, no need to scroll smoothly\n      if (\n        duration === 0 ||\n        !arePositionsDifferent(currentPosition, position.end)\n      ) {\n        MH.elScrollTo(scrollable, position.end);\n        return position.end;\n      }\n\n      startTime = timeStamp;\n    }\n\n    if (startTime !== timeStamp && previousTimeStamp !== timeStamp) {\n      const elapsed = timeStamp - startTime;\n      const progress = easeInOutQuad(MH.min(1, elapsed / duration));\n\n      currentPosition = {\n        top:\n          position.start.top +\n          (position.end.top - position.start.top) * progress,\n        left:\n          position.start.left +\n          (position.end.left - position.start.left) * progress,\n      };\n\n      MH.elScrollTo(scrollable, currentPosition);\n\n      if (progress === 1) {\n        return currentPosition;\n      }\n    }\n\n    previousTimeStamp = timeStamp;\n    return step();\n  };\n\n  return step();\n};\n\nconst isScrollableBodyInQuirks = (element: Element): element is HTMLElement =>\n  element === MH.getBody() && MH.getDocScrollingElement() === null;\n\n// must be called in \"measure time\"\nconst getBorderWidth = (element: Element, side: Offset) =>\n  MH.ceil(MH.parseFloat(getComputedStylePropNow(element, `border-${side}`)));\n\n// ------------------------------\n\nlet mainContentElement: HTMLElement;\nlet mainScrollableElement: HTMLElement;\n\nlet initPromise: Promise<void> | null = null;\nconst init = (): Promise<void> => {\n  if (!initPromise) {\n    initPromise = (async () => {\n      const mainScrollableElementSelector =\n        settings.mainScrollableElementSelector;\n\n      const contentElement = await waitForElementOrInteractive(() => {\n        return mainScrollableElementSelector\n          ? MH.docQuerySelector(mainScrollableElementSelector)\n          : MH.getBody(); // default if no selector\n      });\n\n      // defaults\n      mainScrollableElement = getDefaultScrollingElement();\n      mainContentElement = MH.getBody();\n\n      if (!contentElement) {\n        logError(\n          MH.usageError(\n            `No match for '${mainScrollableElementSelector}'. ` +\n              \"Scroll tracking/capturing may not work as intended.\",\n          ),\n        );\n      } else if (!MH.isHTMLElement(contentElement)) {\n        logWarn(\"mainScrollableElementSelector should point to an HTMLElement\");\n      } else if (contentElement !== mainContentElement) {\n        mainScrollableElement = mainContentElement = contentElement;\n      }\n    })();\n  }\n\n  return initPromise;\n};\n\n// Try to find the main scrollable/content elements asap so that tryGetMain*\n// can return them if called before fetchMain*\nif (MH.hasDOM()) {\n  waitForInteractive().then(init);\n}\n"],"mappings":"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","ignoreList":[]}