{"version":3,"file":"dom-search.js","names":["MH","getData","waitForElement","logError","getReferenceElement","spec","thisElement","referenceElement","getElementById","slice","relation","find","p","startsWith","concat","usageError","rest","lengthOf","matchOp","refOrCls","selector","PREFIX_REF","DATA_REF","getFirstReferenceElement","getLastReferenceElement","getThisReferenceElement","getNextReferenceElement","getPrevReferenceElement","bugError","waitForReferenceElement","timeout","arguments","length","undefined","prefixName","prefixData","getAllReferenceElements","docQuerySelectorAll","docQuerySelector","allRefs","closest","getNextOrPrevReferenceElement","goBackward","getDoc","contains","numRefs","refIndex","i","currentIsAfter","isNodeBAfterA"],"sources":["../../../src/ts/utils/dom-search.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Searching for reference elements\n * The functions allow you to find elements that match a given string\n * specification.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { logError } from \"@lisn/utils/log\";\n\n/**\n * Get the element that matches the given reference specification.\n *\n * The specification is of the form:\n *\n * ```\n * <FullSpec> ::=\n *     <Relation> \".\" <ClassName>  |\n *     <Relation> [\"-\" <ReferenceName>] |\n *     #<DOM_ID>\n *\n * <Relation> :==\n *     \"next\"  |\n *     \"prev\"  |\n *     \"this\"  |\n *     \"first\" |\n *     \"last\"\n * ```\n *\n * - `<DOM_ID>` is the unique ID of the element\n * - `<ClassName>` is a CSS class on the element\n * - `<ReferenceName>` is the value of the `data-lisn-ref` attribute on the\n *   element you are targeting. If not given, defaults to the value of the\n *   `data-lisn-ref` attribute on `thisElement`.\n *\n * There now follows an explanation of how \"next\", \"prev\", \"this\", \"first\" and\n * \"last\" search the DOM:\n * - \"next\": the tree is search in document order (depth first, then breadth),\n *   so the returned element could be a descendant of `thisElement`\n * - \"prev\": the tree is search in document order (depth first, then breadth),\n *   but excluding ancestors of `thisElement`, so the returned element is\n *   guaranteed to _not_ be an ancestor or descendant of `thisElement`.\n * - \"this\": if the given element itself matches the specification, it is\n *   returned, otherwise the closest ancestor of the given element that matches\n *   the specification\n * - \"first\": the first element matching; the tree is search in document order\n *   (depth first, then breadth).\n * - \"last\": the last element matching; the tree is search in document order\n *   (depth first, then breadth).\n *\n * @category DOM: Searching for reference elements\n *\n * @param {} thisElement The element to search relative to\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                        If the specification is invalid or if thisElement is\n *                        not given for a specification of \"next\", \"prev\" or \"this\"\n */\nexport const getReferenceElement = (\n  spec: string,\n  thisElement: Element,\n): Element | null => {\n  if (!spec) {\n    return thisElement;\n  }\n\n  if (spec[0] === \"#\") {\n    // element ID\n    const referenceElement = MH.getElementById(spec.slice(1));\n    if (!referenceElement) {\n      return null;\n    }\n    return referenceElement;\n  }\n\n  const relation = [\"next\", \"prev\", \"this\", \"first\", \"last\"].find(\n    (p) => spec.startsWith(`${p}.`) || spec.startsWith(`${p}-`) || spec === p,\n  );\n\n  if (!relation) {\n    throw MH.usageError(`Invalid search specification '${spec}'`);\n  }\n\n  const rest = spec.slice(MH.lengthOf(relation));\n  const matchOp = rest.slice(0, 1);\n  let refOrCls = rest.slice(1);\n\n  let selector: string;\n  if (matchOp === \".\") {\n    selector = matchOp + refOrCls;\n  } else {\n    if (!refOrCls) {\n      refOrCls = getData(thisElement, PREFIX_REF) || \"\";\n    }\n\n    if (!refOrCls) {\n      throw MH.usageError(`No reference name in '${spec}'`);\n    }\n\n    selector = `[${DATA_REF}=\"${refOrCls}\"]`;\n  }\n\n  let referenceElement;\n  if (relation === \"first\") {\n    referenceElement = getFirstReferenceElement(selector);\n  } else if (relation === \"last\") {\n    referenceElement = getLastReferenceElement(selector);\n  } else {\n    if (relation === \"this\") {\n      referenceElement = getThisReferenceElement(selector, thisElement);\n    } else if (relation === \"next\") {\n      referenceElement = getNextReferenceElement(selector, thisElement);\n    } else if (relation === \"prev\") {\n      referenceElement = getPrevReferenceElement(selector, thisElement);\n    } else {\n      /* istanbul ignore next */ {\n        logError(MH.bugError(`Unhandled relation case ${relation}`));\n        return null;\n      }\n    }\n  }\n\n  if (!referenceElement) {\n    return null;\n  }\n\n  return referenceElement;\n};\n\n/**\n * Like {@link getReferenceElement} excepts if no element matches the\n * specification if will wait for at most the given time for such an element.\n *\n * @category DOM: Searching for reference elements\n */\nexport const waitForReferenceElement = (\n  spec: string,\n  thisElement: Element,\n  timeout = 200,\n) => waitForElement(() => getReferenceElement(spec, thisElement), timeout);\n\n// ----------------------------------------\n\nconst PREFIX_REF = MH.prefixName(\"ref\");\nconst DATA_REF = MH.prefixData(PREFIX_REF);\n\nconst getAllReferenceElements = (\n  selector: string,\n): NodeListOf<Element> | null => MH.docQuerySelectorAll(selector);\n\nconst getFirstReferenceElement = (selector: string): Element | null =>\n  MH.docQuerySelector(selector);\n\nconst getLastReferenceElement = (selector: string): Element | null => {\n  const allRefs = getAllReferenceElements(selector);\n  return (allRefs && allRefs[MH.lengthOf(allRefs) - 1]) || null;\n};\n\nconst getThisReferenceElement = (\n  selector: string,\n  thisElement: Element,\n): Element | null => thisElement.closest(selector);\n\nconst getNextReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, false);\n\nconst getPrevReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, true);\n\nconst getNextOrPrevReferenceElement = (\n  selector: string,\n  thisElement: Element,\n  goBackward: boolean,\n): Element | null => {\n  thisElement = getThisReferenceElement(selector, thisElement) || thisElement;\n\n  if (!MH.getDoc().contains(thisElement)) {\n    return null;\n  }\n\n  const allRefs = getAllReferenceElements(selector);\n  if (!allRefs) {\n    return null;\n  }\n\n  const numRefs = MH.lengthOf(allRefs);\n  let refIndex = goBackward ? numRefs - 1 : -1;\n  for (let i = 0; i < numRefs; i++) {\n    const currentIsAfter = MH.isNodeBAfterA(thisElement, allRefs[i]);\n\n    // As soon as we find either the starting element or the first element\n    // that follows it, stop iteration.\n    // - If we're looking for the previous reference, then take the previous\n    //   element in the iteration.\n    // - Otherwise, if the current element in the iteration is the same as the\n    //   starting one, then take either the next element in the iteration.\n    //   - Otherwise, (if the current element follows the starting one, as\n    //     would happen if the starting element was not in the list of matched\n    //     elements, take the current element in the iteration.\n    if (allRefs[i] === thisElement || currentIsAfter) {\n      refIndex = i + (goBackward ? -1 : currentIsAfter ? 0 : 1);\n      break;\n    }\n  }\n\n  return allRefs[refIndex] || null;\n};\n"],"mappings":"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","ignoreList":[]}