{"version":3,"file":"scroll.cjs","names":["MC","_interopRequireWildcard","require","MH","_settings","_animations","_cssAlter","_directions","_domEvents","_domOptimize","_event","_log","_math","_text","_validation","_xMap","_debug","_interopRequireDefault","e","__esModule","default","t","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_asyncIterator","Symbol","asyncIterator","iterator","AsyncFromSyncIterator","TypeError","AsyncFromSyncIteratorContinuation","Promise","reject","done","resolve","value","then","s","next","prototype","apply","arguments","return","throw","isScrollable","element","options","axis","active","noCache","_isScrollableCache$ge","cachedResult","isScrollableCache","isNullish","offset","result","elScrollTo","toLowerCase","canScroll","dimension","isDocScrollable","getDocScrollingElement","hasOverflow","overflowProp","getComputedStylePropNow","scrollingOverflows","S_SCROLL","S_AUTO","S_VISIBLE","includes","sGet","setTimer","deleteKey","prune","IS_SCROLLABLE_CACHE_TIMEOUT","exports","getClosestScrollable","ancestor","parentOf","getCurrentScrollAction","scrollable","toScrollableOrDefault","info","currentScrollInfos","copyObject","_action","scrollTo","to","userOptions","getOptions","_scrollable","cancel","isCancelled","cancelFn","_weCanInterrupt","scrollEvents","preventScrollHandler","_userCanInterrupt","eventType","addEventListenerTo","once","preventDefault","passive","thisInfo","waitFor","scrollActionPromise","cleanup","_currentScrollInfos$g","removeEventListenerFrom","initiateScroll","catch","updateCurrentScrollInfo","isValidScrollDirection","direction","SCROLL_DIRECTIONS","isValidScrollDirectionList","directions","isValidStrList","mapScrollable","original","actualScrollable","mappedScrollables","unmapScrollable","getClientWidthNow","isScrollableBodyInQuirks","offsetWidth","getBorderWidth","S_LEFT","S_RIGHT","S_CLIENT_WIDTH","getClientHeightNow","offsetHeight","S_TOP","S_BOTTOM","S_CLIENT_HEIGHT","tryGetMainContentElement","mainContentElement","fetchMainContentElement","init","tryGetMainScrollableElement","mainScrollableElement","fetchMainScrollableElement","getDefaultScrollingElement","_MH$getDocScrollingEl","body","getBody","tryGetScrollableElement","target","toScrollableOrMain","fetchScrollableElement","newXMap","newMap","DIFF_THRESHOLD","arePositionsDifferent","start","end","threshold","maxAbs","top","left","side","ceil","parseFloat","getMain","isElement","_mappedScrollables$ge","getWindow","getDoc","usageError","_options$offset","_options$altOffset","_options$duration","_options$weCanInterru","_options$userCanInter","getTargetCoordinates","altTarget","_target","_offset","_altTarget","_altOffset","altOffset","_duration","duration","weCanInterrupt","userCanInterrupt","newInfo","_newInfo$_action","existingScrollInfo","merge","isDocScrollingElement","contains","getBoundingClientRect","S_SCROLL_TOP","S_SCROLL_LEFT","isString","targetEl","docQuerySelector","isObject","getStartEndPosition","waitForMeasureTime","applyOffset","position","_offset$top","_offset$left","getEndPosition","_start","_end","startPosition","targetCoordinates","endPosition","isFunction","scrollH","S_SCROLL_HEIGHT","scrollW","S_SCROLL_WIDTH","clientH","clientW","min","max","_existingScrollInfo$_","_existingScrollInfo$_2","currentPosition","_position","currentVelocity","_velocity","elapsed","_elapsed","logger","debug","Logger","name","formatAsString","randId","logAtCreation","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","newAnimationFrameIterator","_step","deltaTime","sinceLast","debug8","l","v","criticallyDamped","lTarget","dt","lag","isDone","assign","err","initPromise","mainScrollableElementSelector","settings","contentElement","waitForElementOrInteractive","logError","isHTMLElement","logWarn","hasDOM","waitForInteractive"],"sources":["../../../src/ts/utils/scroll.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  ScrollDirection,\n  ScrollTarget,\n  TargetCoordinates,\n  CoordinateOffset,\n  ScrollPosition,\n  Offset,\n} from \"@lisn/globals/types\";\n\nimport {\n  newAnimationFrameIterator,\n  ElapsedTimes,\n} from \"@lisn/utils/animations\";\nimport { getComputedStylePropNow } from \"@lisn/utils/css-alter\";\nimport { SCROLL_DIRECTIONS } from \"@lisn/utils/directions\";\nimport {\n  waitForInteractive,\n  waitForElementOrInteractive,\n} from \"@lisn/utils/dom-events\";\nimport { waitForMeasureTime } from \"@lisn/utils/dom-optimize\";\nimport { addEventListenerTo, removeEventListenerFrom } from \"@lisn/utils/event\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { maxAbs, criticallyDamped } from \"@lisn/utils/math\";\nimport { randId, formatAsString } from \"@lisn/utils/text\";\nimport { isValidStrList } from \"@lisn/utils/validation\";\n\nimport { newXMap } from \"@lisn/modules/x-map\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * @category Scrolling\n */\nexport type ScrollAction = {\n  cancel: () => boolean;\n\n  /**\n   * Will reject if the scroll is cancelled.\n   */\n  waitFor: () => Promise<ScrollPosition>;\n};\n\n/**\n * @category Scrolling\n * @interface\n */\nexport type ScrollToOptions = {\n  /**\n   * The element that should be scrolled.\n   *\n   * @defaultValue If `document.body` is scrollable, will use that; otherwise `document.scrollingElement`\n   */\n  scrollable?: Element;\n\n  /**\n   * Offset the target coordinates by the given amount(s).\n   *\n   * E.g. if the final target coordinates are computed to be\n   * `{top: 100, left: 0}` and you specify offset as `{top: 10, left: 20}`, it\n   * will scroll to  `{top: 110, left: 20}`.\n   *\n   * @defaultValue undefined\n   */\n  offset?: CoordinateOffset;\n\n  // TODO maybe support fixed average velocity as an alternative to fixed duration?\n  /**\n   * The duration of the scroll animation in milliseconds. If not given, it is\n   * instant.\n   *\n   * @defaultValue 0\n   */\n  duration?: number;\n\n  /**\n   * Whether another request to us to scroll the same target can interrupt this\n   * scroll before it finishes.\n   *\n   * @defaultValue false\n   */\n  weCanInterrupt?: boolean;\n\n  /**\n   * Whether a user attempt to scroll the target can interrupt this before it\n   * finishes.\n   *\n   * @defaultValue false\n   */\n  userCanInterrupt?: boolean;\n\n  /**\n   * If the scrolling element is already at the given coordinates (or strictly\n   * speaking we allow for 5 pixels difference), then if `altTarget` is given,\n   * this will become the target to scroll to.\n   *\n   * @defaultValue undefined\n   */\n  altTarget?: TargetCoordinates | Element | string;\n\n  /**\n   * Offset the target coordinates by the given amount(s) when `altTarget` is used.\n   *\n   * See {@link ScrollToOptions.offset}.\n   *\n   * @defaultValue undefined\n   */\n  altOffset?: CoordinateOffset;\n};\n\n// ----------\n\n/**\n * Returns true if the given element is scrollable in the given direction, or\n * in either direction (if `axis` is not given).\n *\n * It first checks whether the current scroll offset on the target along the\n * given axis is non-0, and if so returns true immediately. Otherwise it will\n * attempt to determine if it's scrollable using one of these methods\n * (controlled by `options.active`):\n * - passive check (default): Will examine `clientWidth/Height`,\n *   `scrollWidth/Height` as well as the computed `overflow` CSS property to try\n *   to determine if the target is scrollable. This is not 100% reliable but is\n *   safer than the active check\n * - active check: Will attempt to scroll the target by 1px and examine if the\n *   scroll offset had changed, then revert it back to 0. This is a more\n *   reliable check, however it can cause issues in certain contexts. In\n *   particular, if a scroll on the target had just been initiated (but it's\n *   scroll offset was still 0), the scroll may be cancelled. Never use that\n *   inside scroll-based handlers.\n *\n * **NOTE:** If the layout has been invalidated and not yet recalculated, this\n * will cause a forced layout, so always {@link waitForMeasureTime} before\n * calling this function when possible.\n *\n * @param [options.axis]    One of \"x\" or \"y\" for horizontal or vertical scroll\n *                          respectively. If not given, it checks both.\n * @param [options.active]  If true, then if the target's current scroll offset\n *                          is 0, it will attempt to scroll it rather than\n *                          looking at its overflow.\n * @param [options.noCache] By default the result of a check is cached for 1s\n *                          and if there's already a cached result for this\n *                          element, it is returned. Set this to true to disable\n *                          checking the cache and also saving the result into\n *                          the cache.\n *\n * @category Scrolling\n */\nexport const isScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n): boolean => {\n  const { axis, active, noCache } = options ?? {};\n  if (!axis) {\n    return (\n      isScrollable(element, { axis: \"y\", active, noCache }) ||\n      isScrollable(element, { axis: \"x\", active, noCache })\n    );\n  }\n\n  if (!noCache) {\n    const cachedResult = isScrollableCache.get(element)?.get(axis);\n    if (!MH.isNullish(cachedResult)) {\n      return cachedResult;\n    }\n  }\n\n  const offset = axis === \"x\" ? \"Left\" : \"Top\";\n  let result = false;\n\n  if (element[`scroll${offset}`]) {\n    result = true;\n  } else if (active) {\n    // Use scrollTo with explicit behavior set to instant instead of setting\n    // the scrollTop/Left properties since the latter doesn't work with\n    // scroll-behavior smooth.\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 1 });\n    const canScroll = element[`scroll${offset}`] > 0;\n    MH.elScrollTo(element, { [MH.toLowerCase(offset)]: 0 });\n    result = canScroll;\n  } else {\n    const dimension = axis === \"x\" ? \"Width\" : \"Height\";\n    const isDocScrollable = element === MH.getDocScrollingElement();\n\n    const hasOverflow =\n      element[`scroll${dimension}`] > element[`client${dimension}`];\n    const overflowProp = getComputedStylePropNow(element, \"overflow\");\n    const scrollingOverflows = [\n      MC.S_SCROLL,\n      MC.S_AUTO,\n      ...(isDocScrollable ? [MC.S_VISIBLE] : []),\n    ];\n\n    result = hasOverflow && MH.includes(scrollingOverflows, overflowProp);\n  }\n\n  if (!noCache) {\n    isScrollableCache.sGet(element).set(axis, result);\n    MH.setTimer(() => {\n      MH.deleteKey(isScrollableCache.get(element), axis);\n      isScrollableCache.prune(element);\n    }, IS_SCROLLABLE_CACHE_TIMEOUT);\n  }\n\n  return result;\n};\n\n/**\n * Returns the closest scrollable ancestor of the given element, _not including\n * it_.\n *\n * @param options See {@link isScrollable}\n *\n * @returns `null` if no scrollable ancestors are found.\n *\n * @category Scrolling\n */\nexport const getClosestScrollable = (\n  element: Element,\n  options?: {\n    axis?: \"x\" | \"y\";\n    active?: boolean;\n    noCache?: boolean;\n  },\n) => {\n  // Walk up the tree, starting at the element in question but excluding it.\n  let ancestor: Element | null | undefined = element;\n  while ((ancestor = MH.parentOf(ancestor))) {\n    if (isScrollable(ancestor, options)) {\n      return ancestor;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Returns the current {@link ScrollAction} if any.\n *\n * @category Scrolling\n */\nexport const getCurrentScrollAction = (\n  scrollable?: Element,\n): ScrollAction | null => {\n  scrollable = toScrollableOrDefault(scrollable);\n  const info = currentScrollInfos.get(scrollable);\n  if (info) {\n    return MH.copyObject(info._action);\n  }\n  return null;\n};\n\n/**\n * Scrolls the given scrollable element to the given `to` target.\n *\n * Returns `null` if there's an ongoing scroll that is not cancellable.\n *\n * Note that if `to` is an element or a selector, then it _must_ be a\n * descendant of the scrollable element.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *               If the target coordinates are invalid.\n *\n * @param to If this is an element, then its top-left position is used as\n *           the target coordinates. If it is a string, then it is treated\n *           as a selector for an element using `querySelector`.\n *\n * @returns `null` if there's an ongoing scroll that is not cancellable,\n * otherwise a {@link ScrollAction}.\n *\n * @category Scrolling\n */\nexport const scrollTo = (\n  to: TargetCoordinates | Element | string,\n  userOptions?: ScrollToOptions,\n): ScrollAction | null => {\n  const options = getOptions(to, userOptions);\n  const scrollable = options._scrollable;\n\n  // cancel current scroll action if any\n  const info = currentScrollInfos.get(scrollable);\n  if (info) {\n    if (!info._action.cancel()) {\n      // current scroll action is not cancellable by us\n      return null;\n    }\n  }\n\n  let isCancelled = false;\n\n  const cancelFn = options._weCanInterrupt\n    ? () => (isCancelled = true)\n    : () => false;\n\n  const scrollEvents = [\"touchmove\", \"wheel\"]; // don't bother with keyboard\n  let preventScrollHandler: EventListener | null = null;\n\n  if (options._userCanInterrupt) {\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(\n        scrollable,\n        eventType,\n        () => {\n          isCancelled = true;\n        },\n        { once: true },\n      );\n    }\n  } else {\n    preventScrollHandler = MH.preventDefault;\n    for (const eventType of scrollEvents) {\n      addEventListenerTo(scrollable, eventType, preventScrollHandler, {\n        passive: false,\n      });\n    }\n  }\n\n  const thisInfo: ScrollInfo = {\n    _action: {\n      waitFor: () => scrollActionPromise,\n      cancel: cancelFn,\n    },\n  };\n\n  const cleanup = () => {\n    if (currentScrollInfos.get(scrollable)?._action === thisInfo._action) {\n      MH.deleteKey(currentScrollInfos, scrollable);\n    }\n\n    if (preventScrollHandler) {\n      for (const eventType of scrollEvents) {\n        removeEventListenerFrom(scrollable, eventType, preventScrollHandler, {\n          passive: false,\n        });\n      }\n    }\n  };\n\n  const scrollActionPromise = initiateScroll(options, () => isCancelled);\n  thisInfo._action.waitFor().then(cleanup).catch(cleanup);\n\n  updateCurrentScrollInfo(scrollable, thisInfo);\n  return thisInfo._action;\n};\n\n/**\n * Returns true if the given string is a valid scroll direction.\n *\n * @category Validation\n */\nexport const isValidScrollDirection = (\n  direction: string,\n): direction is ScrollDirection => MH.includes(SCROLL_DIRECTIONS, direction);\n\n/**\n * Returns true if the given string or array is a list of valid scroll\n * directions.\n *\n * @category Validation\n */\nexport const isValidScrollDirectionList = (directions: string | string[]) =>\n  isValidStrList(directions, isValidScrollDirection, false);\n\n/**\n * @ignore\n * @internal\n */\nexport const mapScrollable = (original: Element, actualScrollable: Element) =>\n  mappedScrollables.set(original, actualScrollable);\n\n/**\n * @ignore\n * @internal\n */\nexport const unmapScrollable = (original: Element) =>\n  MH.deleteKey(mappedScrollables, original);\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientWidthNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetWidth -\n      getBorderWidth(element, MC.S_LEFT) -\n      getBorderWidth(element, MC.S_RIGHT)\n    : element[MC.S_CLIENT_WIDTH];\n\n/**\n * @ignore\n * @internal\n */\nexport const getClientHeightNow = (element: Element) =>\n  isScrollableBodyInQuirks(element)\n    ? element.offsetHeight -\n      getBorderWidth(element, MC.S_TOP) -\n      getBorderWidth(element, MC.S_BOTTOM)\n    : element[MC.S_CLIENT_HEIGHT];\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainContentElement = (): HTMLElement | null =>\n  mainContentElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainContentElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainContentElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetMainScrollableElement = (): HTMLElement | null =>\n  mainScrollableElement ?? null;\n\n/**\n * @ignore\n * @internal\n *\n * Exposed via ScrollWatcher\n */\nexport const fetchMainScrollableElement = async (): Promise<HTMLElement> => {\n  await init();\n\n  return mainScrollableElement;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getDefaultScrollingElement = () => {\n  const body = MH.getBody();\n  return isScrollable(body) ? body : (MH.getDocScrollingElement() ?? body);\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const tryGetScrollableElement = (\n  target: ScrollTarget | null | undefined,\n): Element | null => toScrollableOrMain(target, tryGetMainScrollableElement);\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchScrollableElement = async (\n  target: ScrollTarget | null | undefined,\n): Promise<Element> => toScrollableOrMain(target, fetchMainScrollableElement);\n\n// ----------------------------------------\n\ntype ScrollToOptionsInternal = {\n  _target: TargetCoordinates;\n  _offset: CoordinateOffset | null;\n  _altTarget: TargetCoordinates | null;\n  _altOffset: CoordinateOffset | null;\n  _scrollable: Element;\n  _duration: number;\n  _weCanInterrupt: boolean;\n  _userCanInterrupt: boolean;\n};\n\ntype Velocity = { top: number; left: number };\n\ntype ScrollInfo = {\n  _action: ScrollAction;\n  _position?: ScrollPosition;\n  _velocity?: Velocity;\n  _elapsed?: ElapsedTimes;\n};\n\nconst IS_SCROLLABLE_CACHE_TIMEOUT = 1000;\n\nconst isScrollableCache = newXMap<Element, Map<\"x\" | \"y\", boolean>>(() =>\n  MH.newMap(),\n);\n\nconst mappedScrollables = MH.newMap<Element, Element>();\n\nconst currentScrollInfos = MH.newMap<Element, ScrollInfo>();\n\nconst DIFF_THRESHOLD = 5;\nconst arePositionsDifferent = (\n  start: ScrollPosition,\n  end: ScrollPosition,\n  threshold = DIFF_THRESHOLD,\n) => maxAbs(start.top - end.top, start.left - end.left) > threshold;\n\n// must be called in \"measure time\"\nconst getBorderWidth = (element: Element, side: Offset) =>\n  MH.ceil(MH.parseFloat(getComputedStylePropNow(element, `border-${side}`)));\n\nconst isScrollableBodyInQuirks = (element: Element): element is HTMLElement =>\n  element === MH.getBody() && MH.getDocScrollingElement() === null;\n\nconst toScrollableOrMain = <R>(\n  target: ScrollTarget | null | undefined,\n  getMain: () => R,\n): Element | R => {\n  if (MH.isElement(target)) {\n    return mappedScrollables.get(target) ?? target;\n  }\n\n  if (!target || target === MH.getWindow() || target === MH.getDoc()) {\n    return getMain();\n  }\n\n  throw MH.usageError(\"Unsupported scroll target\");\n};\n\nconst toScrollableOrDefault = (scrollable: Element | undefined): Element =>\n  scrollable ?? getDefaultScrollingElement();\n\nconst getOptions = (\n  to: TargetCoordinates | Element | string,\n  options: ScrollToOptions | undefined,\n): ScrollToOptionsInternal => {\n  const scrollable = toScrollableOrDefault(options?.scrollable);\n  const target = getTargetCoordinates(scrollable, to);\n  const altTarget = options?.altTarget\n    ? getTargetCoordinates(scrollable, options?.altTarget)\n    : null;\n\n  return {\n    _target: target,\n    _offset: options?.offset ?? null,\n    _altTarget: altTarget,\n    _altOffset: options?.altOffset ?? null,\n    _scrollable: scrollable,\n    _duration: options?.duration ?? 0,\n    _weCanInterrupt: options?.weCanInterrupt ?? false,\n    _userCanInterrupt: options?.userCanInterrupt ?? false,\n  };\n};\n\nconst updateCurrentScrollInfo = (\n  scrollable: Element,\n  newInfo: Partial<ScrollInfo>,\n) => {\n  const existingScrollInfo = currentScrollInfos.get(scrollable);\n  const _action = newInfo._action ?? existingScrollInfo?._action;\n  if (_action) {\n    currentScrollInfos.set(\n      scrollable,\n      MH.merge(existingScrollInfo, newInfo, { _action }),\n    );\n  }\n};\n\nconst getTargetCoordinates = (\n  scrollable: Element,\n  target: TargetCoordinates | Element | string,\n): TargetCoordinates => {\n  const isDocScrollingElement = scrollable === MH.getDocScrollingElement();\n\n  if (MH.isElement(target)) {\n    if (scrollable === target || !scrollable.contains(target)) {\n      throw MH.usageError(\"Target must be a descendant of the scrollable one\");\n    }\n\n    return {\n      top: () =>\n        MH.getBoundingClientRect(target).top -\n        MH.getBoundingClientRect(scrollable).top +\n        (isDocScrollingElement ? 0 : scrollable[MC.S_SCROLL_TOP]),\n      left: () =>\n        MH.getBoundingClientRect(target).left -\n        MH.getBoundingClientRect(scrollable).left +\n        (isDocScrollingElement ? 0 : scrollable[MC.S_SCROLL_LEFT]),\n    };\n  }\n\n  if (MH.isString(target)) {\n    const targetEl = MH.docQuerySelector(target);\n    if (!targetEl) {\n      throw MH.usageError(`No match for '${target}'`);\n    }\n\n    return getTargetCoordinates(scrollable, targetEl);\n  }\n\n  if (!MH.isObject(target) || !(\"top\" in target || \"left\" in target)) {\n    throw MH.usageError(\"Invalid coordinates\");\n  }\n\n  return target;\n};\n\nconst getStartEndPosition = async (\n  options: ScrollToOptionsInternal,\n): Promise<{ _start: ScrollPosition; _end: ScrollPosition }> => {\n  await waitForMeasureTime();\n\n  const applyOffset = (\n    position: ScrollPosition,\n    offset: CoordinateOffset | null,\n  ) => {\n    position.top += offset?.top ?? 0;\n    position.left += offset?.left ?? 0;\n  };\n\n  const scrollable = options._scrollable;\n  const start = {\n    top: scrollable[MC.S_SCROLL_TOP],\n    left: scrollable[MC.S_SCROLL_LEFT],\n  };\n\n  let end = getEndPosition(scrollable, start, options._target);\n  applyOffset(end, options._offset);\n\n  if (!arePositionsDifferent(start, end) && options._altTarget) {\n    end = getEndPosition(scrollable, start, options._altTarget);\n    applyOffset(end, options._altOffset);\n  }\n\n  return { _start: start, _end: end };\n};\n\n// must be called in \"measure time\"\nconst getEndPosition = (\n  scrollable: Element,\n  startPosition: ScrollPosition,\n  targetCoordinates: TargetCoordinates,\n): ScrollPosition => {\n  // by default no change in scroll top or left\n  const endPosition = MH.copyObject(startPosition);\n\n  if (!MH.isNullish(targetCoordinates?.top)) {\n    if (MH.isFunction(targetCoordinates.top)) {\n      endPosition.top = targetCoordinates.top(scrollable);\n    } else {\n      endPosition.top = targetCoordinates.top;\n    }\n  }\n\n  if (!MH.isNullish(targetCoordinates?.left)) {\n    if (MH.isFunction(targetCoordinates.left)) {\n      endPosition.left = targetCoordinates.left(scrollable);\n    } else {\n      endPosition.left = targetCoordinates.left;\n    }\n  }\n\n  // Set boundaries\n  const scrollH = scrollable[MC.S_SCROLL_HEIGHT];\n  const scrollW = scrollable[MC.S_SCROLL_WIDTH];\n  const clientH = getClientHeightNow(scrollable);\n  const clientW = getClientWidthNow(scrollable);\n  endPosition.top = MH.min(scrollH - clientH, endPosition.top);\n  endPosition.top = MH.max(0, endPosition.top);\n\n  endPosition.left = MH.min(scrollW - clientW, endPosition.left);\n  endPosition.left = MH.max(0, endPosition.left);\n\n  return endPosition;\n};\n\nconst initiateScroll = async (\n  options: ScrollToOptionsInternal,\n  isCancelled: () => boolean,\n) => {\n  const position = await getStartEndPosition(options);\n  const duration = options._duration;\n  const scrollable = options._scrollable;\n  const existingScrollInfo = currentScrollInfos.get(scrollable);\n\n  const currentPosition = existingScrollInfo?._position ?? position._start;\n  const currentVelocity = existingScrollInfo?._velocity ?? {\n    [MC.S_TOP]: 0,\n    [MC.S_LEFT]: 0,\n  };\n  let elapsed = existingScrollInfo?._elapsed;\n\n  const logger = debug\n    ? new debug.Logger({\n        name: `scroll-${formatAsString(scrollable)}-${randId()}`,\n        logAtCreation: {\n          options,\n          position,\n          elapsed,\n          currentPosition: MH.copyObject(currentPosition),\n          currentVelocity: MH.copyObject(currentVelocity),\n        },\n      })\n    : null;\n\n  for await (elapsed of newAnimationFrameIterator(elapsed)) {\n    const deltaTime = elapsed.sinceLast;\n    if (deltaTime === 0) {\n      // First time\n      continue;\n    }\n\n    // Element.scrollTo equates to a measurement and needs to run after\n    // painting to avoid forced layout.\n    await waitForMeasureTime();\n\n    if (isCancelled()) {\n      // Reject the promise\n      logger?.debug8(\"Cancelled\");\n      throw currentPosition;\n    }\n\n    for (const s of [MC.S_LEFT, MC.S_TOP] as const) {\n      const { l, v } = criticallyDamped({\n        l: currentPosition[s],\n        v: currentVelocity[s],\n        lTarget: position._end[s],\n        dt: deltaTime,\n        lag: duration,\n      });\n\n      currentPosition[s] = l;\n      currentVelocity[s] = v;\n    }\n\n    updateCurrentScrollInfo(scrollable, {\n      _position: currentPosition,\n      _velocity: currentVelocity,\n      _elapsed: elapsed,\n    });\n\n    const isDone = !arePositionsDifferent(currentPosition, position._end, 0.5);\n    if (isDone) {\n      MH.assign(currentPosition, position._end); // use exact final coordinates\n    }\n\n    MH.elScrollTo(scrollable, currentPosition);\n\n    if (isDone) {\n      logger?.debug8(\"Done\");\n      break;\n    }\n  }\n\n  return currentPosition;\n};\n\n// ------------------------------\n\nlet mainContentElement: HTMLElement;\nlet mainScrollableElement: HTMLElement;\n\nlet initPromise: Promise<void> | null = null;\nconst init = (): Promise<void> => {\n  if (!initPromise) {\n    initPromise = (async () => {\n      const mainScrollableElementSelector =\n        settings.mainScrollableElementSelector;\n\n      const contentElement = await waitForElementOrInteractive(() => {\n        return mainScrollableElementSelector\n          ? MH.docQuerySelector(mainScrollableElementSelector)\n          : MH.getBody(); // default if no selector\n      });\n\n      // defaults\n      mainScrollableElement = getDefaultScrollingElement();\n      mainContentElement = MH.getBody();\n\n      if (!contentElement) {\n        logError(\n          MH.usageError(\n            `No match for '${mainScrollableElementSelector}'. ` +\n              \"Scroll tracking/capturing may not work as intended.\",\n          ),\n        );\n      } else if (!MH.isHTMLElement(contentElement)) {\n        logWarn(\"mainScrollableElementSelector should point to an HTMLElement\");\n      } else if (contentElement !== mainContentElement) {\n        mainScrollableElement = mainContentElement = contentElement;\n      }\n    })();\n  }\n\n  return initPromise;\n};\n\n// Try to find the main scrollable/content elements asap so that tryGetMain*\n// can return them if called before fetchMain*\nif (MH.hasDOM()) {\n  waitForInteractive().then(init);\n}\n"],"mappings":"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","ignoreList":[]}