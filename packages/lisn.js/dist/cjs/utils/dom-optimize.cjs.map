{"version":3,"file":"dom-optimize.cjs","names":["MH","_interopRequireWildcard","require","_log","_tasks","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","waitForMutateTime","newPromise","resolve","scheduleDOMTask","scheduledDOMMutations","exports","waitForMeasureTime","scheduledDOMMeasurements","waitForSubsequentMutateTime","then","waitForSubsequentMeasureTime","hasScheduledDOMTasks","queue","push","onAnimationFrame","runAllDOMTasks","lengthOf","runDOMTaskQueue","scheduleHighPriorityTask","shift","err","logError"],"sources":["../../../src/ts/utils/dom-optimize.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Preventing layout trashing\n *\n * {@link waitForMeasureTime} allows you to schedule tasks that read or\n * \"measure\", the DOM, for example getting computed styles, taking the\n * `offsetWidth` or the `scrollTop` of an element, etc... anything that _would_\n * force a layout if it runs after the layout has been invalidated by a\n * \"mutation\".\n *\n * See https://gist.github.com/paulirish/5d52fb081b3570c81e3 for a list of\n * operations that should be run on a valid layout to avoid forced layouts.\n *\n * {@link waitForMutateTime} allows you to schedule tasks that invalidate the\n * DOM layout by making changes to the style, inserting or removing elements,\n * etc.\n *\n * These ensure that:\n * - All mutation tasks that would invalidate the style run together before the\n *   next repaint.\n * - All measurement tasks that need a valid style will run as soon as possible\n *   after the next repaint.\n * - If a mutation task is scheduled by another mutation task, it will run in\n *   the same batch.\n * - If a measurement task is scheduled by either a mutation or another\n *   measurement task, it will run in the same batch.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { logError } from \"@lisn/utils/log\";\nimport { scheduleHighPriorityTask } from \"@lisn/utils/tasks\";\n\n/**\n * Returns a Promise that is resolved before the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMutateTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMutations, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved as soon as possible after the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForMeasureTime = () =>\n  MH.newPromise<void>((resolve) => {\n    scheduleDOMTask(scheduledDOMMeasurements, resolve);\n  });\n\n/**\n * Returns a Promise that is resolved before the repaint that follows the next\n * repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMutateTime = () =>\n  waitForMutateTime().then(waitForMeasureTime).then(waitForMutateTime);\n\n/**\n * Returns a Promise that is resolved as soon as possible after the repaint\n * that follows the next repaint.\n *\n * @category DOM: Preventing layout trashing\n */\nexport const waitForSubsequentMeasureTime = () =>\n  waitForMeasureTime().then(waitForMutateTime).then(waitForMeasureTime);\n\n// ----------------------------------------\n\ntype TaskResolver = () => void;\ntype DOMTaskQueue = TaskResolver[];\n\nconst scheduledDOMMeasurements: DOMTaskQueue = [];\nconst scheduledDOMMutations: DOMTaskQueue = [];\nlet hasScheduledDOMTasks = false;\n\nconst scheduleDOMTask = (queue: DOMTaskQueue, resolve: TaskResolver) => {\n  queue.push(resolve);\n  if (!hasScheduledDOMTasks) {\n    hasScheduledDOMTasks = true;\n    MH.onAnimationFrame(runAllDOMTasks);\n  }\n};\n\nconst runAllDOMTasks = async () => {\n  // We suspend (await null) after each queue to ensure that microtasks that\n  // have been added by await waitFor* or waitFor*().then run before the next\n  // queue, so that if they schedule more measurements and/or mutations, they\n  // can be flushed now, in the same batch.\n\n  // We're inside an animation frame. Run all mutation tasks now.\n  while (MH.lengthOf(scheduledDOMMutations)) {\n    runDOMTaskQueue(scheduledDOMMutations);\n    // wait for tasks awaiting on the resolved promises, then check queue again\n    await null;\n  }\n\n  // The measurement queue is now empty => scheduling measurements after\n  // this point will result in rescheduling both queues again in the next\n  // frame.\n  //\n  // Schedule the measurement tasks as soon as possible, after the upcoming\n  // paint. Use a macro task with as high priority as possible.\n  scheduleHighPriorityTask(async () => {\n    while (MH.lengthOf(scheduledDOMMeasurements)) {\n      runDOMTaskQueue(scheduledDOMMeasurements);\n      // wait for tasks awaiting on the resolved promises, then check queue again\n      await null;\n    }\n\n    if (MH.lengthOf(scheduledDOMMutations)) {\n      // There have been mutations added. Schedule another flush.\n      MH.onAnimationFrame(runAllDOMTasks);\n    } else {\n      hasScheduledDOMTasks = false;\n    }\n  });\n};\n\nconst runDOMTaskQueue = (queue: DOMTaskQueue) => {\n  let resolve: TaskResolver | undefined;\n  while ((resolve = queue.shift())) {\n    try {\n      resolve();\n    } catch (err) /* istanbul ignore next */ {\n      logError(err);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]}