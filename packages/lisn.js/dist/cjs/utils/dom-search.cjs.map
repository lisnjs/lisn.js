{"version":3,"file":"dom-search.cjs","names":["MH","_interopRequireWildcard","require","_cssAlter","_domEvents","_log","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","_typeof","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getReferenceElement","exports","spec","thisElement","referenceElement","getElementById","slice","relation","find","p","startsWith","concat","usageError","rest","lengthOf","matchOp","refOrCls","selector","getData","PREFIX_REF","DATA_REF","getFirstReferenceElement","getLastReferenceElement","getThisReferenceElement","getNextReferenceElement","getPrevReferenceElement","logError","bugError","waitForReferenceElement","timeout","arguments","length","undefined","waitForElement","prefixName","prefixData","getAllReferenceElements","docQuerySelectorAll","docQuerySelector","allRefs","closest","getNextOrPrevReferenceElement","goBackward","getDoc","contains","numRefs","refIndex","currentIsAfter","isNodeBAfterA"],"sources":["../../../src/ts/utils/dom-search.ts"],"sourcesContent":["/**\n * @module Utils\n *\n * @categoryDescription DOM: Searching for reference elements\n * The functions allow you to find elements that match a given string\n * specification.\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport { waitForElement } from \"@lisn/utils/dom-events\";\nimport { logError } from \"@lisn/utils/log\";\n\n/**\n * Get the element that matches the given reference specification.\n *\n * The specification is of the form:\n *\n * ```\n * <FullSpec> ::=\n *     <Relation> \".\" <ClassName>  |\n *     <Relation> [\"-\" <ReferenceName>] |\n *     #<DOM_ID>\n *\n * <Relation> :==\n *     \"next\"  |\n *     \"prev\"  |\n *     \"this\"  |\n *     \"first\" |\n *     \"last\"\n * ```\n *\n * - `<DOM_ID>` is the unique ID of the element\n * - `<ClassName>` is a CSS class on the element\n * - `<ReferenceName>` is the value of the `data-lisn-ref` attribute on the\n *   element you are targeting. If not given, defaults to the value of the\n *   `data-lisn-ref` attribute on `thisElement`.\n *\n * There now follows an explanation of how \"next\", \"prev\", \"this\", \"first\" and\n * \"last\" search the DOM:\n * - \"next\": the tree is search in document order (depth first, then breadth),\n *   so the returned element could be a descendant of `thisElement`\n * - \"prev\": the tree is search in document order (depth first, then breadth),\n *   but excluding ancestors of `thisElement`, so the returned element is\n *   guaranteed to _not_ be an ancestor or descendant of `thisElement`.\n * - \"this\": if the given element itself matches the specification, it is\n *   returned, otherwise the closest ancestor of the given element that matches\n *   the specification\n * - \"first\": the first element matching; the tree is search in document order\n *   (depth first, then breadth).\n * - \"last\": the last element matching; the tree is search in document order\n *   (depth first, then breadth).\n *\n * @category DOM: Searching for reference elements\n *\n * @param {} thisElement The element to search relative to\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                        If the specification is invalid or if thisElement is\n *                        not given for a specification of \"next\", \"prev\" or \"this\"\n */\nexport const getReferenceElement = (\n  spec: string,\n  thisElement: Element,\n): Element | null => {\n  if (!spec) {\n    return thisElement;\n  }\n\n  if (spec[0] === \"#\") {\n    // element ID\n    const referenceElement = MH.getElementById(spec.slice(1));\n    if (!referenceElement) {\n      return null;\n    }\n    return referenceElement;\n  }\n\n  const relation = [\"next\", \"prev\", \"this\", \"first\", \"last\"].find(\n    (p) => spec.startsWith(`${p}.`) || spec.startsWith(`${p}-`) || spec === p,\n  );\n\n  if (!relation) {\n    throw MH.usageError(`Invalid search specification '${spec}'`);\n  }\n\n  const rest = spec.slice(MH.lengthOf(relation));\n  const matchOp = rest.slice(0, 1);\n  let refOrCls = rest.slice(1);\n\n  let selector: string;\n  if (matchOp === \".\") {\n    selector = matchOp + refOrCls;\n  } else {\n    if (!refOrCls) {\n      refOrCls = getData(thisElement, PREFIX_REF) || \"\";\n    }\n\n    if (!refOrCls) {\n      throw MH.usageError(`No reference name in '${spec}'`);\n    }\n\n    selector = `[${DATA_REF}=\"${refOrCls}\"]`;\n  }\n\n  let referenceElement;\n  if (relation === \"first\") {\n    referenceElement = getFirstReferenceElement(selector);\n  } else if (relation === \"last\") {\n    referenceElement = getLastReferenceElement(selector);\n  } else {\n    if (relation === \"this\") {\n      referenceElement = getThisReferenceElement(selector, thisElement);\n    } else if (relation === \"next\") {\n      referenceElement = getNextReferenceElement(selector, thisElement);\n    } else if (relation === \"prev\") {\n      referenceElement = getPrevReferenceElement(selector, thisElement);\n    } else {\n      /* istanbul ignore next */ {\n        logError(MH.bugError(`Unhandled relation case ${relation}`));\n        return null;\n      }\n    }\n  }\n\n  if (!referenceElement) {\n    return null;\n  }\n\n  return referenceElement;\n};\n\n/**\n * Like {@link getReferenceElement} excepts if no element matches the\n * specification if will wait for at most the given time for such an element.\n *\n * @category DOM: Searching for reference elements\n */\nexport const waitForReferenceElement = (\n  spec: string,\n  thisElement: Element,\n  timeout = 200,\n) => waitForElement(() => getReferenceElement(spec, thisElement), timeout);\n\n// ----------------------------------------\n\nconst PREFIX_REF = MH.prefixName(\"ref\");\nconst DATA_REF = MH.prefixData(PREFIX_REF);\n\nconst getAllReferenceElements = (\n  selector: string,\n): NodeListOf<Element> | null => MH.docQuerySelectorAll(selector);\n\nconst getFirstReferenceElement = (selector: string): Element | null =>\n  MH.docQuerySelector(selector);\n\nconst getLastReferenceElement = (selector: string): Element | null => {\n  const allRefs = getAllReferenceElements(selector);\n  return (allRefs && allRefs[MH.lengthOf(allRefs) - 1]) || null;\n};\n\nconst getThisReferenceElement = (\n  selector: string,\n  thisElement: Element,\n): Element | null => thisElement.closest(selector);\n\nconst getNextReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, false);\n\nconst getPrevReferenceElement = (selector: string, thisElement: Element) =>\n  getNextOrPrevReferenceElement(selector, thisElement, true);\n\nconst getNextOrPrevReferenceElement = (\n  selector: string,\n  thisElement: Element,\n  goBackward: boolean,\n): Element | null => {\n  thisElement = getThisReferenceElement(selector, thisElement) || thisElement;\n\n  if (!MH.getDoc().contains(thisElement)) {\n    return null;\n  }\n\n  const allRefs = getAllReferenceElements(selector);\n  if (!allRefs) {\n    return null;\n  }\n\n  const numRefs = MH.lengthOf(allRefs);\n  let refIndex = goBackward ? numRefs - 1 : -1;\n  for (let i = 0; i < numRefs; i++) {\n    const currentIsAfter = MH.isNodeBAfterA(thisElement, allRefs[i]);\n\n    // As soon as we find either the starting element or the first element\n    // that follows it, stop iteration.\n    // - If we're looking for the previous reference, then take the previous\n    //   element in the iteration.\n    // - Otherwise, if the current element in the iteration is the same as the\n    //   starting one, then take either the next element in the iteration.\n    //   - Otherwise, (if the current element follows the starting one, as\n    //     would happen if the starting element was not in the list of matched\n    //     elements, take the current element in the iteration.\n    if (allRefs[i] === thisElement || currentIsAfter) {\n      refIndex = i + (goBackward ? -1 : currentIsAfter ? 0 : 1);\n      break;\n    }\n  }\n\n  return allRefs[refIndex] || null;\n};\n"],"mappings":"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","ignoreList":[]}