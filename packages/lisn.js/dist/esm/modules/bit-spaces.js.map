{"version":3,"file":"bit-spaces.js","names":["MH","getBitmask","BitSpaces","constructor","_defineProperty","counter","newCounter","create","propNames","newBitSpace","defineProperty","get","_nBits","_bitmask","newBitSpaces","createBitSpace","spaces","start","end","lengthOf","usageError","bitmask","space","bit","has","p","isString","isNumber","bitmaskFor","pStart","pEnd","isEmpty","thisStart","log2","thisEnd","nameOf","val","_propNames","name","value","enumerable"],"sources":["../../../src/ts/modules/bit-spaces.ts"],"sourcesContent":["/**\n * @module Modules/BitSpaces\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getBitmask } from \"@lisn/utils/math\";\n\nexport type BitPropName = string;\n\n/**\n * A union of all property names in the space.\n */\nexport type BitSpaceKey<S> = S extends BitSpace<infer T> ? T : never;\n\n/**\n * {@link BitSpace} represents a single set of mutually exclusive (or\n * orthogonal) properties.\n *\n * Each property has a numeric value equal to 1 bit-shifted by a certain number\n * of bits.\n *\n * Created using {@link BitSpaces.create}\n *\n * @interface\n */\nexport type BitSpace<T extends BitPropName> = {\n  /**\n   * The starting bit of the space. It's 0 for the first space created in a\n   * given set of {@link BitSpaces}.\n   */\n  start: number;\n\n  /**\n   * The ending bit of the space. It's always equal to\n   * start + (# of properties in space) - 1\n   */\n  end: number;\n\n  /**\n   * A bitmask of all values in the space.\n   */\n  bitmask: number;\n\n  /**\n   * Returns true if the given name is one of the properties in the space.\n   * It is case-sensitive.\n   */\n  has: (p: string) => p is T;\n\n  /**\n   * Takes the names of two properties within the space and returns a bitmask\n   * that covers all values between them _including the starting and ending\n   * one_.*\n   *\n   * If pStart > pEnd, they are reversed.\n   *\n   * * The numeric values of the properties are guaranteed to be in the same\n   *   order, increasing in value, as the keys passed to the `BitSpaces.create`,\n   *   function.\n   *\n   * @param {} pStart  The name of the property that holds the start value.\n   *                   If null the bitmask will cover from the lowest property.\n   * @param {} pEnd    The name of the property that holds the end cut-off\n   *                   value for the bitmask. The bitmask with _not_ include\n   *                   pEnd's value.\n   *                   If null the bitmask will cover to the highest property,\n   *                   _including_.\n   *\n   * @returns {} Returns a non-0 bitmask containing all values in the space\n   *             between the given ones.\n   *             Returns 0 if one or both of the given properties do not exist\n   *             in the space.\n   */\n  bitmaskFor: (pStart?: T | null, pEnd?: T | null) => number;\n\n  /**\n   * Returns the name of the property with the given value, or null if the\n   * value does not correspond to one of the space properties.\n   */\n  nameOf: (val: number) => T | null;\n\n  /**\n   * Holds properties whose numeric values are non-overlapping binary values,\n   * suitable for bitmasking.\n   *\n   * The given properties are set under the \"bit\" key in the object and hold\n   * the numeric value.\n   *\n   * @example\n   * ```javascript\n   * const space = new BitSpaces().create(\"up\", \"down\", \"left\", \"right\");\n   *\n   * // {\n   * //     bit: {\n   * //         up:    1, // at bit 0, i.e. 1 << 0\n   * //         down:  2, // at bit 1, i.e. 1 << 1\n   * //         left:  4, // at bit 2, i.e. 1 << 2\n   * //         right: 8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      0,\n   * //     end:        3,\n   * //     bitmask:    15, // 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"up\" || p === \"down\" || p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : v === 4 ...\n   * // }\n   *\n   * space.bitmaskFor(); // => space.bitmask (15)\n   * space.bitmaskFor(\"left\"); // => space.bit.left | space.bit.right (12)\n   * space.bitmaskFor(null, \"down\"); // => space.bit.up | space.bit.down (3)\n   * ```\n   */\n  bit: {\n    [key in T]: number;\n  };\n};\n\n/**\n * {@link BitSpaces} represents one or more related {@link BitSpace}s whose bit\n * values will not overlap.\n */\nexport class BitSpaces {\n  /**\n   * Creates and returns a new BitSpace that is bit shifted to the left as\n   * many bits as the ending bit of the previous space created by this\n   * instances, so that each new space created is non-overlapping with previous\n   * ones.\n   *\n   * The numeric values of the properties are guaranteed to be in the same\n   * order, increasing in value, as the keys passed to the function.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the number of bits in the space will exceed 32.\n   *\n   * @example\n   * ```javascript\n   * const spaces = new BitSpaces();\n   * const spaceA = spaces.create(\"up\", \"down\");\n   *\n   * // spaces.nBits   => 2\n   * // spaces.bitmask => 3\n   * //\n   * // spaceA:\n   * // {\n   * //     bit: {\n   * //         up:     1, // at bit 0, i.e. 1 << 0\n   * //         down:   2, // at bit 1, i.e. 1 << 1\n   * //     },\n   * //     start:      0,\n   * //     end:        1,\n   * //     bitmask:    3, // 1 << 0 | 1 << 1\n   * //     has:        (p) => p === \"up\" || p === \"down\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : null\n   * // }\n   *\n   * const spaceB = spaces.create(\"left\", \"right\");\n   *\n   * // spaces.nBits   => 4\n   * // spaces.bitmask => 15\n   * //\n   * // spaceB:\n   * // {\n   * //     bit: {\n   * //         left:   4, // at bit 2, i.e. 1 << 2\n   * //         right:  8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      2,\n   * //     end:        3,\n   * //     bitmask:    12, // 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 4 ? \"left\" : v === 8 ? \"right\" : null\n   * // }\n   *\n   * ```\n   */\n  readonly create: <T extends BitPropName>(\n    ...propNames: readonly T[]\n  ) => BitSpace<T>;\n\n  /**\n   * Returns the number of bits all created spaces span, i.e. the end bit of\n   * the one + 1.\n   */\n  readonly nBits!: number;\n\n  /**\n   * Returns a bitmask containing all values in all created spaces.\n   */\n  readonly bitmask!: number;\n\n  constructor() {\n    const counter = newCounter();\n\n    this.create = (...propNames) => newBitSpace(counter, propNames);\n    MH.defineProperty(this, \"nBits\", { get: () => counter._nBits });\n    MH.defineProperty(this, \"bitmask\", { get: () => counter._bitmask });\n  }\n}\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newBitSpaces = () => new BitSpaces();\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const createBitSpace = <T extends BitPropName>(\n  spaces: BitSpaces,\n  ...propNames: readonly T[]\n): BitSpace<T> => spaces.create(...propNames);\n\n// ----------------------------------------\n\ntype BitCounter = {\n  _nBits: number;\n  _bitmask: number;\n};\n\nconst newCounter = (): BitCounter => ({\n  _nBits: 0,\n  _bitmask: 0,\n});\n\nconst newBitSpace = <T extends BitPropName>(\n  counter: BitCounter,\n  propNames: readonly T[],\n): BitSpace<T> => {\n  const start = counter._nBits;\n  const end = start + MH.lengthOf(propNames) - 1;\n  if (end >= 31) {\n    throw MH.usageError(\"BitSpaces overflow\");\n  }\n\n  const bitmask = getBitmask(start, end);\n  const space: BitSpace<T> = {\n    bit: {},\n    start,\n    end,\n    bitmask,\n\n    has: (p) =>\n      MH.isString(p) &&\n      p in space.bit &&\n      MH.isNumber((space.bit as Record<string, unknown>)[p]),\n\n    bitmaskFor: (pStart, pEnd) => {\n      if (\n        (!MH.isEmpty(pStart) && !space.has(pStart)) ||\n        (!MH.isEmpty(pEnd) && !space.has(pEnd))\n      ) {\n        return 0;\n      }\n\n      const thisStart = !MH.isEmpty(pStart)\n        ? MH.log2(space.bit[pStart])\n        : start;\n      const thisEnd = !MH.isEmpty(pEnd) ? MH.log2(space.bit[pEnd]) : end;\n\n      return getBitmask(thisStart, thisEnd);\n    },\n\n    nameOf: (val) => propNames[MH.log2(val) - start] ?? null,\n  } as BitSpace<T>;\n\n  for (const name of propNames) {\n    MH.defineProperty(space.bit, name, {\n      value: 1 << counter._nBits++,\n      enumerable: true,\n    });\n  }\n\n  counter._bitmask |= bitmask;\n\n  return space;\n};\n"],"mappings":"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","ignoreList":[]}