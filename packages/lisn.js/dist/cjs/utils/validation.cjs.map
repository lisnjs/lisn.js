{"version":3,"file":"validation.cjs","names":["MH","_interopRequireWildcard","require","_errors","_math","_misc","_text","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","_typeof","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","isValidStrList","exports","value","checkFn","allowEmpty","arguments","length","undefined","res","validateStrList","isNullish","err","isInstanceOf","LisnUsageError","key","_toArray","filterBlank","toArray","map","v","_validateString","validateNumList","_toArray2","_validateNumber","validateNumber","validateBoolean","_validateBoolean","validateString","validateStringRequired","result","isEmpty","usageError","concat","validateBooleanOrString","stringCheckFn","_validateBooleanOrString","isArray","isIterableObject","arrayFrom","isLiteralString","splitOn","trim","typeDescription","numVal","toNum","boolVal","toBool"],"sources":["../../../src/ts/utils/validation.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { toNum } from \"@lisn/utils/math\";\nimport { toBool } from \"@lisn/utils/misc\";\nimport { splitOn } from \"@lisn/utils/text\";\n\n/**\n * Returns true if the input is a string array or comma-separated string, whose\n * elements are valid according to the `validator` function.\n *\n * @param {} allowEmpty If `false`, then input without any entries is\n * considered _invalid_.\n *\n * @category Validation\n */\nexport const isValidStrList = <T extends string = string>(\n  value: unknown,\n  checkFn: (value: string) => value is T,\n  allowEmpty = true,\n): value is CommaSeparatedStr<T> | T[] => {\n  try {\n    const res = validateStrList(\"\", value, checkFn);\n    return allowEmpty || !MH.isNullish(res);\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns an array of strings from the given list while validating each one\n * using the `checkFn` function.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a string or array of strings, or if any\n *                entries do not pass `checkFn`.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateStrList = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateString(key, v, checkFn, \"a string or a string array\"),\n    ),\n  );\n\n/**\n * Returns an array of numbers from the given list.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a number or array of numbers. Numerical\n *                strings are accepted.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateNumList = (\n  key: string,\n  value: unknown,\n): number[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateNumber(key, v, \"a number or a number array\"),\n    ),\n  );\n\n/**\n * Returns a number corresponding to the supplied value, ensuring the supplied\n * value is a valid number or a string containing only a number.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateNumber = (key: string, value: unknown) =>\n  _validateNumber(key, value);\n\n/**\n * Returns a boolean corresponding to the given value as follows:\n *\n * - `null` and `undefined` result in `undefined`\n * - `false` and `\"false\"` result in `false`\n * - `\"\"`, `true` and `\"true\"` result in `true`\n * - other values throw an error error\n *\n * Note that an empty string is treated as `true`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is not a valid boolean or boolean string.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateBoolean = (key: string, value: unknown) =>\n  _validateBoolean(key, value);\n\n/**\n * Returns a valid string from the supplied value, ensuring the supplied value\n * is a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} checkFn      If given and the supplied value is a string, then it\n *                        is called with the value as a single argument. It\n *                        must return true if the value is valid and false\n *                        otherwise.\n *                        If it is not given, then any literal string is\n *                        accepted.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n) => _validateString(key, value, checkFn);\n\n/**\n * Like {@link validateString} except it requires input to be given and\n * non-empty.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid or empty.\n *\n * @category Validation\n */\nexport const validateStringRequired = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T => {\n  const result = _validateString(key, value, checkFn);\n\n  if (MH.isEmpty(result)) {\n    throw MH.usageError(`'${key}' is required`);\n  }\n\n  return result;\n};\n\n/**\n * Returns a valid boolean or a string from the supplied value, ensuring the\n * supplied value is either a boolean or boolean string (see\n * {@link validateBoolean}), or a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} stringCheckFn If given and the supplied value is a string _other\n *                         than a boolean string_, then it is called with the\n *                         value as a single argument. It must return true if\n *                         the value is valid and false otherwise.\n *                         If it is not given, then any literal string is\n *                         accepted.\n *\n * @category Validation\n */\nexport const validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n) => _validateBooleanOrString(key, value, stringCheckFn);\n\n// --------------------\n\nconst toArray = (value: unknown): unknown[] | undefined => {\n  let result: unknown[] | null;\n  if (MH.isArray(value)) {\n    result = value;\n  } else if (MH.isIterableObject(value)) {\n    result = MH.arrayFrom(value);\n  } else if (MH.isLiteralString(value)) {\n    result = splitOn(value, \",\");\n  } else if (!MH.isNullish(value)) {\n    result = [value];\n  } else {\n    result = null;\n  }\n\n  return result\n    ? MH.filterBlank(result.map((v) => (MH.isLiteralString(v) ? v.trim() : v)))\n    : undefined;\n};\n\nconst _validateNumber = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const numVal = toNum(value, null);\n  if (numVal === null) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a number\"}`);\n  }\n\n  return numVal;\n};\n\nconst _validateBoolean = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal === null) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? '\"true\" or \"false\"'}`,\n    );\n  }\n\n  return boolVal;\n};\n\nconst _validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n  typeDescription?: string,\n): (typeof checkFn extends null | undefined ? string : T) | undefined => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a string\"}`);\n  } else if (checkFn && !checkFn(value)) {\n    throw MH.usageError(`Invalid value for '${key}'`);\n  }\n\n  return value as typeof checkFn extends null | undefined ? string : T;\n};\n\nconst _validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal !== null) {\n    return boolVal;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? \"a boolean or string\"}`,\n    );\n  }\n\n  return _validateString(key, value, stringCheckFn);\n};\n"],"mappings":"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","ignoreList":[]}