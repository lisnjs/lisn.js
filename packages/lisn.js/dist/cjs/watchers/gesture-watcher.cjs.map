{"version":3,"file":"gesture-watcher.cjs","names":["MC","_interopRequireWildcard","require","MH","_cssAlter","_directions","_event2","_tasks","_gesture","_gestureKey","_gesturePointer","_gestureTouch","_gestureWheel","_log","_math","_text","_validation","_callback2","_xMap","_debug","_interopRequireDefault","e","__esModule","default","t","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","GestureWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","myConfig","configStrKey","objToStrKey","instance","instances","constructor","key","illegalConstructorError","logger","debug","Logger","name","logAtCreation","allCallbacks","newXWeakMap","newMap","allListeners","createCallback","target","handler","options","_allCallbacks$get","remove","_callback","debug5","_wrapper","getCallbackAndWrapper","onRemove","deleteHandler","sGet","_options","setupOnGesture","userOptions","getOptions","device","_options$_devices","_devices","DEVICES","_allListeners$get","listeners","debug4","setupListeners","_nCallbacks","_preventDefault","_nPreventDefault","deleteKey","prune","_options$_devices2","_allListeners$get2","_remove","invokeCallbacks","event","_allListeners$get$get","_allListeners$get3","preventDefault","isTerminated","_allCallbacks$get2","values","intents","_intents","hasAddedTabIndex","hasPreventedSelect","S_KEY","isElement","getTabIndex","setTabIndex","S_TOUCH","addClasses","PREFIX_NO_TOUCH_ACTION","includes","S_DRAG","preventSelect","addOrRemoveListeners","action","listener","eventTypes","method","addEventListenerTo","removeEventListenerFrom","eventType","debug8","passive","capture","addInitialListener","initialListener","initiatingEvents","removeInitialListener","addOngoingListener","processEvent","ongoingEvents","removeOngoingListener","unsetTabIndex","removeClasses","undoPreventSelect","trackGesture","element","setGestureCssProps","intent","INTENTS","totalDeltaX","totalDeltaY","totalDeltaZ","noTrackGesture","offGesture","onGesture","_allCallbacks$get3","exports","SYMBOL","_config$preventDefaul","_config$naturalTouchS","_config$touchDragHold","_config$touchDragNumF","_debounceWindow","toNonNegNum","S_DEBOUNCE_WINDOW","_deltaThreshold","deltaThreshold","_angleDiffThreshold","toPosNum","angleDiffThreshold","_naturalTouchScroll","naturalTouchScroll","_touchDragHoldTime","touchDragHoldTime","_touchDragNumFingers","touchDragNumFingers","S_KEYDOWN","pointer","S_POINTERDOWN","S_CLICK","touch","S_TOUCHSTART","wheel","S_WHEEL","S_POINTERUP","S_POINTERMOVE","S_POINTERCANCEL","S_TOUCHEND","S_TOUCHMOVE","S_TOUCHCANCEL","fragmentGetters","getKeyGestureFragment","S_POINTER","getPointerGestureFragment","getTouchGestureFragment","getWheelGestureFragment","_validateStrList","_validateStrList2","_validateStrList3","_options$minTotalDelt","_options$maxTotalDelt","_options$minTotalDelt2","_options$maxTotalDelt2","_options$minTotalDelt3","_options$maxTotalDelt3","_options$preventDefau","_options$naturalTouch","_options$touchDragHol","_options$touchDragNum","debounceWindow","validateStrList","devices","isValidInputDevice","directions","isValidDirection","isValidIntent","_minTotalDeltaX","minTotalDeltaX","_maxTotalDeltaX","maxTotalDeltaX","_minTotalDeltaY","minTotalDeltaY","_maxTotalDeltaY","maxTotalDeltaY","_minTotalDeltaZ","minTotalDeltaZ","_maxTotalDeltaZ","maxTotalDeltaZ","preventNextClick","reverseScroll","dragHoldTime","dragNumFingers","eventQueue","id","randId","callback","wrapCallback","debouncedWrapper","getDebouncedHandler","fragment","eventQueueCopy","_eventQueueCopy","_eventQueueCopy$","isRemoved","deltaX","deltaY","deltaZ","round","maxAbs","debug7","debug9","clearEventQueue","newTotalDeltaX","toNumWithBounds","min","max","newTotalDeltaY","newTotalDeltaZ","addDeltaZ","direction","time","lengthOf","timeStamp","data","S_NONE","invoke","catch","logError","wrapper","push","type","map","preventDefaultActionFor","setTimer","queue","keepLastEvent","splice","isActualGesture","currentTarget","isPointerDown","S_MOUSEDOWN","buttons","isHTMLElement","focus","preventScroll","S_UNKNOWN","prefix","S_ZOOM","setNumericStyleJsVars","_prefix","_numDecimal"],"sources":["../../../src/ts/watchers/gesture-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/GestureWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  Direction,\n  GestureIntent,\n  GestureDevice,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport {\n  addClasses,\n  removeClasses,\n  setNumericStyleJsVars,\n} from \"@lisn/utils/css-alter\";\nimport { isValidDirection } from \"@lisn/utils/directions\";\nimport {\n  addEventListenerTo,\n  removeEventListenerFrom,\n  preventSelect,\n  undoPreventSelect,\n} from \"@lisn/utils/event\";\nimport { getDebouncedHandler } from \"@lisn/utils/tasks\";\n\nimport { addDeltaZ } from \"@lisn/utils/gesture\";\n\nimport {\n  isValidInputDevice,\n  isValidIntent,\n  GestureFragment,\n  DEVICES,\n  INTENTS,\n} from \"@lisn/utils/gesture\";\nimport { getKeyGestureFragment } from \"@lisn/utils/gesture-key\";\nimport { getPointerGestureFragment } from \"@lisn/utils/gesture-pointer\";\nimport { getTouchGestureFragment } from \"@lisn/utils/gesture-touch\";\nimport { getWheelGestureFragment } from \"@lisn/utils/gesture-wheel\";\nimport { logError } from \"@lisn/utils/log\";\nimport {\n  maxAbs,\n  toNonNegNum,\n  toPosNum,\n  toNumWithBounds,\n} from \"@lisn/utils/math\";\nimport { randId, objToStrKey } from \"@lisn/utils/text\";\nimport { validateStrList } from \"@lisn/utils/validation\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { LoggerInterface } from \"@lisn/debug/types\";\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link GestureWatcher} listens for user gestures resulting from wheel,\n * pointer, touch or key input events.\n *\n * It supports scroll, zoom or drag type gestures.\n *\n * It manages registered callbacks globally and reuses event listeners for more\n * efficient performance.\n */\nexport class GestureWatcher {\n  /**\n   * Call the given handler whenever the user performs a gesture on the target\n   * matching the given options.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same event target, even if the options differ. If the handler has already\n   * been added for this target, either using {@link onGesture} or\n   * {@link trackGesture}, then it will be removed and re-added with the\n   * current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onGesture: (\n    target: EventTarget,\n    handler: OnGestureHandler,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offGesture: (target: EventTarget, handler: OnGestureHandler) => void;\n\n  /**\n   * This is the same as {@link onGesture} except that if `handler` is not\n   * given, then it defaults to an internal handler that updates a set of CSS\n   * variables on the target's style:\n   *\n   *   - `--lisn-js--<Intent>-delta-x`\n   *   - `--lisn-js--<Intent>-delta-y`\n   *   - `--lisn-js--<Intent>-delta-z`\n   *\n   * where and `<Intent>` is one of {@link GestureIntent} and the delta X, Y\n   * and Z are the _total summed up_ `deltaX`, `deltaY` and `deltaZ` since the\n   * callback was added, summed over all devices used (key, touch, etc).\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackGesture} or using\n   * {@link onGesture}, then it will be removed and re-added with the current\n   * options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly trackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n    options?: OnGestureOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackGesture}.\n   */\n  readonly noTrackGesture: (\n    element: Element,\n    handler?: OnGestureHandler | null,\n  ) => void;\n\n  /**\n   * Creates a new instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config?: GestureWatcherConfig) {\n    return new GestureWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of GestureWatcher with the given\n   * {@link GestureWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config?: GestureWatcherConfig) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(myConfig);\n\n    let instance = instances.get(configStrKey);\n    if (!instance) {\n      instance = new GestureWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: GestureWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"GestureWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"GestureWatcher\", logAtCreation: config })\n      : null;\n\n    const allCallbacks = newXWeakMap<\n      EventTarget,\n      Map<\n        OnGestureHandler,\n        {\n          _callback: OnGestureCallback;\n          _wrapper: OnGestureHandlerWrapper;\n          _options: OnGestureOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    // For each target and event type, add only 1 global listener that will then\n    // manage the event queues and callbacks.\n    const allListeners = newXWeakMap<\n      EventTarget,\n      Map<GestureDevice, DeviceListeners>\n    >(() => MH.newMap());\n\n    // ----------\n\n    const createCallback = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ): OnGestureCallback => {\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler for\", options);\n      const { _callback, _wrapper } = getCallbackAndWrapper(\n        handler,\n        options,\n        logger,\n      );\n\n      _callback.onRemove(() => deleteHandler(target, handler, options));\n\n      allCallbacks.sGet(target).set(handler, {\n        _callback,\n        _wrapper,\n        _options: options,\n      });\n\n      return _callback;\n    };\n\n    // ----------\n\n    // async for consistency with other watchers and future compatibility in\n    // case of change needed\n    const setupOnGesture = async (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      userOptions: OnGestureOptions | undefined,\n    ) => {\n      const options = getOptions(config, userOptions ?? {});\n      createCallback(target, handler, options);\n\n      for (const device of options._devices ?? DEVICES) {\n        let listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          debug: logger?.debug4(\n            `Listeners already added for ${device}`,\n            target,\n            options,\n          );\n        } else {\n          debug: logger?.debug4(\n            `Adding listeners for ${device}`,\n            target,\n            options,\n          );\n\n          listeners = setupListeners(target, device, options);\n          allListeners.sGet(target).set(device, listeners);\n        }\n\n        listeners._nCallbacks++;\n        if (options._preventDefault) {\n          listeners._nPreventDefault++;\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      target: EventTarget,\n      handler: OnGestureHandler,\n      options: OnGestureOptionsInternal,\n    ) => {\n      MH.deleteKey(allCallbacks.get(target), handler);\n      allCallbacks.prune(target);\n\n      for (const device of options._devices ?? DEVICES) {\n        const listeners = allListeners.get(target)?.get(device);\n        if (listeners) {\n          listeners._nCallbacks--;\n          if (options._preventDefault) {\n            listeners._nPreventDefault--;\n          }\n\n          if (!listeners._nCallbacks) {\n            debug: logger?.debug4(\n              `No more callbacks for target and device ${device}; removing listeners`,\n              target,\n            );\n\n            MH.deleteKey(allListeners.get(target), device);\n            listeners._remove();\n          }\n        }\n      }\n    };\n\n    // ----------\n\n    const invokeCallbacks = (\n      target: EventTarget,\n      device: GestureDevice,\n      event: Event,\n    ): boolean /* true if terminated */ => {\n      const preventDefault =\n        (allListeners.get(target)?.get(device)?._nPreventDefault ?? 0) > 0;\n\n      let isTerminated = false;\n      for (const { _wrapper } of allCallbacks.get(target)?.values() || []) {\n        isTerminated =\n          _wrapper(target, device, event, preventDefault) || isTerminated;\n      }\n\n      return isTerminated;\n    };\n\n    // ----------\n\n    const setupListeners = (\n      target: EventTarget,\n      device: GestureDevice,\n      options: OnGestureOptionsInternal,\n    ): DeviceListeners => {\n      const intents = options._intents;\n      let hasAddedTabIndex = false;\n      let hasPreventedSelect = false;\n\n      if (\n        device === MC.S_KEY &&\n        MH.isElement(target) &&\n        !MH.getTabIndex(target)\n      ) {\n        hasAddedTabIndex = true;\n        // enable element to receive keydown events\n        MH.setTabIndex(target);\n      } else if (MH.isElement(target) && device === MC.S_TOUCH) {\n        if (options._preventDefault) {\n          addClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n        }\n\n        if (!intents || MH.includes(intents, MC.S_DRAG)) {\n          hasPreventedSelect = true;\n          preventSelect(target);\n        }\n      }\n\n      const addOrRemoveListeners = (\n        action: \"add\" | \"remove\",\n        listener: EventListener,\n        eventTypes: readonly (keyof GlobalEventHandlersEventMap)[],\n      ) => {\n        const method =\n          action === \"add\" ? addEventListenerTo : removeEventListenerFrom;\n        for (const eventType of eventTypes) {\n          debug: logger?.debug8(`${action} listener for ${eventType}`, target);\n          method(target, eventType, listener, {\n            passive: false,\n            capture: true,\n          });\n        }\n      };\n\n      const addInitialListener = () =>\n        addOrRemoveListeners(\"add\", initialListener, initiatingEvents[device]);\n\n      const removeInitialListener = () =>\n        addOrRemoveListeners(\n          \"remove\",\n          initialListener,\n          initiatingEvents[device],\n        );\n\n      const addOngoingListener = () =>\n        addOrRemoveListeners(\"add\", processEvent, ongoingEvents[device]);\n\n      const removeOngoingListener = () =>\n        addOrRemoveListeners(\"remove\", processEvent, ongoingEvents[device]);\n\n      const initialListener = (event: Event) => {\n        processEvent(event);\n        removeInitialListener();\n        addOngoingListener();\n      };\n\n      const processEvent = (event: Event) => {\n        const isTerminated = invokeCallbacks(target, device, event);\n        if (isTerminated) {\n          removeOngoingListener();\n          addInitialListener();\n        }\n      };\n\n      addInitialListener();\n\n      return {\n        _nCallbacks: 0,\n        _nPreventDefault: 0,\n        _remove: () => {\n          if (MH.isElement(target)) {\n            if (hasAddedTabIndex) {\n              MH.unsetTabIndex(target);\n            }\n\n            removeClasses(target, MC.PREFIX_NO_TOUCH_ACTION);\n\n            if (hasPreventedSelect) {\n              undoPreventSelect(target);\n            }\n          }\n\n          removeOngoingListener();\n          removeInitialListener();\n        },\n      };\n    };\n\n    // ----------\n\n    this.trackGesture = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n        // initial values\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, {\n            intent,\n            totalDeltaX: 0,\n            totalDeltaY: 0,\n            totalDeltaZ: 1,\n          });\n        }\n      }\n\n      return setupOnGesture(element, handler, options);\n    };\n\n    // ----------\n\n    this.noTrackGesture = (element, handler?) => {\n      if (!handler) {\n        handler = setGestureCssProps;\n\n        // delete the properties\n        for (const intent of INTENTS) {\n          setGestureCssProps(element, { intent });\n        }\n      }\n\n      this.offGesture(element, handler);\n    };\n\n    // ----------\n\n    this.onGesture = setupOnGesture;\n\n    // ----------\n\n    this.offGesture = (target, handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(target)?.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type GestureWatcherConfig = {\n  /**\n   * The default value for\n   * {@link OnGestureOptions.preventDefault | preventDefault} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  preventDefault?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.debounceWindow | debounceWindow} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 150\n   */\n  debounceWindow?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.deltaThreshold | deltaThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 5\n   */\n  deltaThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.angleDiffThreshold | angleDiffThreshold} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * It does not make much sense to set this to 0.\n   *\n   * The value is in _degrees_, not radians.\n   *\n   * @defaultValue 35\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.naturalTouchScroll | naturalTouchScroll} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue true\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragHoldTime | touchDragHoldTime} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 500\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The default value for\n   * {@link OnGestureOptions.touchDragNumFingers | touchDragNumFingers} in calls to\n   * {@link GestureWatcher.onGesture}.\n   *\n   * @defaultValue 1\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * @interface\n */\nexport type OnGestureOptions = {\n  /**\n   * One or more device types to listen for. If not specified, then all devices\n   * are enabled.\n   *\n   * It can be a comma-separated list of {@link GestureDevice}s or an array of\n   * such devices.\n   *\n   * @defaultValue undefined\n   */\n  devices?: CommaSeparatedStr<GestureDevice> | GestureDevice[];\n\n  /**\n   * If given, callback will only be called if the gesture's direction is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link Direction}s or an array of such\n   * directions.\n   *\n   * @defaultValue undefined\n   */\n  directions?: CommaSeparatedStr<Direction> | Direction[];\n\n  /**\n   * If given, callback will only be called if the gesture's intent is one\n   * of the given ones.\n   *\n   * It can be a comma-separated list of {@link GestureIntent}s or an\n   * array of such intents.\n   *\n   * @defaultValue undefined\n   */\n  intents?: CommaSeparatedStr<GestureIntent> | GestureIntent[];\n\n  /**\n   * Set minimum total delta X. Further reductions in delta X below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaX?: number;\n\n  /**\n   * Set maximum total delta X. Further increase in delta X above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaX?: number;\n\n  /**\n   * Set minimum total delta Y. Further reductions in delta Y below this value\n   * will be ignored.\n   *\n   * The value is in pixels and can be negative.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaY?: number;\n\n  /**\n   * Set maximum total delta Y. Further increase in delta Y above this value\n   * will be ignored.\n   *\n   * The value is in pixels.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaY?: number;\n\n  /**\n   * Set minimum total delta Z. Further reductions in delta Z below this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and can be less than 1 but\n   * must be > 0.1 which is a hard minimum.\n   *\n   * @defaultValue undefined\n   */\n  minTotalDeltaZ?: number;\n\n  /**\n   * Set maximum total delta Z. Further increase in delta Z above this value\n   * will be ignored.\n   *\n   * The value is in percentage zoom, relative to 1, and must be positive.\n   *\n   * @defaultValue undefined\n   */\n  maxTotalDeltaZ?: number;\n\n  /**\n   * If true, the events of the gesture, e.g. relevant key presses or touch\n   * moves, etc, will have their default action prevented.\n   *\n   * **IMPORTANT:** For pointer gestures, then pointer/mouse down and click\n   * will be prevented.\n   *\n   * @defaultValue {@link GestureWatcherConfig.preventDefault}\n   */\n  preventDefault?: boolean;\n\n  /**\n   * If given, callback will be called at most once every `debounceWindow`\n   * milliseconds.\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.debounceWindow}\n   */\n  debounceWindow?: number;\n\n  /**\n   * Callback will only be called when the gesture's accumulated delta, since\n   * the last time callback was called, exceeds `deltaThreshold`.\n   *\n   * At least one of the three deltas (X, Y or Z) must exceed this number (in\n   * absolute value). Note that when comparing `deltaZ`, it is multiplied by\n   * 100 since it represents fractions of 1 (100%). So supplying\n   * `deltaThreshold` of 10 means is equivalent to the following condition:\n   *\n   * ```\n   * abs(deltaX) >= 10 || abs(deltaY) >= 10 ||  abs(1 - deltaZ) >= 0.1\n   * ```\n   *\n   * Accumulation of the delta ends if the gesture is terminated, for example,\n   * in case of touch gestures, by a \"touchcancel\" event of by the final finger\n   * lifting off..\n   *\n   * Note that if both `debounceWindow` and `deltaThreshold` are set, _both_\n   * must be exceeded before callback is called.\n   *\n   * @defaultValue {@link GestureWatcherConfig.deltaThreshold}\n   */\n  deltaThreshold?: number;\n\n  /**\n   * See {@link Utils.getVectorDirection | getVectorDirection}.\n   *\n   * @defaultValue {@link GestureWatcherConfig.angleDiffThreshold}\n   */\n  angleDiffThreshold?: number;\n\n  /**\n   * Whether touch scroll gestures follow the natural direction: swipe up\n   * with scroll intent results in direction down and swipe down results in\n   * direction up.\n   *\n   * @defaultValue {@link GestureWatcherConfig.naturalTouchScroll}\n   */\n  naturalTouchScroll?: boolean;\n\n  /**\n   * If the user presses and holds on a touchscreen for at least the given\n   * amount of milliseconds before moving the finger(s), touch gestures other\n   * than pinch will be treated as a drag intent instead of scroll as long as\n   * the number of fingers touching the screen is {@link touchDragNumFingers}.\n   *\n   * Set to 0 in order to treat _all_ non-pinch touch gestures as drag.\n   *\n   * Set to a negative number in order to treat _all_ non-pinch touch gestures\n   * as scroll.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragHoldTime?: number;\n\n  /**\n   * The number of fingers that could be considered a drag intent for touch\n   * gestures.\n   *\n   * @defaultValue {@link GestureWatcherConfig.touchDragHoldTime}\n   */\n  touchDragNumFingers?: number;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - the event target that was passed to the {@link GestureWatcher.onGesture}\n *   call (equivalent to\n *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget | Event:currentTarget}).\n * - the {@link GestureData} that describes the gesture's progression since the\n *   last time the callback was called and since the callback was added.\n */\nexport type OnGestureHandlerArgs = [EventTarget, GestureData, Event[]];\nexport type OnGestureCallback = Callback<OnGestureHandlerArgs>;\nexport type OnGestureHandler =\n  | CallbackHandler<OnGestureHandlerArgs>\n  | OnGestureCallback;\n\nexport type GestureData = {\n  device: GestureDevice;\n  direction: Direction;\n  intent: GestureIntent;\n\n  /**\n   * Delta in the horizontal direction since the start of the gesture.\n   */\n  deltaX: number;\n\n  /**\n   * Delta in the vertical direction since the start of the gesture.\n   */\n  deltaY: number;\n\n  /**\n   * Relative fractional zoom in or out for zoom intents since the start of\n   * the gesture.\n   *\n   * For zoom in, `deltaZ` is always > 1, and for zoom out it is < 1.\n   *\n   * For non-zoom gestures it is 1.\n   */\n  deltaZ: number;\n\n  /**\n   * The time in milliseconds it took for the gesture. This will be the\n   * difference in timestamps between the first and last event that composed\n   * the gesture. For key and wheel gestures this could be 0, since 1 event is\n   * sufficient for them.\n   */\n  time: number;\n  // TODO totalTime, velocity (bound by max), averageVelocity (bound by max)\n\n  /**\n   * Delta in the horizontal direction since the callback was added.\n   */\n  totalDeltaX: number;\n\n  /**\n   * Delta in the vertical direction since the callback was added.\n   */\n  totalDeltaY: number;\n\n  /**\n   * Percentage (relative) zoom in or out for zoom intents since the callback\n   * was added.\n   */\n  totalDeltaZ: number;\n};\n\n// ----------------------------------------\n\ntype GestureWatcherConfigInternal = {\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureOptionsInternal = {\n  _devices: GestureDevice[] | null;\n  _directions: Direction[] | null;\n  _intents: GestureIntent[] | null;\n  _minTotalDeltaX: number | null;\n  _maxTotalDeltaX: number | null;\n  _minTotalDeltaY: number | null;\n  _maxTotalDeltaY: number | null;\n  _minTotalDeltaZ: number | null;\n  _maxTotalDeltaZ: number | null;\n  _preventDefault: boolean;\n  _debounceWindow: number;\n  _deltaThreshold: number;\n  _angleDiffThreshold: number;\n  _naturalTouchScroll: boolean;\n  _touchDragHoldTime: number;\n  _touchDragNumFingers: number;\n};\n\ntype OnGestureHandlerWrapper = (\n  _target: EventTarget,\n  _device: GestureDevice,\n  _event: Event,\n  _preventDefault: boolean,\n) => boolean;\n\n// Specific to a combination of target + device\ntype DeviceListeners = {\n  _nCallbacks: number; // total number of callbacks\n  _nPreventDefault: number; // total number wanting to prevent default action\n  _remove: () => void;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = MH.newMap<string, GestureWatcher>();\n\nconst getConfig = (\n  config: GestureWatcherConfig | undefined,\n): GestureWatcherConfigInternal => {\n  config ??= {};\n  return {\n    _preventDefault: config.preventDefault ?? true,\n    _debounceWindow: toNonNegNum(config[MC.S_DEBOUNCE_WINDOW], 150),\n    _deltaThreshold: toNonNegNum(config.deltaThreshold, 5),\n    _angleDiffThreshold: toPosNum(config.angleDiffThreshold, 35),\n    _naturalTouchScroll: config.naturalTouchScroll ?? true,\n    _touchDragHoldTime: config.touchDragHoldTime ?? 500,\n    _touchDragNumFingers: config.touchDragNumFingers ?? 1,\n  };\n};\n\nconst initiatingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  // If the browser doesn't support pointer events, then\n  // addEventListenerTo will transform it into mousedown\n  //\n  // We need to listen for click, since that occurs after a pointerup (i.e.\n  // after a gesure is terminated and the ongoing listeners removed), but it\n  // needs to have its default action prevented.\n  pointer: [MC.S_POINTERDOWN, MC.S_CLICK],\n  touch: [MC.S_TOUCHSTART],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst ongoingEvents: {\n  [D in GestureDevice]: readonly (keyof GlobalEventHandlersEventMap)[];\n} = {\n  key: [MC.S_KEYDOWN],\n  pointer: [\n    // If the browser doesn't support point events, then\n    // addEventListenerTo will transform them into mouse*\n    MC.S_POINTERDOWN,\n    MC.S_POINTERUP, // would terminate\n    MC.S_POINTERMOVE,\n    MC.S_POINTERCANCEL, // would terminate\n    MC.S_CLICK, // would terminate; can be default-prevented\n  ],\n  touch: [MC.S_TOUCHSTART, MC.S_TOUCHEND, MC.S_TOUCHMOVE, MC.S_TOUCHCANCEL],\n  wheel: [MC.S_WHEEL],\n} as const;\n\nconst fragmentGetters: {\n  [D in GestureDevice]: (\n    events: Event[],\n    options: {\n      deltaThreshold?: number;\n      angleDiffThreshold?: number;\n      reverseScroll?: boolean;\n      dragHoldTime?: number;\n      dragNumFingers?: number;\n    },\n  ) => GestureFragment | null | false;\n} = {\n  [MC.S_KEY]: getKeyGestureFragment,\n  [MC.S_POINTER]: getPointerGestureFragment,\n  [MC.S_TOUCH]: getTouchGestureFragment,\n  [MC.S_WHEEL]: getWheelGestureFragment,\n};\n\nconst getOptions = (\n  config: GestureWatcherConfigInternal,\n  options: OnGestureOptions,\n): OnGestureOptionsInternal => {\n  const debounceWindow = toNonNegNum(\n    options[MC.S_DEBOUNCE_WINDOW],\n    config._debounceWindow, // watcher is never debounced, so apply default here\n  );\n  const deltaThreshold = toNonNegNum(\n    options.deltaThreshold,\n    config._deltaThreshold,\n  );\n\n  return {\n    _devices:\n      validateStrList(\"devices\", options.devices, isValidInputDevice) ?? null,\n    _directions:\n      validateStrList(\"directions\", options.directions, isValidDirection) ??\n      null,\n    _intents:\n      validateStrList(\"intents\", options.intents, isValidIntent) ?? null,\n    _minTotalDeltaX: options.minTotalDeltaX ?? null,\n    _maxTotalDeltaX: options.maxTotalDeltaX ?? null,\n    _minTotalDeltaY: options.minTotalDeltaY ?? null,\n    _maxTotalDeltaY: options.maxTotalDeltaY ?? null,\n    _minTotalDeltaZ: options.minTotalDeltaZ ?? null,\n    _maxTotalDeltaZ: options.maxTotalDeltaZ ?? null,\n    _preventDefault: options.preventDefault ?? config._preventDefault,\n    _debounceWindow: debounceWindow,\n    _deltaThreshold: deltaThreshold,\n    _angleDiffThreshold: toNonNegNum(\n      options.angleDiffThreshold,\n      config._angleDiffThreshold,\n    ),\n    _naturalTouchScroll:\n      options.naturalTouchScroll ?? config._naturalTouchScroll,\n    _touchDragHoldTime: options.touchDragHoldTime ?? config._touchDragHoldTime,\n    _touchDragNumFingers:\n      options.touchDragNumFingers ?? config._touchDragNumFingers,\n  };\n};\n\n// Since each callback needs to accumulate events during its debounce window\n// and until its threshold is exceeded, we use a wrapper around the\n// user-supplied handler to do that.\nconst getCallbackAndWrapper = (\n  handler: OnGestureHandler,\n  options: OnGestureOptionsInternal,\n  logger: LoggerInterface | null,\n): { _callback: OnGestureCallback; _wrapper: OnGestureHandlerWrapper } => {\n  let totalDeltaX = 0,\n    totalDeltaY = 0,\n    totalDeltaZ = 1;\n  // When there's a pointer down, drag then pointerup, since we prevent\n  // pointerdown default action, this results in a click event shortly\n  // afterwards even when there's been a movement of the mouse. We detect that\n  // and prevent this click.\n  let preventNextClick = false;\n\n  const directions = options._directions;\n  const intents = options._intents;\n  const minTotalDeltaX = options._minTotalDeltaX;\n  const maxTotalDeltaX = options._maxTotalDeltaX;\n  const minTotalDeltaY = options._minTotalDeltaY;\n  const maxTotalDeltaY = options._maxTotalDeltaY;\n  const minTotalDeltaZ = options._minTotalDeltaZ;\n  const maxTotalDeltaZ = options._maxTotalDeltaZ;\n  const deltaThreshold = options._deltaThreshold;\n  const angleDiffThreshold = options._angleDiffThreshold;\n  const reverseScroll = !options._naturalTouchScroll;\n  const dragHoldTime = options._touchDragHoldTime;\n  const dragNumFingers = options._touchDragNumFingers;\n\n  // The event queue is cleared when the threshold is exceeded AND the debounce\n  // window has passed. It's not necessary for the actual handler to be called\n  // then (e.g. if the direction or intent doesn't match, it won't be).\n  const eventQueue: Event[] = [];\n  const id = randId();\n\n  // Since handler could be a function or a callback (not callable), we wrap it\n  // so that in case it's already a callback, its removal will result in\n  // deleteHandler getting called. It is not debounced itself, instead there's\n  // a debounced wrapper that invokes it.\n  const callback = wrapCallback(handler);\n\n  // The debounced callback wrapper is what is debounced.\n  // It accumulates total deltas and checks if the conditions (of threshold,\n  // direction and intent) are satisfied before calling the real handler.\n  //\n  // Most importantly, since it is only called when the debounce window has\n  // expired it can clear the event queue if the threshold is also exceeded.\n  const debouncedWrapper = getDebouncedHandler(\n    options._debounceWindow,\n    (\n      target: EventTarget,\n      fragment: GestureFragment,\n      eventQueueCopy: Event[],\n    ) => {\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      const deltaX = fragment.deltaX;\n      const deltaY = fragment.deltaY;\n      const deltaZ = fragment.deltaZ;\n      const device = fragment.device;\n\n      if (\n        MH.round(maxAbs(deltaX, deltaY, (1 - deltaZ) * 100)) < deltaThreshold\n      ) {\n        debug: logger?.debug7(\n          `[${id}] Delta threshold not exceeded for callback`,\n        );\n        return;\n      }\n\n      debug: logger?.debug9(`[${id}] Done summing events for ${device}`);\n      clearEventQueue(device, eventQueue);\n\n      const newTotalDeltaX = toNumWithBounds(totalDeltaX + deltaX, {\n        min: minTotalDeltaX,\n        max: maxTotalDeltaX,\n      });\n\n      const newTotalDeltaY = toNumWithBounds(totalDeltaY + deltaY, {\n        min: minTotalDeltaY,\n        max: maxTotalDeltaY,\n      });\n\n      const newTotalDeltaZ = toNumWithBounds(addDeltaZ(totalDeltaZ, deltaZ), {\n        min: minTotalDeltaZ,\n        max: maxTotalDeltaZ,\n      });\n\n      if (\n        newTotalDeltaX === totalDeltaX &&\n        newTotalDeltaY === totalDeltaY &&\n        newTotalDeltaZ === totalDeltaZ\n      ) {\n        return;\n      }\n\n      totalDeltaX = newTotalDeltaX;\n      totalDeltaY = newTotalDeltaY;\n      totalDeltaZ = newTotalDeltaZ;\n\n      const direction = fragment.direction;\n      const intent = fragment.intent;\n      const time =\n        eventQueueCopy[MH.lengthOf(eventQueueCopy) - 1]?.timeStamp -\n          eventQueueCopy[0]?.timeStamp || 0;\n\n      const data = {\n        device,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n        time,\n        totalDeltaX,\n        totalDeltaY,\n        totalDeltaZ,\n      };\n\n      if (\n        direction !== MC.S_NONE &&\n        (!directions || MH.includes(directions, direction)) &&\n        (!intents || MH.includes(intents, intent))\n      ) {\n        callback.invoke(target, data, eventQueueCopy).catch(logError);\n      } else {\n        debug: logger?.debug7(\n          `[${id}] Directions or intents not matching for callback`,\n        );\n      }\n    },\n  );\n\n  // This wrapper is NOT debounced and adds the events to the queue, prevents\n  // default action if needed, and indicates whether the gesture is terminated.\n  const wrapper = (\n    target: EventTarget,\n    device: GestureDevice,\n    event: Event,\n    preventDefault: boolean,\n  ) => {\n    eventQueue.push(event);\n\n    const fragment = fragmentGetters[device](eventQueue, {\n      angleDiffThreshold,\n      deltaThreshold,\n      reverseScroll,\n      dragHoldTime,\n      dragNumFingers,\n    });\n\n    debug: logger?.debug8(\n      `[${id}] Got fragment for ${device} (${event.type})`,\n      fragment,\n      [...eventQueue].map((e) => e.type),\n    );\n\n    if (preventDefault) {\n      preventDefaultActionFor(\n        event,\n        !!fragment || (event.type === MC.S_CLICK && preventNextClick),\n      );\n    }\n\n    if (fragment === false) {\n      // not enough events in the queue, pass\n      debug: logger?.debug9(`[${id}] Not enough events for gesture ${device}`);\n      return false;\n    } else if (fragment === null) {\n      // consider the gesture terminated\n      clearEventQueue(device, eventQueue);\n      debug: logger?.debug9(`[${id}] Gesture for ${device} terminated`);\n      return true;\n    }\n\n    if (device === MC.S_POINTER) {\n      // If we're here, there's been a drag, expect a click immediately\n      // afterwards and prevent default action.\n      preventNextClick = true;\n      MH.setTimer(() => {\n        preventNextClick = false;\n      }, 10);\n    }\n\n    debouncedWrapper(\n      target,\n      fragment,\n      [...eventQueue], // copy\n    );\n\n    return false;\n  };\n\n  return { _callback: callback, _wrapper: wrapper };\n};\n\nconst clearEventQueue = (device: GestureDevice, queue: Event[]) => {\n  const keepLastEvent = device === MC.S_POINTER || device === MC.S_TOUCH;\n  queue.splice(0, MH.lengthOf(queue) - (keepLastEvent ? 1 : 0));\n};\n\nconst preventDefaultActionFor = (event: Event, isActualGesture: boolean) => {\n  const target = event.currentTarget;\n  const eventType = event.type;\n  const isPointerDown =\n    eventType === MC.S_POINTERDOWN || eventType === MC.S_MOUSEDOWN;\n\n  if (\n    eventType === MC.S_TOUCHMOVE ||\n    eventType === MC.S_WHEEL ||\n    ((eventType === MC.S_CLICK || eventType === MC.S_KEYDOWN) &&\n      isActualGesture) ||\n    (isPointerDown && (event as MouseEvent).buttons === 1)\n  ) {\n    MH.preventDefault(event);\n\n    if (isPointerDown && MH.isHTMLElement(target)) {\n      // Otherwise capturing key events won't work\n      target.focus({ preventScroll: true });\n    }\n  }\n};\n\nconst setGestureCssProps = (\n  target: EventTarget,\n  data: Partial<GestureData>,\n) => {\n  const intent = data.intent;\n\n  if (!MH.isElement(target) || !intent || intent === MC.S_UNKNOWN) {\n    return;\n  }\n\n  const prefix = `${intent}-`;\n\n  if (intent === MC.S_ZOOM) {\n    setNumericStyleJsVars(\n      target,\n      {\n        deltaZ: data.totalDeltaZ,\n      },\n      {\n        _prefix: prefix,\n        _numDecimal: 2,\n      },\n    ); // don't await here\n  } else {\n    setNumericStyleJsVars(\n      target,\n      {\n        deltaX: data.totalDeltaX,\n        deltaY: data.totalDeltaY,\n      },\n      {\n        _prefix: prefix,\n      },\n    ); // don't await here\n  }\n};\n"],"mappings":"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","ignoreList":[]}