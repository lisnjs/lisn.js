{"version":3,"file":"view-watcher.js","names":["MC","MH","setNumericStyleJsVars","waitForInteractive","waitForMeasureTime","waitForSubsequentMeasureTime","logError","omitKeys","compareValuesIn","createOverlay","getClosestScrollable","fetchViewportSize","toMargins","objToStrKey","VIEWS_SPACE","getViewsBitmask","parseScrollOffset","wrapCallback","newXMap","newXWeakMap","XIntersectionObserver","DOMWatcher","ScrollWatcher","SizeWatcher","debug","ViewWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","_instances$get","myConfig","configStrKey","_root","instance","instances","get","sGet","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","allViewData","newWeakMap","allCallbacks","newMap","intersectionHandler","entries","debug9","length","entry","processEntry","observeOptions","root","threshold","_threshold","rootMargin","_rootMargin","xObserver","fetchCurrentView","element","realtime","fetchData","entryOrElement","intersection","fetchIntersectionData","data","fetchViewData","newPromise","resolve","observer","newIntersectionObserver","promise","disconnect","then","observe","createCallback","handler","options","trackType","_allCallbacks$get","_element","remove","_callback","debug5","callback","onRemove","deleteHandler","_trackType","_options","setupOnView","target","userOptions","fetchOptions","viewData","rootBounds","S_WIDTH","S_HEIGHT","TRACK_FULL","setupInviewTrack","isRemoved","observeLater","skipInitial","viewsToBitmask","views","_viewsBitmask","invokeCallback","removeOnView","_allCallbacks$get2","currEntry","setViewCssProps","deleteKey","prune","has","debug4","unobserve","targetOf","latestData","viewsBitmask","_allCallbacks$get3","values","viewCallback","debug8","sizeWatcher","scrollWatcher","_debounceWindow","domWatcher","subtree","isInview","removeTrackCallback","scrollableAncestors","fetchScrollableAncestors","addTrackCallback","_config$_root","trackCallback","prevData","changed","viewChanged","onMutation","categories","S_ATTRIBUTE","S_SKIP_INITIAL","onResize","S_DEBOUNCE_WINDOW","_resizeThreshold","getWindow","ancestor","onScroll","scrollable","_scrollThreshold","enterOrLeaveCallback","target__ignored","S_AT","assign","bitmask","TRACK_REGULAR","fetchElement","trackView","noTrackView","onView","offView","SYMBOL","_config$rootMargin","debounceWindow","resizeThreshold","scrollThreshold","active","push","copyBoundingRectProps","targetBounds","relative","bit","entryOrTarget","vpSize","rootMargins","isIntersecting","isCrossOrigin","isInstanceOf","IntersectionObserverEntry","boundingClientRect","fetchBounds","_target","_targetBounds","_rootMargins","_rootBounds","_isIntersecting","_isCrossOrigin","rect","getBoundingClientRect","width","height","x","left","right","y","top","bottom","S_LEFT","S_RIGHT","S_TOP","S_BOTTOM","_intersection$_isInte","vpHeight","vpWidth","fetchViews","merge","hMiddle","NaN","vMiddle","useScrollingAncestor","delta","_left","_right","_top","_bottom","xView","yView","S_BELOW","S_ABOVE","scrollingAncestor","props","_prefix","_numDecimal","isElement","isString","usageError","overlayOptions","getOverlayOptions","reference","value","ovrDimension","parent","isHTMLElement","undefined","style","invoke","copyObject","catch"],"sources":["../../../src/ts/watchers/view-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/ViewWatcher\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport {\n  ViewTarget,\n  View,\n  BoundingRect,\n  CommaSeparatedStr,\n} from \"@lisn/globals/types\";\n\nimport { setNumericStyleJsVars } from \"@lisn/utils/css-alter\";\nimport { waitForInteractive } from \"@lisn/utils/dom-events\";\nimport {\n  waitForMeasureTime,\n  waitForSubsequentMeasureTime,\n} from \"@lisn/utils/dom-optimize\";\nimport { logError } from \"@lisn/utils/log\";\nimport { omitKeys, compareValuesIn } from \"@lisn/utils/misc\";\nimport { createOverlay, OverlayOptions } from \"@lisn/utils/overlays\";\nimport { getClosestScrollable } from \"@lisn/utils/scroll\";\nimport { fetchViewportSize } from \"@lisn/utils/size\";\nimport { toMargins, objToStrKey } from \"@lisn/utils/text\";\nimport {\n  VIEWS_SPACE,\n  getViewsBitmask,\n  parseScrollOffset,\n} from \"@lisn/utils/views\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap, newXWeakMap } from \"@lisn/modules/x-map\";\nimport { XIntersectionObserver } from \"@lisn/modules/x-intersection-observer\";\n\nimport { DOMWatcher } from \"@lisn/watchers/dom-watcher\";\nimport { ScrollWatcher } from \"@lisn/watchers/scroll-watcher\";\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link ViewWatcher} monitors the position of a given target relative to the\n * given {@link ViewWatcherConfig.root | root} or the viewport.\n *\n * It's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}.\n *\n * It manages registered callbacks globally and reuses IntersectionObservers\n * for more efficient performance.\n */\nexport class ViewWatcher {\n  /**\n   * Call the given handler whenever the {@link ViewWatcherConfig.root | root}'s\n   * view relative to the target position changes, i.e. when the target enters\n   * or leaves the root.\n   *\n   * Unless {@link OnViewOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the current view if it matches this\n   * set of options*.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackView} or using\n   * {@link onView}, then it will be removed and re-added with the current\n   * options. So if previously it was also tracking position across root\n   * using {@link trackView}, it will no longer do so.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or the options are invalid.\n   */\n  readonly onView: (\n    target: ViewTarget,\n    handler: OnViewHandler,\n    options?: OnViewOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly offView: (target: ViewTarget, handler: OnViewHandler) => void;\n\n  /**\n   * This does more than just {@link onView}. The difference is that in\n   * addition to a change of {@link View}, such as the target entering or\n   * leaving the ViewWatcher's {@link ViewWatcherConfig.root | root} (by\n   * default the viewport), the handler is also called each time the target's\n   * relative view changes _while inside the root_.\n   *\n   * A change of relative position happens when:\n   * - the target is resized\n   * - the root is resized\n   * - the any of the target's scrollable ancestors is scrolled\n   * - the target's attributes changed that resulted in a change of position\n   *\n   * All of the above are accounted for. Internally it uses\n   * {@link ScrollWatcher}, {@link DOMWatcher} and {@link SizeWatcher} to keep\n   * track of all of this.\n   *\n   * If the target is leaves the ViewWatcher's\n   * {@link ViewWatcherConfig.root | root}, the handler will be called with\n   * the {@link ViewData}, and the above events will stop being tracked until\n   * the target enters the watcher's root again.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times for the\n   * same target, even if the options differ. If the handler has already been\n   * added for this target, either using {@link trackView} or using\n   * {@link onView}, then it will be removed and re-added with the current\n   * options.\n   *\n   * ------\n   *\n   * If `handler` is not given, then it defaults to an internal handler that\n   * updates the following set of CSS variables on the target's style and\n   * represent its relative position:\n   *\n   * - `--lisn-js--r-top`\n   * - `--lisn-js--r-bottom`\n   * - `--lisn-js--r-left`\n   * - `--lisn-js--r-right`\n   * - `--lisn-js--r-width`\n   * - `--lisn-js--r-height`\n   * - `--lisn-js--r-h-middle`\n   * - `--lisn-js--r-v-middle`\n   *\n   * See {@link ViewData.relative} for an explanation of each.\n   *\n   * Note that only Element targets are supported here and not offsets.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target or \"views\" are invalid.\n   */\n  readonly trackView: (\n    element: Element,\n    handler?: OnViewHandler | null,\n    options?: TrackViewOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler for {@link trackView}.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the target is invalid.\n   */\n  readonly noTrackView: (\n    element: Element,\n    handler?: OnViewHandler | null,\n  ) => void;\n\n  /**\n   * Get the current view relative to the target. By default, it will\n   * {@link waitForMeasureTime} and so will be delayed by one frame.\n   *\n   * @param {} realtime If true, it will not {@link waitForMeasureTime}. Use\n   *                    this only when doing realtime scroll-based animations\n   *                    as it may cause a forced layout.\n   */\n  readonly fetchCurrentView: (\n    target: ViewTarget,\n    realtime?: boolean,\n  ) => Promise<ViewData>;\n\n  /**\n   * Creates a new instance of ViewWatcher with the given\n   * {@link ViewWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config: ViewWatcherConfig = {}) {\n    return new ViewWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing  instance of ViewWatcher with the given\n   * {@link ViewWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config: ViewWatcherConfig = {}) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    let instance = instances.get(myConfig._root)?.get(configStrKey);\n    if (!instance) {\n      instance = new ViewWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(myConfig._root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: ViewWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"ViewWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"ViewWatcher\", logAtCreation: config })\n      : null;\n\n    const allViewData = MH.newWeakMap<Element, ViewData>();\n\n    const allCallbacks = newXWeakMap<\n      Element,\n      Map<\n        OnViewHandler,\n        {\n          _callback: OnViewCallback;\n          _trackType: TrackType;\n          _options: OnViewOptionsInternal;\n        }\n      >\n    >(() => MH.newMap());\n\n    const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n      debug: logger?.debug9(`Got ${entries.length} new entries`, entries);\n\n      for (const entry of entries) {\n        processEntry(entry);\n      }\n    };\n\n    const observeOptions = {\n      root: config._root,\n      threshold: config._threshold,\n      rootMargin: config._rootMargin,\n    };\n\n    const xObserver = new XIntersectionObserver(\n      intersectionHandler,\n      observeOptions,\n    );\n\n    // ----------\n\n    const fetchCurrentView = (\n      element: Element,\n      realtime = false,\n    ): Promise<ViewData> => {\n      const fetchData = async (\n        entryOrElement: IntersectionObserverEntry | Element,\n      ) => {\n        const intersection = await fetchIntersectionData(\n          config,\n          entryOrElement,\n          realtime,\n        );\n        const data = await fetchViewData(intersection, realtime);\n        return data;\n      };\n\n      if (realtime) {\n        return fetchData(element);\n      }\n\n      return MH.newPromise((resolve) => {\n        // Use a temp IntersectionObserver\n        const observer = MH.newIntersectionObserver((entries) => {\n          const promise = fetchData(entries[0]);\n          observer.disconnect();\n          promise.then(resolve);\n        }, observeOptions);\n\n        observer.observe(element);\n      });\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnViewHandler,\n      options: OnViewOptionsInternal,\n      trackType: TrackType,\n    ): OnViewCallback => {\n      const element = options._element;\n      MH.remove(allCallbacks.get(element)?.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", options);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        deleteHandler(handler, options);\n      });\n\n      allCallbacks.sGet(element).set(handler, {\n        _callback: callback,\n        _trackType: trackType,\n        _options: options,\n      });\n\n      return callback;\n    };\n\n    // ----------\n\n    const setupOnView = async (\n      target: ViewTarget,\n      handler: OnViewHandler,\n      userOptions: (OnViewOptions & TrackViewOptions) | undefined,\n      trackType: TrackType,\n    ) => {\n      const options = await fetchOptions(config._root, target, userOptions);\n      const element = options._element;\n\n      const callback = createCallback(handler, options, trackType);\n\n      // View watcher should be used before the DOM is loaded since the initial\n      // size of the root may be 0 or close to 0 and would lead to premature\n      // triggering.\n      await waitForInteractive();\n\n      // Initial call doesn't need to be realtime, and best to use an actual\n      // IntersectionObserverEntry for that one.\n      let viewData = await fetchCurrentView(element);\n\n      if (\n        viewData.rootBounds[MC.S_WIDTH] === 0 &&\n        viewData.rootBounds[MC.S_HEIGHT] === 0\n      ) {\n        // Possibly the root is being setup now, wait for one AF\n        debug: logger?.debug5(\n          \"Got zero root size, deferring for a bit\",\n          config._root,\n        );\n        await waitForSubsequentMeasureTime();\n        viewData = await fetchCurrentView(element);\n      }\n\n      if (trackType === TRACK_FULL) {\n        // Detect resize or scroll\n        await setupInviewTrack(options, callback, viewData);\n      }\n\n      if (callback.isRemoved()) {\n        return;\n      }\n\n      // Always use observeLater to skip the initial call from the\n      // IntersectionObserver, and call callbacks that have skipInitial: false\n      // here. Otherwise, we can't tell from inside the intersectionHandler whether\n      // a callback wants to skip its initial call or not.\n      //\n      // It's ok if already observed, won't do anything.\n      xObserver.observeLater(element);\n\n      if (!userOptions?.skipInitial) {\n        debug: logger?.debug5(\"Calling initially with\", element, viewData);\n        if (viewsToBitmask(viewData.views) & options._viewsBitmask) {\n          await invokeCallback(callback, element, viewData);\n        }\n      }\n    };\n\n    // ----------\n\n    const removeOnView = async (\n      target: ViewTarget,\n      handler: OnViewHandler,\n      trackType: TrackType,\n    ) => {\n      // For time sync, so that if called immediately after onView without\n      // awaiting, it will remove the callback that is about to be added.\n      // But if no such handler has been added we may unnecessarily\n      // create an overlay... TODO\n      const options = await fetchOptions(config._root, target, {});\n      const element = options._element;\n\n      const currEntry = allCallbacks.get(element)?.get(handler);\n      if (currEntry?._trackType === trackType) {\n        MH.remove(currEntry._callback);\n\n        if (handler === setViewCssProps) {\n          // delete the properties\n          setViewCssProps(element, null);\n        }\n      }\n    };\n\n    // ----------\n\n    const deleteHandler = (\n      handler: OnViewHandler,\n      options: OnViewOptionsInternal,\n    ) => {\n      const element = options._element;\n\n      MH.deleteKey(allCallbacks.get(element), handler);\n      allCallbacks.prune(element);\n\n      if (!allCallbacks.has(element)) {\n        debug: logger?.debug4(\n          \"No more callbacks for target; unobserving\",\n          element,\n        );\n\n        xObserver.unobserve(element);\n        MH.deleteKey(allViewData, element);\n      }\n    };\n\n    // ----------\n\n    const processEntry = async (entry: IntersectionObserverEntry) => {\n      // In reality, it can't be just a base Element\n      const element = MH.targetOf(entry);\n\n      // This doesn't need to be \"realtime\", since IntersectionObserver alone\n      // introduces a delay.\n      const intersection = await fetchIntersectionData(config, entry);\n      const latestData = await fetchViewData(intersection);\n      debug: logger?.debug9(\"Got ViewData\", element, latestData);\n\n      const viewsBitmask = viewsToBitmask(latestData.views);\n\n      for (const entry of allCallbacks.get(element)?.values() || []) {\n        if (viewsBitmask & entry._options._viewsBitmask) {\n          invokeCallback(entry._callback, element, latestData);\n        }\n      }\n    };\n\n    // ----------\n\n    const setupInviewTrack = async (\n      options: OnViewOptionsInternal,\n      viewCallback: OnViewCallback,\n      viewData: ViewData,\n    ) => {\n      const element = options._element;\n      debug: logger?.debug8(\n        \"Setting up size, scroll and attribute tracking\",\n        element,\n      );\n\n      const sizeWatcher = SizeWatcher.reuse();\n      const scrollWatcher = ScrollWatcher.reuse();\n      const realtime = options._debounceWindow === 0;\n\n      // Detect when target's class or style attribute change\n      const domWatcher = DOMWatcher.create({\n        root: element,\n        // only direct children\n        subtree: false,\n      });\n\n      // We need to remove the tracking callback when target leaves view and re-add\n      // it when it enters view. But the OnViewCallback that is associated may have\n      // already been added prior, by calling onView with this handler, so we can't\n      // always wrap around it, in order to detect when it's called with a change\n      // of view. So we setup another OnViewCallback tied to the tracking callback.\n      let isInview = false;\n\n      let removeTrackCallback: (() => void) | null = null;\n\n      // Finds any scrollable ancestors of the element and detect scroll on them.\n      const scrollableAncestors = await fetchScrollableAncestors(\n        element,\n        realtime,\n      );\n      if (viewCallback.isRemoved()) {\n        return;\n      }\n\n      const addTrackCallback = () => {\n        const trackCallback = wrapCallback(async () => {\n          const prevData = allViewData.get(element);\n\n          // Get the latest view data for the target\n          const latestData = await fetchCurrentView(element, realtime);\n          debug: logger?.debug9(\"Got ViewData\", element, latestData);\n\n          const changed = viewChanged(latestData, prevData);\n          if (changed) {\n            // When comparing for changes, we round the numbers to certain number\n            // of decimal places, and allViewData serves as a \"last threshold\"\n            // state, so only update it if there was a significant change.\n            // Otherwise very quick changes in small increments would get\n            // rejected as \"no change\".\n            allViewData.set(element, latestData);\n\n            if (isInview && !viewCallback.isRemoved()) {\n              // Could have been removed during the debounce window\n              await invokeCallback(viewCallback, element, latestData);\n            }\n          } else {\n            debug: logger?.debug9(\"ViewData same as last\");\n          }\n        });\n\n        // TODO Is there a better way to detect when it's moved?\n        viewCallback.onRemove(trackCallback.remove);\n        removeTrackCallback = trackCallback.remove;\n\n        // Detect when target's class or style attribute change\n        domWatcher.onMutation(trackCallback, {\n          categories: [MC.S_ATTRIBUTE],\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when target is resized\n        sizeWatcher.onResize(trackCallback, {\n          target: element,\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          threshold: options._resizeThreshold,\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when the root is resized\n        sizeWatcher.onResize(trackCallback, {\n          target: config._root ?? MH.getWindow(),\n          [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n          threshold: options._resizeThreshold,\n          [MC.S_SKIP_INITIAL]: true,\n        });\n\n        // Detect when the target's scrollable ancestors are scrolled (this\n        // will almost certainly include the main scrollable element).\n        for (const ancestor of scrollableAncestors) {\n          scrollWatcher.onScroll(trackCallback, {\n            scrollable: ancestor,\n            [MC.S_DEBOUNCE_WINDOW]: options._debounceWindow,\n            threshold: options._scrollThreshold,\n            [MC.S_SKIP_INITIAL]: true,\n          });\n        }\n      };\n\n      const enterOrLeaveCallback = createCallback(\n        (target__ignored, viewData) => {\n          if (viewData.views[0] === MC.S_AT) {\n            if (!isInview) {\n              isInview = true;\n              addTrackCallback();\n            }\n          } else if (removeTrackCallback) {\n            isInview = false;\n            removeTrackCallback();\n            removeTrackCallback = null;\n          }\n        },\n        MH.assign(options, {\n          _viewsBitmask: VIEWS_SPACE.bitmask,\n        }),\n        TRACK_REGULAR,\n      );\n\n      viewCallback.onRemove(enterOrLeaveCallback.remove);\n\n      allViewData.set(element, viewData); // to avoid duplicate initial call\n      // Setup the track and the \"inView\" state\n      if (!enterOrLeaveCallback.isRemoved()) {\n        invokeCallback(enterOrLeaveCallback, element, viewData);\n      }\n    };\n\n    // ----------\n\n    this.fetchCurrentView = (target, realtime = false) =>\n      fetchElement(config._root, target).then((element) =>\n        fetchCurrentView(element, realtime),\n      );\n\n    // ----------\n\n    this.trackView = (element, handler?, options?) => {\n      if (!handler) {\n        handler = setViewCssProps;\n      }\n\n      return setupOnView(element, handler, options, TRACK_FULL);\n    };\n\n    // ----------\n\n    this.noTrackView = (element, handler?) => {\n      if (!handler) {\n        handler = setViewCssProps;\n      }\n\n      removeOnView(element, handler, TRACK_FULL); // no need to await\n    };\n\n    // ----------\n\n    this.onView = (target, handler, options?) =>\n      setupOnView(target, handler, options, TRACK_REGULAR);\n\n    // ----------\n\n    this.offView = (target, handler) =>\n      removeOnView(target, handler, TRACK_REGULAR); // no need to await\n  }\n}\n\n/**\n * @interface\n */\nexport type ViewWatcherConfig = {\n  /**\n   * The root element to use for the IntersectionObserver.\n   *\n   * **NOTE:** If the target you want to observe (via\n   * {@link ViewWatcher.onView}) is inside a scrolling element, then you should\n   * probably set the watcher's root to be that scrolling element or a wrapper\n   * around it. However, even if you don't or can't do that, the watcher will\n   * try to be smart about that, and when the target is no longer intercepting\n   * because it's scrolled outside its scrolling container, and yet its\n   * bounding box is still inside the watcher root (e.g. the viewport) the\n   * watcher will determine the relative view based on the scrolling container\n   * and not the actual watcher root.\n   *\n   * @defaultValue null\n   */\n  root?: Element | null;\n\n  /**\n   * The rootMargin to pass to the IntersectionObserver constructor options.\n   *\n   * @defaultValue \"0px 0px 0px 0px\"\n   */\n  rootMargin?: string;\n\n  /**\n   * The threshold to pass to the IntersectionObserver constructor options.\n   *\n   * @defaultValue 0\n   */\n  threshold?: number | number[];\n};\n\n/**\n * @interface\n */\nexport type OnViewOptions = {\n  /**\n   * Specifies a list of {@link View}s to target for.\n   *\n   * The handler will only be called if there is a change of view relative to\n   * the target that matches the given ones.\n   *\n   * It can be a comma-separated list of \"views\" or an array of such names.\n   *\n   * @defaultValue undefined\n   */\n  views?: CommaSeparatedStr<View> | View[];\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * @interface\n */\nexport type TrackViewOptions = {\n  /**\n   * Use this debounce window for the {@link ScrollWatcher} and\n   * {@link SizeWatcher} involved in the view tracking.\n   *\n   * **IMPORTANT:**\n   * If the debounce window is non-0 (default), then the callback is always\n   * delayed by at least an animation frame following a scroll event to allow\n   * for optimized `scrollTop`/`scrollLeft` measurements via\n   * {@link waitForMeasureTime}.\n   *\n   * If you set this is 0, this indicates that the callback should be\n   * \"realtime\" and will therefore skip {@link waitForMeasureTime}, which could\n   * lead to forced re-layouts during scroll, but you probably need this when\n   * doing scroll-based animations.\n   *\n   * @defaultValue undefined // ScrollWatcher and SizeWatcher defaults\n   */\n  debounceWindow?: number;\n\n  /**\n   * Use this resize threshold for the {@link SizeWatcher} involved in the view\n   * tracking.\n   *\n   * @defaultValue undefined // SizeWatcher default\n   */\n  resizeThreshold?: number;\n\n  /**\n   * Use this scroll threshold for the {@link ScrollWatcher} involved in the\n   * view tracking.\n   *\n   * @defaultValue undefined // ScrollWatcher default\n   */\n  scrollThreshold?: number;\n\n  /**\n   * Do not call the handler until there's a future resize of the element.\n   *\n   * By default we call the handler (almost) immediately with the current size\n   * data for the target.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * The handler is invoked with two arguments:\n *\n * - The element that is the target of the IntersectionObserver. If the call to\n *   {@link ViewWatcher.onView} specified an element as the target, it will be\n *   the same. If it specified an offset, then the element passed to the\n *   callback will be an absolutely positioned trigger overlay that's created\n *   as a result.\n * - the {@link ViewData} for relative to the target\n */\nexport type OnViewHandlerArgs = [Element, ViewData];\nexport type OnViewCallback = Callback<OnViewHandlerArgs>;\nexport type OnViewHandler = CallbackHandler<OnViewHandlerArgs> | OnViewCallback;\n\nexport type ViewData = {\n  isIntersecting: boolean;\n\n  targetBounds: BoundingRect;\n\n  rootBounds: BoundingRect;\n\n  /**\n   * The current view or views of the target. There would be two views given\n   * only if the target is _not_ in view and it's diagonally across from the\n   * root, e.g. both below and to the right.\n   */\n  views: [View, View?];\n\n  /**\n   * This is the target's position relative to the\n   * {@link ViewWatcherConfig.root | root} with values relative to the root\n   * size.\n   *\n   * It is like the {@link targetBounds} except that each quantity is scaled by\n   * the root's width or height, and having two additional computed values.\n   */\n  relative: {\n    x: number;\n    y: number;\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n    width: number;\n    height: number;\n\n    /**\n     * Average of the relative left and right.\n     */\n    hMiddle: number;\n\n    /**\n     * Average of the relative top and bottom.\n     */\n    vMiddle: number;\n  };\n};\n\n// ----------------------------------------\n\ntype ViewWatcherConfigInternal = {\n  _root: Element | null;\n  _rootMargin: string;\n  _threshold: number | number[];\n};\n\ntype OnViewOptionsInternal = {\n  _element: Element;\n  _viewsBitmask: number;\n  _debounceWindow: number | undefined;\n  _resizeThreshold: number | undefined;\n  _scrollThreshold: number | undefined;\n};\n\ntype IntersectionData = {\n  _target: Element;\n  _targetBounds: BoundingRect;\n  _root: Element | null;\n  _rootMargins: [number, number, number, number];\n  _rootBounds: BoundingRect;\n  _isIntersecting: boolean | null; // null means unknown, no IntersectionObserverEntry\n  _isCrossOrigin: boolean | null; // null means unknown, no IntersectionObserverEntry\n};\n\ntype TrackType = typeof TRACK_REGULAR | typeof TRACK_FULL;\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<Element | null, Map<string, ViewWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst getConfig = (\n  config: ViewWatcherConfig | undefined,\n): ViewWatcherConfigInternal => {\n  return {\n    _root: config?.root || null,\n    _rootMargin: config?.rootMargin ?? \"0px 0px 0px 0px\",\n    _threshold: config?.threshold || 0,\n  };\n};\n\nconst TRACK_REGULAR = 1; // only entering/leaving root\nconst TRACK_FULL = 2; // entering/leaving + moving across (fine-grained)\n\n// --------------------\n\nconst fetchOptions = async (\n  root: Element | null,\n  target: ViewTarget,\n  options: (OnViewOptions & TrackViewOptions) | undefined,\n): Promise<OnViewOptionsInternal> => {\n  return {\n    _element: await fetchElement(root, target),\n    _viewsBitmask: getViewsBitmask(options?.views),\n    _debounceWindow: options?.debounceWindow,\n    _resizeThreshold: options?.resizeThreshold,\n    _scrollThreshold: options?.scrollThreshold,\n  };\n};\n\nconst fetchScrollableAncestors = async (\n  element: Element,\n  realtime: boolean,\n) => {\n  if (!realtime) {\n    await waitForMeasureTime();\n  }\n\n  const scrollableAncestors = [];\n  let ancestor: Element | null | undefined = element;\n  while ((ancestor = getClosestScrollable(ancestor, { active: true }))) {\n    scrollableAncestors.push(ancestor);\n  }\n\n  return scrollableAncestors;\n};\n\nconst viewChanged = (latestData: ViewData, prevData: ViewData | undefined) =>\n  !prevData ||\n  viewsToBitmask(prevData.views) !== viewsToBitmask(latestData.views) ||\n  !compareValuesIn(\n    MH.copyBoundingRectProps(prevData.targetBounds),\n    MH.copyBoundingRectProps(latestData.targetBounds),\n  ) ||\n  !compareValuesIn(prevData.rootBounds, latestData.rootBounds) ||\n  !compareValuesIn(prevData.relative, latestData.relative);\n\nconst viewsToBitmask = (views: [View, View?]) =>\n  VIEWS_SPACE.bit[views[0]] | (views[1] ? VIEWS_SPACE.bit[views[1]] : 0);\n\nconst fetchIntersectionData = async (\n  config: ViewWatcherConfigInternal,\n  entryOrTarget: IntersectionObserverEntry | Element,\n  realtime = false,\n): Promise<IntersectionData> => {\n  const root = config._root;\n  const vpSize = await fetchViewportSize(realtime);\n  const rootMargins = toMargins(config._rootMargin, vpSize);\n\n  let target: Element;\n  let targetBounds: BoundingRect;\n  let rootBounds: BoundingRect | null = null;\n  let isIntersecting: boolean | null = null;\n  let isCrossOrigin: boolean | null = null;\n\n  if (MH.isInstanceOf(entryOrTarget, IntersectionObserverEntry)) {\n    target = entryOrTarget.target;\n    targetBounds = entryOrTarget.boundingClientRect;\n    rootBounds = entryOrTarget.rootBounds;\n    isIntersecting = entryOrTarget.isIntersecting;\n    isCrossOrigin = !entryOrTarget.rootBounds;\n  } else {\n    target = entryOrTarget;\n    targetBounds = await fetchBounds(target, realtime);\n  }\n\n  if (!rootBounds) {\n    rootBounds = await fetchBounds(root, realtime, rootMargins);\n  }\n\n  return {\n    _target: target,\n    _targetBounds: targetBounds,\n    _root: root,\n    _rootMargins: rootMargins,\n    _rootBounds: rootBounds,\n    _isIntersecting: isIntersecting,\n    _isCrossOrigin: isCrossOrigin,\n  };\n};\n\nconst fetchBounds = async (\n  root: Element | null,\n  realtime: boolean,\n  rootMargins?: [number, number, number, number],\n): Promise<BoundingRect> => {\n  let rect: BoundingRect;\n\n  if (root) {\n    if (!realtime) {\n      await waitForMeasureTime();\n    }\n\n    rect = MH.copyBoundingRectProps(MH.getBoundingClientRect(root));\n  } else {\n    const { width, height } = await fetchViewportSize(realtime);\n    rect = {\n      x: 0,\n      left: 0,\n      right: width,\n      width,\n      y: 0,\n      top: 0,\n      bottom: height,\n      height,\n    };\n  }\n\n  if (rootMargins) {\n    rect.x = rect[MC.S_LEFT] -= rootMargins[3];\n    rect[MC.S_RIGHT] += rootMargins[1];\n    rect[MC.S_WIDTH] += rootMargins[1] + rootMargins[3];\n\n    rect.y = rect[MC.S_TOP] -= rootMargins[0];\n    rect[MC.S_BOTTOM] += rootMargins[2];\n    rect[MC.S_HEIGHT] += rootMargins[0] + rootMargins[2];\n  }\n\n  return rect;\n};\n\nconst fetchViewData = async (\n  intersection: IntersectionData,\n  realtime = false,\n): Promise<ViewData> => {\n  const vpSize = await fetchViewportSize(realtime);\n  const vpHeight = vpSize[MC.S_HEIGHT];\n  const vpWidth = vpSize[MC.S_WIDTH];\n\n  const views = await fetchViews(intersection, realtime);\n\n  const relative = MH.merge(\n    { hMiddle: NaN, vMiddle: NaN },\n    MH.copyBoundingRectProps(intersection._targetBounds),\n  );\n\n  relative.y /= vpHeight;\n  relative[MC.S_TOP] /= vpHeight;\n  relative[MC.S_BOTTOM] /= vpHeight;\n  relative[MC.S_HEIGHT] /= vpHeight;\n\n  relative.x /= vpWidth;\n  relative[MC.S_LEFT] /= vpWidth;\n  relative[MC.S_RIGHT] /= vpWidth;\n  relative[MC.S_WIDTH] /= vpWidth;\n\n  relative.hMiddle = (relative[MC.S_LEFT] + relative[MC.S_RIGHT]) / 2;\n  relative.vMiddle = (relative[MC.S_TOP] + relative[MC.S_BOTTOM]) / 2;\n\n  const viewData: ViewData = {\n    isIntersecting: intersection._isIntersecting ?? views[0] === MC.S_AT,\n    targetBounds: intersection._targetBounds,\n    rootBounds: intersection._rootBounds,\n    views,\n    relative,\n  };\n\n  return viewData;\n};\n\nconst fetchViews = async (\n  intersection: IntersectionData,\n  realtime: boolean,\n  useScrollingAncestor?: Element,\n): Promise<[View, View?]> => {\n  if (intersection._isIntersecting) {\n    return [MC.S_AT];\n  }\n\n  let rootBounds: BoundingRect;\n  if (useScrollingAncestor) {\n    rootBounds = await fetchBounds(\n      useScrollingAncestor,\n      realtime,\n      intersection._rootMargins,\n    );\n  } else {\n    rootBounds = intersection._rootBounds;\n  }\n\n  const targetBounds = intersection._targetBounds;\n  const delta = {\n    _left: rootBounds[MC.S_LEFT] - targetBounds[MC.S_LEFT],\n    _right: targetBounds[MC.S_RIGHT] - rootBounds[MC.S_RIGHT],\n    _top: rootBounds[MC.S_TOP] - targetBounds[MC.S_TOP],\n    _bottom: targetBounds[MC.S_BOTTOM] - rootBounds[MC.S_BOTTOM],\n  };\n\n  let xView: View | null = null;\n  let yView: View | null = null;\n  if (delta._left > 0 && delta._right > 0) {\n    // Target is wider than root: use greater delta to determine position.\n    // Remember, the view is the _root_ position relative to target.\n    xView = delta._left > delta._right ? MC.S_RIGHT : MC.S_LEFT;\n  } else if (delta._left > 0) {\n    // Target is to the left of the root\n    xView = MC.S_RIGHT;\n  } else if (delta._right > 0) {\n    // Target is to the right of the root\n    xView = MC.S_LEFT;\n  } // else target is horizontally contained in root, see below\n\n  if (delta._top > 0 && delta._bottom > 0) {\n    // Target is taller than root: use greater delta to determine position.\n    // Remember, the view is the _root_ position relative to target.\n    yView = delta._top > delta._bottom ? MC.S_BELOW : MC.S_ABOVE;\n  } else if (delta._top > 0) {\n    // Target is above the root\n    yView = MC.S_BELOW;\n  } else if (delta._bottom > 0) {\n    // Target is below the root\n    yView = MC.S_ABOVE;\n  } // else target is vertically contained in root, see below\n\n  if (xView && yView) {\n    // diagonally out of vide\n    return [xView, yView];\n  } else if (xView) {\n    // horizontally out of vide\n    return [xView];\n  } else if (yView) {\n    // vertically out of vide\n    return [yView];\n  }\n\n  // The target is contained in the root bounds and yet isIntersecting was\n  // not true. This means that either:\n  //\n  // 1. It may be intersecting, but we didn't get an actual\n  //    IntersectionObserverEntry and we don't know if it's intersecting\n  //    or not\n  // 2. The target is inside a scrolling element that is _not_ being used as\n  //    the observer root, and the target has scrolled out of the scrollable\n  //    bounds but still inside the viewport\n  // 3. We're inside a cross-origin iFrame and the iFrame is partially or\n  //    fully not-intersecting\n\n  if (!intersection._isCrossOrigin) {\n    // This is case 1. or 2. => get the views relative to the closest\n    // scrollable ancestor relative to which it is _not_ intersecting, if\n    // any. If it's nested inside several scrolling elements, we'll end up\n    // looping over each one until we find the one for which the target is\n    // outside its box.\n    //\n    // It is too risky to use active isScrollable check here since we could be\n    // inside an onScroll handler, so just use passive.\n    const scrollingAncestor = getClosestScrollable(\n      useScrollingAncestor ?? intersection._target,\n    );\n\n    if (scrollingAncestor) {\n      return fetchViews(intersection, realtime, scrollingAncestor);\n    }\n  }\n\n  // Either case 3. (cross-origin iframe outside the viewport) or case 1. and\n  // the target is actually intersecting the root. Either way, it's to be\n  // considered in-view of its root.\n  return [MC.S_AT];\n};\n\nconst setViewCssProps = (\n  element: Element,\n  viewData: ViewData | undefined | null,\n) => {\n  const relative: Record<string, number> = viewData?.relative || {};\n  const props = {\n    top: relative.top,\n    bottom: relative.bottom,\n    left: relative.left,\n    right: relative.right,\n    [MC.S_WIDTH]: relative[MC.S_WIDTH],\n    [MC.S_HEIGHT]: relative[MC.S_HEIGHT],\n    hMiddle: relative.hMiddle,\n    vMiddle: relative.vMiddle,\n  };\n  setNumericStyleJsVars(element, props, { _prefix: \"r-\", _numDecimal: 4 }); // don't await here\n};\n\nconst fetchElement = async (\n  root: Element | null,\n  target: ViewTarget,\n): Promise<Element> => {\n  if (MH.isElement(target)) {\n    return target;\n  } else if (!MH.isString(target)) {\n    throw MH.usageError(\n      \"'target' must be an offset string or an HTMLElement | SVGElement | MathMLElement\",\n    );\n  }\n\n  const overlayOptions = getOverlayOptions(root, target);\n  return await createOverlay(overlayOptions);\n};\n\nconst getOverlayOptions = (\n  root: Element | null,\n  target: string,\n): OverlayOptions => {\n  const { reference, value } = parseScrollOffset(target);\n\n  let ovrDimension: \"width\" | \"height\";\n  if (reference === MC.S_TOP || reference === MC.S_BOTTOM) {\n    ovrDimension = MC.S_WIDTH;\n  } else if (reference === MC.S_LEFT || reference === MC.S_RIGHT) {\n    ovrDimension = MC.S_HEIGHT;\n  } else {\n    throw MH.usageError(`Invalid offset reference: '${reference}'`);\n  }\n\n  return {\n    parent: MH.isHTMLElement(root) ? root : undefined,\n    style: {\n      [reference]: value,\n      [ovrDimension]: \"100%\",\n    },\n  };\n};\n\nconst invokeCallback = (\n  callback: OnViewCallback,\n  element: Element,\n  viewData: ViewData,\n) => callback.invoke(element, MH.copyObject(viewData)).catch(logError);\n"],"mappings":"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","ignoreList":[]}