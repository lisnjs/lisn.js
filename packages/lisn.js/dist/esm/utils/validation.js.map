{"version":3,"file":"validation.js","names":["MH","LisnUsageError","toNum","toBool","splitOn","isValidStrList","value","checkFn","allowEmpty","arguments","length","undefined","res","validateStrList","isNullish","err","isInstanceOf","key","_toArray","filterBlank","toArray","map","v","_validateString","validateNumList","_toArray2","_validateNumber","validateNumber","validateBoolean","_validateBoolean","validateString","validateStringRequired","result","isEmpty","usageError","concat","validateBooleanOrString","stringCheckFn","_validateBooleanOrString","isArray","isIterableObject","arrayFrom","isLiteralString","trim","typeDescription","numVal","boolVal"],"sources":["../../../src/ts/utils/validation.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { CommaSeparatedStr } from \"@lisn/globals/types\";\n\nimport { toNum } from \"@lisn/utils/math\";\nimport { toBool } from \"@lisn/utils/misc\";\nimport { splitOn } from \"@lisn/utils/text\";\n\n/**\n * Returns true if the input is a string array or comma-separated string, whose\n * elements are valid according to the `validator` function.\n *\n * @param {} allowEmpty If `false`, then input without any entries is\n * considered _invalid_.\n *\n * @category Validation\n */\nexport const isValidStrList = <T extends string = string>(\n  value: unknown,\n  checkFn: (value: string) => value is T,\n  allowEmpty = true,\n): value is CommaSeparatedStr<T> | T[] => {\n  try {\n    const res = validateStrList(\"\", value, checkFn);\n    return allowEmpty || !MH.isNullish(res);\n  } catch (err) {\n    if (MH.isInstanceOf(err, LisnUsageError)) {\n      return false;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns an array of strings from the given list while validating each one\n * using the `checkFn` function.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a string or array of strings, or if any\n *                entries do not pass `checkFn`.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateStrList = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateString(key, v, checkFn, \"a string or a string array\"),\n    ),\n  );\n\n/**\n * Returns an array of numbers from the given list.\n *\n * If it returns without throwing, the input is necessarily valid.\n * If the result is an empty array, it will return `null`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the input is not a number or array of numbers. Numerical\n *                strings are accepted.\n *\n * @param {} key Used in the error message thrown\n *\n * @return {} `undefined` if the input contains no non-empty values (after\n * trimming whitespace on left/right from each), otherwise a non-empty array of\n * values.\n *\n * @category Validation\n */\nexport const validateNumList = (\n  key: string,\n  value: unknown,\n): number[] | undefined =>\n  MH.filterBlank(\n    toArray(value)?.map((v) =>\n      _validateNumber(key, v, \"a number or a number array\"),\n    ),\n  );\n\n/**\n * Returns a number corresponding to the supplied value, ensuring the supplied\n * value is a valid number or a string containing only a number.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateNumber = (key: string, value: unknown) =>\n  _validateNumber(key, value);\n\n/**\n * Returns a boolean corresponding to the given value as follows:\n *\n * - `null` and `undefined` result in `undefined`\n * - `false` and `\"false\"` result in `false`\n * - `\"\"`, `true` and `\"true\"` result in `true`\n * - other values throw an error error\n *\n * Note that an empty string is treated as `true`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is not a valid boolean or boolean string.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateBoolean = (key: string, value: unknown) =>\n  _validateBoolean(key, value);\n\n/**\n * Returns a valid string from the supplied value, ensuring the supplied value\n * is a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} checkFn      If given and the supplied value is a string, then it\n *                        is called with the value as a single argument. It\n *                        must return true if the value is valid and false\n *                        otherwise.\n *                        If it is not given, then any literal string is\n *                        accepted.\n *\n * @return {} `undefined` if the input is nullish.\n *\n * @category Validation\n */\nexport const validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n) => _validateString(key, value, checkFn);\n\n/**\n * Like {@link validateString} except it requires input to be given and\n * non-empty.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid or empty.\n *\n * @category Validation\n */\nexport const validateStringRequired = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n): T => {\n  const result = _validateString(key, value, checkFn);\n\n  if (MH.isEmpty(result)) {\n    throw MH.usageError(`'${key}' is required`);\n  }\n\n  return result;\n};\n\n/**\n * Returns a valid boolean or a string from the supplied value, ensuring the\n * supplied value is either a boolean or boolean string (see\n * {@link validateBoolean}), or a string that conforms to the given `checkFn`.\n *\n * @throws {@link Errors.LisnUsageError | LisnUsageError}\n *                If the value is invalid.\n *\n * @param {} stringCheckFn If given and the supplied value is a string _other\n *                         than a boolean string_, then it is called with the\n *                         value as a single argument. It must return true if\n *                         the value is valid and false otherwise.\n *                         If it is not given, then any literal string is\n *                         accepted.\n *\n * @category Validation\n */\nexport const validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n) => _validateBooleanOrString(key, value, stringCheckFn);\n\n// --------------------\n\nconst toArray = (value: unknown): unknown[] | undefined => {\n  let result: unknown[] | null;\n  if (MH.isArray(value)) {\n    result = value;\n  } else if (MH.isIterableObject(value)) {\n    result = MH.arrayFrom(value);\n  } else if (MH.isLiteralString(value)) {\n    result = splitOn(value, \",\");\n  } else if (!MH.isNullish(value)) {\n    result = [value];\n  } else {\n    result = null;\n  }\n\n  return result\n    ? MH.filterBlank(result.map((v) => (MH.isLiteralString(v) ? v.trim() : v)))\n    : undefined;\n};\n\nconst _validateNumber = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const numVal = toNum(value, null);\n  if (numVal === null) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a number\"}`);\n  }\n\n  return numVal;\n};\n\nconst _validateBoolean = (\n  key: string,\n  value: unknown,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal === null) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? '\"true\" or \"false\"'}`,\n    );\n  }\n\n  return boolVal;\n};\n\nconst _validateString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  checkFn?: (value: string) => value is T,\n  typeDescription?: string,\n): (typeof checkFn extends null | undefined ? string : T) | undefined => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(`'${key}' must be ${typeDescription ?? \"a string\"}`);\n  } else if (checkFn && !checkFn(value)) {\n    throw MH.usageError(`Invalid value for '${key}'`);\n  }\n\n  return value as typeof checkFn extends null | undefined ? string : T;\n};\n\nconst _validateBooleanOrString = <T extends string = string>(\n  key: string,\n  value: unknown,\n  stringCheckFn?: (value: string) => value is T,\n  typeDescription?: string,\n) => {\n  if (MH.isNullish(value)) {\n    return;\n  }\n\n  const boolVal = toBool(value);\n  if (boolVal !== null) {\n    return boolVal;\n  }\n\n  if (!MH.isLiteralString(value)) {\n    throw MH.usageError(\n      `'${key}' must be ${typeDescription ?? \"a boolean or string\"}`,\n    );\n  }\n\n  return _validateString(key, value, stringCheckFn);\n};\n"],"mappings":"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","ignoreList":[]}