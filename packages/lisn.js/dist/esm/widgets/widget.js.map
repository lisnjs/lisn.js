{"version":3,"file":"widget.js","names":["MC","MH","settings","hasClass","getData","waitForInteractive","logWarn","toArrayIfSingle","waitForDelay","formatAsString","kebabToCamelCase","splitOn","wrapCallback","newXWeakMap","DOMWatcher","debug","Widget","get","element","id","_instances$get","instances","constructor","config","_defineProperty","logger","Logger","name","logAtCreation","_instances$get2","destroy","sGet","set","isDisabled","isDestroyed","destroyPromise","enableCallbacks","newSet","disableCallbacks","destroyCallbacks","disable","debug8","callback","invoke","enable","toggleEnable","onDisable","handler","add","onEnable","clear","elInstances","deleteKey","prune","onDestroy","getElement","registerWidget","newWidget","configValidator","options","_options$selector","registeredWidgets","has","prefixedName","prefixName","selector","getDefaultWidgetSelector","autoWidgets","domWatcher","reuse","onMutation","operation","currentTargetOf","thisConfigValidator","isFunction","widgets","configSpecs","dataAttr","supportsMultiple","push","spec","fetchWidgetConfig","undefined","theseWidgets","lengthOf","w","target","categories","S_REMOVED","S_ADDED","getWidgetConfig","input","validator","separator","Object","toOptionsObject","key","configPromises","prefix","fetchUniqueWidget","Type","widget","newMap","entry","filter","v","isEmpty","value"],"sources":["../../../src/ts/widgets/widget.ts"],"sourcesContent":["/**\n * ## Specification for the HTML API for widgets\n *\n * The following describes the general syntax when using the HTML API for\n * automatic creation of widgets based on data attributes\n * ({@link Settings.settings.autoWidgets | settings.autoWidgets} must be true.\n *\n * A widget specification should be given as a\n * `data-lisn-<WidgetName>=\"<WidgetConfList>\"` attribute.\n *\n * Alternatively, if using all default configurations, you can simply add the\n * `lisn-<WidgetName>` CSS class. Specifying a configuration using CSS classes\n * is not currently possible for widgets, only triggers.\n *\n * The general specification for a widget is of the form:\n *\n * ```\n * <WidgetConfList> ::= <WidgetConf> { \";\" <WidgetConf> }\n *\n * <WidgetConf> ::= [ <WidgetOption> { \"|\" <WidgetOption> } ]\n *\n * <WidgetOption> ::=\n *     <BooleanOptionName> [ \"=\" ( \"false\" | \"true\" ) ] |\n *     <OptionName> \"=\" <OptionValue>\n * ```\n *\n * **NOTE:**\n *\n * There can be 0 or more spaces around any of the separator characters.\n *\n * Not all widgets support multiple instances per single element and therefore\n * multiple configurations. Refer to the specific widget.\n *\n * The characters \"|\", \";\", \"=\" are reserved separators and cannot be used\n * literally as part of an option value.\n *\n * @module Widgets\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { hasClass, getData } from \"@lisn/utils/css-alter\";\nimport { waitForInteractive } from \"@lisn/utils/dom-events\";\nimport { logWarn } from \"@lisn/utils/log\";\nimport { toArrayIfSingle } from \"@lisn/utils/misc\";\nimport { waitForDelay } from \"@lisn/utils/tasks\";\nimport { formatAsString, kebabToCamelCase, splitOn } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXWeakMap } from \"@lisn/modules/x-map\";\n\nimport { DOMWatcher } from \"@lisn/watchers/dom-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\nexport class Widget {\n  /**\n   * Disables the functionality of the widget. What this means is specific to\n   * each widget.\n   */\n  readonly disable: () => Promise<void>;\n\n  /**\n   * Re-enables the functionality of the widget. What this means is specific to\n   * each widget.\n   */\n  readonly enable: () => Promise<void>;\n\n  /**\n   * Re-enables the widget if disabled, otherwise disables it.\n   */\n  readonly toggleEnable: () => Promise<void>;\n\n  /**\n   * The given handler will be called when the widget is disabled.\n   */\n  readonly onDisable: (handler: WidgetHandler) => void;\n\n  /**\n   * The given handler will be called when the widget is enabled.\n   */\n  readonly onEnable: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns true if the widget is currently disabled.\n   */\n  readonly isDisabled: () => boolean;\n\n  /**\n   * Undoes all modifications to the element and returns it to its original state.\n   *\n   * You will need to recreate it if you want to enable its functionality again.\n   */\n  readonly destroy: () => Promise<void>;\n\n  /**\n   * The given handler will be called when the widget is destroyed.\n   */\n  readonly onDestroy: (handler: WidgetHandler) => void;\n\n  /**\n   * Returns true if the widget is destroyed.\n   */\n  readonly isDestroyed: () => boolean;\n\n  /**\n   * Returns the element passed to the widget constructor.\n   */\n  readonly getElement: () => Element;\n\n  /**\n   * Retrieve an existing widget by element and ID.\n   */\n  static get(element: Element, id: string): Widget | null {\n    return instances.get(element)?.get(id) || null;\n  }\n\n  /**\n   * **IMPORTANT:** If ID is given and there's already a widget with this ID on\n   * this element, it will be destroyed!\n   */\n  constructor(element: Element, config?: { id?: string }) {\n    const logger = debug\n      ? new debug.Logger({\n          name: `${this.constructor.name}-${formatAsString(element)}`,\n          logAtCreation: this,\n        })\n      : null;\n\n    const id = config?.id;\n    if (id) {\n      instances.get(element)?.get(id)?.destroy(); // don't await here\n      instances.sGet(element).set(id, this);\n    }\n\n    let isDisabled = false;\n    let isDestroyed = false;\n    let destroyPromise: Promise<void>;\n\n    const enableCallbacks = MH.newSet<WidgetCallback>();\n    const disableCallbacks = MH.newSet<WidgetCallback>();\n    const destroyCallbacks = MH.newSet<WidgetCallback>();\n\n    this.disable = async () => {\n      if (!isDisabled) {\n        debug: logger?.debug8(\"Disabling\");\n        isDisabled = true;\n\n        for (const callback of disableCallbacks) {\n          await callback.invoke(this);\n        }\n      }\n    };\n\n    this.enable = async () => {\n      if (!isDestroyed && isDisabled) {\n        debug: logger?.debug8(\"Enabling\");\n        isDisabled = false;\n\n        for (const callback of enableCallbacks) {\n          await callback.invoke(this);\n        }\n      }\n    };\n\n    this.toggleEnable = async () => {\n      if (!isDestroyed) {\n        await (isDisabled ? this.enable : this.disable)();\n      }\n    };\n\n    this.onDisable = (handler) => disableCallbacks.add(wrapCallback(handler));\n    this.onEnable = (handler) => enableCallbacks.add(wrapCallback(handler));\n\n    this.isDisabled = () => isDisabled;\n\n    this.destroy = () => {\n      if (!destroyPromise) {\n        destroyPromise = (async () => {\n          debug: logger?.debug8(\"Destroying\");\n          isDestroyed = true;\n          await this.disable();\n\n          for (const callback of destroyCallbacks) {\n            await callback.invoke(this);\n          }\n\n          enableCallbacks.clear();\n          disableCallbacks.clear();\n          destroyCallbacks.clear();\n\n          if (id) {\n            const elInstances = instances.get(element);\n            if (elInstances?.get(id) === this) {\n              MH.deleteKey(elInstances, id);\n              instances.prune(element);\n            }\n          }\n        })();\n      }\n\n      return destroyPromise;\n    };\n\n    this.onDestroy = (handler) => destroyCallbacks.add(wrapCallback(handler));\n\n    this.isDestroyed = () => isDestroyed;\n\n    this.getElement = () => element;\n  }\n}\n\nexport type WidgetCallbackArgs = [Widget];\nexport type WidgetCallback = Callback<WidgetCallbackArgs>;\nexport type WidgetHandler =\n  | WidgetCallback\n  | CallbackHandler<WidgetCallbackArgs>;\n\n/**\n * **NOTE:** If the function returns a widget or a list of widgets created for\n * the given element, then each one will be automatically destroyed if the\n * element is removed from the DOM.\n */\nexport type WidgetCreateFn<Config extends Record<string, unknown>> = (\n  element: Element,\n  config?: Config,\n) => Widget | Widget[] | null | Promise<Widget | Widget[] | null>;\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidatorObject<\n  Config extends Record<string, unknown>,\n> = {\n  [K in keyof Config]: (key: K, v: unknown) => Config[K];\n};\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigAsyncValidatorObject<\n  Config extends Record<string, unknown>,\n> = {\n  [K in keyof Config]: (key: K, v: unknown) => Config[K] | Promise<Config[K]>;\n};\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidatorFunc<Config extends Record<string, unknown>> =\n  (\n    element: Element,\n  ) =>\n    | WidgetConfigValidatorObject<Config>\n    | WidgetConfigAsyncValidatorObject<Config>;\n\n/**\n * @see {@link getWidgetConfig}.\n */\nexport type WidgetConfigValidator<Config extends Record<string, unknown>> =\n  | WidgetConfigValidatorObject<Config>\n  | WidgetConfigValidatorFunc<Config>;\n\n/**\n * Enables automatic setting up of a widget from an elements matching the given\n * selector.\n *\n * If {@link settings.autoWidgets} is true, nothing is done. Otherwise,\n * when an element matching the selector is added to the DOM, `newWidget` will\n * be called and it's expected to setup the widget.\n *\n * **IMPORTANT:** The widget that is returned by `newWidget` will be\n * automatically destroyed when the element that created them is removed from\n * the DOM.\n *\n * **IMPORTANT:** If a widget by that name is already registered, the current\n * call does nothing, even if the remaining arguments differ.\n *\n * @param {} name       The name of the widget. Should be in kebab-case.\n * @param {} newWidget  Called for every element matching the widget selector.\n * @param {} configValidator\n *                      A validator object, or a function that returns such an\n *                      object, for all options supported by the widget. If\n *                      given, then the `newWidget` function will also be\n *                      passed a configuration object constructed from the\n *                      element's data attribute.\n * @param {} [options.selector]\n *                      The selector to match elements for. If not given, then\n *                      uses a default value of `[data-lisn-<name>], .lisn-<name>`\n * @param {} [options.supportsMultiple]\n *                      If true, and if `configValidator` is given, then the\n *                      value of the element's widget specific data attribute\n *                      will be split on \";\" and each one parsed individually\n *                      as a configuration. Then the `newWidget` function will\n *                      be called once for each configuration.\n */\nexport const registerWidget = async <Config extends Record<string, unknown>>(\n  name: string,\n  newWidget: WidgetCreateFn<Config>,\n  configValidator?: null | WidgetConfigValidator<Config>,\n  options?: {\n    selector?: string;\n    supportsMultiple?: boolean;\n  },\n) => {\n  if (registeredWidgets.has(name)) {\n    return;\n  }\n\n  registeredWidgets.add(name);\n\n  // init after DOM loaded so that the settings can be configured by the user\n  // straight after loading LISN.js\n  await waitForInteractive();\n\n  const prefixedName = MH.prefixName(name);\n  const selector = options?.selector ?? getDefaultWidgetSelector(prefixedName);\n\n  if (settings.autoWidgets) {\n    const domWatcher = DOMWatcher.reuse();\n    domWatcher.onMutation(\n      async (operation) => {\n        const element = MH.currentTargetOf(operation);\n        const thisConfigValidator = MH.isFunction(configValidator)\n          ? await configValidator(element)\n          : configValidator;\n\n        const widgets: Widget[] = [];\n        const configSpecs: string[] = [];\n        const dataAttr = getData(element, prefixedName);\n\n        if (options?.supportsMultiple) {\n          if (hasClass(element, prefixedName)) {\n            configSpecs.push(\"\");\n          }\n\n          if (dataAttr !== null) {\n            configSpecs.push(\n              ...(dataAttr ? splitOn(dataAttr, \";\", true) : [\"\"]),\n            );\n          }\n        } else {\n          configSpecs.push(dataAttr ?? \"\");\n        }\n\n        for (const spec of configSpecs) {\n          const config = thisConfigValidator\n            ? await fetchWidgetConfig(spec, thisConfigValidator)\n            : undefined;\n\n          const theseWidgets = await newWidget(element, config);\n          if (theseWidgets) {\n            widgets.push(...toArrayIfSingle(theseWidgets));\n          }\n        }\n\n        // auto-destroy on element remove\n        if (MH.lengthOf(widgets)) {\n          domWatcher.onMutation(\n            () => {\n              for (const w of widgets) {\n                w.destroy();\n              }\n            },\n            {\n              target: element,\n              categories: [MC.S_REMOVED],\n            },\n          );\n        }\n      },\n      {\n        selector,\n        categories: [MC.S_ADDED],\n      },\n    );\n  }\n};\n\n/**\n * Returns a configuration object from the given user input, which can be\n * either an object or a `<separator>` separated string of key=values.\n *\n * If `input` is a string, it must be of the format:\n *\n * ```\n * <UserConfigString> ::= <OptionSpec> { <Separator> <OptionSpec> }\n *\n * <OptionSpec> ::=\n *     <BooleanOptionName> [ \"=\" ( \"false\" | \"true\" ) ] |\n *     <OptionName> \"=\" <OptionValue>\n * ```\n *\n * By default, for widgets `<separator>` is \"|\".\n *\n * **NOTE:** If `input` is a string, option names will be converted from\n * kebab-case to camelCase.\n *\n * The given `validator` defines the shape of the returned object. It is called\n * for each entry _in the `validator` object_, with that key and the\n * corresponding value from the input configuration, as the two parameters.\n *\n * If a key is not found in the input, the value passed to the validating\n * function will be `undefined`.\n *\n * If the input is a string and a key has no value, the value passed to the\n * validating function will be an empty string `\"\"`.\n *\n * The final configuration contains all keys from the `validator` object with\n * the value that the validating function for each key returned.\n *\n * There are several built-in validating functions that you can make use of.\n *\n * @see {@link Utils.validateStrList}\n * @see {@link Utils.validateNumber}\n * @see {@link Utils.validateBoolean}\n * @see {@link Utils.validateString}\n * @see {@link Utils.validateBooleanOrString}\n */\nexport const getWidgetConfig = <Config extends Record<string, unknown>>(\n  input: Record<string, unknown> | string | null | undefined,\n  validator: WidgetConfigValidatorObject<Config>,\n  separator = \"|\",\n): Config => {\n  const config = {} as Config;\n  if (!(input instanceof Object)) {\n    input = toOptionsObject(input, separator);\n  }\n\n  for (const key in validator) {\n    config[key] = validator[key](key, input[key]);\n  }\n  return config;\n};\n\n/**\n * Like {@link getWidgetConfig} but it accepts an object whose validator\n * functions may return a promise.\n */\nexport const fetchWidgetConfig = async <Config extends Record<string, unknown>>(\n  input: Record<string, unknown> | string | null | undefined,\n  validator: WidgetConfigAsyncValidatorObject<Config>,\n  separator = \"|\",\n): Promise<Config> => {\n  const config = {} as Config;\n  const configPromises = getWidgetConfig<{\n    [K in keyof Config]: Config[K] | Promise<Config[K]>;\n  }>(input, validator, separator);\n\n  for (const key in configPromises) {\n    config[key] = await configPromises[key];\n  }\n\n  return config;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const getDefaultWidgetSelector = (prefix: string) =>\n  `.${prefix},[data-${prefix}]`;\n\n/**\n * @ignore\n * @internal\n */\nexport const fetchUniqueWidget = async <W extends Widget>(\n  name: string,\n  element: Element,\n  Type: { get: (element: Element) => W | null },\n): Promise<W | null> => {\n  let widget = Type.get(element);\n  if (!widget) {\n    await waitForDelay(0); // in case it's being processed now\n    widget = Type.get(element);\n\n    if (!widget) {\n      logWarn(`No ${name} widget for element ${formatAsString(element)}`);\n      return null;\n    }\n  }\n\n  return widget;\n};\n\nconst instances = newXWeakMap<Element, Map<string, Widget>>(() => MH.newMap());\nconst registeredWidgets = MH.newSet<string>();\n\n// --------------------\n\nconst toOptionsObject = (\n  input: string | null | undefined,\n  separator: string,\n) => {\n  const options: Record<string, string> = {};\n  for (const entry of MH.filter(\n    splitOn(input ?? \"\", separator, true),\n    (v) => !MH.isEmpty(v),\n  )) {\n    const [key, value] = splitOn(entry, /\\s*=\\s*/, true, 1);\n    options[kebabToCamelCase(key)] = value ?? \"\";\n  }\n  return options;\n};\n"],"mappings":"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","ignoreList":[]}