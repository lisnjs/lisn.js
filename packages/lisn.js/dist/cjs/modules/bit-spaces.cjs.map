{"version":3,"file":"bit-spaces.cjs","names":["MH","_interopRequireWildcard","require","_math","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","BitSpaces","constructor","counter","newCounter","create","propNames","newBitSpace","_nBits","_bitmask","exports","newBitSpaces","createBitSpace","spaces","start","end","lengthOf","usageError","bitmask","getBitmask","space","bit","p","isString","isNumber","bitmaskFor","pStart","pEnd","isEmpty","thisStart","log2","thisEnd","nameOf","val","_propNames","name"],"sources":["../../../src/ts/modules/bit-spaces.ts"],"sourcesContent":["/**\n * @module Modules/BitSpaces\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { getBitmask } from \"@lisn/utils/math\";\n\nexport type BitPropName = string;\n\n/**\n * A union of all property names in the space.\n */\nexport type BitSpaceKey<S> = S extends BitSpace<infer T> ? T : never;\n\n/**\n * {@link BitSpace} represents a single set of mutually exclusive (or\n * orthogonal) properties.\n *\n * Each property has a numeric value equal to 1 bit-shifted by a certain number\n * of bits.\n *\n * Created using {@link BitSpaces.create}\n *\n * @interface\n */\nexport type BitSpace<T extends BitPropName> = {\n  /**\n   * The starting bit of the space. It's 0 for the first space created in a\n   * given set of {@link BitSpaces}.\n   */\n  start: number;\n\n  /**\n   * The ending bit of the space. It's always equal to\n   * start + (# of properties in space) - 1\n   */\n  end: number;\n\n  /**\n   * A bitmask of all values in the space.\n   */\n  bitmask: number;\n\n  /**\n   * Returns true if the given name is one of the properties in the space.\n   * It is case-sensitive.\n   */\n  has: (p: string) => p is T;\n\n  /**\n   * Takes the names of two properties within the space and returns a bitmask\n   * that covers all values between them _including the starting and ending\n   * one_.*\n   *\n   * If pStart > pEnd, they are reversed.\n   *\n   * * The numeric values of the properties are guaranteed to be in the same\n   *   order, increasing in value, as the keys passed to the `BitSpaces.create`,\n   *   function.\n   *\n   * @param {} pStart  The name of the property that holds the start value.\n   *                   If null the bitmask will cover from the lowest property.\n   * @param {} pEnd    The name of the property that holds the end cut-off\n   *                   value for the bitmask. The bitmask with _not_ include\n   *                   pEnd's value.\n   *                   If null the bitmask will cover to the highest property,\n   *                   _including_.\n   *\n   * @returns {} Returns a non-0 bitmask containing all values in the space\n   *             between the given ones.\n   *             Returns 0 if one or both of the given properties do not exist\n   *             in the space.\n   */\n  bitmaskFor: (pStart?: T | null, pEnd?: T | null) => number;\n\n  /**\n   * Returns the name of the property with the given value, or null if the\n   * value does not correspond to one of the space properties.\n   */\n  nameOf: (val: number) => T | null;\n\n  /**\n   * Holds properties whose numeric values are non-overlapping binary values,\n   * suitable for bitmasking.\n   *\n   * The given properties are set under the \"bit\" key in the object and hold\n   * the numeric value.\n   *\n   * @example\n   * ```javascript\n   * const space = new BitSpaces().create(\"up\", \"down\", \"left\", \"right\");\n   *\n   * // {\n   * //     bit: {\n   * //         up:    1, // at bit 0, i.e. 1 << 0\n   * //         down:  2, // at bit 1, i.e. 1 << 1\n   * //         left:  4, // at bit 2, i.e. 1 << 2\n   * //         right: 8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      0,\n   * //     end:        3,\n   * //     bitmask:    15, // 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"up\" || p === \"down\" || p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : v === 4 ...\n   * // }\n   *\n   * space.bitmaskFor(); // => space.bitmask (15)\n   * space.bitmaskFor(\"left\"); // => space.bit.left | space.bit.right (12)\n   * space.bitmaskFor(null, \"down\"); // => space.bit.up | space.bit.down (3)\n   * ```\n   */\n  bit: {\n    [key in T]: number;\n  };\n};\n\n/**\n * {@link BitSpaces} represents one or more related {@link BitSpace}s whose bit\n * values will not overlap.\n */\nexport class BitSpaces {\n  /**\n   * Creates and returns a new BitSpace that is bit shifted to the left as\n   * many bits as the ending bit of the previous space created by this\n   * instances, so that each new space created is non-overlapping with previous\n   * ones.\n   *\n   * The numeric values of the properties are guaranteed to be in the same\n   * order, increasing in value, as the keys passed to the function.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the number of bits in the space will exceed 32.\n   *\n   * @example\n   * ```javascript\n   * const spaces = new BitSpaces();\n   * const spaceA = spaces.create(\"up\", \"down\");\n   *\n   * // spaces.nBits   => 2\n   * // spaces.bitmask => 3\n   * //\n   * // spaceA:\n   * // {\n   * //     bit: {\n   * //         up:     1, // at bit 0, i.e. 1 << 0\n   * //         down:   2, // at bit 1, i.e. 1 << 1\n   * //     },\n   * //     start:      0,\n   * //     end:        1,\n   * //     bitmask:    3, // 1 << 0 | 1 << 1\n   * //     has:        (p) => p === \"up\" || p === \"down\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 1 ? \"up\" : v === 2 ? \"down\" : null\n   * // }\n   *\n   * const spaceB = spaces.create(\"left\", \"right\");\n   *\n   * // spaces.nBits   => 4\n   * // spaces.bitmask => 15\n   * //\n   * // spaceB:\n   * // {\n   * //     bit: {\n   * //         left:   4, // at bit 2, i.e. 1 << 2\n   * //         right:  8, // at bit 3, i.e. 1 << 3\n   * //     },\n   * //     start:      2,\n   * //     end:        3,\n   * //     bitmask:    12, // 1 << 2 | 1 << 3\n   * //     has:        (p) => p === \"left\" || p === \"right\",\n   * //     bitmaskFor: (pStart, pEnd) => ...\n   * //     nameOf:     (v) => v === 4 ? \"left\" : v === 8 ? \"right\" : null\n   * // }\n   *\n   * ```\n   */\n  readonly create: <T extends BitPropName>(\n    ...propNames: readonly T[]\n  ) => BitSpace<T>;\n\n  /**\n   * Returns the number of bits all created spaces span, i.e. the end bit of\n   * the one + 1.\n   */\n  readonly nBits!: number;\n\n  /**\n   * Returns a bitmask containing all values in all created spaces.\n   */\n  readonly bitmask!: number;\n\n  constructor() {\n    const counter = newCounter();\n\n    this.create = (...propNames) => newBitSpace(counter, propNames);\n    MH.defineProperty(this, \"nBits\", { get: () => counter._nBits });\n    MH.defineProperty(this, \"bitmask\", { get: () => counter._bitmask });\n  }\n}\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const newBitSpaces = () => new BitSpaces();\n\n/**\n * For minification optimization\n *\n * @ignore\n * @internal\n */\nexport const createBitSpace = <T extends BitPropName>(\n  spaces: BitSpaces,\n  ...propNames: readonly T[]\n): BitSpace<T> => spaces.create(...propNames);\n\n// ----------------------------------------\n\ntype BitCounter = {\n  _nBits: number;\n  _bitmask: number;\n};\n\nconst newCounter = (): BitCounter => ({\n  _nBits: 0,\n  _bitmask: 0,\n});\n\nconst newBitSpace = <T extends BitPropName>(\n  counter: BitCounter,\n  propNames: readonly T[],\n): BitSpace<T> => {\n  const start = counter._nBits;\n  const end = start + MH.lengthOf(propNames) - 1;\n  if (end >= 31) {\n    throw MH.usageError(\"BitSpaces overflow\");\n  }\n\n  const bitmask = getBitmask(start, end);\n  const space: BitSpace<T> = {\n    bit: {},\n    start,\n    end,\n    bitmask,\n\n    has: (p) =>\n      MH.isString(p) &&\n      p in space.bit &&\n      MH.isNumber((space.bit as Record<string, unknown>)[p]),\n\n    bitmaskFor: (pStart, pEnd) => {\n      if (\n        (!MH.isEmpty(pStart) && !space.has(pStart)) ||\n        (!MH.isEmpty(pEnd) && !space.has(pEnd))\n      ) {\n        return 0;\n      }\n\n      const thisStart = !MH.isEmpty(pStart)\n        ? MH.log2(space.bit[pStart])\n        : start;\n      const thisEnd = !MH.isEmpty(pEnd) ? MH.log2(space.bit[pEnd]) : end;\n\n      return getBitmask(thisStart, thisEnd);\n    },\n\n    nameOf: (val) => propNames[MH.log2(val) - start] ?? null,\n  } as BitSpace<T>;\n\n  for (const name of propNames) {\n    MH.defineProperty(space.bit, name, {\n      value: 1 << counter._nBits++,\n      enumerable: true,\n    });\n  }\n\n  counter._bitmask |= bitmask;\n\n  return space;\n};\n"],"mappings":"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","ignoreList":[]}