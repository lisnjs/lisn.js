{"version":3,"file":"text.js","names":["MC","MH","formatAsString","value","maxLen","result","maybeConvertToString","isNullish","lengthOf","slice","max","joinAsString","separator","_len","arguments","length","args","Array","_key","map","a","join","splitOn","input","trim","limit","output","addEntry","s","push","matchIndex","matchLength","isLiteralString","indexOf","_match$index","match","exec","index","kebabToCamelCase","camelToKebabCase","randId","nChars","undefined","segment","floor","MATH","random","toString","toMargins","absoluteSize","_parts$","_parts$2","_ref","_parts$3","toPxValue","strValue","margin","parseFloat","S_HEIGHT","S_WIDTH","parts","margins","objToStrKey","obj","stringify","flattenForSorting","array","isArray","keysOf","sort","k","isNonPrimitive","constructorOf","OBJECT","stringifyReplacer","key","nested","isElement","classStr","classList","id","concat","tagName","isInstanceOf","Error","isString","stack","message","v","isIterableObject","typeOrClassOf","arrayFrom","STRING"],"sources":["../../../src/ts/utils/text.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Size, StrRecord } from \"@lisn/globals/types\";\n\n/**\n * Formats an object as a string. It supports more meaningful formatting as\n * string for certain types rather than using the default string\n * representation.\n *\n * **NOTE:** This is not intended for serialization of data that needs to be\n * de-serialized. Only for debugging output.\n *\n * @param {} value     The value to format as string.\n * @param {} [maxLen]  Maximum length of the returned string. If not given or\n *                     is <= 0, the string is not truncated. Otherwise, if the\n *                     result is longer than maxLen, it is truncated to\n *                     `maxLen - 3` and added a suffix of \"...\".\n *                     Note that if `maxLen` is > 0 but <= 3, the result is\n *                     always \"...\"\n *\n * @category Text\n */\nexport const formatAsString = (value: unknown, maxLen?: number) => {\n  const result = maybeConvertToString(value, false);\n\n  if (!MH.isNullish(maxLen) && maxLen > 0 && MH.lengthOf(result) > maxLen) {\n    return result.slice(0, MH.max(0, maxLen - 3)) + \"...\";\n  }\n\n  return result;\n};\n\n/**\n * Join an array of values as string using separator. It uses\n * {@link formatAsString} rather than the default string representation as\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join | Array:join} would.\n *\n * @param {} separator  The separator to use to delimit each argument.\n * @param {} args       Objects or values to convert to string and join.\n *\n * @category Text\n */\nexport const joinAsString = (separator: string, ...args: unknown[]) =>\n  args.map((a) => formatAsString(a)).join(separator);\n\n/**\n * Similar to\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split | String.prototype.split}\n * except that\n * 1. `limit` is interpreted as the maximum number of splits, and the\n *   returned array contains `limit + 1` entries. Also if `limit` is given and\n *   the number of substrings is greater than the limit, all the remaining\n *   substrings are present in the final substring.\n * 2. If input is an empty string (or containing only whitespace), returns an\n *    empty array.\n *\n * @example\n * ```javascript\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 0); // -> ['foo, bar, baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 1); // -> ['foo', 'bar, baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 2); // -> ['foo', 'bar', 'baz']\n * splitOn('foo, bar, baz', RegExp(',\\\\s*'), 3); // -> ['foo', 'bar', 'baz']\n * ```\n *\n * @param {} trim  If true, entries will be trimmed for whitespace after splitting.\n *\n * @param {} limit If not given or < 0, the string will be split on every\n *                 occurrence of `separator`. Otherwise, it will be split on\n *                 the first `limit` number of occurrences of `separator`.\n *\n * @category Text\n */\nexport const splitOn = (\n  input: string,\n  separator: string | RegExp,\n  trim?: boolean,\n  limit?: number,\n) => {\n  if (!input.trim()) {\n    return [];\n  }\n\n  limit = limit ?? -1;\n\n  const output: string[] = [];\n  const addEntry = (s: string) => output.push(trim ? s.trim() : s);\n\n  while (limit--) {\n    let matchIndex = -1,\n      matchLength = 0;\n    if (MH.isLiteralString(separator)) {\n      matchIndex = input.indexOf(separator);\n      matchLength = MH.lengthOf(separator);\n    } else {\n      const match = separator.exec(input);\n      matchIndex = match?.index ?? -1;\n      matchLength = match ? MH.lengthOf(match[0]) : 0;\n    }\n\n    if (matchIndex < 0) {\n      break;\n    }\n\n    addEntry(input.slice(0, matchIndex));\n    input = input.slice(matchIndex + matchLength);\n  }\n\n  addEntry(input);\n  return output;\n};\n\n/**\n * Converts a kebab-cased-string to camelCase.\n * The result is undefined if the input string is not formatted in\n * kebab-case.\n *\n * @category Text\n */\nexport const kebabToCamelCase = MH.kebabToCamelCase;\n\n/**\n * Converts a camelCasedString to kebab-case.\n * The result is undefined if the input string is not formatted in\n * camelCase.\n *\n * @category Text\n */\nexport const camelToKebabCase = MH.camelToKebabCase;\n\n/**\n * Generates a random string of a fixed length.\n *\n * **IMPORTANT:** This is _not_ suitable for cryptographic applications.\n *\n * @param {} [nChars = 8]  The length of the returned stirng.\n *\n * @category Text\n */\nexport const randId = (nChars = 8) => {\n  const segment = () =>\n    MH.floor(100000 + MC.MATH.random() * 900000).toString(36);\n\n  let s = \"\";\n  while (MH.lengthOf(s) < nChars) {\n    s += segment();\n  }\n  return s.slice(0, nChars);\n};\n\n/**\n * Returns an array of numeric margins in pixels from the given margin string.\n * The string should contain margins in either pixels or percentage; other\n * units are not supported.\n *\n * Percentage values are converted to pixels relative to the given\n * `absoluteSize`: left/right margins relative to the width, and top/bottom\n * margins relative to the height.\n *\n * Note that for the margin property, percentages are always relative to the\n * WIDTH of the parent, so you should pass the parent width as both the width\n * and the height keys in `absoluteSize`. But for IntersectionObserver's\n * `rootMargin`, top/bottom margin is relative to the height of the root, so\n * pass the actual root size.\n *\n * @return {} [topMarginInPx, rightMarginInPx, bottomMarginInPx, leftMarginInPx]\n *\n * @category Text\n */\nexport const toMargins = (value: string, absoluteSize: Size) => {\n  const toPxValue = (strValue: string | undefined, index: number) => {\n    let margin = MH.parseFloat(strValue || \"\") || 0;\n\n    if (strValue === margin + \"%\") {\n      margin *=\n        index % 2 ? absoluteSize[MC.S_HEIGHT] : absoluteSize[MC.S_WIDTH];\n    }\n\n    return margin;\n  };\n\n  const parts = splitOn(value, \" \", true);\n  const margins: [number, number, number, number] = [\n    // top\n    toPxValue(parts[0], 0),\n    // right\n    toPxValue(parts[1] ?? parts[0], 1),\n    // bottom\n    toPxValue(parts[2] ?? parts[0], 2),\n    // left\n    toPxValue(parts[3] ?? parts[1] ?? parts[0], 3),\n  ];\n\n  return margins;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport const objToStrKey = (obj: StrRecord): string =>\n  MH.stringify(flattenForSorting(obj));\n\n// --------------------\n\nconst flattenForSorting = (obj: StrRecord): unknown[] => {\n  const array = MH.isArray(obj)\n    ? obj\n    : MH.keysOf(obj)\n        .sort()\n        .map((k) => obj[k]);\n\n  return array.map((value) => {\n    if (\n      MH.isArray(value) ||\n      (MH.isNonPrimitive(value) && MH.constructorOf(value) === MC.OBJECT)\n    ) {\n      return flattenForSorting(value);\n    }\n    return value;\n  });\n};\n\nconst stringifyReplacer = (key: string, value: unknown) =>\n  key ? maybeConvertToString(value, true) : value;\n\nconst maybeConvertToString = <B extends boolean, V>(\n  value: V,\n  nested: B,\n): B extends false ? string : string | V => {\n  let result: string | V = \"\";\n\n  if (MH.isElement(value)) {\n    const classStr = MH.classList(value).toString().trim();\n\n    result = value.id\n      ? \"#\" + value.id\n      : `<${MH.tagName(value)}${classStr ? ' class=\"' + classStr + '\"' : \"\"}>`;\n\n    //\n  } else if (MH.isInstanceOf(value, Error)) {\n    /* istanbul ignore else */\n    if (\"stack\" in value && MH.isString(value.stack)) {\n      result = value.stack;\n    } else {\n      result = `Error: ${value.message}`;\n    }\n\n    //\n  } else if (MH.isArray(value)) {\n    result =\n      \"[\" +\n      value\n        .map((v) =>\n          MH.isString(v) ? MH.stringify(v) : maybeConvertToString(v, false),\n        )\n        .join(\",\") +\n      \"]\";\n\n    //\n  } else if (MH.isIterableObject(value)) {\n    result =\n      MH.typeOrClassOf(value) +\n      \"(\" +\n      maybeConvertToString(MH.arrayFrom(value), false) +\n      \")\";\n\n    //\n  } else if (MH.isNonPrimitive(value)) {\n    result = nested ? value : MH.stringify(value, stringifyReplacer);\n\n    //\n  } else {\n    // primitive\n    result = nested ? value : MC.STRING(value);\n  }\n\n  return result as B extends false ? string : string | V;\n};\n"],"mappings":"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","ignoreList":[]}