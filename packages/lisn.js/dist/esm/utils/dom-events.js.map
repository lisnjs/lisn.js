{"version":3,"file":"dom-events.js","names":["MH","settings","waitForElement","checkFn","timeout","newPromise","resolve","callFn","result","isNullish","setTimer","observer","disconnect","newMutationObserver","observe","getDocElement","childList","subtree","waitForElementOrInteractive","isInteractive","then","res","waitForInteractive","readyState","getReadyState","INTERACTIVE","COMPLETE","getDoc","addEventListener","waitForComplete","waitForPageReady","pageIsReady","timer","dispatchReady","clearTimer","pageLoadTimeout","isPageReady","hasDOM"],"sources":["../../../src/ts/utils/dom-events.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport { NonNullableReturnType } from \"@lisn/globals/types\";\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined`.\n *\n * The Promise is resolved with `checkFn`'s return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @param {} timeout If given, then if no such element is present after this\n *                    many milliseconds, the promise will resolve to `null`.\n *\n * @category DOM: Events\n */\nexport const waitForElement = <\n  F extends () => unknown,\n  T extends number | undefined = undefined,\n>(\n  checkFn: F,\n  timeout?: number,\n) =>\n  MH.newPromise<\n    T extends undefined\n      ? NonNullableReturnType<F>\n      : null | NonNullableReturnType<F>\n  >((resolve) => {\n    const callFn = () => {\n      const result = checkFn();\n      if (!MH.isNullish(result)) {\n        resolve(result as NonNullableReturnType<F>);\n        return true; // done\n      }\n      return false;\n    };\n\n    if (callFn()) {\n      return; // resolved already\n    }\n\n    if (!MH.isNullish(timeout)) {\n      MH.setTimer(() => {\n        resolve(\n          null as T extends undefined\n            ? NonNullableReturnType<F>\n            : null | NonNullableReturnType<F>,\n        );\n        observer.disconnect();\n      }, timeout);\n    }\n\n    const observer = MH.newMutationObserver(() => {\n      if (callFn()) {\n        observer.disconnect();\n      }\n    });\n\n    observer.observe(MH.getDocElement(), {\n      childList: true,\n      subtree: true,\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the given `checkFn` function returns\n * a value other than `null` or `undefined` or the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * becomes \"interactive\".\n *\n * It always calls the given `checkFn` first before examining the `readyState`.\n *\n * If the `readyState` became interactive before the element was found, the\n * Promise resolves to `null`. Otherwise the Promise is resolved with `checkFn`'s\n * return value.\n *\n * The function is called initially, and then every time there are changes to\n * the DOM children. Uses\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver | MutationObserver}.\n *\n * @category DOM: Events\n */\nexport const waitForElementOrInteractive = <F extends () => unknown>(\n  checkFn: F,\n) =>\n  MH.newPromise<NonNullableReturnType<F> | null>((resolve) => {\n    let isInteractive = false;\n    // Check element first, then readyState. The callback to waitForElement is\n    // run synchronously first time, so isInteractive will be false and checkFn\n    // will run.\n    waitForElement(() => isInteractive || checkFn()).then((res) => {\n      if (!isInteractive) {\n        resolve(res as NonNullableReturnType<F>);\n      } // else already resolved to null\n    });\n\n    waitForInteractive().then(() => {\n      isInteractive = true;\n      resolve(null);\n    });\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"interactive\" (or if it's already \"interactive\" or \"complete\", the\n * Promise is fulfilled immediately).\n *\n * @category DOM: Events\n */\nexport const waitForInteractive = () =>\n  MH.newPromise<void>((resolve) => {\n    const readyState = MH.getReadyState();\n    if (readyState === INTERACTIVE || readyState === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"DOMContentLoaded\", () => resolve());\n  });\n\n/**\n * Returns a Promise that is resolved when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" (or if it's already \"complete\", the Promise is fulfilled\n * immediately).\n *\n * @category DOM: Events\n */\nexport const waitForComplete = () =>\n  MH.newPromise<void>((resolve) => {\n    if (MH.getReadyState() === COMPLETE) {\n      resolve();\n      return;\n    }\n\n    MH.getDoc().addEventListener(\"readystatechange\", () => {\n      if (MH.getReadyState() === COMPLETE) {\n        resolve();\n      }\n    });\n  });\n\n/**\n * Returns a Promise that is resolved either when the\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState | Document:readyState}\n * is \"complete\" or the `readyState` is \"interactive\" and at least\n * {@link settings.pageLoadTimeout} milliseconds have passed (if > 0) since it\n * became \"interactive\".\n *\n * @category DOM: Events\n */\nexport const waitForPageReady = () =>\n  MH.newPromise<void>((resolve) => {\n    if (pageIsReady) {\n      resolve();\n      return;\n    }\n\n    return waitForInteractive().then(() => {\n      // Setup a listener for the complete state but wait at most\n      // <pageLoadTimeout> (if specified)\n      let timer: ReturnType<typeof setTimeout> | null = null;\n\n      const dispatchReady = () => {\n        pageIsReady = true;\n        if (timer) {\n          MH.clearTimer(timer);\n          timer = null;\n        }\n        resolve();\n      };\n\n      if (settings.pageLoadTimeout > 0) {\n        timer = MH.setTimer(() => {\n          dispatchReady();\n        }, settings.pageLoadTimeout);\n      }\n\n      waitForComplete().then(dispatchReady);\n    });\n  });\n\n/**\n * Returns true if the page is \"ready\". See {@link waitForPageReady}.\n *\n * @category DOM: Events\n */\nexport const isPageReady = () => pageIsReady;\n\n// --------------------\n\nconst COMPLETE = \"complete\";\nconst INTERACTIVE = \"interactive\";\n\nlet pageIsReady = false;\n\nif (!MH.hasDOM()) {\n  pageIsReady = true;\n} else {\n  waitForPageReady(); // ensure pageIsReady is set even if waitForPageReady is not called\n}\n"],"mappings":"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","ignoreList":[]}