{"version":3,"file":"gesture-wheel.js","names":["MC","MH","getVectorDirection","havingMaxAbs","normalizeWheel","addDeltaZ","getWheelGestureFragment","events","options","isIterableObject","direction","S_NONE","intent","deltaX","deltaY","deltaZ","event","isWheelEvent","type","S_WHEEL","data","thisIntent","S_SCROLL","thisDeltaX","pixelX","thisDeltaY","pixelY","thisDeltaZ","maxDelta","ctrlKey","percentage","abs","S_ZOOM","shiftKey","S_UNKNOWN","S_AMBIGUOUS","S_IN","S_OUT","angleDiffThreshold","device"],"sources":["../../../src/ts/utils/gesture-wheel.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureIntent } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport { havingMaxAbs } from \"@lisn/utils/math\";\nimport { normalizeWheel } from \"@lisn/utils/normalize-wheel\";\n\nimport { GestureFragment, addDeltaZ } from \"@lisn/utils/gesture\";\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"wheel\" events\n * will be considered.\n *\n * If there are no \"wheel\" events in the given list of events, returns `false`.\n *\n * The deltas of all events are summed together before determining final delta\n * and direction.\n *\n * If the events are of conflicting types, i.e. some scroll, some zoom, then\n * the intent will be \"unknown\" and the direction will be \"ambiguous\".\n *\n * If the deltas sum up to 0, the direction will be \"none\".\n *\n * **IMPORTANT NOTES ON THE DELTA VALUES**\n *\n * For wheel gestures the deltas are _highly_ unreliable, especially when\n * zooming (Control + wheel or pinching trackpad). You should not assume they\n * correspond to the would-be scroll or zoom amount that the browser would do.\n * But they can be used to determine relative amounts for animating, etc.\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"line\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaLineHeight | settings.deltaLineHeight}).\n *\n * If the browser reports the delta values of a WheelEvent to be in mode \"page\",\n * then a configurable fixed value is used\n * ({@link Settings.settings.deltaPageWidth | settings.deltaPageWidth} and\n * ({@link Settings.settings.deltaPageHeight | settings.deltaPageHeight}).\n *\n * For zoom intents `deltaZ` is based on what the browser reports as the\n * `deltaY`, which in most browsers roughly corresponds to a percentage zoom\n * factor.\n *\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}.\n *                                        Default is 5.\n *\n * @returns {} `false` if there are no \"wheel\" events in the list, otherwise a\n * {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getWheelGestureFragment = (\n  events: Event | readonly Event[],\n  options?: {\n    angleDiffThreshold?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent | null = null;\n  let deltaX = 0,\n    deltaY = 0,\n    deltaZ = 1;\n\n  for (const event of events) {\n    if (!MH.isWheelEvent(event) || event.type !== MC.S_WHEEL) {\n      continue;\n    }\n\n    const data = normalizeWheel(event);\n    let thisIntent: GestureIntent = MC.S_SCROLL;\n    let thisDeltaX = data.pixelX;\n    let thisDeltaY = data.pixelY;\n    let thisDeltaZ = 1;\n    const maxDelta = havingMaxAbs(thisDeltaX, thisDeltaY);\n\n    if (event.ctrlKey && !thisDeltaX) {\n      // Browsers report negative deltaY for zoom in, so swap sign\n      let percentage = -maxDelta;\n      // If it's more than 50, assume it's a mouse wheel => delta is roughly\n      // multiple of 10%. Otherwise a trackpad => delta is roughly multiple of 1%\n      if (MH.abs(percentage) >= 50) {\n        percentage /= 10;\n      }\n\n      thisDeltaZ = 1 + percentage / 100;\n\n      thisDeltaX = thisDeltaY = 0;\n      thisIntent = MC.S_ZOOM;\n    } else if (event.shiftKey && !thisDeltaX) {\n      // Holding Shift while turning wheel or swiping trackpad in vertically\n      // results in sideways scroll.\n      thisDeltaX = thisDeltaY;\n      thisDeltaY = 0;\n    }\n\n    deltaX += thisDeltaX;\n    deltaY += thisDeltaY;\n    deltaZ = addDeltaZ(deltaZ, thisDeltaZ);\n\n    if (!thisIntent) {\n      // not a relevant key\n    } else if (!intent) {\n      intent = thisIntent;\n    } else if (intent !== thisIntent) {\n      // mixture of zoom and scroll\n      intent = MC.S_UNKNOWN;\n    }\n  }\n\n  if (!intent) {\n    return false; // no relevant events\n  } else if (intent === MC.S_UNKNOWN) {\n    direction = MC.S_AMBIGUOUS;\n  } else if (intent === MC.S_ZOOM) {\n    direction = deltaZ > 1 ? MC.S_IN : deltaZ < 1 ? MC.S_OUT : MC.S_NONE;\n  } else {\n    direction = getVectorDirection(\n      [deltaX, deltaY],\n      options?.angleDiffThreshold,\n    );\n  }\n\n  return direction === MC.S_NONE\n    ? false\n    : {\n        device: MC.S_WHEEL,\n        direction,\n        intent,\n        deltaX,\n        deltaY,\n        deltaZ,\n      };\n};\n"],"mappings":"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","ignoreList":[]}