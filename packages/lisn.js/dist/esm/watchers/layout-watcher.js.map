{"version":3,"file":"layout-watcher.js","names":["MC","MH","settings","getData","getLayoutBitmask","NUM_LAYOUTS","ORDERED_DEVICES","ORDERED_ASPECTR","logError","logWarn","omitKeys","copyExistingKeys","createOverlay","objToStrKey","wrapCallback","newXMap","SizeWatcher","debug","LayoutWatcher","create","config","getConfig","CONSTRUCTOR_KEY","reuse","_instances$get","myConfig","configStrKey","_root","instance","instances","get","sGet","set","constructor","key","_defineProperty","illegalConstructorError","logger","Logger","name","logAtCreation","nonIntersectingBitmask","currentLayoutData","device","aspectRatio","allCallbacks","newMap","fetchCurrentLayout","readyPromise","copyObject","setupOverlays","root","overlays","createOverlays","_deviceBreakpoints","_aspectRatioBreakpoints","newPromise","resolve","isReady","intersectionHandler","entries","numEntries","lengthOf","debug9","bugError","entry","getNonIntersecting","processLayoutChange","observeOptions","rootMargin","observer","newIntersectionObserver","triggerOverlay","observe","createCallback","handler","layoutBitmask","_allCallbacks$get","remove","_callback","debug5","callback","onRemove","deleteHandler","_layoutBitmask","setupOnLayout","options","skipInitial","layoutData","isRemoved","changeMatches","invokeCallback","deleteKey","skipCallbacks","deviceBit","floor","log2","bitmask","aspectRatioBit","INFINITY","nameOf","debug8","values","onLayout","offLayout","_allCallbacks$get2","SYMBOL","VAR_BORDER_HEIGHT","prefixCssJsVar","PREFIX_DEVICE","prefixName","PREFIX_ASPECTR","_config$root","deviceBreakpoints","aspectRatioBreakpoints","overlayPromises","overlayParent","style","position","S_WIDTH","push","parent","data","parentHeightCss","trackSize","target","promiseAll","getOverlayLayout","overlay","layout","has","thisLayoutData","prevLayoutData","bit","targetOf","isHTMLElement","typeOrClassOf","isIntersecting","invoke","catch"],"sources":["../../../src/ts/watchers/layout-watcher.ts"],"sourcesContent":["/**\n * @module Watchers/LayoutWatcher\n */\n\n// NOTES FOR DEVELOPERS\n//\n// For each layout (device or aspect ratio), we create an overlay that has a\n// a width that corresponds to the layout:\n//  - for device layouts, it's a fixed width in pixels, equal to the minimum\n//    width of the device\n//  - for aspect ratio layouts, the overlay has a width that's relative to\n//    the root's height, equal to the minimum width of the aspect ratio\n//\n// Then we observe each overlay with an IntersectionObserver whose root\n// is this Watcher's root and whose root margin is -100% from the left (i.e.\n// right-most edge of the root).\n//\n// If the root is null, i.e. the viewport, the overlays will have a \"fixed\"\n// position and be inserted in document.body. Otherwise, they'll be inserted\n// in the root element with an \"absolute\" position. The root element, if not\n// body must be positioned. It gets a default position of \"relative\" through\n// the class `.lisn-overlay-container`, which Overlays ensures it gets.\n//\n// If using custom root we track its size through SizeWatcher as the\n// aspectRatio overlays are relative to the height, and we can't rely on CSS\n// alone as the root may not have a fixed height through CSS.\n//\n// Whenever any overlay intersects the root, this means that the viewport\n// width is now equal to or narrower than the overlay.\n//\n// ~~~~ The current device or aspect ratio corresponds to the _widest_\n// ~~~~ overlay that does not intersect.\n//\n// For example:\n//\n// | mobile\n// ========| mobile-wide\n// ======================| tablet\n// =========================================| desktop\n//\n// _________________________________| viewport width\n//\n// Here, mobile, mobile-wide and tablet overlays are _not_ intersecting, only\n// desktop intersects. The device layout is therefore tablet.\n//\n// Therefore:\n// - have the layout bit spaces ordered from narrowest layout at lowest bit\n//   to widest layout at hightest bit\n// - keep a running bitmask of which overlays are not intersecting and update\n//   it each time there is an IntersectionObserverEntry.\n// - get the highest device or aspect ratio bit in that bitmask to find out\n//   the widest non-intersecting overlay\n//\n// For simplicity we create overlays also for layouts that have a 0-width.\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  Layout,\n  DeviceSpec,\n  Device,\n  AspectRatioSpec,\n  AspectRatio,\n} from \"@lisn/globals/types\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport {\n  getLayoutBitmask,\n  NUM_LAYOUTS,\n  ORDERED_DEVICES,\n  ORDERED_ASPECTR,\n} from \"@lisn/utils/layout\";\nimport { logError, logWarn } from \"@lisn/utils/log\";\nimport { omitKeys, copyExistingKeys } from \"@lisn/utils/misc\";\nimport { createOverlay } from \"@lisn/utils/overlays\";\nimport { objToStrKey } from \"@lisn/utils/text\";\n\nimport {\n  CallbackHandler,\n  Callback,\n  wrapCallback,\n} from \"@lisn/modules/callback\";\nimport { newXMap } from \"@lisn/modules/x-map\";\n\nimport { SizeWatcher } from \"@lisn/watchers/size-watcher\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link LayoutWatcher} listens for changes in either the width or aspect\n * ratio of the viewport or the given {@link LayoutWatcherConfig.root | root}.\n *\n * It does not track resize events; rather it's built on top of\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver | IntersectionObserver}.\n *\n * It manages registered callbacks globally and reuses IntersectionObservers\n * for more efficient performance.\n */\nexport class LayoutWatcher {\n  /**\n   * Call the given handler whenever the layout changes.\n   *\n   * Unless {@link OnLayoutOptions.skipInitial} is true, the handler is also\n   * called (almost) immediately with the current layout.\n   *\n   * **IMPORTANT:** The same handler can _not_ be added multiple times, even if\n   * the options differ. If the handler has already been added, it is removed\n   * and re-added with the current options.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the options are invalid.\n   */\n  readonly onLayout: (\n    handler: OnLayoutHandler,\n    options?: OnLayoutOptions,\n  ) => Promise<void>;\n\n  /**\n   * Removes a previously added handler.\n   */\n  readonly offLayout: (handler: OnLayoutHandler) => void;\n\n  /**\n   * Get the current screen layout.\n   */\n  readonly fetchCurrentLayout: () => Promise<LayoutData>;\n\n  /**\n   * Creates a new instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}. It does not save it for future reuse.\n   */\n  static create(config?: LayoutWatcherConfig) {\n    return new LayoutWatcher(getConfig(config), CONSTRUCTOR_KEY);\n  }\n\n  /**\n   * Returns an existing instance of LayoutWatcher with the given\n   * {@link LayoutWatcherConfig}, or creates a new one.\n   *\n   * **NOTE:** It saves it for future reuse, so don't use this for temporary\n   * short-lived watchers.\n   */\n  static reuse(config?: LayoutWatcherConfig) {\n    const myConfig = getConfig(config);\n    const configStrKey = objToStrKey(omitKeys(myConfig, { _root: null }));\n\n    let instance = instances.get(myConfig._root)?.get(configStrKey);\n    if (!instance) {\n      instance = new LayoutWatcher(myConfig, CONSTRUCTOR_KEY);\n      instances.sGet(myConfig._root).set(configStrKey, instance);\n    }\n\n    return instance;\n  }\n\n  private constructor(\n    config: LayoutWatcherConfigInternal,\n    key: typeof CONSTRUCTOR_KEY,\n  ) {\n    if (key !== CONSTRUCTOR_KEY) {\n      throw MH.illegalConstructorError(\"LayoutWatcher.create\");\n    }\n\n    const logger = debug\n      ? new debug.Logger({ name: \"LayoutWatcher\", logAtCreation: config })\n      : null;\n    let nonIntersectingBitmask = 0;\n    let currentLayoutData: LayoutData = {\n      device: null,\n      aspectRatio: null,\n    };\n\n    const allCallbacks = MH.newMap<\n      OnLayoutHandler,\n      {\n        _callback: OnLayoutCallback;\n        _layoutBitmask: number;\n      }\n    >();\n\n    // ----------\n\n    const fetchCurrentLayout = async (): Promise<LayoutData> => {\n      await readyPromise;\n\n      return MH.copyObject(currentLayoutData);\n    };\n\n    // ----------\n\n    const setupOverlays = async () => {\n      const { root, overlays } = await createOverlays(\n        config._root,\n        config._deviceBreakpoints,\n        config._aspectRatioBreakpoints,\n      );\n\n      return MH.newPromise<void>((resolve) => {\n        let isReady = false;\n\n        const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n          const numEntries = MH.lengthOf(entries);\n          debug: logger?.debug9(`Got ${numEntries} new entries`, entries);\n\n          if (!isReady) {\n            /* istanbul ignore next */ // shouldn't happen\n            if (numEntries < NUM_LAYOUTS) {\n              logWarn(\n                MH.bugError(\n                  `Got IntersectionObserver ${numEntries}, ` +\n                    `expected >= ${NUM_LAYOUTS}`,\n                ),\n              );\n            }\n          }\n\n          for (const entry of entries) {\n            nonIntersectingBitmask = getNonIntersecting(\n              nonIntersectingBitmask,\n              entry,\n            );\n          }\n\n          // If this is the initial call from IntersectionObserver, skip callbacks.\n          // Those that have skipInitial: false would be called elsewhere, by\n          // setupOnLayout\n          processLayoutChange(!isReady);\n          isReady = true;\n          resolve(); // ready after IntersectionObserver has called us the 1st time\n        };\n\n        // ----------\n\n        const observeOptions = {\n          root,\n          rootMargin: \"5px 0% 5px -100%\",\n        };\n\n        const observer = MH.newIntersectionObserver(\n          intersectionHandler,\n          observeOptions,\n        );\n\n        for (const triggerOverlay of overlays) {\n          observer.observe(triggerOverlay);\n        }\n      });\n    };\n\n    // ----------\n\n    const createCallback = (\n      handler: OnLayoutHandler,\n      layoutBitmask: number,\n    ): OnLayoutCallback => {\n      MH.remove(allCallbacks.get(handler)?._callback);\n\n      debug: logger?.debug5(\"Adding/updating handler\", layoutBitmask);\n      const callback = wrapCallback(handler);\n      callback.onRemove(() => {\n        deleteHandler(handler);\n      });\n\n      allCallbacks.set(handler, {\n        _callback: callback,\n        _layoutBitmask: layoutBitmask,\n      });\n      return callback;\n    };\n\n    const setupOnLayout = async (\n      handler: OnLayoutHandler,\n      options: OnLayoutOptions | undefined,\n    ) => {\n      const layoutBitmask = getLayoutBitmask(options);\n      const callback = createCallback(handler, layoutBitmask);\n\n      if (options?.skipInitial) {\n        return;\n      }\n\n      const layoutData = await fetchCurrentLayout();\n\n      if (\n        !callback.isRemoved() &&\n        changeMatches(layoutBitmask, layoutData, null)\n      ) {\n        debug: logger?.debug5(\"Calling initially with\", layoutData);\n        await invokeCallback(callback, layoutData);\n      }\n    };\n\n    const deleteHandler = (handler: OnLayoutHandler) => {\n      MH.deleteKey(allCallbacks, handler);\n      // no need to unobserve the overlays\n    };\n\n    const processLayoutChange = (skipCallbacks: boolean) => {\n      const deviceBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_DEVICES.bitmask),\n      );\n\n      const aspectRatioBit = MH.floor(\n        MH.log2(nonIntersectingBitmask & ORDERED_ASPECTR.bitmask),\n      );\n\n      const layoutData: LayoutData = { device: null, aspectRatio: null };\n\n      // -Infinity means all of the overlays are intersecting, which would only\n      // happen if the narrowest overlay is not actually 0-width (which is not the\n      // case by default and against the recommended settings).\n      if (deviceBit !== -MC.INFINITY) {\n        layoutData.device = ORDERED_DEVICES.nameOf(1 << deviceBit);\n      }\n      if (aspectRatioBit !== -MC.INFINITY) {\n        layoutData.aspectRatio = ORDERED_ASPECTR.nameOf(1 << aspectRatioBit);\n      }\n\n      debug: logger?.debug8(\"New layout\", layoutData);\n\n      if (!skipCallbacks) {\n        for (const entry of allCallbacks.values()) {\n          const layoutBitmask = entry._layoutBitmask;\n          if (!changeMatches(layoutBitmask, layoutData, currentLayoutData)) {\n            debug: logger?.debug9(\n              `Layout change does not match bitmask ${layoutBitmask}`,\n            );\n            continue;\n          }\n\n          invokeCallback(entry._callback, layoutData);\n        }\n      }\n\n      currentLayoutData = layoutData;\n    };\n\n    const readyPromise = setupOverlays(); // no need to await\n\n    // ----------\n\n    this.fetchCurrentLayout = fetchCurrentLayout;\n\n    // ----------\n\n    this.onLayout = setupOnLayout;\n\n    // ----------\n\n    this.offLayout = (handler) => {\n      debug: logger?.debug5(\"Removing handler\");\n      MH.remove(allCallbacks.get(handler)?._callback);\n    };\n  }\n}\n\n/**\n * @interface\n */\nexport type LayoutWatcherConfig = {\n  /**\n   * The root element whose layout to watch. If not given or `null`, then the\n   * viewport layout is watched.\n   *\n   * @defaultValue null\n   */\n  root?: HTMLElement | null;\n\n  /**\n   * Use custom device breakpoints. Only known device names ({@link Device})\n   * are supported. If any are missing from the given dictionary, the value\n   * from {@link settings.deviceBreakpoints} is used.\n   *\n   * @defaultValue {@link settings.deviceBreakpoints}\n   */\n  deviceBreakpoints?: typeof settings.deviceBreakpoints;\n\n  /**\n   * Use custom aspect ratio breakpoints. Only known aspect ratio names\n   * ({@link AspectRatio}) are supported. If any are missing from the given\n   * dictionary, the value from {@link settings.aspectRatioBreakpoints} is\n   * used.\n   *\n   * @defaultValue {@link settings.aspectRatioBreakpoints}\n   */\n  aspectRatioBreakpoints?: typeof settings.aspectRatioBreakpoints;\n};\n\n/**\n * @interface\n */\nexport type OnLayoutOptions = {\n  /**\n   * Specifies a list of {@link Device}s to target for.\n   *\n   * The handler will only be called if there is a change of device to a device\n   * matching the specification.\n   *\n   * It can be:\n   * - \"min <Device>\": devices at least as wide as `<Device>`\n   * - \"max <Device>\": devices at most as wide as `<Device>`\n   * - \"<DeviceMin> to <DeviceMax>\": devices at least as wide as `<DeviceMin>`\n   *                                 and at most as wide as `<DeviceMax>`\n   * - a comma-separated list of device names\n   * - an array of device names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * Also note that an empty array is treated the same as not given, or `null`.\n   *\n   * @defaultValue undefined\n   */\n  devices?: DeviceSpec | Device[];\n\n  /**\n   * Specifies a list of {@link AspectRatio}s to target for.\n   *\n   * The handler will only be called if there is a change of aspect ratio to\n   * an aspect ratios matching the specification.\n   *\n   * It can be:\n   * - \"min <AspectRatio>\": aspect ratios at least as wide as `<AspectRatio>`\n   * - \"max <AspectRatio>\": aspect ratios at most as wide as `<AspectRatio>`\n   * - \"<AspectRatioMin> to <AspectRatioMax>\": aspect ratios at least as wide\n   *                        as `<AspectRatioMin>` and at most as wide as\n   *                        `<AspectRatioMax>`\n   * - a comma-separated list of aspect ratio names\n   * - an array of aspect ratio names\n   *\n   * **NOTE**\n   *\n   * If only one of {@link devices} or {@link aspectRatios} is specified, the\n   * handler will only be called for matching changes of device or aspect ratio\n   * respectively.\n   *\n   * If neither is specified, the handler will be called for any change of layout\n   * (device or aspect ratio).\n   *\n   * @defaultValue undefined\n   */\n  aspectRatios?: AspectRatioSpec | AspectRatio[];\n\n  /**\n   * Do not call the handler until there's a future change of layout.\n   *\n   * By default, we call the handler (almost) immediately with the current\n   * layout data if it matches the given {@link devices} and {@link aspectRatios}.\n   *\n   * @defaultValue false\n   */\n  skipInitial?: boolean;\n};\n\n/**\n * The handler is invoked with one argument:\n *\n * - the current {@link LayoutData}\n */\nexport type OnLayoutHandlerArgs = [LayoutData];\nexport type OnLayoutCallback = Callback<OnLayoutHandlerArgs>;\nexport type OnLayoutHandler =\n  | CallbackHandler<OnLayoutHandlerArgs>\n  | OnLayoutCallback;\n\n/**\n * Note that {@link device} or {@link aspectRatio} would only be null if the\n * viewport is narrower than the narrowest device/aspect ratio. This would only\n * happen if the narrowest device/aspect ratio is _not_ 0-width (which is not\n * the case with the default breakpoints and is against the recommendation for\n * setting breakpoints.\n */\nexport type LayoutData = {\n  device: Device | null;\n  aspectRatio: AspectRatio | null;\n};\n\n// ----------------------------------------\n\ntype LayoutWatcherConfigInternal = {\n  _root: HTMLElement | null;\n  _deviceBreakpoints: typeof settings.deviceBreakpoints;\n  _aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints;\n};\n\nconst CONSTRUCTOR_KEY: unique symbol = MC.SYMBOL() as typeof CONSTRUCTOR_KEY;\nconst instances = newXMap<HTMLElement | null, Map<string, LayoutWatcher>>(() =>\n  MH.newMap(),\n);\n\nconst VAR_BORDER_HEIGHT = MH.prefixCssJsVar(\"border-height\");\nconst PREFIX_DEVICE = MH.prefixName(\"device\");\nconst PREFIX_ASPECTR = MH.prefixName(\"aspect-ratio\");\n\nconst getConfig = (\n  config: LayoutWatcherConfig | undefined,\n): LayoutWatcherConfigInternal => {\n  const deviceBreakpoints = MH.copyObject(settings.deviceBreakpoints);\n  if (config?.deviceBreakpoints) {\n    copyExistingKeys(config.deviceBreakpoints, deviceBreakpoints);\n  }\n\n  const aspectRatioBreakpoints = MH.copyObject(settings.aspectRatioBreakpoints);\n\n  if (config?.aspectRatioBreakpoints) {\n    copyExistingKeys(config.aspectRatioBreakpoints, aspectRatioBreakpoints);\n  }\n\n  return {\n    _root: config?.root ?? null,\n    _deviceBreakpoints: deviceBreakpoints,\n    _aspectRatioBreakpoints: aspectRatioBreakpoints,\n  };\n};\n\n// ----------------------------------------\n\nconst createOverlays = async (\n  root: HTMLElement | null,\n  deviceBreakpoints: typeof settings.deviceBreakpoints,\n  aspectRatioBreakpoints: typeof settings.aspectRatioBreakpoints,\n) => {\n  const overlayPromises = [];\n\n  let overlayParent: HTMLElement;\n  if (root) {\n    overlayParent = root;\n  } else {\n    // Since modals remove the scrollbar on the body when active, the width of\n    // the body changes upon open/close of a modal, which would create\n    // glitching if it happens near a device breakpoint. So if the root is the\n    // viewport, we create a fixed positioned container to hold the overlays\n    // and set its width to be 100vw and use that as the root of\n    overlayParent = await createOverlay({\n      style: {\n        position: \"fixed\",\n        [MC.S_WIDTH]: \"100vw\",\n      },\n    });\n  }\n\n  let device: Device;\n  for (device in deviceBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]: deviceBreakpoints[device] + \"px\",\n        },\n        data: {\n          [PREFIX_DEVICE]: device,\n        },\n      }),\n    );\n  }\n\n  const parentHeightCss = root ? `var(${VAR_BORDER_HEIGHT}, 0) * 1px` : \"100vh\";\n  if (root) {\n    SizeWatcher.reuse().trackSize(null, { target: root });\n  }\n\n  let aspectRatio: AspectRatio;\n  for (aspectRatio in aspectRatioBreakpoints) {\n    overlayPromises.push(\n      createOverlay({\n        parent: overlayParent,\n        style: {\n          position: \"absolute\",\n          [MC.S_WIDTH]:\n            `calc(${aspectRatioBreakpoints[aspectRatio]} ` +\n            `* ${parentHeightCss})`,\n        },\n        data: {\n          [PREFIX_ASPECTR]: aspectRatio,\n        },\n      }),\n    );\n  }\n\n  const overlays = await MH.promiseAll(overlayPromises);\n  return { root: overlayParent, overlays };\n};\n\nconst getOverlayLayout = (overlay: HTMLElement): Layout | null => {\n  const layout =\n    getData(overlay, PREFIX_DEVICE) || getData(overlay, PREFIX_ASPECTR);\n  /* istanbul ignore else */\n  if (layout && (ORDERED_DEVICES.has(layout) || ORDERED_ASPECTR.has(layout))) {\n    return layout;\n  } else {\n    // shouldn't happen\n    logError(MH.bugError(\"No device or aspectRatio data attribute\"));\n    return null;\n  }\n};\n\nconst changeMatches = (\n  layoutBitmask: number,\n  thisLayoutData: LayoutData,\n  prevLayoutData: LayoutData | undefined | null,\n): boolean => {\n  // True if the callback is interested in a change of device and there's a\n  // change of device and the new device is one of the ones it's interested in\n  // (or it's null, i.e. device is undefined).\n  // And the same for aspect ratios.\n\n  if (\n    prevLayoutData?.device !== thisLayoutData.device &&\n    (!thisLayoutData.device ||\n      ORDERED_DEVICES.bit[thisLayoutData.device] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  if (\n    prevLayoutData?.aspectRatio !== thisLayoutData.aspectRatio &&\n    (!thisLayoutData.aspectRatio ||\n      ORDERED_ASPECTR.bit[thisLayoutData.aspectRatio] & layoutBitmask)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getNonIntersecting = (\n  nonIntersectingBitmask: number, // current\n  entry: IntersectionObserverEntry,\n): number => {\n  const target = MH.targetOf(entry);\n  /* istanbul ignore next */ // shouldn't happen\n  if (!MH.isHTMLElement(target)) {\n    logError(\n      MH.bugError(\n        `IntersectionObserver called us with '${MH.typeOrClassOf(target)}'`,\n      ),\n    );\n    return nonIntersectingBitmask;\n  }\n\n  const layout = getOverlayLayout(target);\n  let bit = 0;\n  if (!layout) {\n    // error already logged by getOverlayLayout\n  } else if (ORDERED_DEVICES.has(layout)) {\n    bit = ORDERED_DEVICES.bit[layout];\n  } else if (ORDERED_ASPECTR.has(layout)) {\n    bit = ORDERED_ASPECTR.bit[layout];\n  } else {\n    /* istanbul ignore next */ // shouldn't happen\n    logError(\n      MH.bugError(`Unknown device or aspectRatio data attribute: ${layout}`),\n    );\n  }\n\n  if (entry.isIntersecting) {\n    nonIntersectingBitmask &= ~bit;\n  } else {\n    nonIntersectingBitmask |= bit;\n  }\n\n  return nonIntersectingBitmask;\n};\n\nconst invokeCallback = (callback: OnLayoutCallback, layoutData: LayoutData) =>\n  callback.invoke(MH.copyObject(layoutData)).catch(logError);\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAEd,SAASC,QAAQ;AAUjB,SAASC,OAAO;AAChB,SACEC,gBAAgB,EAChBC,WAAW,EACXC,eAAe,EACfC,eAAe;AAEjB,SAASC,QAAQ,EAAEC,OAAO;AAC1B,SAASC,QAAQ,EAAEC,gBAAgB;AACnC,SAASC,aAAa;AACtB,SAASC,WAAW;AAEpB,SAGEC,YAAY;AAEd,SAASC,OAAO;AAEhB,SAASC,WAAW;AAEpB,OAAOC,KAAK;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EA6BzB;AACF;AACA;AACA;EACE,OAAOC,MAAMA,CAACC,MAA4B,EAAE;IAC1C,OAAO,IAAIF,aAAa,CAACG,SAAS,CAACD,MAAM,CAAC,EAAEE,eAAe,CAAC;EAC9D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAKA,CAACH,MAA4B,EAAE;IAAA,IAAAI,cAAA;IACzC,MAAMC,QAAQ,GAAGJ,SAAS,CAACD,MAAM,CAAC;IAClC,MAAMM,YAAY,GAAGb,WAAW,CAACH,QAAQ,CAACe,QAAQ,EAAE;MAAEE,KAAK,EAAE;IAAK,CAAC,CAAC,CAAC;IAErE,IAAIC,QAAQ,IAAAJ,cAAA,GAAGK,SAAS,CAACC,GAAG,CAACL,QAAQ,CAACE,KAAK,CAAC,cAAAH,cAAA,uBAA7BA,cAAA,CAA+BM,GAAG,CAACJ,YAAY,CAAC;IAC/D,IAAI,CAACE,QAAQ,EAAE;MACbA,QAAQ,GAAG,IAAIV,aAAa,CAACO,QAAQ,EAAEH,eAAe,CAAC;MACvDO,SAAS,CAACE,IAAI,CAACN,QAAQ,CAACE,KAAK,CAAC,CAACK,GAAG,CAACN,YAAY,EAAEE,QAAQ,CAAC;IAC5D;IAEA,OAAOA,QAAQ;EACjB;EAEQK,WAAWA,CACjBb,MAAmC,EACnCc,GAA2B,EAC3B;IA3DF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAZEC,eAAA;IAkBA;AACF;AACA;IAFEA,eAAA;IAKA;AACF;AACA;IAFEA,eAAA;IAqCE,IAAID,GAAG,KAAKZ,eAAe,EAAE;MAC3B,MAAMrB,EAAE,CAACmC,uBAAuB,CAAC,sBAAsB,CAAC;IAC1D;IAEA,MAAMC,MAAM,GAAGpB,KAAK,GAChB,IAAIA,KAAK,CAACqB,MAAM,CAAC;MAAEC,IAAI,EAAE,eAAe;MAAEC,aAAa,EAAEpB;IAAO,CAAC,CAAC,GAClE,IAAI;IACR,IAAIqB,sBAAsB,GAAG,CAAC;IAC9B,IAAIC,iBAA6B,GAAG;MAClCC,MAAM,EAAE,IAAI;MACZC,WAAW,EAAE;IACf,CAAC;IAED,MAAMC,YAAY,GAAG5C,EAAE,CAAC6C,MAAM,CAM5B,CAAC;;IAEH;;IAEA,MAAMC,kBAAkB,GAAG,MAAAA,CAAA,KAAiC;MAC1D,MAAMC,YAAY;MAElB,OAAO/C,EAAE,CAACgD,UAAU,CAACP,iBAAiB,CAAC;IACzC,CAAC;;IAED;;IAEA,MAAMQ,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,MAAM;QAAEC,IAAI;QAAEC;MAAS,CAAC,GAAG,MAAMC,cAAc,CAC7CjC,MAAM,CAACO,KAAK,EACZP,MAAM,CAACkC,kBAAkB,EACzBlC,MAAM,CAACmC,uBACT,CAAC;MAED,OAAOtD,EAAE,CAACuD,UAAU,CAAQC,OAAO,IAAK;QACtC,IAAIC,OAAO,GAAG,KAAK;QAEnB,MAAMC,mBAAmB,GAAIC,OAAoC,IAAK;UACpE,MAAMC,UAAU,GAAG5D,EAAE,CAAC6D,QAAQ,CAACF,OAAO,CAAC;UACvC3C,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE0B,MAAM,CAAC,OAAOF,UAAU,cAAc,EAAED,OAAO,CAAC;UAE/D,IAAI,CAACF,OAAO,EAAE;YACZ,2BAA2B;YAC3B,IAAIG,UAAU,GAAGxD,WAAW,EAAE;cAC5BI,OAAO,CACLR,EAAE,CAAC+D,QAAQ,CACT,4BAA4BH,UAAU,IAAI,GACxC,eAAexD,WAAW,EAC9B,CACF,CAAC;YACH;UACF;UAEA,KAAK,MAAM4D,KAAK,IAAIL,OAAO,EAAE;YAC3BnB,sBAAsB,GAAGyB,kBAAkB,CACzCzB,sBAAsB,EACtBwB,KACF,CAAC;UACH;;UAEA;UACA;UACA;UACAE,mBAAmB,CAAC,CAACT,OAAO,CAAC;UAC7BA,OAAO,GAAG,IAAI;UACdD,OAAO,CAAC,CAAC,CAAC,CAAC;QACb,CAAC;;QAED;;QAEA,MAAMW,cAAc,GAAG;UACrBjB,IAAI;UACJkB,UAAU,EAAE;QACd,CAAC;QAED,MAAMC,QAAQ,GAAGrE,EAAE,CAACsE,uBAAuB,CACzCZ,mBAAmB,EACnBS,cACF,CAAC;QAED,KAAK,MAAMI,cAAc,IAAIpB,QAAQ,EAAE;UACrCkB,QAAQ,CAACG,OAAO,CAACD,cAAc,CAAC;QAClC;MACF,CAAC,CAAC;IACJ,CAAC;;IAED;;IAEA,MAAME,cAAc,GAAGA,CACrBC,OAAwB,EACxBC,aAAqB,KACA;MAAA,IAAAC,iBAAA;MACrB5E,EAAE,CAAC6E,MAAM,EAAAD,iBAAA,GAAChC,YAAY,CAACf,GAAG,CAAC6C,OAAO,CAAC,cAAAE,iBAAA,uBAAzBA,iBAAA,CAA2BE,SAAS,CAAC;MAE/C9D,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE2C,MAAM,CAAC,yBAAyB,EAAEJ,aAAa,CAAC;MAC/D,MAAMK,QAAQ,GAAGnE,YAAY,CAAC6D,OAAO,CAAC;MACtCM,QAAQ,CAACC,QAAQ,CAAC,MAAM;QACtBC,aAAa,CAACR,OAAO,CAAC;MACxB,CAAC,CAAC;MAEF9B,YAAY,CAACb,GAAG,CAAC2C,OAAO,EAAE;QACxBI,SAAS,EAAEE,QAAQ;QACnBG,cAAc,EAAER;MAClB,CAAC,CAAC;MACF,OAAOK,QAAQ;IACjB,CAAC;IAED,MAAMI,aAAa,GAAG,MAAAA,CACpBV,OAAwB,EACxBW,OAAoC,KACjC;MACH,MAAMV,aAAa,GAAGxE,gBAAgB,CAACkF,OAAO,CAAC;MAC/C,MAAML,QAAQ,GAAGP,cAAc,CAACC,OAAO,EAAEC,aAAa,CAAC;MAEvD,IAAIU,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEC,WAAW,EAAE;QACxB;MACF;MAEA,MAAMC,UAAU,GAAG,MAAMzC,kBAAkB,CAAC,CAAC;MAE7C,IACE,CAACkC,QAAQ,CAACQ,SAAS,CAAC,CAAC,IACrBC,aAAa,CAACd,aAAa,EAAEY,UAAU,EAAE,IAAI,CAAC,EAC9C;QACAvE,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE2C,MAAM,CAAC,wBAAwB,EAAEQ,UAAU,CAAC;QAC3D,MAAMG,cAAc,CAACV,QAAQ,EAAEO,UAAU,CAAC;MAC5C;IACF,CAAC;IAED,MAAML,aAAa,GAAIR,OAAwB,IAAK;MAClD1E,EAAE,CAAC2F,SAAS,CAAC/C,YAAY,EAAE8B,OAAO,CAAC;MACnC;IACF,CAAC;IAED,MAAMR,mBAAmB,GAAI0B,aAAsB,IAAK;MACtD,MAAMC,SAAS,GAAG7F,EAAE,CAAC8F,KAAK,CACxB9F,EAAE,CAAC+F,IAAI,CAACvD,sBAAsB,GAAGnC,eAAe,CAAC2F,OAAO,CAC1D,CAAC;MAED,MAAMC,cAAc,GAAGjG,EAAE,CAAC8F,KAAK,CAC7B9F,EAAE,CAAC+F,IAAI,CAACvD,sBAAsB,GAAGlC,eAAe,CAAC0F,OAAO,CAC1D,CAAC;MAED,MAAMT,UAAsB,GAAG;QAAE7C,MAAM,EAAE,IAAI;QAAEC,WAAW,EAAE;MAAK,CAAC;;MAElE;MACA;MACA;MACA,IAAIkD,SAAS,KAAK,CAAC9F,EAAE,CAACmG,QAAQ,EAAE;QAC9BX,UAAU,CAAC7C,MAAM,GAAGrC,eAAe,CAAC8F,MAAM,CAAC,CAAC,IAAIN,SAAS,CAAC;MAC5D;MACA,IAAII,cAAc,KAAK,CAAClG,EAAE,CAACmG,QAAQ,EAAE;QACnCX,UAAU,CAAC5C,WAAW,GAAGrC,eAAe,CAAC6F,MAAM,CAAC,CAAC,IAAIF,cAAc,CAAC;MACtE;MAEAjF,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAEgE,MAAM,CAAC,YAAY,EAAEb,UAAU,CAAC;MAE/C,IAAI,CAACK,aAAa,EAAE;QAClB,KAAK,MAAM5B,KAAK,IAAIpB,YAAY,CAACyD,MAAM,CAAC,CAAC,EAAE;UACzC,MAAM1B,aAAa,GAAGX,KAAK,CAACmB,cAAc;UAC1C,IAAI,CAACM,aAAa,CAACd,aAAa,EAAEY,UAAU,EAAE9C,iBAAiB,CAAC,EAAE;YAChEzB,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE0B,MAAM,CACnB,wCAAwCa,aAAa,EACvD,CAAC;YACD;UACF;UAEAe,cAAc,CAAC1B,KAAK,CAACc,SAAS,EAAES,UAAU,CAAC;QAC7C;MACF;MAEA9C,iBAAiB,GAAG8C,UAAU;IAChC,CAAC;IAED,MAAMxC,YAAY,GAAGE,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEtC;;IAEA,IAAI,CAACH,kBAAkB,GAAGA,kBAAkB;;IAE5C;;IAEA,IAAI,CAACwD,QAAQ,GAAGlB,aAAa;;IAE7B;;IAEA,IAAI,CAACmB,SAAS,GAAI7B,OAAO,IAAK;MAAA,IAAA8B,kBAAA;MAC5BxF,KAAK,EAAEoB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE2C,MAAM,CAAC,kBAAkB,CAAC;MACzC/E,EAAE,CAAC6E,MAAM,EAAA2B,kBAAA,GAAC5D,YAAY,CAACf,GAAG,CAAC6C,OAAO,CAAC,cAAA8B,kBAAA,uBAAzBA,kBAAA,CAA2B1B,SAAS,CAAC;IACjD,CAAC;EACH;AACF;;AAEA;AACA;AACA;;AA8BA;AACA;AACA;;AAsEA;AACA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;;AAQA,MAAMzD,eAA8B,GAAGtB,EAAE,CAAC0G,MAAM,CAAC,CAA2B;AAC5E,MAAM7E,SAAS,GAAGd,OAAO,CAAiD,MACxEd,EAAE,CAAC6C,MAAM,CAAC,CACZ,CAAC;AAED,MAAM6D,iBAAiB,GAAG1G,EAAE,CAAC2G,cAAc,CAAC,eAAe,CAAC;AAC5D,MAAMC,aAAa,GAAG5G,EAAE,CAAC6G,UAAU,CAAC,QAAQ,CAAC;AAC7C,MAAMC,cAAc,GAAG9G,EAAE,CAAC6G,UAAU,CAAC,cAAc,CAAC;AAEpD,MAAMzF,SAAS,GACbD,MAAuC,IACP;EAAA,IAAA4F,YAAA;EAChC,MAAMC,iBAAiB,GAAGhH,EAAE,CAACgD,UAAU,CAAC/C,QAAQ,CAAC+G,iBAAiB,CAAC;EACnE,IAAI7F,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE6F,iBAAiB,EAAE;IAC7BtG,gBAAgB,CAACS,MAAM,CAAC6F,iBAAiB,EAAEA,iBAAiB,CAAC;EAC/D;EAEA,MAAMC,sBAAsB,GAAGjH,EAAE,CAACgD,UAAU,CAAC/C,QAAQ,CAACgH,sBAAsB,CAAC;EAE7E,IAAI9F,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE8F,sBAAsB,EAAE;IAClCvG,gBAAgB,CAACS,MAAM,CAAC8F,sBAAsB,EAAEA,sBAAsB,CAAC;EACzE;EAEA,OAAO;IACLvF,KAAK,GAAAqF,YAAA,GAAE5F,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE+B,IAAI,cAAA6D,YAAA,cAAAA,YAAA,GAAI,IAAI;IAC3B1D,kBAAkB,EAAE2D,iBAAiB;IACrC1D,uBAAuB,EAAE2D;EAC3B,CAAC;AACH,CAAC;;AAED;;AAEA,MAAM7D,cAAc,GAAG,MAAAA,CACrBF,IAAwB,EACxB8D,iBAAoD,EACpDC,sBAA8D,KAC3D;EACH,MAAMC,eAAe,GAAG,EAAE;EAE1B,IAAIC,aAA0B;EAC9B,IAAIjE,IAAI,EAAE;IACRiE,aAAa,GAAGjE,IAAI;EACtB,CAAC,MAAM;IACL;IACA;IACA;IACA;IACA;IACAiE,aAAa,GAAG,MAAMxG,aAAa,CAAC;MAClCyG,KAAK,EAAE;QACLC,QAAQ,EAAE,OAAO;QACjB,CAACtH,EAAE,CAACuH,OAAO,GAAG;MAChB;IACF,CAAC,CAAC;EACJ;EAEA,IAAI5E,MAAc;EAClB,KAAKA,MAAM,IAAIsE,iBAAiB,EAAE;IAChCE,eAAe,CAACK,IAAI,CAClB5G,aAAa,CAAC;MACZ6G,MAAM,EAAEL,aAAa;MACrBC,KAAK,EAAE;QACLC,QAAQ,EAAE,UAAU;QACpB,CAACtH,EAAE,CAACuH,OAAO,GAAGN,iBAAiB,CAACtE,MAAM,CAAC,GAAG;MAC5C,CAAC;MACD+E,IAAI,EAAE;QACJ,CAACb,aAAa,GAAGlE;MACnB;IACF,CAAC,CACH,CAAC;EACH;EAEA,MAAMgF,eAAe,GAAGxE,IAAI,GAAG,OAAOwD,iBAAiB,YAAY,GAAG,OAAO;EAC7E,IAAIxD,IAAI,EAAE;IACRnC,WAAW,CAACO,KAAK,CAAC,CAAC,CAACqG,SAAS,CAAC,IAAI,EAAE;MAAEC,MAAM,EAAE1E;IAAK,CAAC,CAAC;EACvD;EAEA,IAAIP,WAAwB;EAC5B,KAAKA,WAAW,IAAIsE,sBAAsB,EAAE;IAC1CC,eAAe,CAACK,IAAI,CAClB5G,aAAa,CAAC;MACZ6G,MAAM,EAAEL,aAAa;MACrBC,KAAK,EAAE;QACLC,QAAQ,EAAE,UAAU;QACpB,CAACtH,EAAE,CAACuH,OAAO,GACT,QAAQL,sBAAsB,CAACtE,WAAW,CAAC,GAAG,GAC9C,KAAK+E,eAAe;MACxB,CAAC;MACDD,IAAI,EAAE;QACJ,CAACX,cAAc,GAAGnE;MACpB;IACF,CAAC,CACH,CAAC;EACH;EAEA,MAAMQ,QAAQ,GAAG,MAAMnD,EAAE,CAAC6H,UAAU,CAACX,eAAe,CAAC;EACrD,OAAO;IAAEhE,IAAI,EAAEiE,aAAa;IAAEhE;EAAS,CAAC;AAC1C,CAAC;AAED,MAAM2E,gBAAgB,GAAIC,OAAoB,IAAoB;EAChE,MAAMC,MAAM,GACV9H,OAAO,CAAC6H,OAAO,EAAEnB,aAAa,CAAC,IAAI1G,OAAO,CAAC6H,OAAO,EAAEjB,cAAc,CAAC;EACrE;EACA,IAAIkB,MAAM,KAAK3H,eAAe,CAAC4H,GAAG,CAACD,MAAM,CAAC,IAAI1H,eAAe,CAAC2H,GAAG,CAACD,MAAM,CAAC,CAAC,EAAE;IAC1E,OAAOA,MAAM;EACf,CAAC,MAAM;IACL;IACAzH,QAAQ,CAACP,EAAE,CAAC+D,QAAQ,CAAC,yCAAyC,CAAC,CAAC;IAChE,OAAO,IAAI;EACb;AACF,CAAC;AAED,MAAM0B,aAAa,GAAGA,CACpBd,aAAqB,EACrBuD,cAA0B,EAC1BC,cAA6C,KACjC;EACZ;EACA;EACA;EACA;;EAEA,IACE,CAAAA,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEzF,MAAM,MAAKwF,cAAc,CAACxF,MAAM,KAC/C,CAACwF,cAAc,CAACxF,MAAM,IACrBrC,eAAe,CAAC+H,GAAG,CAACF,cAAc,CAACxF,MAAM,CAAC,GAAGiC,aAAa,CAAC,EAC7D;IACA,OAAO,IAAI;EACb;EAEA,IACE,CAAAwD,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAExF,WAAW,MAAKuF,cAAc,CAACvF,WAAW,KACzD,CAACuF,cAAc,CAACvF,WAAW,IAC1BrC,eAAe,CAAC8H,GAAG,CAACF,cAAc,CAACvF,WAAW,CAAC,GAAGgC,aAAa,CAAC,EAClE;IACA,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;AAED,MAAMV,kBAAkB,GAAGA,CACzBzB,sBAA8B,EAC9BwB,KAAgC,KACrB;EACX,MAAM4D,MAAM,GAAG5H,EAAE,CAACqI,QAAQ,CAACrE,KAAK,CAAC;EACjC,2BAA2B;EAC3B,IAAI,CAAChE,EAAE,CAACsI,aAAa,CAACV,MAAM,CAAC,EAAE;IAC7BrH,QAAQ,CACNP,EAAE,CAAC+D,QAAQ,CACT,wCAAwC/D,EAAE,CAACuI,aAAa,CAACX,MAAM,CAAC,GAClE,CACF,CAAC;IACD,OAAOpF,sBAAsB;EAC/B;EAEA,MAAMwF,MAAM,GAAGF,gBAAgB,CAACF,MAAM,CAAC;EACvC,IAAIQ,GAAG,GAAG,CAAC;EACX,IAAI,CAACJ,MAAM,EAAE;IACX;EAAA,CACD,MAAM,IAAI3H,eAAe,CAAC4H,GAAG,CAACD,MAAM,CAAC,EAAE;IACtCI,GAAG,GAAG/H,eAAe,CAAC+H,GAAG,CAACJ,MAAM,CAAC;EACnC,CAAC,MAAM,IAAI1H,eAAe,CAAC2H,GAAG,CAACD,MAAM,CAAC,EAAE;IACtCI,GAAG,GAAG9H,eAAe,CAAC8H,GAAG,CAACJ,MAAM,CAAC;EACnC,CAAC,MAAM;IACL,2BAA2B;IAC3BzH,QAAQ,CACNP,EAAE,CAAC+D,QAAQ,CAAC,iDAAiDiE,MAAM,EAAE,CACvE,CAAC;EACH;EAEA,IAAIhE,KAAK,CAACwE,cAAc,EAAE;IACxBhG,sBAAsB,IAAI,CAAC4F,GAAG;EAChC,CAAC,MAAM;IACL5F,sBAAsB,IAAI4F,GAAG;EAC/B;EAEA,OAAO5F,sBAAsB;AAC/B,CAAC;AAED,MAAMkD,cAAc,GAAGA,CAACV,QAA0B,EAAEO,UAAsB,KACxEP,QAAQ,CAACyD,MAAM,CAACzI,EAAE,CAACgD,UAAU,CAACuC,UAAU,CAAC,CAAC,CAACmD,KAAK,CAACnI,QAAQ,CAAC","ignoreList":[]}