{"version":3,"file":"trigger.js","names":["MC","MH","LisnUsageError","wrapCallback","getData","waitForReferenceElement","waitForDelay","formatAsString","randId","splitOn","validateString","validateNumber","validateBoolean","fetchAction","Widget","registerWidget","fetchWidgetConfig","debug","Trigger","get","element","id","instance","isInstanceOf","register","registerTrigger","a","actions","config","constructor","_config$once","_config$oneWay","_config$delay","_config$doDelay","_config$undoDelay","_defineProperty","logger","Logger","name","logAtCreation","once","oneWay","delay","doDelay","undoDelay","lastCallId","toggleState","callActions","callFn","newToggleState","isDisabled","myCallId","debug10","action","destroy","run","do","reverse","undo","toggle","S_TOGGLE","onDestroy","debug5","remove","invoke","getActions","getConfig","copyObject","newTrigger","configValidator","clsPref","prefixName","newWidget","_getData","widgets","baseConfigValidator","newBaseConfigValidator","thisConfigValidator","isFunction","allSpecs","TRIGGER_SEP","cls","classList","startsWith","push","slice","lengthOf","spec","_config$actOn","tmp","configSpec","OPTION_PREF_CHAR","argSpec","allActionSpecs","ACTION_PREF_CHAR","args","filterBlank","assign","actionTarget","actOn","actionSpec","actionArgsAndOptions","ACTION_ARGS_PREF_CHAR","err","selector","key","value","_ref","isLiteralString","undefined"],"sources":["../../../src/ts/triggers/trigger.ts"],"sourcesContent":["/**\n * ## Specification for the HTML API for triggers\n *\n * The following describes the general syntax when using the HTML API and\n * automatic widgets\n * ({@link Settings.settings.autoWidgets | settings.autoWidgets} is true)\n * specifically for triggers and actions.\n *\n * A trigger specification should be given as a\n * `data-lisn-on-<TriggerName>=\"<TriggerSpecList>\"` attribute.\n * A fallback option of using a CSS class of the form\n * `lisn-on-<TriggerName>--<TriggerSpec>` is also supported but not recommended.\n *\n * The general specification for a trigger is of the form:\n *\n * ```\n * <TriggerSpecList> ::= <TriggerSpec> { \";\" <TriggerSpec> }\n *\n * <TriggerSpec> ::= [ <TriggerArg> { \",\" <TriggerArg> } ]\n *                   \"@\" <ActionSpec> { \"@\" <ActionSpec> }\n *                   { \"+\" <TriggerOption> }\n *\n * <TriggerOption> ::=\n *     <BooleanOptionName> [ \"=\" ( \"false\" | \"true\" ) ] |\n *     <OptionName> \"=\" <OptionValue>\n *\n * <ActionSpec> ::= <ActionName> [ \":\" <ActionArgOrOption> { \",\" <ActionArgOrOption> } ]\n *\n * <ActionArgOrOption> ::= <ActionArg> | <OptionName> \"=\" <OptionValue>\n * ```\n *\n * where `<TriggerArg>` is the particular trigger's main argument, which could\n * be required or optional (and not all triggers accept an argument). See each\n * trigger's specification for their arguments and options.\n *\n * Also refer to each action for their accepted arguments and/or options if any.\n *\n * **NOTE:**\n *\n * There can be 0 or more spaces around any of the separator characters.\n *\n * At least one action (with a preceding \"@\" character) is always required.\n *\n * The characters \";\", \",\", \"=\", \"@\", \"+\" and \":\" are reserved separators and\n * cannot be used literally as part of an argument or option value.\n *\n * @module Triggers\n *\n * @categoryDescription Manual run\n * {@link Trigger} is the base trigger class that you can extend when building\n * custom triggers and it also registers a trigger that needs to be run\n * manually (by e.g. the {@link Actions.Run | Run} action).\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { LisnUsageError } from \"@lisn/globals/errors\";\n\nimport { wrapCallback } from \"@lisn/modules/callback\";\n\nimport { getData } from \"@lisn/utils/css-alter\";\nimport { waitForReferenceElement } from \"@lisn/utils/dom-search\";\nimport { waitForDelay } from \"@lisn/utils/tasks\";\nimport { formatAsString, randId, splitOn } from \"@lisn/utils/text\";\nimport {\n  validateString,\n  validateNumber,\n  validateBoolean,\n} from \"@lisn/utils/validation\";\n\nimport { Action, fetchAction } from \"@lisn/actions/action\";\n\nimport {\n  Widget,\n  WidgetConfigValidator,\n  WidgetConfigValidatorFunc,\n  WidgetConfigAsyncValidatorObject,\n  registerWidget,\n  fetchWidgetConfig,\n} from \"@lisn/widgets/widget\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * {@link Trigger} is the base trigger class that you can extend when building\n * custom triggers and it also registers a trigger that needs to be run\n * manually (by e.g. the {@link Actions.Run | Run} action).\n *\n * -------\n *\n * To use with auto-widgets (HTML API), see {@link registerTrigger} for the\n * specification.\n *\n * @example\n * Show the element 1000ms after the first time the trigger is run.\n *\n * ```html\n * <div data-lisn-on-run=\"@show +once +delay=1000\"></div>\n * ```\n *\n * @category Manual run\n */\nexport class Trigger extends Widget {\n  /**\n   * \"Do\"es all the {@link Action}s linked to the trigger.\n   */\n  readonly run: () => Promise<void>;\n\n  /**\n   * \"Undo\"es all the {@link Action}s linked to the trigger.\n   */\n  readonly reverse: () => Promise<void>;\n\n  /**\n   * \"Toggle\"s all the {@link Action}s linked to the trigger.\n   */\n  readonly toggle: () => Promise<void>;\n\n  /**\n   * Returns the trigger's actions.\n   */\n  readonly getActions: () => Action[];\n\n  /**\n   * Returns the trigger config.\n   */\n  readonly getConfig: () => TriggerConfig;\n\n  static get(element: Element, id: string): Trigger | null {\n    const instance = super.get(element, id);\n    if (MH.isInstanceOf(instance, Trigger)) {\n      return instance;\n    }\n    return null;\n  }\n\n  static register() {\n    registerTrigger(\n      \"run\",\n      (element, a, actions, config) => new Trigger(element, actions, config),\n      {},\n    );\n  }\n\n  /**\n   * If no actions are supplied, nothing is done.\n   *\n   * @throws {@link Errors.LisnUsageError | LisnUsageError}\n   *                If the config is invalid.\n   */\n  constructor(element: Element, actions: Action[], config?: TriggerConfig) {\n    super(element, config);\n\n    const logger = debug\n      ? new debug.Logger({\n          name: `Trigger-${formatAsString(element)}`,\n          logAtCreation: { actions, config },\n        })\n      : null;\n\n    const once = config?.once ?? false;\n    const oneWay = config?.oneWay ?? false;\n    const delay = config?.delay ?? 0;\n    const doDelay = config?.doDelay ?? delay;\n    const undoDelay = config?.undoDelay ?? delay;\n\n    let lastCallId: string;\n    // false if next should be do; true if next should be undo.\n    // Used for determining delays only.\n    let toggleState = false;\n\n    const callActions = async (\n      delay: number,\n      callFn: (action: Action) => void,\n      newToggleState: boolean,\n    ) => {\n      if (this.isDisabled()) {\n        return;\n      }\n\n      const myCallId = randId();\n      lastCallId = myCallId;\n      debug: logger?.debug10(\n        `callActions [${myCallId}] (new toggle state ${newToggleState})`,\n        callFn,\n      );\n\n      if (delay) {\n        await waitForDelay(delay);\n        if (lastCallId !== myCallId) {\n          // overriden by subsequent call\n          debug: logger?.debug10(\n            `callActions [${myCallId}]: overriden by ${lastCallId}`,\n          );\n          return;\n        }\n      }\n\n      for (const action of actions) {\n        debug: logger?.debug10(`callActions [${myCallId}]`, action);\n        callFn(action);\n      }\n\n      toggleState = newToggleState;\n\n      if (toggleState && once) {\n        this.destroy();\n      }\n    };\n\n    const run = wrapCallback(() => {\n      callActions(\n        doDelay,\n        (action) => {\n          action.do();\n        },\n        true,\n      ); // don't await\n    });\n\n    const reverse = wrapCallback(() => {\n      if (!oneWay) {\n        callActions(\n          undoDelay,\n          (action) => {\n            action.undo();\n          },\n          false,\n        ); // don't await\n      }\n    });\n\n    const toggle = wrapCallback(() => {\n      callActions(\n        toggleState ? undoDelay : doDelay,\n        (action) => {\n          action[MC.S_TOGGLE]();\n        },\n        !toggleState,\n      ); // don't await\n    });\n\n    // ----------\n\n    this.onDestroy(() => {\n      debug: logger?.debug5(\"Removing callbacks\");\n      MH.remove(run);\n      MH.remove(reverse);\n      MH.remove(toggle);\n    });\n\n    this.run = run.invoke;\n    this.reverse = reverse.invoke;\n    this[MC.S_TOGGLE] = oneWay ? run.invoke : toggle.invoke;\n    this.getActions = () => [...actions]; // copy\n    this.getConfig = () => MH.copyObject(config);\n  }\n}\n\n/**\n * @interface\n */\nexport type TriggerConfig = {\n  /**\n   * An ID for the trigger so that it can be looked up by ID. It has to be\n   * unique for each element, but you can use the same ID on different\n   * elements.\n   *\n   * @defaultValue undefined\n   */\n  id?: string;\n\n  /**\n   * If true, the trigger will run at most once. This will result in the `run`\n   * or `toggle` methods removing all three of `run`, `reverse` and `toggle`\n   * when called, so that the actions are done at most once.\n   *\n   * @defaultValue false\n   */\n  once?: boolean;\n\n  /**\n   * If true, then the `reverse` method of the trigger will do nothing and the\n   * `toggle` method will always do the actions, i.e. will be equivalent to\n   * `run`.\n   *\n   * @defaultValue false\n   */\n  oneWay?: boolean;\n\n  /**\n   * Delay in milliseconds before doing, undoing or toggling actions.\n   *\n   * @defaultValue 0\n   */\n  delay?: number;\n\n  /**\n   * Delay in milliseconds before doing actions.\n   *\n   * @defaultValue {@link TriggerConfig.delay}\n   */\n  doDelay?: number;\n\n  /**\n   * Delay in milliseconds before undoing actions.\n   *\n   * @defaultValue {@link TriggerConfig.delay}\n   */\n  undoDelay?: number;\n\n  /**\n   * The element to instantiate all actions on this trigger for.\n   *\n   * @defaultValue The element on which the {@link Trigger} is defined\n   */\n  actOn?: Element;\n};\n\nexport type TriggerCreateFn<Config extends TriggerConfig> = (\n  element: Element,\n  args: string[],\n  actions: Action[],\n  config: Config,\n) => Trigger | Promise<Trigger>;\n\n/**\n * Registers the given trigger as a widget to be automatically configured for\n * all elements that have a trigger specification with the given name.\n *\n * A trigger specification can be given as a\n * `data-lisn-on-<TriggerName>=\"<TriggerSpec> { \";\" <TriggerSpec> }\"` attribute\n * or as one or more `lisn-on-<TriggerName>--<TriggerSpec>` classes.\n *\n * See the top of the {@link Triggers} page for an explanation of `<TriggerSpec>`.\n *\n * Using classes instead of attributes is not recommended and only available as\n * a fallback option.\n *\n * **IMPORTANT:** If a trigger by that name is already registered, the current\n * call does nothing, even if the remaining arguments differ.\n *\n * @param name       The name of the trigger. Should be in kebab-case.\n * @param newTrigger Called for every trigger specification on any element\n *                   that has one or more trigger specifications.\n * @param configValidator\n *                   A validator object, or a function that returns such an\n *                   object, for all options that are specific to the\n *                   trigger. Base options (in {@link TriggerConfig}) will\n *                   be parsed automatically and don't need to be handled by\n *                   `configValidator`.\n *                   If the parameter is a function, it will be called with\n *                   the element on which the trigger is being defined.\n *\n * @see {@link registerWidget}\n */\nexport const registerTrigger = <Config extends TriggerConfig = TriggerConfig>(\n  name: string,\n  newTrigger: TriggerCreateFn<Config>,\n  configValidator?: null | WidgetConfigValidator<Config>,\n) => {\n  const clsPref = MH.prefixName(`on-${name}`);\n\n  const newWidget = async (element: Element) => {\n    const widgets: Widget[] = [];\n    const baseConfigValidator = newBaseConfigValidator(element);\n    const thisConfigValidator = MH.isFunction(configValidator)\n      ? await configValidator(element)\n      : configValidator;\n\n    const allSpecs = splitOn(\n      getData(element, MH.prefixName(`on-${name}`)) ?? \"\",\n      TRIGGER_SEP,\n      true,\n    );\n\n    for (const cls of MH.classList(element)) {\n      if (cls.startsWith(`${clsPref}--`)) {\n        allSpecs.push(cls.slice(MH.lengthOf(clsPref) + 2));\n      }\n    }\n\n    for (const spec of allSpecs) {\n      const [tmp, configSpec] = splitOn(spec, OPTION_PREF_CHAR, true, 1);\n      const [argSpec, allActionSpecs] = splitOn(tmp, ACTION_PREF_CHAR, true, 1);\n\n      const args = MH.filterBlank(splitOn(argSpec, \",\", true)) || [];\n\n      const config = await fetchWidgetConfig(\n        configSpec,\n        MH.assign(\n          baseConfigValidator,\n          thisConfigValidator,\n        ) as WidgetConfigAsyncValidatorObject<Required<TriggerConfig> & Config>,\n        OPTION_PREF_CHAR,\n      );\n\n      const actionTarget = config.actOn ?? element;\n\n      const actions = [];\n      for (const actionSpec of splitOn(\n        allActionSpecs ?? \"\",\n        ACTION_PREF_CHAR,\n        true,\n      )) {\n        const [name, actionArgsAndOptions] = splitOn(\n          actionSpec,\n          ACTION_ARGS_PREF_CHAR,\n          true,\n          1,\n        );\n\n        try {\n          actions.push(\n            await fetchAction(actionTarget, name, actionArgsAndOptions ?? \"\"),\n          );\n        } catch (err) {\n          if (MH.isInstanceOf(err, LisnUsageError)) {\n            // fetchAction would have logged an error\n            continue;\n          }\n\n          throw err;\n        }\n      }\n\n      widgets.push(await newTrigger(element, args, actions, config));\n    }\n\n    return widgets;\n  };\n\n  registerWidget(name, newWidget, null, {\n    selector: `[class^=\"${clsPref}--\"],[class*=\" ${clsPref}--\"],[data-${clsPref}]`,\n  });\n};\n\n// --------------------\n\nconst TRIGGER_SEP = \";\";\nconst OPTION_PREF_CHAR = \"+\";\nconst ACTION_PREF_CHAR = \"@\";\nconst ACTION_ARGS_PREF_CHAR = \":\";\n\nconst newBaseConfigValidator: WidgetConfigValidatorFunc<TriggerConfig> = (\n  element,\n) => {\n  return {\n    id: validateString,\n    once: validateBoolean,\n    oneWay: validateBoolean,\n    delay: validateNumber,\n    doDelay: validateNumber,\n    undoDelay: validateNumber,\n    actOn: (key, value) =>\n      (MH.isLiteralString(value)\n        ? waitForReferenceElement(value, element)\n        : null) ?? undefined,\n  };\n};\n"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAEd,SAASC,cAAc;AAEvB,SAASC,YAAY;AAErB,SAASC,OAAO;AAChB,SAASC,uBAAuB;AAChC,SAASC,YAAY;AACrB,SAASC,cAAc,EAAEC,MAAM,EAAEC,OAAO;AACxC,SACEC,cAAc,EACdC,cAAc,EACdC,eAAe;AAGjB,SAAiBC,WAAW;AAE5B,SACEC,MAAM,EAINC,cAAc,EACdC,iBAAiB;AAGnB,OAAOC,KAAK;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,SAASJ,MAAM,CAAC;EA0BlC,OAAOK,GAAGA,CAACC,OAAgB,EAAEC,EAAU,EAAkB;IACvD,MAAMC,QAAQ,GAAG,KAAK,CAACH,GAAG,CAACC,OAAO,EAAEC,EAAE,CAAC;IACvC,IAAIpB,EAAE,CAACsB,YAAY,CAACD,QAAQ,EAAEJ,OAAO,CAAC,EAAE;MACtC,OAAOI,QAAQ;IACjB;IACA,OAAO,IAAI;EACb;EAEA,OAAOE,QAAQA,CAAA,EAAG;IAChBC,eAAe,CACb,KAAK,EACL,CAACL,OAAO,EAAEM,CAAC,EAAEC,OAAO,EAAEC,MAAM,KAAK,IAAIV,OAAO,CAACE,OAAO,EAAEO,OAAO,EAAEC,MAAM,CAAC,EACtE,CAAC,CACH,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACT,OAAgB,EAAEO,OAAiB,EAAEC,MAAsB,EAAE;IAAA,IAAAE,YAAA,EAAAC,cAAA,EAAAC,aAA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","ignoreList":[]}