{"version":3,"file":"same-height.js","names":["MC","MH","settings","addClasses","removeClasses","getData","setData","delData","setNumericStyleJsVars","getComputedStyleProp","getVisibleContentChildren","logError","isValidNum","toNumWithBounds","quadraticRoots","formatAsString","validateNumber","SizeWatcher","Widget","registerWidget","getDefaultWidgetSelector","debug","SameHeight","get","containerElement","instance","DUMMY_ID","isInstanceOf","register","WIDGET_NAME","element","config","isHTMLElement","usageError","configValidator","constructor","_SameHeight$get","destroyPromise","destroy","id","_defineProperty","items","getItemsFrom","sizeOf","item","keys","parentOf","fetchConfig","then","fullConfig","promiseResolve","isDestroyed","init","toColumn","PREFIX_ORIENTATION","S_VERTICAL","toRow","getItems","getItemConfigs","newMap","entries","PREFIXED_NAME","prefixName","PREFIX_ROOT","PREFIX_ITEM","PREFIX_ITEM__FOR_SELECT","S_TEXT","S_IMAGE","MIN_CHARS_FOR_TEXT","diffTolerance","resizeThreshold","S_DEBOUNCE_WINDOW","minGap","maxFreeR","maxWidthR","isText","lengthOf","innerText","areImagesLoaded","img","querySelectorAll","naturalWidth","width","naturalHeight","height","userConfig","_userConfig$minGap","_userConfig$maxFreeR","_userConfig$maxWidthR","_userConfig$diffToler","_userConfig$resizeThr","_userConfig$debounceW","colGapStr","getNumValue","strReplace","sameHeightMinGap","_minGap","min","_maxFreeR","sameHeightMaxFreeR","max","_maxWidthR","sameHeightMaxWidthR","_diffTolerance","sameHeightDiffTolerance","_resizeThreshold","sameHeightResizeThreshold","_debounceWindow","debounceWindow","sameHeightDebounceWindow","strValue","defaultValue","num","parseFloat","NaN","isNaN","findItems","push","inputItems","itemMap","addItem","itemType","set","isArray","Map","widget","logger","Logger","name","sizeWatcher","reuse","allItems","callCounter","isFirstTime","lastOptimalHeight","hasScheduledReset","counterTimeout","resizeHandler","sizeData","debug7","setTimer","clearTimer","measurements","calculateMeasurements","getOptimalHeight","abs","setWidths","properties","bugError","_width","border","S_WIDTH","content","_height","S_HEIGHT","observeAll","onResize","target","unobserveAll","offResize","getWidthAtH","debug9","sameHeightW","_units","onDisable","onEnable","onDestroy","clear","getProperties","_type","_aspectR","_area","_extraH","_components","getTextComponents","child","components","debug8","tArea","tExtraH","imgAR","flexW","nItems","thisTxtArea","thisTxtExtraH","component","cmpProps","thisAspectR","_tArea","_tExtraH","_imgAR","_flexW","_nItems","targetHeight","h0","sqrt","h2","h1","hR0","hR1","hR2","hF2","hF1","hConstr1","filter","v","hConstr2","tw0","iw0","freeSpace0","debug1"],"sources":["../../../src/ts/widgets/same-height.ts"],"sourcesContent":["/**\n * @module Widgets\n */\n\n// This widget finds optimal widths of flexbox children so that their heights\n// are equal or as close as possible to each other. It takes into account\n// whether they contain text (and possibly other elements, but not images) or\n// images.\n//\n// NOTE:\n//  - We assume that a given flexbox child is either a \"text container\" and\n//    contains only text and other non-image elements (such as buttons), or is\n//    an \"image container\" and contains only images.\n//  - We also assume that all the text inside a text container is the same\n//    font size as the font size of the text container.\n//\n// ~~~~~~ BACKGROUND: analysis for one text container and one image container ~~~~~~\n//\n// A text box has a fixed area, its height decreasing as width increases.\n// Whereas an image has a fixed aspect ratio, its height increasing as width\n// increases.\n//\n// We want to find an optimal configuration at which the text container (which\n// can include other elements apart from text) and image heights are equal, or\n// if not possible, at which they are as close as possible to each other while\n// satisfying as best as possible these \"guidelines\" (constraints that are not\n// enforced), based on visual appeal:\n//   - minGap, minimum gap between each item\n//   - maxWidthR, maximum ratio between the width of the widest child and the\n//     narrowest child\n//   - maxFreeR, maximum free space in the container as a percentage of its\n//     total width\n//\n// Then we set flex-basis as the optimal width (making sure this is disabled\n// when the flex direction is column). This allows for fluid width if the user\n// to configure shrink or wrap on the flexbox using CSS.\n//\n// ~~~~~~ FORMULAE: text and image width as a function of their height ~~~~~~\n//\n// For a given height, h, the widths of the text and image are:\n//\n//                 txtArea\n//   txtW(h) =  —————————————\n//              h - txtExtraH\n//\n//   imgW(h) = imgAspectR * h\n//\n// where txtExtraH comes from buttons and other non-text elements inside the\n// text container, whose height is treated as fixed (not changing with width).\n//\n// ~~~~~~ PLOT: total width as a function of height ~~~~~~\n//\n// The sum of the widths of image and text varies with their height, h, as:\n//\n//   w(h) = txtW(h) + imgW(h)\n//\n//              txtArea\n//        =  —————————————  +  imgAspectR * h\n//           h - txtExtraH\n//\n//\n//       w(h)\n//        ^\n//        | |              .\n//        | .             .\n//        |  .           .\n// flexW  +   .         .\n//        |    .       .\n//        |     .    .\n//        |       -\n//        |\n//        |———|———|—————|———————————> h\n//            h1  h0    h2\n//\n//\n// ~~~~~~ FORMULAE: height at which total width is minimum ~~~~~~\n//\n// The minimum of the function w(h) is at h = h0\n//\n//            ⌈   txtArea  ⌉\n//   h0 = sqrt| —————————— | + txtExtraH\n//            ⌊ imgAspectR ⌋\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// The widths of image and text container at height = h0 are:\n//\n//   txtW(h0) = sqrt( txtArea * imgAspectR )\n//\n//   imgW(h0) = sqrt( txtArea * imgAspectR ) + imgAspectR * txtExtraH\n//            = txtW(h0) + imgAspectR * txtExtraH\n//\n// - NOTE: at if txtExtraH is 0 (i.e. the container has only text), then\n//   their widths are equal at h0; otherwise the image is wider\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// There are zero, one or two values of h at which w(h) equals the flexbox\n// width, flexW. Labelled h1 and h2 above.\n//\n// ~~~~~~ FORMULAE: height at which total width is equal to flexbox width ~~~~~~\n//\n// The heights at which the sum of the widths, w(h) equals exactly flexW are:\n//\n//          -b ± sqrt( b^2 - 4ac )\n//   h2/1 = ——————————————————————\n//                  2a\n//\n// where:\n// a = imgAspectR\n// b = - ( (imgAspectR * txtExtraH) + flexW )\n// c = txtArea + (txtExtraH * flexW)\n//\n// If h1 and h2 are real, then h1 <= h0 <= h2, as shown in plot above.\n//\n// ~~~~~~ SCENARIOS: free space or overflow in the flexbox ~~~~~~\n//\n// Whether there is a solution to the above equation, i.e. whether h1 and h2\n// are real, depends on which scenario we have:\n//\n// 1. If flexW = w(h0), then h1 = h2 = h0\n// 2. If flexW < w(h0), then there is no exact solution, i.e. it's impossible\n//    to fit the text and image inside the flexbox and have them equal heights;\n//    there is overflow even at h0\n// 3. If flexW > w(h0) (as in the graph above), then at h0 there is free space\n//    in the flexbox and we can choose any height between h1 and h2\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// The widths h0, h1 and h2 represent the following visual configuration:\n//   - h0: intermediate height, maximum free space in the container;\n//   - h1: minimum height (i.e. wide text and small image), no free space in\n//     the container;\n//   - h2: maximum height (i.e. narrow text and large image), no free space in\n//     the container;\n//\n// ~~~~~~ THEREFORE: approach ~~~~~~\n//\n// 1. If flexW = w(h0), i.e. h1 = h2 = h0:\n//    => we choose h0 as the height\n// 2. If flexW < w(h0), i.e. it's impossible to fit the text and image inside\n//    the flexbox and have them equal heights:\n//    => we still choose h0 as the height as that gives the least amount of\n//       overflow; user-defined CSS can control whether the items will be\n//       shrunk, the flexbox will wrap or overflow\n// 3. If flexW > w(h0), i.e. at h0 there is free space in the flexbox:\n//    => choose a height between h1 and h2 that best fits with the guidelines\n//       maxWidthR and maxFreeR\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// In scenario 3 we can look at the guidelines, maxWidthR and maxFreeR.\n//\n// ~~~~~~ GUIDELINE: maxWidthR ~~~~~~\n//\n// ~~~~~~ FORMULAE: height at which text and image width are equal ~~~~~~\n//\n// The width of the text and image container are equal at height hR0:\n//\n//         txtExtraH + sqrt( txtExtraH^2  +  4 * (h0 - txtExtraH)^2 )\n// hR0  =  ——————————————————————————————————————————————————————————\n//                                    2\n//\n// ~~~~~~ FORMULAE: height at which text to image width is maxWidthR ~~~~~~\n//\n// For heights < hR0, i.e. text becomes wider than the image, at some point the\n// ratio of text width to image width becomes maxWidthR. This happens at hR1.\n//\n//                         ⌈                 4 * (h0 - txtExtraH)^2 ⌉\n//         txtExtraH + sqrt| txtExtraH^2  +  —————————————————————— |\n//                         ⌊                        maxWidthR       ⌋\n// hR1  =  ——————————————————————————————————————————————————————————\n//                                    2\n//\n// ~~~~~~ FORMULAE: height at which image to text width is maxWidthR ~~~~~~\n//\n// For heights > hR0, i.e. text becomes narrower than the image, at some point\n// the ratio of image width to text width becomes maxWidthR. This happens at hR2.\n//\n//         txtExtraH + sqrt( txtExtraH^2  +  4 * maxWidthR * (h0 - txtExtraH)^2 )\n// hR2  =  ——————————————————————————————————————————————————————————————————————\n//                                        2\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// NOTE:\n// - hR1 <= hR0 <= hR2 && hR0 <= h0\n// - hR0, hR1 and hR2 are the first (larger) roots of the quadratic equation\n//   with coefficients:\n//     a = imgAspectR * R\n//     b = - imgAspectR * txtExtraH * R\n//     c = - textArea\n//   where R = 1 gives hR0, R = maxWidthR gives hR1 and R = 1 / maxWidthR gives hR2\n// - The smaller roots of the equation should be negative, so we ignore them\n//\n// ~~~~~~ GUIDELINE: maxFreeR ~~~~~~\n//\n// ~~~~~~ FORMULAE: free space in flexbox relative to its width ~~~~~~\n//\n// The percentage of free space in the container is:\n//\n//           flexW - w(h)\n// freeR  =  ————————————\n//              flexW\n//\n//\n//                             txtArea\n//                flexW  -  —————————————  - imgAspectR * h\n//                          h - txtExtraH\n//             =  —————————————————————————————————————————\n//                                flexW\n//\n// ~~~~~~ FORMULAE: height at which relative free space is maxFreeR ~~~~~~\n//\n// This would be equal to maxFreeR at hF1 and hF2:\n//\n//          -b ± sqrt( b^2 - 4ac )\n//   hF2/1 = ——————————————————————\n//                  2a\n//\n// where:\n// a = imgAspectR\n// b = - ( (imgAspectR * txtExtraH) + ( flexW * (1 - maxFreeR) ) )\n// c = txtArea + ( txtExtraH * flexW * (1 - maxFreeR) )\n//\n// If hF1 and hF2 are real, then h1 < hF1 <= h0 <= hF2 < h2.\n//\n// ~~~~~~ THEREFORE: choosing a height in scenario 3 ~~~~~~\n//\n// So in scenario 3 we can choose any height h between\n//\n//   max(h1, hR1, hF1)  and  min(h2, hR2, hF2)\n//\n// Note, it's possible that max(h1, hR1, hF1) is greater than min(h2, hR2, hF2),\n// e.g. if hF1 > hR2 or hR1 > hF2.\n//\n// This will make the text and image equal height, fitting in the flexbox, and\n// if possible, satisfying both maxFreeR and maxWidthR.\n//\n// Here we choose the smallest height possible, which would result in the\n// larger ratio between text width and image width, but it will satisfy the\n// constraints maxFreeR and maxWidthR, so that is ok.\n//\n// ~~~~~~ GENERALISING: for more than one text and/or image container ~~~~~~\n//\n// We can generalise the above in order to find an approximate solution for the\n// case of multiple text or image containers (an exact solution would require\n// solving a polynomial of degree equal to the number of elements).\n//\n// If we imaging putting all text in one container and all images in another\n// container we are back at the above exact solutions for a single text and\n// image container.\n//\n// We can solve for the following parameters:\n// - txtArea:    total text area\n//               = sum_i(txtArea_i)\n//\n// - txtExtraH:  weighted average extra height\n//               = sum_i(txtExtraH_i * txtArea_i) / txtArea\n//\n// - imgAspectR: total image aspect ratio (for horizontally laid out image\n//               containers)\n//               = sum_i(imgAspectR_i)\n//\n// ~~~~~~ CASE 1: only images containers ~~~~~~\n// If we have only image containers, we solve for the optimal height as follows:\n//\n//   flexW = imgAspectR * h\n//\n//                   flexW\n//   => hIdeal  =  ——————————\n//                 imgAspectR\n//\n// ~~~~~~ CASE 2: only text containers ~~~~~~\n// If we have only text containers, we solve for the optimal height as follows:\n//\n//                  txtArea\n//   flexW  =  ——————————————————\n//             hIdeal - txtExtraH\n//\n//                 txtArea\n//   => hIdeal  =  ———————  +  txtExtraH\n//                  flexW\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Once we've found the optimal height h, we calculate the individual widths of\n// the flexbox children as:\n//\n//                  txtArea_i\n//   txtW_i(h) =  —————————————\n//                h - txtExtraH_i\n//\n//   imgW_i(h) = imgAspectR_i * h\n//\n// ~~~~~~ IMPLEMENTATION ~~~~~~\n//\n// We go through the flexbox children and determine whether a child is a \"text\n// container\" or an \"image container\".\n//\n// For image containers, we measure the width and height and calculate the\n// aspect ratio using these.\n//\n// For text containers, we measure their width and height. We calculate the\n// text area by measuring the size of all children of the text container that\n// are deemed to contain only text (or if the entire text container is deemed\n// to contain only text, then we take its size). Then we sum the areas of\n// all such text-only boxes.\n//\n// To determine the extra height in the text container, we take the total\n// height of all text-only boxes inside it, and we subtract that from its\n// measured height.\n//\n// NOTE:\n// - This does not work if the flexbox children are set to align stretch,\n//   because in such cases there would be free vertical space in the container\n//   that shouldn't be counted.\n// - If the flexbox children or any of their descendants have paddings and\n//   margins, then this calculation would only work if the paddings/margins\n//   inside text containers are absolute and only on top and bottom, and\n//   paddings/margins inside image containers are in percentages and only on\n//   descendants of the image container. Otherwise the image aspect ratio and the\n//   extra text height would not be constant, and there may be extra width in\n//   the text container. It is very tricky to take all of this into account. So\n//   we ignore such cases and assume constant image aspect ratio and constant\n//   text area and text container extra height.\n//\n// We use resize observers to get the size of relevant elements and\n// re-calculate as needed.\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { settings } from \"@lisn/globals/settings\";\n\nimport {\n  addClasses,\n  removeClasses,\n  getData,\n  setData,\n  delData,\n  setNumericStyleJsVars,\n  getComputedStyleProp,\n} from \"@lisn/utils/css-alter\";\nimport { getVisibleContentChildren } from \"@lisn/utils/dom-query\";\nimport { logError } from \"@lisn/utils/log\";\nimport { isValidNum, toNumWithBounds, quadraticRoots } from \"@lisn/utils/math\";\nimport { formatAsString } from \"@lisn/utils/text\";\nimport { validateNumber } from \"@lisn/utils/validation\";\n\nimport { SizeWatcher, SizeData } from \"@lisn/watchers/size-watcher\";\n\nimport {\n  Widget,\n  WidgetConfigValidatorObject,\n  registerWidget,\n  getDefaultWidgetSelector,\n} from \"@lisn/widgets/widget\";\n\nimport { LoggerInterface } from \"@lisn/debug/types\";\n\nimport debug from \"@lisn/debug/debug\";\n\n/**\n * Configures the given element as a {@link SameHeight} widget.\n *\n * The SameHeight widget sets up the given element as a flexbox and sets the\n * flex basis of its components so that their heights are as close as possible\n * to each other. It tracks their size (see {@link SizeWatcher}) and\n * continually updates the basis as needed.\n *\n * When calculating the best flex basis that would result in equal heights,\n * SameHeight determines whether a flex child is mostly text or mostly images\n * since the height of these scales in opposite manner with their width.\n * Therefore, the components of the widget should contain either mostly text or\n * mostly images.\n *\n * The widget should have more than one item and the items must be immediate\n * children of the container element.\n *\n * SameHeight tries to automatically determine if an item is mostly text or\n * mostly images based on the total display text content, but you can override\n * this in two ways:\n * 1. By passing a map of elements as {@link SameHeightConfig.items | items}\n *    instead of an array, and setting the value for each to either `\"text\"` or\n *    `\"image\"`\n * 2. By setting the `data-lisn-same-height-item` attribute to `\"text\"` or\n *   `\"image\"` on the children. **NOTE** however that when auto-discovering the\n *   items (i.e. when you have not explicitly passed a list/map of items), if\n *   you set the `data-lisn-same-height-item` attribute on _any_ child you must\n *   also add this attribute to all other children that are to be used by the\n *   widget. Other children (that don't have this attribute) will be ignored\n *   and assumed to be either zero-size or position absolute/fixed.\n *\n * **IMPORTANT:** You should not instantiate more than one {@link SameHeight}\n * widget on a given element. Use {@link SameHeight.get} to get an existing\n * instance if any. If there is already a widget instance, it will be destroyed!\n *\n * **IMPORTANT:** The element you pass will be set to `display: flex` and its\n * children will get `box-sizing: border-box` and continually updated\n * `flex-basis` style. You can add additional CSS to the element or its\n * children if you wish. For example you may wish to set `flex-wrap: wrap` on\n * the element and a `min-width` on the children.\n *\n * -----\n *\n * To use with auto-widgets (HTML API) (see {@link settings.autoWidgets}), the\n * following CSS classes or data attributes are recognized:\n * - `lisn-same-height` class or `data-lisn-same-height` attribute set on the\n *   container element that constitutes the widget\n *\n * When using auto-widgets, the elements that will be used as items are\n * discovered in the following way:\n * 1. The immediate children of the top-level element that constitutes the\n *    widget that have the `lisn-same-height-item` class or\n *    `data-lisn-same-height-item` attribute are taken.\n * 2. If none of the root's children have this class or attribute, then all of\n *    the immediate children of the widget element except any `script` or\n *    `style` elements are taken as the items.\n *\n * See below examples for what values you can use set for the data attribute\n * in order to modify the configuration of the automatically created widget.\n *\n * @example\n * This defines a simple SameHeight widget with one text and one image child.\n *\n * ```html\n * <div class=\"lisn-same-height\">\n *   <div>\n *     <p>\n *       Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n *       eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n *       minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n *       aliquip ex ea commodo consequat. Duis aute irure dolor in\n *       reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n *       pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n *       culpa qui officia deserunt mollit anim id est laborum.\n *     </p>\n *   </div>\n *\n *   <div>\n *     <img\n *       src=\"https://www.wikipedia.org/portal/wikipedia.org/assets/img/Wikipedia-logo-v2@1.5x.png\"\n *     />\n *   </div>\n * </div>\n * ```\n *\n * @example\n * This defines a SameHeight widget with the flexbox children specified\n * explicitly (and one ignored), as well as having all custom settings.\n *\n * ```html\n * <div data-lisn-same-height=\"diff-tolerance=20\n *                             | resize-threshold=10\n *                             | debounce-window=50\n *                             | min-gap=50\n *                             | max-free-r=0.2\n *                             | max-width-r=3.2\">\n *   <div>Example ignored child</div>\n *\n *   <div data-lisn-same-height-item><!-- Will be detected as text anyway -->\n *     <p>\n *       Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n *       eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n *       minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n *       aliquip ex ea commodo consequat. Duis aute irure dolor in\n *       reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n *       pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n *       culpa qui officia deserunt mollit anim id est laborum.\n *     </p>\n *   </div>\n *\n *   <!-- Explicitly set to image type, though it will be detected as such -->\n *   <div data-lisn-same-height-item=\"image\">\n *     <img\n *       src=\"https://www.wikipedia.org/portal/wikipedia.org/assets/img/Wikipedia-logo-v2@1.5x.png\"\n *     />\n *   </div>\n *\n *   <!-- Explicitly set to text type, because it will NOT be detected as such (text too short). -->\n *   <div data-lisn-same-height-item=\"text\">\n *     <p>\n *       Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n *     </p>\n *   </div>\n * </div>\n * ```\n */\nexport class SameHeight extends Widget {\n  /**\n   * Switches the flexbox to vertical (column) mode.\n   *\n   * You can alternatively do this by setting the\n   * `data-lisn-orientation=\"vertical\"` attribute on the element at any time.\n   *\n   * You can do this for example as part of a trigger:\n   *\n   * @example\n   * ```html\n   * <div class=\"lisn-same-height\"\n   *      data-lisn-on-layout=\"max-mobile-wide:set-attribute=data-lisn-orientation#vertical\">\n   *      <!-- ... children -->\n   * </div>\n   * ```\n   */\n  readonly toColumn: () => Promise<void>;\n\n  /**\n   * Switches the flexbox back to horizontal (row) mode, which is the default.\n   *\n   * You can alternatively do this by deleting the\n   * `data-lisn-orientation` attribute on the element, or setting it to\n   * `\"horizontal\"` at any time.\n   */\n  readonly toRow: () => Promise<void>;\n\n  /**\n   * Returns the elements used as the flex children.\n   */\n  readonly getItems: () => Element[];\n\n  /**\n   * Returns a map of the elements used as the flex children with their type.\n   */\n  readonly getItemConfigs: () => Map<Element, \"text\" | \"image\">;\n\n  /**\n   * If the element is already configured as a SameHeight widget, the widget\n   * instance is returned. Otherwise null.\n   */\n  static get(containerElement: Element): SameHeight | null {\n    const instance = super.get(containerElement, DUMMY_ID);\n    if (MH.isInstanceOf(instance, SameHeight)) {\n      return instance;\n    }\n    return null;\n  }\n\n  static register() {\n    registerWidget(\n      WIDGET_NAME,\n      (element, config) => {\n        if (MH.isHTMLElement(element)) {\n          if (!SameHeight.get(element)) {\n            return new SameHeight(element, config);\n          }\n        } else {\n          logError(\n            MH.usageError(\n              \"Only HTMLElement is supported for SameHeight widget\",\n            ),\n          );\n        }\n        return null;\n      },\n      configValidator,\n    );\n  }\n\n  constructor(containerElement: HTMLElement, config?: SameHeightConfig) {\n    const destroyPromise = SameHeight.get(containerElement)?.destroy();\n    super(containerElement, { id: DUMMY_ID });\n\n    const items = getItemsFrom(containerElement, config?.items);\n\n    if (MH.sizeOf(items) < 2) {\n      throw MH.usageError(\"SameHeight must have more than 1 item\");\n    }\n\n    for (const item of items.keys()) {\n      if (MH.parentOf(item) !== containerElement) {\n        throw MH.usageError(\n          \"SameHeight's items must be its immediate children\",\n        );\n      }\n    }\n\n    fetchConfig(containerElement, config).then((fullConfig) => {\n      (destroyPromise || MH.promiseResolve()).then(() => {\n        if (this.isDestroyed()) {\n          return;\n        }\n\n        init(this, containerElement, items, fullConfig);\n      });\n    });\n\n    this.toColumn = () =>\n      setData(containerElement, MC.PREFIX_ORIENTATION, MC.S_VERTICAL);\n\n    this.toRow = () => delData(containerElement, MC.PREFIX_ORIENTATION);\n\n    this.getItems = () => [...items.keys()];\n    this.getItemConfigs = () => MH.newMap([...items.entries()]);\n  }\n}\n\n/**\n * @interface\n */\nexport type SameHeightConfig = {\n  /**\n   * The elements that will make up the items. They **MUST** be immediate\n   * children of the container element.\n   *\n   * The widget should have more than one item.\n   *\n   * If this is not specified, then\n   * 1. The immediate children of the top-level element that constitutes the\n   *    widget that have the `lisn-same-height-item` class or\n   *    `data-lisn-same-height-item` attribute are taken.\n   * 2. If none of the root's children have this class or attribute, then all of\n   *    the immediate children of the widget element except any `script` or\n   *    `style` elements are taken as the items.\n   */\n  items?: Element[] | Map<Element, \"image\" | \"text\">;\n\n  /**\n   * After setting the flex basis of the children and their size updates, in\n   * case the resultant height differs from the predicted calculated one by\n   * `diffTolerance` in pixels, then the calculations are re-run using the new\n   * sizes. Calculations are re-run at most once only.\n   *\n   * Differences between the predicted and resultant height would happen if the\n   * children contain a mixture of text and images or if there are margins or\n   * paddings that don't scale in the same way as the content.\n   *\n   * @defaultValue {@link settings.sameHeightDiffTolerance}\n   */\n  diffTolerance?: number;\n\n  /**\n   * The `resizeThreshold` to pass to the {@link SizeWatcher}.\n   *\n   * @defaultValue {@link settings.sameHeightResizeThreshold}\n   */\n  resizeThreshold?: number;\n\n  /**\n   * The `debounceWindow` to pass to the {@link SizeWatcher}.\n   *\n   * @defaultValue {@link settings.sameHeightDebounceWindow}\n   */\n  debounceWindow?: number;\n\n  /**\n   * Minimum gap between the flex items. Note that setting this to 0 while at\n   * the same time setting `flex-wrap` to `wrap` (or `wrap-reverse`) on the\n   * element may lead to premature/unnecessary wrapping.\n   *\n   * Note that this is not strictly enforced, and is only used in finding\n   * optimal height based on other constraints. If you want to enforce this gap,\n   * set it as a `column-gap` CSS rule.\n   *\n   * @defaultValue The effective `column-gap` on the container element style or\n   *               if none, {@link settings.sameHeightMinGap}\n   */\n  minGap?: number;\n\n  /**\n   * Maximum ratio between the free space in the flex container and its total\n   * width. You can set this to a negative number to disable this restriction.\n   *\n   * It has to be < 1. Otherwise it is invalid and disables this restriction.\n   *\n   * Note that this is not strictly enforced, and is only used in finding\n   * optimal height based on other constraints.\n   *\n   * @defaultValue {@link settings.sameHeightMaxFreeR}\n   */\n  maxFreeR?: number;\n\n  /**\n   * Maximum ratio between the width of the widest item and the narrowest item.\n   * You can set this to 0 or a negative number to disable this restriction.\n   *\n   * It has to be >= 1. Otherwise it is invalid and disables this restriction.\n   *\n   * Note that this is not strictly enforced, and is only used in finding\n   * optimal height based on other constraints.\n   *\n   * @defaultValue {@link settings.sameHeightMaxWidthR}\n   */\n  maxWidthR?: number;\n};\n\n// ------------------------------\n\ntype SameHeightConfigInternal = {\n  _minGap: number;\n  _diffTolerance: number;\n  _resizeThreshold: number;\n  _debounceWindow: number;\n  _maxFreeR: number;\n  _maxWidthR: number;\n};\n\ntype ItemProperties = {\n  _type: \"\" | \"image\" | \"text\";\n  _width: number;\n  _height: number;\n  _aspectR: number;\n  _area: number;\n  _extraH: number;\n  _components: Element[];\n};\n\ntype AverageMeasurements = {\n  _tArea: number;\n  _tExtraH: number;\n  _imgAR: number;\n  _flexW: number;\n  _nItems: number;\n};\n\nconst WIDGET_NAME = \"same-height\";\nconst PREFIXED_NAME = MH.prefixName(WIDGET_NAME);\nconst PREFIX_ROOT = `${PREFIXED_NAME}__root`;\n\n// Use different classes for styling items to the one used for auto-discovering\n// them, so that re-creating existing widgets can correctly find the items to\n// be used by the new widget synchronously before the current one is destroyed.\nconst PREFIX_ITEM = `${PREFIXED_NAME}__item`;\nconst PREFIX_ITEM__FOR_SELECT = `${PREFIXED_NAME}-item`;\n\nconst S_TEXT = \"text\";\nconst S_IMAGE = \"image\";\n\n// Only one SameHeight widget per element is allowed, but Widget requires a\n// non-blank ID.\nconst DUMMY_ID = PREFIXED_NAME;\n\n// We consider elements that have text content of at least <MIN_CHARS_FOR_TEXT>\n// characters to be text.\nconst MIN_CHARS_FOR_TEXT = 100;\n\nconst configValidator: WidgetConfigValidatorObject<SameHeightConfig> = {\n  diffTolerance: validateNumber,\n  resizeThreshold: validateNumber,\n  [MC.S_DEBOUNCE_WINDOW]: validateNumber,\n  minGap: validateNumber,\n  maxFreeR: validateNumber,\n  maxWidthR: validateNumber,\n};\n\nconst isText = (element: Element) =>\n  getData(element, PREFIX_ITEM__FOR_SELECT) === S_TEXT ||\n  (getData(element, PREFIX_ITEM__FOR_SELECT) !== S_IMAGE &&\n    MH.isHTMLElement(element) &&\n    MH.lengthOf(element.innerText) >= MIN_CHARS_FOR_TEXT);\n\nconst areImagesLoaded = (element: Element) => {\n  for (const img of element.querySelectorAll(\"img\")) {\n    // Don't rely on img.complete since sometimes this returns false even\n    // though the image is loaded and has a size. Just check the size.\n    if (\n      img.naturalWidth === 0 ||\n      img.width === 0 ||\n      img.naturalHeight === 0 ||\n      img.height === 0\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst fetchConfig = async (\n  containerElement: HTMLElement,\n  userConfig: SameHeightConfig | undefined,\n): Promise<SameHeightConfigInternal> => {\n  const colGapStr = await getComputedStyleProp(containerElement, \"column-gap\");\n  const minGap = getNumValue(\n    MH.strReplace(colGapStr, /px$/, \"\"),\n    settings.sameHeightMinGap,\n  );\n\n  return {\n    _minGap: toNumWithBounds(userConfig?.minGap ?? minGap, { min: 0 }, 10),\n    _maxFreeR: toNumWithBounds(\n      userConfig?.maxFreeR ?? settings.sameHeightMaxFreeR,\n      { min: 0, max: 0.9 },\n      -1,\n    ),\n    _maxWidthR: toNumWithBounds(\n      userConfig?.maxWidthR ?? settings.sameHeightMaxWidthR,\n      { min: 1 },\n      -1,\n    ),\n    _diffTolerance:\n      userConfig?.diffTolerance ?? settings.sameHeightDiffTolerance,\n    _resizeThreshold:\n      userConfig?.resizeThreshold ?? settings.sameHeightResizeThreshold,\n    _debounceWindow:\n      userConfig?.debounceWindow ?? settings.sameHeightDebounceWindow,\n  };\n};\n\nconst getNumValue = (strValue: string | null, defaultValue: number): number => {\n  const num = strValue ? MH.parseFloat(strValue) : NaN;\n  return MH.isNaN(num) ? defaultValue : num;\n};\n\nconst findItems = (containerElement: HTMLElement) => {\n  const items = [\n    ...MH.querySelectorAll(\n      containerElement,\n      getDefaultWidgetSelector(PREFIX_ITEM__FOR_SELECT),\n    ),\n  ];\n\n  if (!MH.lengthOf(items)) {\n    items.push(...getVisibleContentChildren(containerElement));\n  }\n\n  return items;\n};\n\nconst getItemsFrom = (\n  containerElement: HTMLElement,\n  inputItems: Element[] | Map<Element, \"image\" | \"text\"> | undefined,\n) => {\n  const itemMap = MH.newMap<Element, \"image\" | \"text\">();\n\n  inputItems = inputItems || findItems(containerElement);\n\n  const addItem = (item: Element, itemType?: \"text\" | \"image\") => {\n    itemType = itemType || (isText(item) ? S_TEXT : S_IMAGE);\n    itemMap.set(item, itemType);\n  };\n\n  if (MH.isArray(inputItems)) {\n    for (const item of inputItems) {\n      addItem(item);\n    }\n  } else if (MH.isInstanceOf(inputItems, Map)) {\n    for (const [item, itemType] of inputItems.entries()) {\n      addItem(item, itemType);\n    }\n  }\n\n  return itemMap;\n};\n\nconst init = (\n  widget: SameHeight,\n  containerElement: HTMLElement,\n  items: Map<Element, \"image\" | \"text\">,\n  config: SameHeightConfigInternal,\n) => {\n  const logger = debug\n    ? new debug.Logger({\n        name: `SameHeight-${formatAsString(containerElement)}`,\n      })\n    : null;\n\n  const diffTolerance = config._diffTolerance;\n  const debounceWindow = config._debounceWindow;\n\n  const sizeWatcher = SizeWatcher.reuse({\n    [MC.S_DEBOUNCE_WINDOW]: debounceWindow,\n    resizeThreshold: config._resizeThreshold,\n  });\n\n  const allItems = MH.newMap<Element, ItemProperties>();\n\n  let callCounter = 0;\n  let isFirstTime = true;\n  let lastOptimalHeight = 0;\n  let hasScheduledReset = false;\n  let counterTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  // ----------\n\n  const resizeHandler = (element: Element, sizeData: SizeData) => {\n    // Since the SizeWatcher calls us once for every element, we batch the\n    // re-calculations so they are done once in every cycle.\n    // Allow the queue of ResizeObserverEntry in the SizeWatcher to be\n    // emptied, and therefore to ensure we have the latest size for all\n    // elements.\n    if (!hasScheduledReset) {\n      debug: logger?.debug7(\"Scheduling calculations\", callCounter);\n      hasScheduledReset = true;\n\n      MH.setTimer(() => {\n        hasScheduledReset = false;\n\n        if (callCounter > 1) {\n          debug: logger?.debug7(\"Already re-calculated once, skipping\");\n          callCounter = 0;\n          return;\n        }\n\n        callCounter++;\n        if (counterTimeout) {\n          MH.clearTimer(counterTimeout);\n        }\n\n        const measurements = calculateMeasurements(\n          containerElement,\n          allItems,\n          isFirstTime,\n          logger,\n        );\n\n        const height = measurements\n          ? getOptimalHeight(measurements, config, logger)\n          : null;\n\n        if (height && MH.abs(lastOptimalHeight - height) > diffTolerance) {\n          // Re-set widths again. We may be called again in the next cycle if\n          // the change in size exceeds the resizeThreshold.\n          lastOptimalHeight = height;\n          isFirstTime = false;\n          setWidths(height); // no need to await\n\n          // If we are _not_ called again in the next cycle (just after\n          // debounceWindow), then reset the counter. It means the resultant\n          // change in size did not exceed the SizeWatcher threshold.\n          counterTimeout = MH.setTimer(() => {\n            callCounter = 0;\n          }, debounceWindow + 50);\n        } else {\n          // Done, until the next time elements are resized\n          callCounter = 0;\n        }\n      }, 0);\n    }\n\n    // Save the size of the item\n    const properties = allItems.get(element);\n    if (!properties) {\n      logError(MH.bugError(\"Got SizeWatcher call for unknown element\"));\n      return;\n    }\n\n    properties._width =\n      sizeData.border[MC.S_WIDTH] || sizeData.content[MC.S_WIDTH];\n    properties._height =\n      sizeData.border[MC.S_HEIGHT] || sizeData.content[MC.S_HEIGHT];\n\n    debug: logger?.debug7(\"Got size\", element, properties);\n  };\n\n  // ----------\n\n  const observeAll = () => {\n    isFirstTime = true;\n\n    for (const element of allItems.keys()) {\n      sizeWatcher.onResize(resizeHandler, { target: element });\n    }\n  };\n\n  // ----------\n\n  const unobserveAll = () => {\n    for (const element of allItems.keys()) {\n      sizeWatcher.offResize(resizeHandler, element);\n    }\n  };\n\n  // ----------\n\n  const setWidths = (height: number) => {\n    for (const [element, properties] of allItems.entries()) {\n      if (MH.parentOf(element) === containerElement) {\n        const width = getWidthAtH(element, properties, height);\n        debug: logger?.debug9(\n          \"Setting width property\",\n          element,\n          properties,\n          width,\n        );\n        setNumericStyleJsVars(\n          element,\n          { sameHeightW: width },\n          { _units: \"px\" },\n        );\n      }\n    }\n  };\n\n  // SETUP ------------------------------\n\n  widget.onDisable(unobserveAll);\n  widget.onEnable(observeAll);\n\n  widget.onDestroy(async () => {\n    for (const element of allItems.keys()) {\n      if (MH.parentOf(element) === containerElement) {\n        // delete the property and attribute\n        await setNumericStyleJsVars(element, { sameHeightW: NaN });\n        await removeClasses(element, PREFIX_ITEM);\n      }\n    }\n\n    allItems.clear();\n\n    await removeClasses(containerElement, PREFIX_ROOT);\n  });\n\n  // Find all relevant items: the container, its direct children and the\n  // top-level text only elements.\n  const getProperties = (itemType: \"\" | \"image\" | \"text\"): ItemProperties => {\n    return {\n      _type: itemType,\n      _width: NaN,\n      _height: NaN,\n      _aspectR: NaN,\n      _area: NaN,\n      _extraH: NaN,\n      _components: [],\n    };\n  };\n\n  allItems.set(containerElement, getProperties(\"\"));\n\n  for (const [item, itemType] of items.entries()) {\n    addClasses(item, PREFIX_ITEM);\n\n    const properties: ItemProperties = getProperties(itemType);\n    allItems.set(item, properties);\n\n    if (itemType === S_TEXT) {\n      properties._components = getTextComponents(item);\n      for (const child of properties._components) {\n        allItems.set(child, getProperties(\"\"));\n      }\n    }\n  }\n\n  addClasses(containerElement, PREFIX_ROOT);\n  observeAll();\n};\n\n/**\n * Find the top-level text-only elements that are descendants of the given one.\n */\nconst getTextComponents = (element: Element): Element[] => {\n  const components: Element[] = [];\n  for (const child of getVisibleContentChildren(element)) {\n    if (isText(child)) {\n      components.push(child);\n    } else {\n      components.push(...getTextComponents(child));\n    }\n  }\n\n  return components;\n};\n\nconst calculateMeasurements = (\n  containerElement: HTMLElement,\n  allItems: Map<Element, ItemProperties>,\n  isFirstTime: boolean,\n  logger: LoggerInterface | null,\n): AverageMeasurements | null => {\n  if (getData(containerElement, MC.PREFIX_ORIENTATION) === MC.S_VERTICAL) {\n    debug: logger?.debug8(\"In vertical mode\");\n    return null;\n  }\n\n  debug: logger?.debug7(\"Calculating measurements\");\n  // initial values\n  let tArea = NaN,\n    tExtraH = 0,\n    imgAR = NaN,\n    flexW = NaN,\n    nItems = 0;\n\n  for (const [element, properties] of allItems.entries()) {\n    const width = properties._width;\n    const height = properties._height;\n\n    if (element === containerElement) {\n      flexW = width;\n      nItems = MH.lengthOf(getVisibleContentChildren(element));\n\n      //\n    } else if (properties._type === S_TEXT) {\n      let thisTxtArea = 0,\n        thisTxtExtraH = 0;\n      const components = properties._components;\n\n      if (MH.lengthOf(components)) {\n        for (const component of properties._components) {\n          const cmpProps = allItems.get(component);\n          if (cmpProps) {\n            thisTxtArea += cmpProps._width * cmpProps._height;\n          } else {\n            logError(MH.bugError(\"Text component not observed\"));\n          }\n        }\n        thisTxtExtraH = height - thisTxtArea / width;\n      } else {\n        thisTxtArea = width * height;\n      }\n\n      properties._area = thisTxtArea;\n      properties._extraH = thisTxtExtraH;\n\n      tArea = (tArea || 0) + thisTxtArea;\n      tExtraH += thisTxtExtraH;\n\n      //\n    } else if (properties._type === S_IMAGE) {\n      if (isFirstTime && !areImagesLoaded(element)) {\n        debug: logger?.debug8(\"Images not loaded\");\n        return null;\n      }\n\n      const thisAspectR = width / height;\n      imgAR = (imgAR || 0) + thisAspectR;\n      properties._aspectR = thisAspectR;\n\n      //\n    } else {\n      // skip grandchildren (text components), here\n      continue;\n    }\n\n    debug: logger?.debug8(\"Examined\", properties, {\n      tArea,\n      tExtraH,\n      imgAR,\n      flexW,\n    });\n  }\n\n  return {\n    _tArea: tArea,\n    _tExtraH: tExtraH,\n    _imgAR: imgAR,\n    _flexW: flexW,\n    _nItems: nItems,\n  };\n};\n\nconst getWidthAtH = (\n  element: Element,\n  properties: ItemProperties,\n  targetHeight: number,\n): number =>\n  properties._type === S_TEXT\n    ? properties._area / (targetHeight - (properties._extraH || 0))\n    : properties._aspectR * targetHeight;\n\nconst getOptimalHeight = (\n  measurements: AverageMeasurements,\n  config: SameHeightConfigInternal,\n  logger: LoggerInterface | null,\n) => {\n  const tArea = measurements._tArea;\n  const tExtraH = measurements._tExtraH;\n  const imgAR = measurements._imgAR;\n  const flexW =\n    measurements._flexW - (measurements._nItems - 1) * config._minGap;\n  const maxFreeR = config._maxFreeR;\n  const maxWidthR = config._maxWidthR;\n\n  debug: logger?.debug8(\"Getting optimal height\", measurements, config);\n\n  // CASE 1: No text items\n  if (MH.isNaN(tArea)) {\n    debug: logger?.debug8(\"No text items\");\n    if (!imgAR) {\n      debug: logger?.debug8(\"Images not loaded\");\n      return NaN;\n    }\n\n    return flexW / imgAR;\n  }\n\n  // CASE 2: No images\n  if (MH.isNaN(imgAR)) {\n    debug: logger?.debug8(\"No images\");\n    return tArea / flexW + tExtraH;\n  }\n\n  if (!imgAR || !tArea) {\n    debug: logger?.debug8(\n      \"Expected both images and text, but no imgAR or tArea\",\n    );\n    return NaN;\n  }\n\n  const h0 = MH.sqrt(tArea / imgAR) + tExtraH;\n\n  // heights satisfying w(h) === flexW\n  const [h2, h1] = quadraticRoots(\n    imgAR,\n    -(imgAR * tExtraH + flexW),\n    tArea + tExtraH * flexW,\n  );\n\n  // heights satisfying maxWidthR\n  let hR0 = NaN,\n    hR1 = NaN,\n    hR2 = NaN;\n  if (maxWidthR > 0) {\n    hR0 = quadraticRoots(imgAR, -imgAR * tExtraH, -tArea)[0];\n\n    hR1 = quadraticRoots(\n      imgAR * maxWidthR,\n\n      -imgAR * tExtraH * maxWidthR,\n      -tArea,\n    )[0];\n\n    hR2 = quadraticRoots(\n      imgAR / maxWidthR,\n      (-imgAR * tExtraH) / maxWidthR,\n      -tArea,\n    )[0];\n  }\n\n  // heights satisfying maxFreeR\n  let hF2 = NaN,\n    hF1 = NaN;\n  if (maxFreeR >= 0) {\n    [hF2, hF1] = quadraticRoots(\n      imgAR,\n      -(imgAR * tExtraH + flexW * (1 - maxFreeR)),\n      tArea + tExtraH * flexW * (1 - maxFreeR),\n    );\n  }\n\n  // limits on constraints\n  const hConstr1 = MH.max(...MH.filter([h1, hR1, hF1], (v) => isValidNum(v)));\n  const hConstr2 = MH.min(...MH.filter([h2, hR2, hF2], (v) => isValidNum(v)));\n\n  // text and image widths at h0\n  const tw0 = tArea / (h0 - tExtraH);\n  const iw0 = h0 * imgAR;\n\n  // free space at h0\n  const freeSpace0 = flexW - tw0 - iw0;\n\n  debug: logger?.debug8(\"Optimal height calculations\", config, measurements, {\n    h0,\n    h1,\n    h2,\n    hR0,\n    hR1,\n    hR2,\n    hF1,\n    hF2,\n    hConstr1,\n    hConstr2,\n    tw0,\n    iw0,\n    freeSpace0,\n  });\n\n  // ~~~~ Some sanity checks\n  // If any of then is NaN, the comparison would be false, so we don't need to\n  // check.\n  // Also, we round the difference to 0.1 pixels to account for rounding\n  // errors during calculations.\n  if (!h0 || h0 <= 0) {\n    debug: logger?.debug1(\"Invalid calculation: Invalid h0\");\n  } else if (isValidNum(h1) !== isValidNum(h2)) {\n    debug: logger?.debug1(\n      \"Invalid calculation: One and only one of h1 or h2 is real\",\n    );\n  } else if (isValidNum(hR1) !== isValidNum(hR2)) {\n    debug: logger?.debug1(\n      \"Invalid calculation: One and only one of hR1 or hR2 is real\",\n    );\n  } else if (isValidNum(hF1) !== isValidNum(hF2)) {\n    debug: logger?.debug1(\n      \"Invalid calculation: One and only one of hF1 or hF2 is real\",\n    );\n  } else if (h1 - h0 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: h1 > h0\");\n  } else if (h0 - h2 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: h0 > h2\");\n  } else if (hR0 - h0 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: hR0 > h0\");\n  } else if (hR1 - hR0 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: hR1 > hR0\");\n  } else if (hR0 - hR2 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: hR0 > hR2\");\n  } else if (hF1 - hF2 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: hF1 > hF2\");\n  } else if (h1 - hF1 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: h1 > hF1\");\n  } else if (hF2 - h2 > 0.1) {\n    debug: logger?.debug1(\"Invalid calculation: hF2 > h2\");\n  } else {\n    // Choose a height\n    if (freeSpace0 <= 0) {\n      // scenario 1 or 2\n      return h0;\n    } else {\n      // scenario 3\n      return MH.min(hConstr1, hConstr2);\n    }\n  }\n\n  logError(\n    MH.bugError(\"Invalid SameHeight calculations\"),\n    measurements,\n    config,\n  );\n  return NaN; // sanity checks failed\n};\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,EAAE;AAEd,SAASC,QAAQ;AAEjB,SACEC,UAAU,EACVC,aAAa,EACbC,OAAO,EACPC,OAAO,EACPC,OAAO,EACPC,qBAAqB,EACrBC,oBAAoB;AAEtB,SAASC,yBAAyB;AAClC,SAASC,QAAQ;AACjB,SAASC,UAAU,EAAEC,eAAe,EAAEC,cAAc;AACpD,SAASC,cAAc;AACvB,SAASC,cAAc;AAEvB,SAASC,WAAW;AAEpB,SACEC,MAAM,EAENC,cAAc,EACdC,wBAAwB;AAK1B,OAAOC,KAAK;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]}