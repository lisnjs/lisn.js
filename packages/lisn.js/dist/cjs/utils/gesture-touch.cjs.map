{"version":3,"file":"gesture-touch.cjs","names":["MC","_interopRequireWildcard","require","MH","_directions","_math","_xMap","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","_typeof","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_createForOfIteratorHelper","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","_n","F","s","done","value","f","TypeError","o","next","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","_arrayLikeToArray","toString","slice","constructor","name","from","test","getTouchGestureFragment","exports","events","options","_options$dragHoldTime","_options$dragNumFinge","isIterableObject","moves","getTouchDiff","deltaThreshold","numMoves","lengthOf","holdTime","getHoldTime","canBeDrag","dragHoldTime","dragNumFingers","angleDiffThreshold","deltaX","havingMaxAbs","apply","map","m","deltaY","deltaZ","filter","d","isSignificant","direction","S_NONE","intent","S_UNKNOWN","vectorA","vectorB","areAntiParallel","startDistance","distanceBetween","startX","startY","endDistance","endX","endY","S_IN","S_OUT","S_ZOOM","deltaSign","reverseScroll","isFirst","_iterator","_step","S_DRAG","S_SCROLL","thisDirection","getVectorDirection","S_AMBIGUOUS","err","lastTouchEvent","isTouchEvent","touches","device","S_TOUCH","arguments","undefined","groupedTouches","newXMap","_iterator2","_step2","event","type","S_TOUCHCANCEL","_iterator4","_step4","touch","sGet","identifier","push","_iterator3","values","_step3","touchList","nTouches","firstTouch","lastTouch","clientX","clientY","maxAbs","firstStart","findIndex","S_TOUCHSTART","firstMove","S_TOUCHMOVE","timeStamp"],"sources":["../../../src/ts/utils/gesture-touch.ts"],"sourcesContent":["/**\n * @module Utils\n */\n\nimport * as MC from \"@lisn/globals/minification-constants\";\nimport * as MH from \"@lisn/globals/minification-helpers\";\n\nimport { Direction, GestureIntent, Vector } from \"@lisn/globals/types\";\n\nimport { getVectorDirection } from \"@lisn/utils/directions\";\n\nimport {\n  maxAbs,\n  havingMaxAbs,\n  distanceBetween,\n  areAntiParallel,\n} from \"@lisn/utils/math\";\nimport { GestureFragment } from \"@lisn/utils/gesture\";\n\nimport { newXMap } from \"@lisn/modules/x-map\";\n\n/**\n * @category Gestures\n */\nexport type TouchDiff = {\n  startX: number;\n  startY: number;\n\n  endX: number;\n  endY: number;\n\n  deltaX: number;\n  deltaY: number;\n\n  isSignificant: boolean;\n};\n\n/**\n * Returns a {@link GestureFragment} for the given events. Only \"touchmove\" events\n * will be considered.\n *\n * If there are less than 2 such events in the given list of events, returns `false`.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"touchcancel\" in the list, returns `null`.\n *\n * Note that by default swipe actions follow the natural direction: swipe up\n * with scroll intent results in direction down and swipe down results in\n * direction up. Drag intent always follows the direction of the gesture.\n *\n * For zoom intents, which necessarily involves exactly two fingers `deltaZ`\n * is based on the relative change in distance between the fingers.\n *\n * @param {} [options.deltaThreshold]\n *                          A change of x or y coordinate less than this is\n *                          considered insignificant, for the purposes of\n *                          determining:\n *                          1) whether the inferred direction is in one of the\n *                             four cardinal ones, or otherwise ambiguous; and\n *                          2) whether more than two fingers have moved and\n *                             therefore whether the direction could be zoom or\n *                             not\n * @param {} [options.angleDiffThreshold] See {@link getVectorDirection}\n * @param {} [options.reverseScroll]\n *                          If set to `true`, will disable natural scroll\n *                          direction.\n * @param {} [options.dragHoldTime]\n *                          If the user presses and holds for at least the\n *                          given amount of milliseconds before moving the\n *                          finger(s), gestures other than pinch will be\n *                          treated as a drag instead of scroll as long as the\n *                          number of fingers touching the screen is\n *                          `options.dragNumFingers`. Default is 500ms.\n * @param {} [options.dragNumFingers]\n *                          The number of fingers that could be considered a\n *                          drag intent. Default is 1.\n *\n * @return {} `false` if there are less than 2 \"touchmove\" events in the list,\n * `null` if the gesture is terminated, otherwise a {@link GestureFragment}.\n *\n * @category Gestures\n */\nexport const getTouchGestureFragment = (\n  events: Event[],\n  options?: {\n    deltaThreshold?: number;\n    angleDiffThreshold?: number;\n    reverseScroll?: boolean;\n    dragHoldTime?: number;\n    dragNumFingers?: number;\n  },\n): GestureFragment | null | false => {\n  if (!MH.isIterableObject(events)) {\n    events = [events];\n  }\n\n  let moves = getTouchDiff(events, options?.deltaThreshold);\n\n  if (!moves) {\n    return null; // terminated\n  }\n\n  let numMoves = MH.lengthOf(moves);\n\n  const holdTime = getHoldTime(events);\n  const canBeDrag =\n    holdTime >= (options?.dragHoldTime ?? 500) &&\n    numMoves === (options?.dragNumFingers ?? 1);\n  const angleDiffThreshold = options?.angleDiffThreshold;\n\n  let deltaX = havingMaxAbs(...moves.map((m) => m.deltaX));\n  let deltaY = havingMaxAbs(...moves.map((m) => m.deltaY));\n  let deltaZ = 1;\n\n  if (numMoves > 2) {\n    // Take only the significant ones\n    moves = MH.filter(moves, (d) => d.isSignificant);\n    numMoves = MH.lengthOf(moves);\n  }\n\n  let direction: Direction = MC.S_NONE;\n  let intent: GestureIntent = MC.S_UNKNOWN;\n  if (numMoves === 2) {\n    // Check if it's a zoom\n    const vectorA: Vector = [moves[0].deltaX, moves[0].deltaY];\n    const vectorB: Vector = [moves[1].deltaX, moves[1].deltaY];\n\n    // If either finger is approx stationary, or if they move in opposite directions,\n    // treat it as zoom.\n    if (\n      !havingMaxAbs(...vectorA) || // finger A still\n      !havingMaxAbs(...vectorB) || // finger B still\n      areAntiParallel(vectorA, vectorB, angleDiffThreshold)\n    ) {\n      // It's a pinch motion => zoom\n      const startDistance = distanceBetween(\n        [moves[0].startX, moves[0].startY],\n        [moves[1].startX, moves[1].startY],\n      );\n\n      const endDistance = distanceBetween(\n        [moves[0].endX, moves[0].endY],\n        [moves[1].endX, moves[1].endY],\n      );\n\n      direction = startDistance < endDistance ? MC.S_IN : MC.S_OUT;\n      deltaZ = endDistance / startDistance;\n      deltaX = deltaY = 0;\n      intent = MC.S_ZOOM;\n    }\n  }\n\n  const deltaSign = canBeDrag || options?.reverseScroll ? 1 : -1;\n  // If scrolling, swap the deltas for natural scroll direction.\n  // Add +0 to force -0 to be +0 since jest doesn't think they're equal\n  deltaX = deltaSign * deltaX + 0;\n  deltaY = deltaSign * deltaY + 0;\n\n  if (direction === MC.S_NONE) {\n    // Wasn't a zoom. Check if all moves are aligned.\n    let isFirst = true;\n\n    for (const m of moves) {\n      // There's at least one significant move, assume scroll or drag intent.\n      intent = canBeDrag ? MC.S_DRAG : MC.S_SCROLL;\n\n      const thisDirection = getVectorDirection(\n        [deltaSign * m.deltaX, deltaSign * m.deltaY],\n        angleDiffThreshold,\n      );\n\n      if (thisDirection === MC.S_NONE) {\n        continue;\n      }\n\n      if (isFirst) {\n        direction = thisDirection;\n      } else if (direction !== thisDirection) {\n        direction = MC.S_AMBIGUOUS;\n        break;\n      }\n\n      isFirst = false;\n    }\n  }\n\n  if (direction === MC.S_NONE) {\n    const lastTouchEvent = events.filter(MH.isTouchEvent).slice(-1)[0];\n    // If all fingers have lifted off, consider it terminated, otherwise wait\n    // for more events.\n    return MH.lengthOf(lastTouchEvent?.touches) ? false : null;\n  }\n\n  return {\n    device: MC.S_TOUCH,\n    direction,\n    intent,\n    deltaX,\n    deltaY,\n    deltaZ,\n  };\n};\n\n/**\n * Returns a description of the changes in each finger between the first and\n * the last relevant TouchEvent in the list.\n *\n * If the gesture is to be considered terminated, e.g. because there is\n * \"touchcancel\" in the list, returns `null`.\n *\n * Note that, `deltaX`/`deltaY` are the end X/Y coordinate minus the start X/Y\n * coordinate. For natural scroll direction you should swap their signs.\n *\n * @param {} deltaThreshold If the change of x and y coordinate are both less\n *                          than this, it is marked as not significant.\n *\n * @category Gestures\n */\nexport const getTouchDiff = (\n  events: Event[],\n  deltaThreshold = 0,\n): TouchDiff[] | null => {\n  // Group each touch point of each event by identifier, so that we can get the\n  // start and end coordinate of each finger\n  const groupedTouches = newXMap<number, Touch[]>((): Touch[] => []);\n\n  for (const event of events) {\n    if (!MH.isTouchEvent(event)) {\n      continue;\n    }\n\n    if (event.type === MC.S_TOUCHCANCEL) {\n      return null; // gesture terminated\n    }\n\n    for (const touch of event.touches) {\n      groupedTouches.sGet(touch.identifier).push(touch);\n    }\n  }\n\n  const moves: TouchDiff[] = [];\n\n  for (const touchList of groupedTouches.values()) {\n    const nTouches = MH.lengthOf(touchList);\n    if (nTouches < 2) {\n      // Only one event had that finger in it, so there's no move for it\n      continue;\n    }\n\n    const firstTouch = touchList[0];\n    const lastTouch = touchList[nTouches - 1];\n    const startX = firstTouch.clientX;\n    const startY = firstTouch.clientY;\n\n    const endX = lastTouch.clientX;\n    const endY = lastTouch.clientY;\n\n    const deltaX = endX - startX;\n    const deltaY = endY - startY;\n\n    const isSignificant = maxAbs(deltaX, deltaY) >= deltaThreshold;\n\n    // Consider it a move in one of the 4 cardinal ones\n    moves.push({\n      startX,\n      startY,\n      endX,\n      endY,\n      deltaX,\n      deltaY,\n      isSignificant,\n    });\n  }\n\n  return moves;\n};\n\n// --------------------\n\nconst getHoldTime = (events: Event[]) => {\n  const firstStart = events.findIndex((e) => e.type === MC.S_TOUCHSTART);\n  const firstMove = events.findIndex((e) => e.type === MC.S_TOUCHMOVE);\n  if (firstStart < 0 || firstMove < 1) {\n    return 0;\n  }\n\n  return events[firstMove].timeStamp - events[firstStart].timeStamp;\n};\n"],"mappings":"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","ignoreList":[]}